{
  "timestamp": "2025-10-14T09:11:09.293Z",
  "ruchy_version": "ruchy 3.77.0",
  "chapters_processed": 16,
  "examples_found": 134,
  "examples_working": 113,
  "examples_failing": 21,
  "success_rate": 84,
  "chapters": {
    "ch04-00-practical-patterns-tdd": {
      "chapter": "ch04-00-practical-patterns-tdd",
      "total_examples": 10,
      "working_examples": 8,
      "failing_examples": 2,
      "examples": [
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 1,
          "line_number": 39,
          "code": "// Calculator with validation and error handling\nfun safe_calculate(operation: &str, a: i32, b: i32) -> i32 {\n    if operation == \"add\" {\n        a + b\n    } else if operation == \"subtract\" {\n        a - b\n    } else if operation == \"multiply\" {\n        a * b\n    } else if operation == \"divide\" {\n        if b == 0 {\n            println(\"Error: Division by zero\");\n            0  // Safe default\n        } else {\n            a / b\n        }\n    } else {\n        println(\"Error: Unknown operation '{}'\", operation);\n        0  // Safe default\n    }\n}\n\nfun main() {\n    let result1 = safe_calculate(\"add\", 10, 5);\n    let result2 = safe_calculate(\"divide\", 12, 3);\n    let result3 = safe_calculate(\"divide\", 10, 0);\n    \n    println(\"10 + 5 = {}\", result1);\n    println(\"12 / 3 = {}\", result2);\n    println(\"10 / 0 = {}\", result3);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 2,
          "line_number": 99,
          "code": "fun validate_user_input(name: &str, age: i32, email: &str) -> bool {\n    // Guard clause: check for empty name\n    if name.len() == 0 {\n        println(\"Error: Name cannot be empty\");\n        return false;\n    }\n    \n    // Guard clause: check age range\n    if age < 0 || age > 150 {\n        println(\"Error: Age must be between 0 and 150\");\n        return false;\n    }\n    \n    // Guard clause: basic email validation\n    if !email.contains('@') {\n        println(\"Error: Invalid email format\");\n        return false;\n    }\n    \n    // All validations passed\n    println(\"User input is valid\");\n    return true;\n}\n\nfun create_user_profile(name: &str, age: i32, email: &str) -> &str {\n    if validate_user_input(name, age, email) {\n        println(\"Creating profile for: {}\", name);\n        return \"Profile created successfully\";\n    } else {\n        return \"Profile creation failed\";\n    }\n}\n\nfun main() {\n    let result1 = create_user_profile(\"Alice\", 25, \"alice@example.com\");\n    let result2 = create_user_profile(\"\", 30, \"bob@example.com\");\n    let result3 = create_user_profile(\"Charlie\", -5, \"charlie@example.com\");\n    \n    println(\"Result 1: {}\", result1);\n    println(\"Result 2: {}\", result2); \n    println(\"Result 3: {}\", result3);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 3,
          "line_number": 146,
          "code": "fun process_score(raw_score: i32, max_score: i32) -> f64 {\n    // Step 1: Validate inputs\n    if max_score <= 0 {\n        println(\"Error: Max score must be positive\");\n        return 0.0;\n    }\n    \n    if raw_score < 0 {\n        println(\"Warning: Negative score adjusted to 0\");\n        return 0.0;\n    }\n    \n    if raw_score > max_score {\n        println(\"Warning: Score exceeds maximum, capping at {}\", max_score);\n        return 100.0;\n    }\n    \n    // Step 2: Calculate percentage\n    let percentage = (raw_score as f64) / (max_score as f64) * 100.0;\n    \n    // Step 3: Round to reasonable precision\n    let rounded = (percentage * 10.0).round() / 10.0;\n    \n    // Step 4: Return result\n    rounded\n}\n\nfun grade_assignment(student: &str, raw_score: i32, max_score: i32) -> &str {\n    let percentage = process_score(raw_score, max_score);\n    \n    println(\"Student: {}\", student);\n    println(\"Score: {}/{} ({:.1}%)\", raw_score, max_score, percentage);\n    \n    // Letter grade assignment\n    if percentage >= 90.0 {\n        return \"A\";\n    } else if percentage >= 80.0 {\n        return \"B\";\n    } else if percentage >= 70.0 {\n        return \"C\";\n    } else if percentage >= 60.0 {\n        return \"D\";\n    } else {\n        return \"F\";\n    }\n}\n\nfun main() {\n    let grade1 = grade_assignment(\"Alice\", 95, 100);\n    let grade2 = grade_assignment(\"Bob\", 42, 50);\n    let grade3 = grade_assignment(\"Charlie\", 150, 100);\n    \n    println(\"Grades: {}, {}, {}\", grade1, grade2, grade3);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 4,
          "line_number": 205,
          "code": "fun get_setting(setting_name: &str, default_value: i32) -> i32 {\n    // Simulate configuration lookup\n    if setting_name == \"timeout\" {\n        return 30;\n    } else if setting_name == \"max_retries\" {\n        return 3;\n    } else if setting_name == \"buffer_size\" {\n        return 1024;\n    } else {\n        println(\"Warning: Unknown setting '{}', using default {}\", setting_name, default_value);\n        return default_value;\n    }\n}\n\nfun initialize_system() -> bool {\n    println(\"Initializing system...\");\n    \n    // Get settings with defaults\n    let timeout = get_setting(\"timeout\", 15);\n    let retries = get_setting(\"max_retries\", 1);\n    let buffer = get_setting(\"buffer_size\", 512);\n    let unknown = get_setting(\"cache_size\", 256);\n    \n    // Display configuration\n    println(\"Configuration:\");\n    println(\"  Timeout: {} seconds\", timeout);\n    println(\"  Max retries: {}\", retries);\n    println(\"  Buffer size: {} bytes\", buffer);\n    println(\"  Cache size: {} MB\", unknown);\n    \n    // Validate critical settings\n    if timeout <= 0 {\n        println(\"Error: Timeout must be positive\");\n        return false;\n    }\n    \n    if retries < 0 {\n        println(\"Error: Retries cannot be negative\");\n        return false;\n    }\n    \n    println(\"✅ System initialized successfully\");\n    return true;\n}\n\nfun main() {\n    let success = initialize_system();\n    \n    if success {\n        println(\"System is ready for operation\");\n    } else {\n        println(\"System initialization failed\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 5,
          "line_number": 266,
          "code": "fun calculate_total(prices: [i32; 5]) -> i32 {\n    let mut total = 0;  // Accumulator starts at zero\n    let mut i = 0;\n    \n    while i < 5 {\n        total = total + prices[i];  // Accumulate each value\n        i = i + 1;\n    }\n    \n    total  // Return accumulated result\n}\n\nfun find_maximum(numbers: [i32; 5]) -> i32 {\n    let mut max_value = numbers[0];  // Accumulator starts with first value\n    let mut i = 1;\n    \n    while i < 5 {\n        if numbers[i] > max_value {\n            max_value = numbers[i];  // Update accumulator if better value found\n        }\n        i = i + 1;\n    }\n    \n    max_value  // Return best value found\n}\n\nfun count_positives(numbers: [i32; 5]) -> i32 {\n    let mut count = 0;  // Counter accumulator\n    let mut i = 0;\n    \n    while i < 5 {\n        if numbers[i] > 0 {\n            count = count + 1;  // Increment counter for matches\n        }\n        i = i + 1;\n    }\n    \n    count  // Return count\n}\n\nfun main() {\n    let prices = [10, 25, 5, 15, 8];\n    let numbers = [-3, 7, -1, 12, 0];\n    \n    let total = calculate_total(prices);\n    let maximum = find_maximum(prices);\n    let positive_count = count_positives(numbers);\n    \n    println(\"Total: {}\", total);\n    println(\"Maximum: {}\", maximum);\n    println(\"Positive numbers: {}\", positive_count);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 6,
          "line_number": 323,
          "code": "fun process_order_state(current_state: &str, action: &str) -> &str {\n    if current_state == \"pending\" {\n        if action == \"pay\" {\n            println(\"Payment received, order confirmed\");\n            return \"confirmed\";\n        } else if action == \"cancel\" {\n            println(\"Order cancelled\");\n            return \"cancelled\";\n        } else {\n            println(\"Invalid action '{}' for pending order\", action);\n            return current_state;\n        }\n    } else if current_state == \"confirmed\" {\n        if action == \"ship\" {\n            println(\"Order shipped\");\n            return \"shipped\";\n        } else if action == \"cancel\" {\n            println(\"Confirmed order cancelled, refund processed\");\n            return \"cancelled\";\n        } else {\n            println(\"Invalid action '{}' for confirmed order\", action);\n            return current_state;\n        }\n    } else if current_state == \"shipped\" {\n        if action == \"deliver\" {\n            println(\"Order delivered\");\n            return \"delivered\";\n        } else {\n            println(\"Cannot modify shipped order\");\n            return current_state;\n        }\n    } else if current_state == \"delivered\" {\n        println(\"Order already completed\");\n        return current_state;\n    } else if current_state == \"cancelled\" {\n        println(\"Order was cancelled\");\n        return current_state;\n    } else {\n        println(\"Unknown order state: {}\", current_state);\n        return \"error\";\n    }\n}\n\nfun track_order() -> &str {\n    let mut state = \"pending\";\n    \n    println(\"Order tracking simulation:\");\n    println(\"Initial state: {}\", state);\n    \n    // Process sequence of actions\n    state = process_order_state(state, \"pay\");\n    println(\"Current state: {}\", state);\n    \n    state = process_order_state(state, \"ship\");\n    println(\"Current state: {}\", state);\n    \n    state = process_order_state(state, \"deliver\");\n    println(\"Current state: {}\", state);\n    \n    state\n}\n\nfun main() {\n    let final_state = track_order();\n    println(\"Final order state: {}\", final_state);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\nError: Failed to parse Ruchy source\n\nCaused by:\n    Expected RightBrace, found Let\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 7,
          "line_number": 394,
          "code": "fun build_greeting(name: &str, formal: bool, include_time: bool) -> String {\n    let mut greeting = String::new();\n    \n    // Start with appropriate formality\n    if formal {\n        greeting = greeting + \"Good day, \";\n    } else {\n        greeting = greeting + \"Hello, \";\n    }\n    \n    // Add the name\n    greeting = greeting + name;\n    \n    // Add time information if requested\n    if include_time {\n        greeting = greeting + \"! Hope you're having a great day\";\n    } else {\n        greeting = greeting + \"!\";\n    }\n    \n    greeting\n}\n\nfun build_email_subject(priority: &str, department: &str, topic: &str) -> String {\n    let mut subject = String::new();\n    \n    // Add priority prefix\n    if priority == \"urgent\" {\n        subject = subject + \"[URGENT] \";\n    } else if priority == \"high\" {\n        subject = subject + \"[HIGH] \";\n    }\n    \n    // Add department prefix\n    subject = subject + \"[\" + department + \"] \";\n    \n    // Add main topic\n    subject = subject + topic;\n    \n    subject\n}\n\nfun main() {\n    let greeting1 = build_greeting(\"Alice\", true, true);\n    let greeting2 = build_greeting(\"Bob\", false, false);\n    \n    let subject1 = build_email_subject(\"urgent\", \"IT\", \"Server maintenance required\");\n    let subject2 = build_email_subject(\"normal\", \"HR\", \"Team meeting scheduled\");\n    \n    println(\"Greetings:\");\n    println(\"  {}\", greeting1);\n    println(\"  {}\", greeting2);\n    \n    println(\"Email subjects:\");\n    println(\"  {}\", subject1);\n    println(\"  {}\", subject2);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 8,
          "line_number": 458,
          "code": "fun process_student_data(name: &str, scores: [i32; 3]) -> String {\n    // Pattern 1: Input validation\n    if name.len() == 0 {\n        return String::from(\"Error: Student name required\");\n    }\n    \n    // Pattern 2: Accumulator for total\n    let mut total = 0;\n    let mut i = 0;\n    while i < 3 {\n        if scores[i] < 0 || scores[i] > 100 {\n            return String::from(\"Error: Scores must be between 0 and 100\");\n        }\n        total = total + scores[i];\n        i = i + 1;\n    }\n    \n    // Pattern 3: Calculation with validation\n    let average = total / 3;\n    \n    // Pattern 4: State-based classification\n    let grade = if average >= 90 {\n        \"A\"\n    } else if average >= 80 {\n        \"B\"\n    } else if average >= 70 {\n        \"C\"\n    } else if average >= 60 {\n        \"D\"\n    } else {\n        \"F\"\n    };\n    \n    // Pattern 5: Builder pattern for result\n    let mut result = String::from(\"Student Report\\n\");\n    result = result + \"Name: \" + name + \"\\n\";\n    result = result + \"Scores: \";\n    \n    // Add individual scores\n    let mut i = 0;\n    while i < 3 {\n        if i > 0 {\n            result = result + \", \";\n        }\n        result = result + &scores[i].to_string();\n        i = i + 1;\n    }\n    \n    result = result + \"\\n\";\n    result = result + \"Average: \" + &average.to_string() + \"\\n\";\n    result = result + \"Grade: \" + grade;\n    \n    result\n}\n\nfun main() {\n    let report1 = process_student_data(\"Alice Johnson\", [95, 87, 92]);\n    let report2 = process_student_data(\"Bob Smith\", [78, 82, 75]);\n    let report3 = process_student_data(\"\", [85, 90, 88]);\n    \n    println(\"{}\\n\", report1);\n    println(\"{}\\n\", report2);  \n    println(\"{}\\n\", report3);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 9,
          "line_number": 529,
          "code": "// Test helper function\nfun assert_equal(actual: i32, expected: i32, test_name: &str) {\n    if actual == expected {\n        println(\"✅ {}: {} == {}\", test_name, actual, expected);\n    } else {\n        println(\"❌ {}: {} != {} (expected)\", test_name, actual, expected);\n    }\n}\n\nfun assert_string_equal(actual: &str, expected: &str, test_name: &str) {\n    if actual == expected {\n        println(\"✅ {}: strings match\", test_name);\n    } else {\n        println(\"❌ {}: '{}' != '{}' (expected)\", test_name, actual, expected);\n    }\n}\n\n// Function to test\nfun calculate_discount(price: i32, discount_percent: i32) -> i32 {\n    if discount_percent < 0 || discount_percent > 100 {\n        return price;  // No discount for invalid percentage\n    }\n    \n    let discount_amount = (price * discount_percent) / 100;\n    price - discount_amount\n}\n\n// Test suite\nfun test_discount_calculation() {\n    println(\"Testing discount calculation...\");\n    \n    // Normal cases\n    assert_equal(calculate_discount(100, 10), 90, \"10% discount on $100\");\n    assert_equal(calculate_discount(50, 20), 40, \"20% discount on $50\");\n    assert_equal(calculate_discount(200, 0), 200, \"0% discount on $200\");\n    \n    // Edge cases\n    assert_equal(calculate_discount(100, -5), 100, \"Negative discount\");\n    assert_equal(calculate_discount(100, 150), 100, \"Over 100% discount\");\n    assert_equal(calculate_discount(0, 50), 0, \"50% discount on $0\");\n    \n    println(\"Discount tests completed.\\n\");\n}\n\nfun main() {\n    test_discount_calculation();\n    \n    // Demo the actual function\n    println(\"Discount examples:\");\n    println(\"$100 with 15% discount: ${}\", calculate_discount(100, 15));\n    println(\"$250 with 25% discount: ${}\", calculate_discount(250, 25));\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 10,
          "line_number": 588,
          "code": "fun count_word_frequencies(text: &str) -> i32 {\n    // Simple word counting simulation\n    // In real implementation, this would be more sophisticated\n    let mut word_count = 0;\n    let mut in_word = false;\n    let chars = text.as_bytes();\n    let mut i = 0;\n    \n    while i < text.len() {\n        let ch = chars[i];\n        \n        // Simple word boundary detection\n        if ch == b' ' || ch == b'\\n' || ch == b'\\t' {\n            if in_word {\n                word_count = word_count + 1;\n                in_word = false;\n            }\n        } else {\n            if !in_word {\n                in_word = true;\n            }\n        }\n        \n        i = i + 1;\n    }\n    \n    // Count the last word if text doesn't end with whitespace\n    if in_word {\n        word_count = word_count + 1;\n    }\n    \n    word_count\n}\n\nfun process_text_efficiently(text: &str) -> String {\n    let word_count = count_word_frequencies(text);\n    let char_count = text.len();\n    \n    // Build result efficiently\n    let mut result = String::from(\"Text Analysis:\\n\");\n    result = result + \"Characters: \" + &char_count.to_string() + \"\\n\";\n    result = result + \"Words: \" + &word_count.to_string() + \"\\n\";\n    \n    // Calculate average word length\n    let avg_word_length = if word_count > 0 {\n        char_count / (word_count as usize)\n    } else {\n        0\n    };\n    \n    result = result + \"Average word length: \" + &avg_word_length.to_string();\n    \n    result\n}\n\nfun main() {\n    let sample_text = \"Hello world this is a simple text processing example\";\n    let analysis = process_text_efficiently(sample_text);\n    \n    println(\"Sample text: \\\"{}\\\"\", sample_text);\n    println(\"{}\", analysis);\n}",
          "passed": false,
          "status": "broken",
          "error": "\nthread 'main' (1920170) panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ruchy-3.77.0/src/backend/transpiler/expressions.rs:40:18:\ninternal error: entered unreachable code\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "conclusion": {
      "chapter": "conclusion",
      "total_examples": 1,
      "working_examples": 1,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/conclusion.md",
          "example_number": 1,
          "line_number": 205,
          "code": "fun calculate(x: i32, y: i32) -> i32 {\n    return x + y;\n}\n\nfun main() {\n    let result = calculate(10, 20);\n    println(result);  // Output: 30\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch06-00-data-structures-tdd": {
      "chapter": "ch06-00-data-structures-tdd",
      "total_examples": 17,
      "working_examples": 17,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 1,
          "line_number": 51,
          "code": "fun main() {\n    let greeting = \"Hello\";\n    let name = \"World\";\n    println(greeting);\n    println(name);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 2,
          "line_number": 73,
          "code": "fun main() {\n    let first = \"Hello\";\n    let second = \"Beautiful\";\n    let third = \"World\";\n    println(first);\n    println(second);\n    println(third);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 3,
          "line_number": 98,
          "code": "fun main() {\n    let number = 42;\n    let text = \"Answer\";\n    println(text);\n    println(number);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 4,
          "line_number": 120,
          "code": "fun main() {\n    let text = \"Hello\"\n    println(text.len())\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 5,
          "line_number": 139,
          "code": "fun main() {\n    let pair = (1, 2)\n    println(pair)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 6,
          "line_number": 158,
          "code": "fun main() {\n    let numbers = [1, 2, 3]\n    println(numbers)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 7,
          "line_number": 177,
          "code": "fun main() {\n    let numbers = [1, 2, 3, 4, 5]\n    println(numbers[0])\n    println(numbers[4])\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 8,
          "line_number": 198,
          "code": "fun main() {\n    let numbers = [10, 20, 30]\n    let sum = numbers[0] + numbers[1] + numbers[2]\n    println(sum)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 9,
          "line_number": 218,
          "code": "fun main() {\n    let pair = (42, \"answer\")\n    println(pair)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 10,
          "line_number": 270,
          "code": "fun main() {\n    let message = \"Hello World\"\n    let name = \"Alice\"\n    let greeting = \"Welcome\"\n    println(message)\n    println(name)\n    println(greeting)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 11,
          "line_number": 282,
          "code": "fun main() {\n    let numbers = [1, 2, 3, 4, 5]\n    let first = numbers[0]\n    let last = numbers[4]\n    println(first)\n    println(last)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 12,
          "line_number": 293,
          "code": "fun main() {\n    let pair = (42, \"answer\")\n    let coordinates = (10, 20, 30)\n    println(pair)\n    println(coordinates)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 13,
          "line_number": 303,
          "code": "fun main() {\n    let text = \"Count\"\n    let number = 100\n    let flag = true\n    println(text)\n    println(number)\n    println(flag)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 14,
          "line_number": 329,
          "code": "fun main() {\n    let first_name = \"John\"\n    let last_name = \"Doe\"\n    let title = \"Mr.\"\n    println(title)\n    println(first_name)\n    println(last_name)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 15,
          "line_number": 341,
          "code": "fun main() {\n    let temperature = (72, \"Fahrenheit\")\n    let pressure = (14.7, \"PSI\")\n    println(temperature)\n    println(pressure)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 16,
          "line_number": 351,
          "code": "fun main() {\n    let scores = [95, 87, 92, 88, 91]\n    let total = scores[0] + scores[1] + scores[2] + scores[3] + scores[4]\n    println(f\"Total score: {total}\")\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 17,
          "line_number": 360,
          "code": "fun main() {\n    let config = (\"MyApp\", \"1.0\", true)\n    println(config)\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch03-00-functions-tdd": {
      "chapter": "ch03-00-functions-tdd",
      "total_examples": 11,
      "working_examples": 9,
      "failing_examples": 2,
      "examples": [
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun greet() {\n    println(\"Hello from function!\");\n}\n\nfun main() {\n    greet();\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 2,
          "line_number": 54,
          "code": "fun add(a, b) {\n    a + b\n}\n\nfun main() {\n    let result = add(5, 3);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 3,
          "line_number": 77,
          "code": "fun multiply(x: i32, y: i32) -> i32 {\n    x * y\n}\n\nfun main() {\n    let product = multiply(6, 7);\n    println(product);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 4,
          "line_number": 100,
          "code": "fun square(n: i32) -> i32 {\n    n * n\n}\n\nfun sum_of_squares(a: i32, b: i32) -> i32 {\n    square(a) + square(b)\n}\n\nfun main() {\n    let result = sum_of_squares(3, 4);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 5,
          "line_number": 127,
          "code": "// Example function definition\nfun calculate_area(length: i32, width: i32) -> i32 {\n    length * width\n}\n\nfun main() {\n    let area = calculate_area(5, 3);\n    println(area);  // Output: 15\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 6,
          "line_number": 167,
          "code": "fun calculate(x: i32, y: i32) -> i32 {\n    x * 2 + y * 3\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 7,
          "line_number": 196,
          "code": "fun calculate(input: i32) -> i32 {\n    input * 2\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 8,
          "line_number": 206,
          "code": "fun combine(a: i32, b: i32, c: i32) -> i32 {\n    a + b + c\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 9,
          "line_number": 216,
          "code": "fun helper(x: i32) -> i32 {\n    x * x\n}\n\nfun main_calculation(n: i32) -> i32 {\n    helper(n) + helper(n + 1)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 10,
          "line_number": 230,
          "code": "fun analyze_sales(df: DataFrame) -> DataFrame {\n    // Function that processes a DataFrame\n    df.group_by(\"product\")\n      .agg(\"revenue\", \"sum\")\n      .sort_by(\"revenue_sum\", descending: true)\n}\n\nfun filter_high_value(df: DataFrame, threshold: f64) -> DataFrame {\n    // Function with DataFrame and parameter\n    df.filter(|row| row[\"value\"] > threshold)\n}\n\nfun main() {\n    let sales = DataFrame::from_csv(\"sales.csv\");\n    let analysis = analyze_sales(sales);\n    let top_items = filter_high_value(analysis, 10000.0);\n    println(\"Found {} high-value items\", top_items.rows());\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Cargo build failed:\n    Updating crates.io index\n     Locking 162 packages to latest compatible versions\n      Adding polars v0.35.4 (available: v0.51.0)\n   Compiling version_check v0.9.5\n   Compiling proc-macro2 v1.0.101\n   Compiling libc v0.2.177\n   Compiling unicode-ident v1.0.19\n   Compiling quote v1.0.41\n   Compiling cfg-if v1.0.3\n   Compiling autocfg v1.5.0\n   Compiling zerocopy v0.8.27\n   Compiling libm v0.2.15\n   Compiling crossbeam-utils v0.8.21\n   Compiling memchr v2.7.6\n   Compiling num-traits v0.2.19\n   Compiling target-features v0.1.6\n   Compiling getrandom v0.3.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling rayon-core v1.13.0\n   Compiling aho-corasick v1.1.3\n   Compiling syn v2.0.106\n   Compiling crossbeam-deque v0.8.6\n   Compiling ahash v0.8.12\n   Compiling regex-syntax v0.8.8\n   Compiling thiserror v1.0.69\n   Compiling syn v1.0.109\n   Compiling smartstring v1.0.1\n   Compiling once_cell v1.21.3\n   Compiling parking_lot_core v0.9.12\n   Compiling either v1.15.0\n   Compiling thiserror-impl v1.0.69\n   Compiling bytemuck_derive v1.10.2\n   Compiling regex-automata v0.4.13\n   Compiling rayon v1.11.0\n   Compiling getrandom v0.2.16\n   Compiling polars-utils v0.35.4\n   Compiling iana-time-zone v0.1.64\n   Compiling smallvec v1.15.1\n   Compiling regex v1.12.2\n   Compiling simdutf8 v0.1.5\n   Compiling scopeguard v1.2.0\n   Compiling allocator-api2 v0.2.21\n   Compiling hashbrown v0.16.0\n   Compiling rustix v1.1.2\n   Compiling static_assertions v1.1.0\n   Compiling equivalent v1.0.2\n   Compiling multiversion-macros v0.7.4\n   Compiling hashbrown v0.14.5\n   Compiling lock_api v0.4.14\n   Compiling indexmap v2.11.4\n   Compiling chrono v0.4.42\n   Compiling bytemuck v1.24.0\n   Compiling rand_core v0.6.4\n   Compiling polars-error v0.35.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling linux-raw-sys v0.11.0\n   Compiling ryu v1.0.20\n   Compiling itoa v1.0.15\n   Compiling bitflags v2.9.4\n   Compiling litrs v0.4.2\n   Compiling rand_chacha v0.3.1\n   Compiling parking_lot v0.12.5\n   Compiling atoi_simd v0.15.6\n   Compiling document-features v0.2.11\n   Compiling strength_reduce v0.2.4\n   Compiling dyn-clone v1.0.20\n   Compiling foreign_vec v0.1.0\n   Compiling ethnum v1.5.2\n   Compiling streaming-iterator v0.1.9\n   Compiling fast-float v0.2.0\n   Compiling rand v0.8.5\n   Compiling polars-core v0.35.4\n   Compiling unicode-segmentation v1.12.0\n   Compiling multiversion v0.7.4\n   Compiling unicode-width v0.2.2\n   Compiling polars-ops v0.35.4\n   Compiling xxhash-rust v0.8.15\n   Compiling rand_distr v0.4.3\n   Compiling argminmax v0.6.3\n   Compiling rustversion v1.0.22\n   Compiling crossterm v0.29.0\n   Compiling polars-arrow v0.35.4\n   Compiling now v0.1.3\n   Compiling atoi v2.0.0\n   Compiling memmap2 v0.7.1\n   Compiling polars-plan v0.35.4\n   Compiling comfy-table v7.2.1\n   Compiling percent-encoding v2.3.2\n   Compiling heck v0.4.1\n   Compiling bytes v1.10.1\n   Compiling home v0.5.11\n   Compiling serde_core v1.0.228\n   Compiling polars-lazy v0.35.4\n   Compiling polars v0.35.4\n   Compiling glob v0.3.3\n   Compiling serde v1.0.228\n   Compiling serde_json v1.0.145\n   Compiling serde_derive v1.0.228\n   Compiling strum_macros v0.25.3\n   Compiling polars-row v0.35.4\n   Compiling polars-time v0.35.4\n   Compiling polars-io v0.35.4\n   Compiling ruchy_binary v0.1.0 (/tmp/.tmp7zJbq3)\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> src/main.rs:1:24\n  |\n1 | fn analyze_sales (df : DataFrame) -> DataFrame { df . groupby (& []) . expect (\"Failed to group DataFrame\") . agg (\"revenue\" , \"sum\") . s...\n  |                        ^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 + use polars::frame::DataFrame;\n  |\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> src/main.rs:1:38\n  |\n1 | fn analyze_sales (df : DataFrame) -> DataFrame { df . groupby (& []) . expect (\"Failed to group DataFrame\") . agg (\"revenue\" , \"sum\") . s...\n  |                                      ^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 + use polars::frame::DataFrame;\n  |\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> src/main.rs:1:379\n  |\n1 | ..._string ()) ; map }) } fn filter_high_value (df : DataFrame , threshold : f64) -> DataFrame { df . lazy () . filter (move | row | row ...\n  |                                                      ^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 + use polars::frame::DataFrame;\n  |\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> src/main.rs:1:411\n  |\n1 | ..._high_value (df : DataFrame , threshold : f64) -> DataFrame { df . lazy () . filter (move | row | row . get (\"value\") . cloned () . un...\n  |                                                      ^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 + use polars::frame::DataFrame;\n  |\n\nerror[E0282]: type annotations needed\n --> src/main.rs:1:453\n  |\n1 | ... -> DataFrame { df . lazy () . filter (move | row | row . get (\"value\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) > ...\n  |                                                  ^^^   --- type must be known at this point\n  |\nhelp: consider giving this closure parameter an explicit type\n  |\n1 | fn analyze_sales (df : DataFrame) -> DataFrame { df . groupby (& []) . expect (\"Failed to group DataFrame\") . agg (\"revenue\" , \"sum\") . sort_by (\"revenue_sum\" , { let mut map : std :: collections :: BTreeMap < String , String > = std :: collections :: BTreeMap :: new () ; map . insert (\"descending\" . to_string () , (true) . to_string ()) ; map }) } fn filter_high_value (df : DataFrame , threshold : f64) -> DataFrame { df . lazy () . filter (move | row: /* Type */ | row . get (\"value\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) > threshold) . collect () . expect (\"DataFrame lazy operation collection should not fail\") } fn main () { { let sales = polars :: prelude :: CsvReader :: from_path (\"sales.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; { let analysis = analyze_sales (sales) ; let top_items = filter_high_value (analysis , 10000f64) ; println ! (\"Found {} high-value items\" , top_items . rows ()) } } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ++++++++++++\n\nerror[E0599]: no method named `finish` found for struct `CsvReader<'a, R>` in the current scope\n  --> src/main.rs:1:756\n   |\n 1 | ... expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; { let analysis = analyze_sales (sales) ; let to...\n   |                                          ^^^^^^ method not found in `CsvReader<'_, std::fs::File>`\n   |\n  ::: /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/polars-io-0.35.4/src/lib.rs:68:8\n   |\n68 |     fn finish(self) -> PolarsResult<DataFrame>;\n   |        ------ the method is available for `CsvReader<'_, std::fs::File>` here\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `SerReader` which provides `finish` is implemented but not in scope; perhaps you want to import it\n   |\n 1 + use polars::prelude::SerReader;\n   |\n\nSome errors have detailed explanations: E0282, E0412, E0599.\nFor more information about an error, try `rustc --explain E0282`.\nerror: could not compile `ruchy_binary` (bin \"ruchy_binary\") due to 6 previous errors\n\nError: Cargo build failed:\n    Updating crates.io index\n     Locking 162 packages to latest compatible versions\n      Adding polars v0.35.4 (available: v0.51.0)\n   Compiling version_check v0.9.5\n   Compiling proc-macro2 v1.0.101\n   Compiling libc v0.2.177\n   Compiling unicode-ident v1.0.19\n   Compiling quote v1.0.41\n   Compiling cfg-if v1.0.3\n   Compiling autocfg v1.5.0\n   Compiling zerocopy v0.8.27\n   Compiling libm v0.2.15\n   Compiling crossbeam-utils v0.8.21\n   Compiling memchr v2.7.6\n   Compiling num-traits v0.2.19\n   Compiling target-features v0.1.6\n   Compiling getrandom v0.3.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling rayon-core v1.13.0\n   Compiling aho-corasick v1.1.3\n   Compiling syn v2.0.106\n   Compiling crossbeam-deque v0.8.6\n   Compiling ahash v0.8.12\n   Compiling regex-syntax v0.8.8\n   Compiling thiserror v1.0.69\n   Compiling syn v1.0.109\n   Compiling smartstring v1.0.1\n   Compiling once_cell v1.21.3\n   Compiling parking_lot_core v0.9.12\n   Compiling either v1.15.0\n   Compiling thiserror-impl v1.0.69\n   Compiling bytemuck_derive v1.10.2\n   Compiling regex-automata v0.4.13\n   Compiling rayon v1.11.0\n   Compiling getrandom v0.2.16\n   Compiling polars-utils v0.35.4\n   Compiling iana-time-zone v0.1.64\n   Compiling smallvec v1.15.1\n   Compiling regex v1.12.2\n   Compiling simdutf8 v0.1.5\n   Compiling scopeguard v1.2.0\n   Compiling allocator-api2 v0.2.21\n   Compiling hashbrown v0.16.0\n   Compiling rustix v1.1.2\n   Compiling static_assertions v1.1.0\n   Compiling equivalent v1.0.2\n   Compiling multiversion-macros v0.7.4\n   Compiling hashbrown v0.14.5\n   Compiling lock_api v0.4.14\n   Compiling indexmap v2.11.4\n   Compiling chrono v0.4.42\n   Compiling bytemuck v1.24.0\n   Compiling rand_core v0.6.4\n   Compiling polars-error v0.35.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling linux-raw-sys v0.11.0\n   Compiling ryu v1.0.20\n   Compiling itoa v1.0.15\n   Compiling bitflags v2.9.4\n   Compiling litrs v0.4.2\n   Compiling rand_chacha v0.3.1\n   Compiling parking_lot v0.12.5\n   Compiling atoi_simd v0.15.6\n   Compiling document-features v0.2.11\n   Compiling strength_reduce v0.2.4\n   Compiling dyn-clone v1.0.20\n   Compiling foreign_vec v0.1.0\n   Compiling ethnum v1.5.2\n   Compiling streaming-iterator v0.1.9\n   Compiling fast-float v0.2.0\n   Compiling rand v0.8.5\n   Compiling polars-core v0.35.4\n   Compiling unicode-segmentation v1.12.0\n   Compiling multiversion v0.7.4\n   Compiling unicode-width v0.2.2\n   Compiling polars-ops v0.35.4\n   Compiling xxhash-rust v0.8.15\n   Compiling rand_distr v0.4.3\n   Compiling argminmax v0.6.3\n   Compiling rustversion v1.0.22\n   Compiling crossterm v0.29.0\n   Compiling polars-arrow v0.35.4\n   Compiling now v0.1.3\n   Compiling atoi v2.0.0\n   Compiling memmap2 v0.7.1\n   Compiling polars-plan v0.35.4\n   Compiling comfy-table v7.2.1\n   Compiling percent-encoding v2.3.2\n   Compiling heck v0.4.1\n   Compiling bytes v1.10.1\n   Compiling home v0.5.11\n   Compiling serde_core v1.0.228\n   Compiling polars-lazy v0.35.4\n   Compiling polars v0.35.4\n   Compiling glob v0.3.3\n   Compiling serde v1.0.228\n   Compiling serde_json v1.0.145\n   Compiling serde_derive v1.0.228\n   Compiling strum_macros v0.25.3\n   Compiling polars-row v0.35.4\n   Compiling polars-time v0.35.4\n   Compiling polars-io v0.35.4\n   Compiling ruchy_binary v0.1.0 (/tmp/.tmp7zJbq3)\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> src/main.rs:1:24\n  |\n1 | fn analyze_sales (df : DataFrame) -> DataFrame { df . groupby (& []) . expect (\"Failed to group DataFrame\") . agg (\"revenue\" , \"sum\") . s...\n  |                        ^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 + use polars::frame::DataFrame;\n  |\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> src/main.rs:1:38\n  |\n1 | fn analyze_sales (df : DataFrame) -> DataFrame { df . groupby (& []) . expect (\"Failed to group DataFrame\") . agg (\"revenue\" , \"sum\") . s...\n  |                                      ^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 + use polars::frame::DataFrame;\n  |\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> src/main.rs:1:379\n  |\n1 | ..._string ()) ; map }) } fn filter_high_value (df : DataFrame , threshold : f64) -> DataFrame { df . lazy () . filter (move | row | row ...\n  |                                                      ^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 + use polars::frame::DataFrame;\n  |\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> src/main.rs:1:411\n  |\n1 | ..._high_value (df : DataFrame , threshold : f64) -> DataFrame { df . lazy () . filter (move | row | row . get (\"value\") . cloned () . un...\n  |                                                      ^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 + use polars::frame::DataFrame;\n  |\n\nerror[E0282]: type annotations needed\n --> src/main.rs:1:453\n  |\n1 | ... -> DataFrame { df . lazy () . filter (move | row | row . get (\"value\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) > ...\n  |                                                  ^^^   --- type must be known at this point\n  |\nhelp: consider giving this closure parameter an explicit type\n  |\n1 | fn analyze_sales (df : DataFrame) -> DataFrame { df . groupby (& []) . expect (\"Failed to group DataFrame\") . agg (\"revenue\" , \"sum\") . sort_by (\"revenue_sum\" , { let mut map : std :: collections :: BTreeMap < String , String > = std :: collections :: BTreeMap :: new () ; map . insert (\"descending\" . to_string () , (true) . to_string ()) ; map }) } fn filter_high_value (df : DataFrame , threshold : f64) -> DataFrame { df . lazy () . filter (move | row: /* Type */ | row . get (\"value\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) > threshold) . collect () . expect (\"DataFrame lazy operation collection should not fail\") } fn main () { { let sales = polars :: prelude :: CsvReader :: from_path (\"sales.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; { let analysis = analyze_sales (sales) ; let top_items = filter_high_value (analysis , 10000f64) ; println ! (\"Found {} high-value items\" , top_items . rows ()) } } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ++++++++++++\n\nerror[E0599]: no method named `finish` found for struct `CsvReader<'a, R>` in the current scope\n  --> src/main.rs:1:756\n   |\n 1 | ... expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; { let analysis = analyze_sales (sales) ; let to...\n   |                                          ^^^^^^ method not found in `CsvReader<'_, std::fs::File>`\n   |\n  ::: /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/polars-io-0.35.4/src/lib.rs:68:8\n   |\n68 |     fn finish(self) -> PolarsResult<DataFrame>;\n   |        ------ the method is available for `CsvReader<'_, std::fs::File>` here\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: trait `SerReader` which provides `finish` is implemented but not in scope; perhaps you want to import it\n   |\n 1 + use polars::prelude::SerReader;\n   |\n\nSome errors have detailed explanations: E0282, E0412, E0599.\nFor more information about an error, try `rustc --explain E0282`.\nerror: could not compile `ruchy_binary` (bin \"ruchy_binary\") due to 6 previous errors\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: finish()"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 11,
          "line_number": 252,
          "code": "fun add_profit_margin(df: DataFrame) -> DataFrame {\n    // Add calculated column to DataFrame\n    df.with_column(\"margin\", |row| {\n        (row[\"revenue\"] - row[\"cost\"]) / row[\"revenue\"] * 100.0\n    })\n}\n\nfun summarize_by_category(df: DataFrame) -> DataFrame {\n    // Aggregate DataFrame by category\n    df.group_by(\"category\")\n      .agg(\"quantity\", \"sum\")\n      .agg(\"revenue\", \"mean\")\n      .agg(\"margin\", \"mean\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Cargo build failed:\n    Updating crates.io index\n     Locking 162 packages to latest compatible versions\n      Adding polars v0.35.4 (available: v0.51.0)\n   Compiling version_check v0.9.5\n   Compiling libc v0.2.177\n   Compiling proc-macro2 v1.0.101\n   Compiling unicode-ident v1.0.19\n   Compiling quote v1.0.41\n   Compiling cfg-if v1.0.3\n   Compiling autocfg v1.5.0\n   Compiling zerocopy v0.8.27\n   Compiling libm v0.2.15\n   Compiling crossbeam-utils v0.8.21\n   Compiling target-features v0.1.6\n   Compiling num-traits v0.2.19\n   Compiling memchr v2.7.6\n   Compiling rayon-core v1.13.0\n   Compiling getrandom v0.3.3\n   Compiling aho-corasick v1.1.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling ahash v0.8.12\n   Compiling syn v2.0.106\n   Compiling crossbeam-deque v0.8.6\n   Compiling thiserror v1.0.69\n   Compiling syn v1.0.109\n   Compiling regex-syntax v0.8.8\n   Compiling smartstring v1.0.1\n   Compiling once_cell v1.21.3\n   Compiling parking_lot_core v0.9.12\n   Compiling either v1.15.0\n   Compiling rayon v1.11.0\n   Compiling thiserror-impl v1.0.69\n   Compiling bytemuck_derive v1.10.2\n   Compiling getrandom v0.2.16\n   Compiling regex-automata v0.4.13\n   Compiling polars-utils v0.35.4\n   Compiling allocator-api2 v0.2.21\n   Compiling hashbrown v0.16.0\n   Compiling rustix v1.1.2\n   Compiling scopeguard v1.2.0\n   Compiling static_assertions v1.1.0\n   Compiling equivalent v1.0.2\n   Compiling iana-time-zone v0.1.64\n   Compiling simdutf8 v0.1.5\n   Compiling regex v1.12.2\n   Compiling smallvec v1.15.1\n   Compiling indexmap v2.11.4\n   Compiling chrono v0.4.42\n   Compiling lock_api v0.4.14\n   Compiling multiversion-macros v0.7.4\n   Compiling hashbrown v0.14.5\n   Compiling bytemuck v1.24.0\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling ryu v1.0.20\n   Compiling polars-error v0.35.4\n   Compiling linux-raw-sys v0.11.0\n   Compiling bitflags v2.9.4\n   Compiling litrs v0.4.2\n   Compiling itoa v1.0.15\n   Compiling rand_chacha v0.3.1\n   Compiling parking_lot v0.12.5\n   Compiling document-features v0.2.11\n   Compiling fast-float v0.2.0\n   Compiling streaming-iterator v0.1.9\n   Compiling ethnum v1.5.2\n   Compiling atoi_simd v0.15.6\n   Compiling strength_reduce v0.2.4\n   Compiling foreign_vec v0.1.0\n   Compiling dyn-clone v1.0.20\n   Compiling rand v0.8.5\n   Compiling polars-core v0.35.4\n   Compiling unicode-segmentation v1.12.0\n   Compiling unicode-width v0.2.2\n   Compiling polars-ops v0.35.4\n   Compiling crossterm v0.29.0\n   Compiling multiversion v0.7.4\n   Compiling xxhash-rust v0.8.15\n   Compiling argminmax v0.6.3\n   Compiling rustversion v1.0.22\n   Compiling now v0.1.3\n   Compiling rand_distr v0.4.3\n   Compiling atoi v2.0.0\n   Compiling polars-arrow v0.35.4\n   Compiling comfy-table v7.2.1\n   Compiling memmap2 v0.7.1\n   Compiling polars-plan v0.35.4\n   Compiling serde_core v1.0.228\n   Compiling home v0.5.11\n   Compiling heck v0.4.1\n   Compiling bytes v1.10.1\n   Compiling percent-encoding v2.3.2\n   Compiling polars-lazy v0.35.4\n   Compiling polars v0.35.4\n   Compiling glob v0.3.3\n   Compiling serde v1.0.228\n   Compiling serde_json v1.0.145\n   Compiling serde_derive v1.0.228\n   Compiling strum_macros v0.25.3\n   Compiling polars-row v0.35.4\n   Compiling polars-time v0.35.4\n   Compiling polars-io v0.35.4\n   Compiling ruchy_binary v0.1.0 (/tmp/.tmpx7Az0m)\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> src/main.rs:1:28\n  |\n1 | fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column (\"margin\" , move | row | { (row . get (\"revenue\") . cloned () . unw...\n  |                            ^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 + use polars::frame::DataFrame;\n  |\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> src/main.rs:1:42\n  |\n1 | fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column (\"margin\" , move | row | { (row . get (\"revenue\") . cloned () . unw...\n  |                                          ^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 + use polars::frame::DataFrame;\n  |\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> src/main.rs:1:392\n  |\n1 | ...d\")) * 100f64 }) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect (\"Failed to group DataFrame\")...\n  |                                                      ^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 + use polars::frame::DataFrame;\n  |\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> src/main.rs:1:406\n  |\n1 | ...}) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect (\"Failed to group DataFrame\") . agg (\"quant...\n  |                                                      ^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 + use polars::frame::DataFrame;\n  |\n\nerror[E0282]: type annotations needed\n --> src/main.rs:1:90\n  |\n1 | fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column (\"margin\" , move | row | { (row . get (\"revenue\") . cloned () . unw...\n  |                                                                                          ^^^      --- type must be known at this point\n  |\nhelp: consider giving this closure parameter an explicit type\n  |\n1 | fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column (\"margin\" , move | row: /* Type */ | { (row . get (\"revenue\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) - row . get (\"cost\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) / row . get (\"revenue\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) * 100f64 }) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect (\"Failed to group DataFrame\") . agg (\"quantity\" , \"sum\") . agg (\"revenue\" , \"mean\") . agg (\"margin\" , \"mean\") } fn main () { }\n  |                                                                                             ++++++++++++\n\nSome errors have detailed explanations: E0282, E0412.\nFor more information about an error, try `rustc --explain E0282`.\nerror: could not compile `ruchy_binary` (bin \"ruchy_binary\") due to 5 previous errors\n\nError: Cargo build failed:\n    Updating crates.io index\n     Locking 162 packages to latest compatible versions\n      Adding polars v0.35.4 (available: v0.51.0)\n   Compiling version_check v0.9.5\n   Compiling libc v0.2.177\n   Compiling proc-macro2 v1.0.101\n   Compiling unicode-ident v1.0.19\n   Compiling quote v1.0.41\n   Compiling cfg-if v1.0.3\n   Compiling autocfg v1.5.0\n   Compiling zerocopy v0.8.27\n   Compiling libm v0.2.15\n   Compiling crossbeam-utils v0.8.21\n   Compiling target-features v0.1.6\n   Compiling num-traits v0.2.19\n   Compiling memchr v2.7.6\n   Compiling rayon-core v1.13.0\n   Compiling getrandom v0.3.3\n   Compiling aho-corasick v1.1.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling ahash v0.8.12\n   Compiling syn v2.0.106\n   Compiling crossbeam-deque v0.8.6\n   Compiling thiserror v1.0.69\n   Compiling syn v1.0.109\n   Compiling regex-syntax v0.8.8\n   Compiling smartstring v1.0.1\n   Compiling once_cell v1.21.3\n   Compiling parking_lot_core v0.9.12\n   Compiling either v1.15.0\n   Compiling rayon v1.11.0\n   Compiling thiserror-impl v1.0.69\n   Compiling bytemuck_derive v1.10.2\n   Compiling getrandom v0.2.16\n   Compiling regex-automata v0.4.13\n   Compiling polars-utils v0.35.4\n   Compiling allocator-api2 v0.2.21\n   Compiling hashbrown v0.16.0\n   Compiling rustix v1.1.2\n   Compiling scopeguard v1.2.0\n   Compiling static_assertions v1.1.0\n   Compiling equivalent v1.0.2\n   Compiling iana-time-zone v0.1.64\n   Compiling simdutf8 v0.1.5\n   Compiling regex v1.12.2\n   Compiling smallvec v1.15.1\n   Compiling indexmap v2.11.4\n   Compiling chrono v0.4.42\n   Compiling lock_api v0.4.14\n   Compiling multiversion-macros v0.7.4\n   Compiling hashbrown v0.14.5\n   Compiling bytemuck v1.24.0\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling ryu v1.0.20\n   Compiling polars-error v0.35.4\n   Compiling linux-raw-sys v0.11.0\n   Compiling bitflags v2.9.4\n   Compiling litrs v0.4.2\n   Compiling itoa v1.0.15\n   Compiling rand_chacha v0.3.1\n   Compiling parking_lot v0.12.5\n   Compiling document-features v0.2.11\n   Compiling fast-float v0.2.0\n   Compiling streaming-iterator v0.1.9\n   Compiling ethnum v1.5.2\n   Compiling atoi_simd v0.15.6\n   Compiling strength_reduce v0.2.4\n   Compiling foreign_vec v0.1.0\n   Compiling dyn-clone v1.0.20\n   Compiling rand v0.8.5\n   Compiling polars-core v0.35.4\n   Compiling unicode-segmentation v1.12.0\n   Compiling unicode-width v0.2.2\n   Compiling polars-ops v0.35.4\n   Compiling crossterm v0.29.0\n   Compiling multiversion v0.7.4\n   Compiling xxhash-rust v0.8.15\n   Compiling argminmax v0.6.3\n   Compiling rustversion v1.0.22\n   Compiling now v0.1.3\n   Compiling rand_distr v0.4.3\n   Compiling atoi v2.0.0\n   Compiling polars-arrow v0.35.4\n   Compiling comfy-table v7.2.1\n   Compiling memmap2 v0.7.1\n   Compiling polars-plan v0.35.4\n   Compiling serde_core v1.0.228\n   Compiling home v0.5.11\n   Compiling heck v0.4.1\n   Compiling bytes v1.10.1\n   Compiling percent-encoding v2.3.2\n   Compiling polars-lazy v0.35.4\n   Compiling polars v0.35.4\n   Compiling glob v0.3.3\n   Compiling serde v1.0.228\n   Compiling serde_json v1.0.145\n   Compiling serde_derive v1.0.228\n   Compiling strum_macros v0.25.3\n   Compiling polars-row v0.35.4\n   Compiling polars-time v0.35.4\n   Compiling polars-io v0.35.4\n   Compiling ruchy_binary v0.1.0 (/tmp/.tmpx7Az0m)\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> src/main.rs:1:28\n  |\n1 | fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column (\"margin\" , move | row | { (row . get (\"revenue\") . cloned () . unw...\n  |                            ^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 + use polars::frame::DataFrame;\n  |\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> src/main.rs:1:42\n  |\n1 | fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column (\"margin\" , move | row | { (row . get (\"revenue\") . cloned () . unw...\n  |                                          ^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 + use polars::frame::DataFrame;\n  |\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> src/main.rs:1:392\n  |\n1 | ...d\")) * 100f64 }) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect (\"Failed to group DataFrame\")...\n  |                                                      ^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 + use polars::frame::DataFrame;\n  |\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> src/main.rs:1:406\n  |\n1 | ...}) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect (\"Failed to group DataFrame\") . agg (\"quant...\n  |                                                      ^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 + use polars::frame::DataFrame;\n  |\n\nerror[E0282]: type annotations needed\n --> src/main.rs:1:90\n  |\n1 | fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column (\"margin\" , move | row | { (row . get (\"revenue\") . cloned () . unw...\n  |                                                                                          ^^^      --- type must be known at this point\n  |\nhelp: consider giving this closure parameter an explicit type\n  |\n1 | fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column (\"margin\" , move | row: /* Type */ | { (row . get (\"revenue\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) - row . get (\"cost\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) / row . get (\"revenue\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) * 100f64 }) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect (\"Failed to group DataFrame\") . agg (\"quantity\" , \"sum\") . agg (\"revenue\" , \"mean\") . agg (\"margin\" , \"mean\") } fn main () { }\n  |                                                                                             ++++++++++++\n\nSome errors have detailed explanations: E0282, E0412.\nFor more information about an error, try `rustc --explain E0282`.\nerror: could not compile `ruchy_binary` (bin \"ruchy_binary\") due to 5 previous errors\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch14-00-toolchain-mastery-tdd": {
      "chapter": "ch14-00-toolchain-mastery-tdd",
      "total_examples": 4,
      "working_examples": 4,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch14-00-toolchain-mastery-tdd.md",
          "example_number": 1,
          "line_number": 44,
          "code": "fun greet(name: String) -> String {\n    \"Hello, \" + name + \"!\"\n}\n\nfun main() {\n    let message = greet(\"Ruchy Developer\");\n    println(message);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch14-00-toolchain-mastery-tdd.md",
          "example_number": 2,
          "line_number": 80,
          "code": "// calculator_test.ruchy\nfun add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\nfun test_addition() {\n    let result = add(2, 3);\n    assert_eq(result, 5);\n    println(\"Addition test passed\");\n}\n\nfun main() {\n    test_addition();\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch14-00-toolchain-mastery-tdd.md",
          "example_number": 3,
          "line_number": 145,
          "code": "fun calculate_factorial(n: i32) -> i32 {\n    if n <= 1 {\n        1\n    } else {\n        n * calculate_factorial(n - 1)\n    }\n}\n\nfun main() {\n    let result = calculate_factorial(10);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch14-00-toolchain-mastery-tdd.md",
          "example_number": 4,
          "line_number": 282,
          "code": "fun fibonacci_recursive(n: i32) -> i32 {\n    if n <= 1 {\n        n\n    } else {\n        fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)\n    }\n}\n\nfun fibonacci_iterative(n: i32) -> i32 {\n    let mut a = 0;\n    let mut b = 1;\n    let mut i = 0;\n    \n    while i < n {\n        let temp = a + b;\n        a = b;\n        b = temp;\n        i = i + 1;\n    }\n    \n    a\n}\n\nfun main() {\n    let result1 = fibonacci_recursive(10);\n    let result2 = fibonacci_iterative(10);\n    println(result1);\n    println(result2);\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch15-00-binary-compilation-deployment": {
      "chapter": "ch15-00-binary-compilation-deployment",
      "total_examples": 4,
      "working_examples": 2,
      "failing_examples": 2,
      "examples": [
        {
          "file": "src/ch15-00-binary-compilation-deployment.md",
          "example_number": 1,
          "line_number": 23,
          "code": "fun main() {\n    println(\"Hello from compiled Ruchy!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch15-00-binary-compilation-deployment.md",
          "example_number": 2,
          "line_number": 58,
          "code": "fun main() {\n    let args = std::env::args();\n    \n    if args.len() < 2 {\n        println(\"Usage: calculator <expression>\");\n        return;\n    }\n    \n    let expr = args[1];\n    let result = evaluate_expression(expr);\n    println(\"Result: {}\", result);\n}\n\nfun evaluate_expression(expr: String) -> f64 {\n    // Simple calculator - supports +, -, *, /\n    if expr.contains('+') {\n        let parts = expr.split('+');\n        return parts[0].parse::<f64>() + parts[1].parse::<f64>();\n    } else if expr.contains('-') {\n        let parts = expr.split('-');\n        return parts[0].parse::<f64>() - parts[1].parse::<f64>();\n    } else if expr.contains('*') {\n        let parts = expr.split('*');\n        return parts[0].parse::<f64>() * parts[1].parse::<f64>();\n    } else if expr.contains('/') {\n        let parts = expr.split('/');\n        let divisor = parts[1].parse::<f64>();\n        if divisor != 0.0 {\n            return parts[0].parse::<f64>() / divisor;\n        }\n    }\n    \n    expr.parse::<f64>()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\nError: Failed to parse Ruchy source\n\nCaused by:\n    Expected RightBrace, found If\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-binary-compilation-deployment.md",
          "example_number": 3,
          "line_number": 104,
          "code": "fun main() {\n    let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    \n    let sum = calculate_sum(&data);\n    let avg = calculate_average(&data);\n    let max = find_maximum(&data);\n    \n    println(\"Data Analysis Results:\");\n    println(\"Sum: {}\", sum);\n    println(\"Average: {:.2}\", avg);\n    println(\"Maximum: {}\", max);\n}\n\nfun calculate_sum(data: &Vec<i32>) -> i32 {\n    let mut total = 0;\n    let mut i = 0;\n    while i < data.len() {\n        total = total + data[i];\n        i = i + 1;\n    }\n    total\n}\n\nfun calculate_average(data: &Vec<i32>) -> f64 {\n    let sum = calculate_sum(data);\n    (sum as f64) / (data.len() as f64)\n}\n\nfun find_maximum(data: &Vec<i32>) -> i32 {\n    let mut max = data[0];\n    let mut i = 1;\n    while i < data.len() {\n        if data[i] > max {\n            max = data[i];\n        }\n        i = i + 1;\n    }\n    max\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch15-00-binary-compilation-deployment.md",
          "example_number": 4,
          "line_number": 156,
          "code": "fun main() {\n    println(\"Mathematical Functions Demo\");\n    \n    let n = 10;\n    println(\"Factorial of {}: {}\", n, factorial(n));\n    \n    let x = 25;\n    println(\"Square root of {}: {}\", x, integer_sqrt(x));\n    \n    let a = 48;\n    let b = 18;\n    println(\"GCD of {} and {}: {}\", a, b, gcd(a, b));\n}\n\nfun factorial(n: i32) -> i64 {\n    if n <= 1 {\n        1\n    } else {\n        (n as i64) * factorial(n - 1)\n    }\n}\n\nfun integer_sqrt(n: i32) -> i32 {\n    if n < 2 {\n        return n;\n    }\n    \n    let mut x = n / 2;\n    let mut prev = 0;\n    \n    while x != prev {\n        prev = x;\n        x = (x + n / x) / 2;\n    }\n    \n    x\n}\n\nfun gcd(mut a: i32, mut b: i32) -> i32 {\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp61Nf6h/main.rs:1:301\n  |\n1 | ...a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematic...\n  |                                               ^^                                           ^^\n  |\n  = note: `#[warn(unused_braces)]` (part of `#[warn(unused)]`) on by default\nhelp: remove these braces\n  |\n1 - fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; let mut prev = 0 ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n = 10 ; { println ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let mut x = 25 ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } }\n1 + fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; let mut prev = 0 ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0 { { let temp = b ; { b = a % b ; a = temp } }  } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n = 10 ; { println ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let mut x = 25 ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } }\n  |\n\nerror[E0384]: cannot assign to immutable argument `b`\n --> /tmp/.tmp61Nf6h/main.rs:1:322\n  |\n1 | ...> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ...\n  |                                                ^^^^^^^^^ cannot assign to immutable argument\n  |\nhelp: consider making this binding mutable\n  |\n1 | fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; let mut prev = 0 ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , mut b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n = 10 ; { println ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let mut x = 25 ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } }\n  |                                                                                                                                                                                                                                                                            +++\n\nerror[E0384]: cannot assign to immutable argument `a`\n --> /tmp/.tmp61Nf6h/main.rs:1:334\n  |\n1 | ...le b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n =...\n  |                                                 ^^^^^^^^ cannot assign to immutable argument\n  |\nhelp: consider making this binding mutable\n  |\n1 | fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; let mut prev = 0 ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (mut a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n = 10 ; { println ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let mut x = 25 ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } }\n  |                                                                                                                                                                                                                                                                  +++\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmp61Nf6h/main.rs:1:491\n  |\n1 | ... ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let mut x = 25 ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let mut...\n  |                                                         ----^\n  |                                                         |\n  |                                                         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmp61Nf6h/main.rs:1:569\n  |\n1 | ...Square root of {}: {}\" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a ...\n  |                                                         ----^\n  |                                                         |\n  |                                                         help: remove this `mut`\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmp61Nf6h/main.rs:1:586\n  |\n1 | ...: {}\" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } }\n  |                                                         ----^\n  |                                                         |\n  |                                                         help: remove this `mut`\n\nerror: aborting due to 2 previous errors; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n\nError: Compilation failed:\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp61Nf6h/main.rs:1:301\n  |\n1 | ...a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematic...\n  |                                               ^^                                           ^^\n  |\n  = note: `#[warn(unused_braces)]` (part of `#[warn(unused)]`) on by default\nhelp: remove these braces\n  |\n1 - fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; let mut prev = 0 ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n = 10 ; { println ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let mut x = 25 ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } }\n1 + fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; let mut prev = 0 ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0 { { let temp = b ; { b = a % b ; a = temp } }  } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n = 10 ; { println ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let mut x = 25 ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } }\n  |\n\nerror[E0384]: cannot assign to immutable argument `b`\n --> /tmp/.tmp61Nf6h/main.rs:1:322\n  |\n1 | ...> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ...\n  |                                                ^^^^^^^^^ cannot assign to immutable argument\n  |\nhelp: consider making this binding mutable\n  |\n1 | fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; let mut prev = 0 ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , mut b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n = 10 ; { println ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let mut x = 25 ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } }\n  |                                                                                                                                                                                                                                                                            +++\n\nerror[E0384]: cannot assign to immutable argument `a`\n --> /tmp/.tmp61Nf6h/main.rs:1:334\n  |\n1 | ...le b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n =...\n  |                                                 ^^^^^^^^ cannot assign to immutable argument\n  |\nhelp: consider making this binding mutable\n  |\n1 | fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; let mut prev = 0 ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (mut a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n = 10 ; { println ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let mut x = 25 ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } }\n  |                                                                                                                                                                                                                                                                  +++\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmp61Nf6h/main.rs:1:491\n  |\n1 | ... ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let mut x = 25 ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let mut...\n  |                                                         ----^\n  |                                                         |\n  |                                                         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmp61Nf6h/main.rs:1:569\n  |\n1 | ...Square root of {}: {}\" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a ...\n  |                                                         ----^\n  |                                                         |\n  |                                                         help: remove this `mut`\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmp61Nf6h/main.rs:1:586\n  |\n1 | ...: {}\" , x , integer_sqrt (x)) ; let mut a = 48 ; let mut b = 18 ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } }\n  |                                                         ----^\n  |                                                         |\n  |                                                         help: remove this `mut`\n\nerror: aborting due to 2 previous errors; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch01-02-hello-world": {
      "chapter": "ch01-02-hello-world",
      "total_examples": 8,
      "working_examples": 8,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 1,
          "line_number": 30,
          "code": "fun main() {\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 2,
          "line_number": 86,
          "code": "fun main() {\n    println(\"Hello\", \"World\", \"from\", \"Ruchy\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 3,
          "line_number": 108,
          "code": "fun main() {\n    let name = \"Alice\";\n\n    // Multiple arguments (comma-separated)\n    println(\"Hello,\", name);\n\n    // String concatenation with +\n    println(\"Hello, \" + name + \"!\");\n\n    // F-string interpolation (modern, clean syntax)\n    println(f\"Hello, {name}!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 4,
          "line_number": 145,
          "code": "fun main() {\n    println(\"The answer is\", 42);\n    println(\"Pi is approximately\", 3.14159);\n    println(\"Is Ruchy awesome?\", true);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 5,
          "line_number": 170,
          "code": "// ❌ This won't work - intentional error example\n// println(Hello, World!);\n//\n\n// Always use quotes for literal text.\n\nfun main() {\n    // ✅ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 6,
          "line_number": 190,
          "code": "// ❌ Quotes don't match - intentional error example\n// println(\"Hello, World!');\n//\n\n// Use either \"...\" or '...' but be consistent.\n\nfun main() {\n    // ✅ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 7,
          "line_number": 210,
          "code": "// ❌ Wrong capitalization - intentional error example\n// PrintLn(\"Hello, World!\");\n//\n\n\nfun main() {\n    // ✅ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 8,
          "line_number": 236,
          "code": "fun main() {\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch16-00-testing-quality-assurance": {
      "chapter": "ch16-00-testing-quality-assurance",
      "total_examples": 8,
      "working_examples": 6,
      "failing_examples": 2,
      "examples": [
        {
          "file": "src/ch16-00-testing-quality-assurance.md",
          "example_number": 1,
          "line_number": 23,
          "code": "fun add_numbers(a: i32, b: i32) -> i32 {\n    a + b\n}\n\nfun main() {\n    // Basic functionality test\n    let result = add_numbers(5, 3);\n    assert_eq(result, 8, \"Addition should work correctly\");\n    \n    println(\"✅ All tests passed!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch16-00-testing-quality-assurance.md",
          "example_number": 2,
          "line_number": 62,
          "code": "fun factorial(n: i32) -> i32 {\n    if n <= 1 {\n        1\n    } else {\n        n * factorial(n - 1)\n    }\n}\n\nfun test_factorial_base_cases() {\n    assert_eq(factorial(0), 1, \"0! should equal 1\");\n    assert_eq(factorial(1), 1, \"1! should equal 1\");\n    println(\"✅ Base cases pass\");\n}\n\nfun test_factorial_recursive_cases() {\n    assert_eq(factorial(3), 6, \"3! should equal 6\");\n    assert_eq(factorial(4), 24, \"4! should equal 24\");\n    assert_eq(factorial(5), 120, \"5! should equal 120\");\n    println(\"✅ Recursive cases pass\");\n}\n\nfun main() {\n    test_factorial_base_cases();\n    test_factorial_recursive_cases();\n    println(\"🎉 All factorial tests passed!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch16-00-testing-quality-assurance.md",
          "example_number": 3,
          "line_number": 92,
          "code": "fun safe_divide(a: i32, b: i32) -> i32 {\n    if b == 0 {\n        println(\"Error: Division by zero\");\n        return 0;\n    }\n    a / b\n}\n\nfun test_division_normal_cases() {\n    assert_eq(safe_divide(10, 2), 5, \"Normal division should work\");\n    assert_eq(safe_divide(15, 3), 5, \"Another normal case\");\n    println(\"✅ Normal division tests pass\");\n}\n\nfun test_division_error_cases() {\n    // Test division by zero handling\n    let result = safe_divide(10, 0);\n    assert_eq(result, 0, \"Division by zero should return 0\");\n    println(\"✅ Error handling tests pass\");\n}\n\nfun main() {\n    test_division_normal_cases();\n    test_division_error_cases();\n    println(\"🎉 All division tests passed!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch16-00-testing-quality-assurance.md",
          "example_number": 4,
          "line_number": 122,
          "code": "fun absolute_value(x: i32) -> i32 {\n    if x < 0 {\n        -x\n    } else {\n        x\n    }\n}\n\nfun test_absolute_value_properties() {\n    // Property: abs(x) >= 0 for all x\n    let test_values = [5, -3, 0, 100, -50];\n    let mut i = 0;\n    \n    while i < 5 {\n        let x = test_values[i];\n        let abs_x = absolute_value(x);\n        \n        // Property 1: Result is always non-negative\n        assert(abs_x >= 0, \"Absolute value must be non-negative\");\n        \n        // Property 2: abs(abs(x)) == abs(x) (idempotent)\n        assert_eq(absolute_value(abs_x), abs_x, \"Absolute value should be idempotent\");\n        \n        i = i + 1;\n    }\n    \n    println(\"✅ Property tests pass\");\n}\n\nfun main() {\n    test_absolute_value_properties();\n    println(\"🎉 All property tests passed!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch16-00-testing-quality-assurance.md",
          "example_number": 5,
          "line_number": 244,
          "code": "// File: calculator_test.ruchy\nfun test_addition() {\n    assert_eq(add(2, 3), 5, \"Basic addition\");\n    assert_eq(add(-1, 1), 0, \"Adding negative numbers\");\n    assert_eq(add(0, 0), 0, \"Adding zeros\");\n    println(\"✅ Addition tests pass\");\n}\n\nfun test_multiplication() {\n    assert_eq(multiply(3, 4), 12, \"Basic multiplication\");\n    assert_eq(multiply(-2, 3), -6, \"Negative multiplication\");\n    assert_eq(multiply(0, 100), 0, \"Multiply by zero\");\n    println(\"✅ Multiplication tests pass\");\n}\n\nfun run_all_tests() {\n    test_addition();\n    test_multiplication();\n    println(\"🎉 Calculator test suite complete!\");\n}\n\nfun main() {\n    run_all_tests();\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `add` in this scope\n --> /tmp/.tmp27W6qc/main.rs:1:36\n  |\n1 | fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative ...\n  |                                    ^^^ not found in this scope\n  |\nhelp: use the `.` operator to call the method `Add::add` on `{integer}`\n  |\n1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"✅ Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"✅ Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"🎉 Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n1 + fn test_addition () { assert_eq ! (2.add(3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"✅ Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"✅ Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"🎉 Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n  |\n\nerror[E0425]: cannot find function `add` in this scope\n --> /tmp/.tmp27W6qc/main.rs:1:94\n  |\n1 | fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative ...\n  |                                                                                              ^^^ not found in this scope\n  |\nhelp: use the `.` operator to call the method `Add::add` on `{integer}`\n  |\n1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"✅ Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"✅ Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"🎉 Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n1 + fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! ((- 1).add(1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"✅ Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"✅ Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"🎉 Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n  |\n\nerror[E0425]: cannot find function `add` in this scope\n --> /tmp/.tmp27W6qc/main.rs:1:163\n  |\n1 | ...0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"✅ Addition tests pass\") ; }...\n  |                                                         ^^^ not found in this scope\n  |\nhelp: use the `.` operator to call the method `Add::add` on `{integer}`\n  |\n1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"✅ Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"✅ Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"🎉 Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n1 + fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (0.add(0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"✅ Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"✅ Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"🎉 Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n  |\n\nerror[E0425]: cannot find function `multiply` in this scope\n --> /tmp/.tmp27W6qc/main.rs:1:287\n  |\n1 | ...ass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `multiply` in this scope\n --> /tmp/.tmp27W6qc/main.rs:1:357\n  |\n1 | ...12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multipl...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `multiply` in this scope\n --> /tmp/.tmp27W6qc/main.rs:1:433\n  |\n1 | ..., \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"✅ Multiplication t...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n\nError: Compilation failed:\nerror[E0425]: cannot find function `add` in this scope\n --> /tmp/.tmp27W6qc/main.rs:1:36\n  |\n1 | fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative ...\n  |                                    ^^^ not found in this scope\n  |\nhelp: use the `.` operator to call the method `Add::add` on `{integer}`\n  |\n1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"✅ Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"✅ Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"🎉 Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n1 + fn test_addition () { assert_eq ! (2.add(3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"✅ Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"✅ Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"🎉 Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n  |\n\nerror[E0425]: cannot find function `add` in this scope\n --> /tmp/.tmp27W6qc/main.rs:1:94\n  |\n1 | fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative ...\n  |                                                                                              ^^^ not found in this scope\n  |\nhelp: use the `.` operator to call the method `Add::add` on `{integer}`\n  |\n1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"✅ Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"✅ Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"🎉 Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n1 + fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! ((- 1).add(1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"✅ Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"✅ Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"🎉 Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n  |\n\nerror[E0425]: cannot find function `add` in this scope\n --> /tmp/.tmp27W6qc/main.rs:1:163\n  |\n1 | ...0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"✅ Addition tests pass\") ; }...\n  |                                                         ^^^ not found in this scope\n  |\nhelp: use the `.` operator to call the method `Add::add` on `{integer}`\n  |\n1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"✅ Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"✅ Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"🎉 Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n1 + fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (0.add(0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"✅ Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"✅ Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"🎉 Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n  |\n\nerror[E0425]: cannot find function `multiply` in this scope\n --> /tmp/.tmp27W6qc/main.rs:1:287\n  |\n1 | ...ass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `multiply` in this scope\n --> /tmp/.tmp27W6qc/main.rs:1:357\n  |\n1 | ...12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multipl...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `multiply` in this scope\n --> /tmp/.tmp27W6qc/main.rs:1:433\n  |\n1 | ..., \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"✅ Multiplication t...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality-assurance.md",
          "example_number": 6,
          "line_number": 272,
          "code": "fun fibonacci(n: i32) -> i32 {\n    if n <= 1 {\n        n\n    } else {\n        fibonacci(n - 1) + fibonacci(n - 2)\n    }\n}\n\nfun test_fibonacci_performance() {\n    // Test reasonable performance expectations\n    let start_time = get_time_ms(); // Placeholder - actual timing would need stdlib\n    let result = fibonacci(20);\n    let end_time = get_time_ms();\n    \n    assert_eq(result, 6765, \"Fibonacci(20) should equal 6765\");\n    \n    // Performance assertion (conceptual)\n    let duration = end_time - start_time;\n    assert(duration < 1000, \"Fibonacci(20) should complete within 1 second\");\n    \n    println(\"✅ Performance test passes\");\n}\n\nfun main() {\n    test_fibonacci_performance();\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch16-00-testing-quality-assurance.md",
          "example_number": 7,
          "line_number": 366,
          "code": "// Clear, specific assertions\nassert_eq(actual, expected, \"Descriptive failure message\");\n\n// Boolean assertions with context\nassert(condition, \"Explain why this should be true\");\n\n// Multiple related assertions\nfun test_range_function() {\n    let result = create_range(1, 5);\n    assert_eq(len(result), 4, \"Range should have 4 elements\");\n    assert_eq(result[0], 1, \"First element should be 1\");  \n    assert_eq(result[3], 4, \"Last element should be 4\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `actual` in this scope\n --> /tmp/.tmp1lJBDP/main.rs:1:325\n  |\n1 | ...ement should be 4\") } } } fn main () { assert_eq ! (actual , expected , \"{}\" , \"Descriptive failure message\") ; assert ! (condition , ...\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `expected` in this scope\n --> /tmp/.tmp1lJBDP/main.rs:1:334\n  |\n1 | ...ld be 4\") } } } fn main () { assert_eq ! (actual , expected , \"{}\" , \"Descriptive failure message\") ; assert ! (condition , \"{}\" , \"Ex...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `condition` in this scope\n --> /tmp/.tmp1lJBDP/main.rs:1:395\n  |\n1 | ...\"{}\" , \"Descriptive failure message\") ; assert ! (condition , \"{}\" , \"Explain why this should be true\") ; }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `create_range` in this scope\n --> /tmp/.tmp1lJBDP/main.rs:1:44\n  |\n1 | fn test_range_function () { { let result = create_range (1 , 5) ; { assert_eq ! (len (result) , 4 , \"{}\" , \"Range should have 4 elements\"...\n  |                                            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n --> /tmp/.tmp1lJBDP/main.rs:1:82\n  |\n1 | fn test_range_function () { { let result = create_range (1 , 5) ; { assert_eq ! (len (result) , 4 , \"{}\" , \"Range should have 4 elements\"...\n  |                                                                                  ^^^ not found in this scope\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n\nError: Compilation failed:\nerror[E0425]: cannot find value `actual` in this scope\n --> /tmp/.tmp1lJBDP/main.rs:1:325\n  |\n1 | ...ement should be 4\") } } } fn main () { assert_eq ! (actual , expected , \"{}\" , \"Descriptive failure message\") ; assert ! (condition , ...\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `expected` in this scope\n --> /tmp/.tmp1lJBDP/main.rs:1:334\n  |\n1 | ...ld be 4\") } } } fn main () { assert_eq ! (actual , expected , \"{}\" , \"Descriptive failure message\") ; assert ! (condition , \"{}\" , \"Ex...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `condition` in this scope\n --> /tmp/.tmp1lJBDP/main.rs:1:395\n  |\n1 | ...\"{}\" , \"Descriptive failure message\") ; assert ! (condition , \"{}\" , \"Explain why this should be true\") ; }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `create_range` in this scope\n --> /tmp/.tmp1lJBDP/main.rs:1:44\n  |\n1 | fn test_range_function () { { let result = create_range (1 , 5) ; { assert_eq ! (len (result) , 4 , \"{}\" , \"Range should have 4 elements\"...\n  |                                            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n --> /tmp/.tmp1lJBDP/main.rs:1:82\n  |\n1 | fn test_range_function () { { let result = create_range (1 , 5) ; { assert_eq ! (len (result) , 4 , \"{}\" , \"Range should have 4 elements\"...\n  |                                                                                  ^^^ not found in this scope\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality-assurance.md",
          "example_number": 8,
          "line_number": 391,
          "code": "fun gcd(a: i32, b: i32) -> i32 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\n// Property: gcd(a, b) divides both a and b\nfun test_gcd_properties() {\n    let a = 48;\n    let b = 18;\n    let result = gcd(a, b);\n    \n    // Property verification\n    assert_eq(a % result, 0, \"GCD should divide first number\");\n    assert_eq(b % result, 0, \"GCD should divide second number\");\n    assert_eq(result, 6, \"GCD(48, 18) should equal 6\");\n    \n    println(\"✅ GCD properties verified\");\n}\n\nfun main() {\n    test_gcd_properties();\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch21-00-professional-tooling-tdd": {
      "chapter": "ch21-00-professional-tooling-tdd",
      "total_examples": 1,
      "working_examples": 1,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch21-00-professional-tooling-tdd.md",
          "example_number": 1,
          "line_number": 24,
          "code": "// test/tooling/simple_test.ruchy - ✓ VERIFIED WORKING\nfun add(a: i32, b: i32) -> i32 {\n    a + b\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch02-00-variables-types-tdd": {
      "chapter": "ch02-00-variables-types-tdd",
      "total_examples": 8,
      "working_examples": 8,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun main() {\n    let x = 42;\n    println(x);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 2,
          "line_number": 51,
          "code": "fun main() {\n    let name = \"Ruchy\";\n    println(name);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 3,
          "line_number": 70,
          "code": "fun main() {\n    let x = 10;\n    let y = 20;\n    let sum = x + y;\n    println(sum);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 4,
          "line_number": 91,
          "code": "fun main() {\n    let pi = 3.14159;\n    let radius = 5.0;\n    let area = pi * radius * radius;\n    println(area);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 5,
          "line_number": 136,
          "code": "fun main() {\n    let outer = 100;\n    // outer is accessible here\n    println(outer);\n}\n// outer is NOT accessible here",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 6,
          "line_number": 163,
          "code": "fun main() {\n    let value1 = 10;\n    let value2 = 20;\n    let result = value1 + value2;\n    println(result);  // Output: 30\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 7,
          "line_number": 173,
          "code": "fun main() {\n    let initial_value = 100;\n    let factor = 2;\n    let adjustment = 50;\n    let divisor = 3;\n    \n    let step1 = initial_value * factor;\n    let step2 = step1 + adjustment;\n    let final_result = step2 / divisor;\n    \n    println(final_result);  // Output: 83\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 8,
          "line_number": 189,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nlet PI = 3.14159;\nlet GRAVITY = 9.81;",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch17-00-error-handling-robustness": {
      "chapter": "ch17-00-error-handling-robustness",
      "total_examples": 11,
      "working_examples": 8,
      "failing_examples": 3,
      "examples": [
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 1,
          "line_number": 45,
          "code": "fun safe_divide(a: i32, b: i32) -> i32 {\n    if b == 0 {\n        println(\"Error: Division by zero attempted\");\n        return 0; // Safe default\n    }\n    a / b\n}\n\nfun main() {\n    let result1 = safe_divide(10, 2);   // Normal case\n    let result2 = safe_divide(10, 0);   // Error case\n    \n    println(\"10 / 2 = {}\", result1);   // Output: 5\n    println(\"10 / 0 = {}\", result2);   // Output: 0 (safe)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 2,
          "line_number": 87,
          "code": "fun validate_age(age: i32) -> i32 {\n    if age < 0 {\n        println(\"Error: Age cannot be negative. Using 0.\");\n        return 0;\n    }\n    \n    if age > 150 {\n        println(\"Error: Age seems unrealistic. Using 150.\");\n        return 150;\n    }\n    \n    age\n}\n\nfun calculate_retirement_year(current_age: i32) -> i32 {\n    let safe_age = validate_age(current_age);\n    let current_year = 2024; // Simplified\n    let retirement_age = 65;\n    \n    if safe_age >= retirement_age {\n        println(\"Already at retirement age\");\n        return current_year;\n    }\n    \n    current_year + (retirement_age - safe_age)\n}\n\nfun main() {\n    let year1 = calculate_retirement_year(30);\n    let year2 = calculate_retirement_year(-5);\n    let year3 = calculate_retirement_year(200);\n    \n    println(\"Retirement years: {}, {}, {}\", year1, year2, year3);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 3,
          "line_number": 125,
          "code": "fun safe_sqrt(x: f64) -> f64 {\n    if x < 0.0 {\n        println(\"Error: Cannot compute square root of negative number\");\n        return 0.0;\n    }\n    \n    // Simple approximation for square root\n    let mut guess = x / 2.0;\n    let mut i = 0;\n    \n    while i < 10 {\n        if guess * guess > x - 0.01 && guess * guess < x + 0.01 {\n            return guess;\n        }\n        guess = (guess + x / guess) / 2.0;\n        i = i + 1;\n    }\n    \n    guess\n}\n\nfun safe_factorial(n: i32) -> i64 {\n    if n < 0 {\n        println(\"Error: Factorial undefined for negative numbers\");\n        return 0;\n    }\n    \n    if n > 20 {\n        println(\"Error: Factorial too large, computing factorial(20)\");\n        return safe_factorial(20);\n    }\n    \n    if n <= 1 {\n        return 1;\n    }\n    \n    (n as i64) * safe_factorial(n - 1)\n}\n\nfun main() {\n    let sqrt1 = safe_sqrt(16.0);\n    let sqrt2 = safe_sqrt(-4.0);\n    \n    let fact1 = safe_factorial(5);\n    let fact2 = safe_factorial(-3);\n    let fact3 = safe_factorial(25);\n    \n    println(\"Square roots: {:.2}, {:.2}\", sqrt1, sqrt2);\n    println(\"Factorials: {}, {}, {}\", fact1, fact2, fact3);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4FyZ32/main.rs:1:582\n  |\n1 | ...factorial(20)\") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let...\n  |                                                                 ^^        ^^\n  |\n  = note: `#[warn(unused_braces)]` (part of `#[warn(unused)]`) on by default\nhelp: remove these braces\n  |\n1 - fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { println ! (\"Error: Cannot compute square root of negative number\") ; return 0f64 } ; let mut guess = x / 2f64 ; let mut i = 0 ; while i < 10 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { return guess } ; guess = (guess + x / guess) / 2f64 ; i = i + 1 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0 { println ! (\"Error: Factorial undefined for negative numbers\") ; return 0 } ; if n > 20 { println ! (\"Error: Factorial too large, computing factorial(20)\") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5) ; let fact2 = safe_factorial (- 3) ; let fact3 = safe_factorial (25) ; println ! (\"{} {:?} {:?}\" , \"Square roots: {:.2}, {:.2}\" , sqrt1 , sqrt2) ; println ! (\"Factorials: {}, {}, {}\" , fact1 , fact2 , fact3) } } }\n1 + fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { println ! (\"Error: Cannot compute square root of negative number\") ; return 0f64 } ; let mut guess = x / 2f64 ; let mut i = 0 ; while i < 10 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { return guess } ; guess = (guess + x / guess) / 2f64 ; i = i + 1 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0 { println ! (\"Error: Factorial undefined for negative numbers\") ; return 0 } ; if n > 20 { println ! (\"Error: Factorial too large, computing factorial(20)\") ; return safe_factorial (20) } ; if n <= 1 { return 1  ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5) ; let fact2 = safe_factorial (- 3) ; let fact3 = safe_factorial (25) ; println ! (\"{} {:?} {:?}\" , \"Square roots: {:.2}, {:.2}\" , sqrt1 , sqrt2) ; println ! (\"Factorials: {}, {}, {}\" , fact1 , fact2 , fact3) } } }\n  |\n\nwarning: unreachable expression\n --> /tmp/.tmp4FyZ32/main.rs:1:595\n  |\n1 | ...ctorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { l...\n  |                                   --------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression\n  |                                   |\n  |                                   any code following this expression is unreachable\n  |\n  = note: `#[warn(unreachable_code)]` (part of `#[warn(unused)]`) on by default\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmp4FyZ32/main.rs:1:570\n  |\n1 | ...-> i64 { if n < 0 { println ! (\"Error: Factorial undefined for negative numbers\") ; return 0 } ; if n > 20 { println ! (\"Error: Factorial too large, computing factorial(20)\") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } ...\n  |       --- expected `i64` because of this return type                                                                                                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0317`.\n\nError: Compilation failed:\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4FyZ32/main.rs:1:582\n  |\n1 | ...factorial(20)\") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let...\n  |                                                                 ^^        ^^\n  |\n  = note: `#[warn(unused_braces)]` (part of `#[warn(unused)]`) on by default\nhelp: remove these braces\n  |\n1 - fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { println ! (\"Error: Cannot compute square root of negative number\") ; return 0f64 } ; let mut guess = x / 2f64 ; let mut i = 0 ; while i < 10 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { return guess } ; guess = (guess + x / guess) / 2f64 ; i = i + 1 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0 { println ! (\"Error: Factorial undefined for negative numbers\") ; return 0 } ; if n > 20 { println ! (\"Error: Factorial too large, computing factorial(20)\") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5) ; let fact2 = safe_factorial (- 3) ; let fact3 = safe_factorial (25) ; println ! (\"{} {:?} {:?}\" , \"Square roots: {:.2}, {:.2}\" , sqrt1 , sqrt2) ; println ! (\"Factorials: {}, {}, {}\" , fact1 , fact2 , fact3) } } }\n1 + fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { println ! (\"Error: Cannot compute square root of negative number\") ; return 0f64 } ; let mut guess = x / 2f64 ; let mut i = 0 ; while i < 10 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { return guess } ; guess = (guess + x / guess) / 2f64 ; i = i + 1 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0 { println ! (\"Error: Factorial undefined for negative numbers\") ; return 0 } ; if n > 20 { println ! (\"Error: Factorial too large, computing factorial(20)\") ; return safe_factorial (20) } ; if n <= 1 { return 1  ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { let sqrt2 = safe_sqrt (- 4f64) ; let fact1 = safe_factorial (5) ; let fact2 = safe_factorial (- 3) ; let fact3 = safe_factorial (25) ; println ! (\"{} {:?} {:?}\" , \"Square roots: {:.2}, {:.2}\" , sqrt1 , sqrt2) ; println ! (\"Factorials: {}, {}, {}\" , fact1 , fact2 , fact3) } } }\n  |\n\nwarning: unreachable expression\n --> /tmp/.tmp4FyZ32/main.rs:1:595\n  |\n1 | ...ctorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { l...\n  |                                   --------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression\n  |                                   |\n  |                                   any code following this expression is unreachable\n  |\n  = note: `#[warn(unreachable_code)]` (part of `#[warn(unused)]`) on by default\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmp4FyZ32/main.rs:1:570\n  |\n1 | ...-> i64 { if n < 0 { println ! (\"Error: Factorial undefined for negative numbers\") ; return 0 } ; if n > 20 { println ! (\"Error: Factorial too large, computing factorial(20)\") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } ...\n  |       --- expected `i64` because of this return type                                                                                                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0317`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 4,
          "line_number": 179,
          "code": "fun safe_array_access(arr: [i32; 5], index: i32) -> i32 {\n    if index < 0 {\n        println(\"Error: Array index cannot be negative\");\n        return arr[0]; // Return first element as default\n    }\n    \n    if index >= 5 {\n        println(\"Error: Array index {} out of bounds\", index);\n        return arr[4]; // Return last element as default\n    }\n    \n    arr[index]\n}\n\nfun find_maximum_safe(numbers: [i32; 5]) -> i32 {\n    let mut max = numbers[0];\n    let mut i = 1;\n    \n    while i < 5 {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n        i = i + 1;\n    }\n    \n    max\n}\n\nfun main() {\n    let data = [10, 25, 5, 30, 15];\n    \n    let val1 = safe_array_access(data, 2);\n    let val2 = safe_array_access(data, -1);\n    let val3 = safe_array_access(data, 10);\n    \n    let maximum = find_maximum_safe(data);\n    \n    println(\"Values: {}, {}, {}\", val1, val2, val3);\n    println(\"Maximum: {}\", maximum);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 5,
          "line_number": 225,
          "code": "fun unreliable_operation(attempt: i32) -> bool {\n    // Simulate an operation that fails sometimes\n    if attempt < 3 {\n        println(\"Operation failed on attempt {}\", attempt);\n        return false;\n    }\n    println(\"Operation succeeded on attempt {}\", attempt);\n    return true;\n}\n\nfun retry_with_limit(max_attempts: i32) -> bool {\n    let mut attempt = 1;\n    \n    while attempt <= max_attempts {\n        println(\"Attempting operation (try {})\", attempt);\n        \n        if unreliable_operation(attempt) {\n            return true;\n        }\n        \n        attempt = attempt + 1;\n    }\n    \n    println(\"Error: Operation failed after {} attempts\", max_attempts);\n    return false;\n}\n\nfun main() {\n    let success = retry_with_limit(5);\n    \n    if success {\n        println(\"✅ Operation completed successfully\");\n    } else {\n        println(\"❌ Operation failed after all retries\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 6,
          "line_number": 265,
          "code": "fun get_config_value(config_name: &str) -> i32 {\n    // Simulate configuration lookup\n    if config_name == \"timeout\" {\n        return 30;\n    } else if config_name == \"retries\" {\n        return 3;\n    } else {\n        println(\"Warning: Unknown config '{}', using default\", config_name);\n        return 0; // Safe default\n    }\n}\n\nfun initialize_system() -> bool {\n    let timeout = get_config_value(\"timeout\");\n    let retries = get_config_value(\"retries\");\n    let unknown = get_config_value(\"unknown_setting\");\n    \n    println(\"System configuration:\");\n    println(\"  Timeout: {} seconds\", timeout);\n    println(\"  Retries: {} attempts\", retries);\n    println(\"  Unknown: {} (default)\", unknown);\n    \n    // Validate configuration\n    if timeout <= 0 {\n        println(\"Error: Invalid timeout configuration\");\n        return false;\n    }\n    \n    if retries < 0 {\n        println(\"Error: Invalid retry configuration\");\n        return false;\n    }\n    \n    println(\"✅ System initialized successfully\");\n    return true;\n}\n\nfun main() {\n    let initialized = initialize_system();\n    \n    if initialized {\n        println(\"System ready for operation\");\n    } else {\n        println(\"System initialization failed\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 7,
          "line_number": 317,
          "code": "fun sanitize_username(username: &str) -> String {\n    // Check for null or empty\n    if username.len() == 0 {\n        println(\"Error: Username cannot be empty\");\n        return String::from(\"anonymous\");\n    }\n    \n    // Check length limits\n    if username.len() < 3 {\n        println(\"Error: Username too short, minimum 3 characters\");\n        return String::from(\"user123\");\n    }\n    \n    if username.len() > 20 {\n        println(\"Warning: Username truncated to 20 characters\");\n        return username.chars().take(20).collect();\n    }\n    \n    // Return sanitized username\n    username.to_string()\n}\n\nfun validate_email(email: &str) -> bool {\n    // Basic email validation\n    if email.len() == 0 {\n        println(\"Error: Email cannot be empty\");\n        return false;\n    }\n    \n    if !email.contains('@') {\n        println(\"Error: Invalid email format - missing @\");\n        return false;\n    }\n    \n    if !email.contains('.') {\n        println(\"Error: Invalid email format - missing domain\");\n        return false;\n    }\n    \n    return true;\n}\n\nfun create_user_account(username: &str, email: &str) -> bool {\n    println(\"Creating user account...\");\n    \n    let safe_username = sanitize_username(username);\n    let valid_email = validate_email(email);\n    \n    if !valid_email {\n        println(\"❌ Account creation failed: Invalid email\");\n        return false;\n    }\n    \n    println(\"✅ Account created for user: {}\", safe_username);\n    return true;\n}\n\nfun main() {\n    let success1 = create_user_account(\"john_doe\", \"john@example.com\");\n    let success2 = create_user_account(\"\", \"invalid-email\");\n    let success3 = create_user_account(\"ab\", \"test@domain.co.uk\");\n    \n    println(\"Account creation results: {}, {}, {}\", success1, success2, success3);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 8,
          "line_number": 385,
          "code": "fun parse_positive_integer(input: &str) -> i32 {\n    // Simulate string to integer conversion\n    let mut result = 0;\n    let mut i = 0;\n    let chars = input.as_bytes();\n    \n    if input.len() == 0 {\n        println(\"Error: Empty input, using 0\");\n        return 0;\n    }\n    \n    // Check for negative sign\n    if chars[0] == b'-' {\n        println(\"Error: Negative numbers not allowed, using 0\");\n        return 0;\n    }\n    \n    // Simple digit parsing (simplified for example)\n    while i < input.len() {\n        let ch = chars[i];\n        if ch >= b'0' && ch <= b'9' {\n            let digit = (ch - b'0') as i32;\n            result = result * 10 + digit;\n        } else {\n            println(\"Error: Invalid character in number, stopping at {}\", result);\n            break;\n        }\n        i = i + 1;\n    }\n    \n    // Validate range\n    if result > 1000 {\n        println(\"Warning: Value {} too large, capping at 1000\", result);\n        return 1000;\n    }\n    \n    result\n}\n\nfun calculate_score(correct: &str, total: &str) -> f64 {\n    let correct_num = parse_positive_integer(correct);\n    let total_num = parse_positive_integer(total);\n    \n    if total_num == 0 {\n        println(\"Error: Cannot calculate score with zero total\");\n        return 0.0;\n    }\n    \n    if correct_num > total_num {\n        println(\"Error: Correct answers cannot exceed total\");\n        return 0.0;\n    }\n    \n    (correct_num as f64) / (total_num as f64) * 100.0\n}\n\nfun main() {\n    let score1 = calculate_score(\"8\", \"10\");\n    let score2 = calculate_score(\"abc\", \"10\");\n    let score3 = calculate_score(\"15\", \"10\");\n    let score4 = calculate_score(\"5\", \"0\");\n    \n    println(\"Scores: {:.1}%, {:.1}%, {:.1}%, {:.1}%\", score1, score2, score3, score4);\n}",
          "passed": false,
          "status": "broken",
          "error": "\nthread 'main' (1949504) panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ruchy-3.77.0/src/backend/transpiler/expressions.rs:40:18:\ninternal error: entered unreachable code\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 9,
          "line_number": 455,
          "code": "fun test_division_error_handling() {\n    println(\"Testing division error handling...\");\n    \n    // Test normal case\n    let result1 = safe_divide(10, 2);\n    if result1 == 5 {\n        println(\"✅ Normal division test passed\");\n    } else {\n        println(\"❌ Normal division test failed\");\n    }\n    \n    // Test division by zero\n    let result2 = safe_divide(10, 0);\n    if result2 == 0 {\n        println(\"✅ Division by zero handling passed\");\n    } else {\n        println(\"❌ Division by zero handling failed\");\n    }\n    \n    // Test negative numbers\n    let result3 = safe_divide(-10, 2);\n    if result3 == -5 {\n        println(\"✅ Negative number handling passed\");\n    } else {\n        println(\"❌ Negative number handling failed\");\n    }\n}\n\nfun test_input_validation() {\n    println(\"Testing input validation...\");\n    \n    // Test valid age\n    let age1 = validate_age(25);\n    if age1 == 25 {\n        println(\"✅ Valid age test passed\");\n    } else {\n        println(\"❌ Valid age test failed\");\n    }\n    \n    // Test negative age\n    let age2 = validate_age(-5);\n    if age2 == 0 {\n        println(\"✅ Negative age handling passed\");\n    } else {\n        println(\"❌ Negative age handling failed\");\n    }\n    \n    // Test extreme age\n    let age3 = validate_age(200);\n    if age3 == 150 {\n        println(\"✅ Extreme age handling passed\");\n    } else {\n        println(\"❌ Extreme age handling failed\");\n    }\n}\n\nfun main() {\n    test_division_error_handling();\n    println(\"\");\n    test_input_validation();\n    println(\"\");\n    println(\"🎉 Error handling tests complete!\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `safe_divide` in this scope\n --> /tmp/.tmpopcCnA/main.rs:1:105\n  |\n1 | ...g division error handling...\") ; { let result1 = safe_divide (10 , 2) ; { if result1 == 5 { println ! (\"✅ Normal division test passed\")...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `safe_divide` in this scope\n --> /tmp/.tmpopcCnA/main.rs:1:263\n  |\n1 | ... Normal division test failed\") } ; let result2 = safe_divide (10 , 0) ; if result2 == 0 { println ! (\"✅ Division by zero handling passed...\n  |                                                      ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `safe_divide` in this scope\n --> /tmp/.tmpopcCnA/main.rs:1:429\n  |\n1 | ...sion by zero handling failed\") } ; let result3 = safe_divide (- 10 , 2) ; if result3 == - 5 { println ! (\"✅ Negative number handling pa...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `validate_age` in this scope\n --> /tmp/.tmpopcCnA/main.rs:1:674\n  |\n1 | ...! (\"Testing input validation...\") ; { let age1 = validate_age (25) ; { if age1 == 25 { println ! (\"✅ Valid age test passed\") } else { p...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `validate_age` in this scope\n --> /tmp/.tmpopcCnA/main.rs:1:812\n  |\n1 | ...tln ! (\"❌ Valid age test failed\") } ; let age2 = validate_age (- 5) ; if age2 == 0 { println ! (\"✅ Negative age handling passed\") } else...\n  |                                                      ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `validate_age` in this scope\n --> /tmp/.tmpopcCnA/main.rs:1:962\n  |\n1 | ...\"❌ Negative age handling failed\") } ; let age3 = validate_age (200) ; if age3 == 150 { println ! (\"✅ Extreme age handling passed\") } els...\n  |                                                      ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n\nError: Compilation failed:\nerror[E0425]: cannot find function `safe_divide` in this scope\n --> /tmp/.tmpopcCnA/main.rs:1:105\n  |\n1 | ...g division error handling...\") ; { let result1 = safe_divide (10 , 2) ; { if result1 == 5 { println ! (\"✅ Normal division test passed\")...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `safe_divide` in this scope\n --> /tmp/.tmpopcCnA/main.rs:1:263\n  |\n1 | ... Normal division test failed\") } ; let result2 = safe_divide (10 , 0) ; if result2 == 0 { println ! (\"✅ Division by zero handling passed...\n  |                                                      ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `safe_divide` in this scope\n --> /tmp/.tmpopcCnA/main.rs:1:429\n  |\n1 | ...sion by zero handling failed\") } ; let result3 = safe_divide (- 10 , 2) ; if result3 == - 5 { println ! (\"✅ Negative number handling pa...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `validate_age` in this scope\n --> /tmp/.tmpopcCnA/main.rs:1:674\n  |\n1 | ...! (\"Testing input validation...\") ; { let age1 = validate_age (25) ; { if age1 == 25 { println ! (\"✅ Valid age test passed\") } else { p...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `validate_age` in this scope\n --> /tmp/.tmpopcCnA/main.rs:1:812\n  |\n1 | ...tln ! (\"❌ Valid age test failed\") } ; let age2 = validate_age (- 5) ; if age2 == 0 { println ! (\"✅ Negative age handling passed\") } else...\n  |                                                      ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `validate_age` in this scope\n --> /tmp/.tmpopcCnA/main.rs:1:962\n  |\n1 | ...\"❌ Negative age handling failed\") } ; let age3 = validate_age (200) ; if age3 == 150 { println ! (\"✅ Extreme age handling passed\") } els...\n  |                                                      ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 10,
          "line_number": 524,
          "code": "fun log_error(component: &str, message: &str) {\n    println(\"[ERROR] {}: {}\", component, message);\n}\n\nfun log_warning(component: &str, message: &str) {\n    println(\"[WARN] {}: {}\", component, message);\n}\n\nfun log_info(component: &str, message: &str) {\n    println(\"[INFO] {}: {}\", component, message);\n}\n\nfun process_user_data(user_id: i32, data: &str) -> bool {\n    log_info(\"DataProcessor\", \"Starting user data processing\");\n    \n    // Validate user ID\n    if user_id <= 0 {\n        log_error(\"DataProcessor\", \"Invalid user ID provided\");\n        return false;\n    }\n    \n    // Validate data\n    if data.len() == 0 {\n        log_error(\"DataProcessor\", \"Empty data received\");\n        return false;\n    }\n    \n    if data.len() > 1000 {\n        log_warning(\"DataProcessor\", \"Data size exceeds recommended limit\");\n    }\n    \n    // Simulate processing\n    log_info(\"DataProcessor\", \"Processing data for user\");\n    \n    // Simulate potential failure\n    if user_id == 999 {\n        log_error(\"DataProcessor\", \"Processing failed for user 999\");\n        return false;\n    }\n    \n    log_info(\"DataProcessor\", \"Data processing completed successfully\");\n    return true;\n}\n\nfun main() {\n    let results = [\n        process_user_data(123, \"valid_data\"),\n        process_user_data(0, \"invalid_user\"),\n        process_user_data(456, \"\"),\n        process_user_data(999, \"test_data\")\n    ];\n    \n    let mut successful = 0;\n    let mut i = 0;\n    \n    while i < 4 {\n        if results[i] {\n            successful = successful + 1;\n        }\n        i = i + 1;\n    }\n    \n    println(\"\");\n    println(\"Summary: {}/4 operations successful\", successful);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 11,
          "line_number": 595,
          "code": "fun calculate_monthly_payment(principal: f64, rate: f64, months: i32) -> f64 {\n    // Preconditions - validate inputs\n    if principal <= 0.0 {\n        println(\"Error: Principal must be positive\");\n        return 0.0;\n    }\n    \n    if rate < 0.0 {\n        println(\"Error: Interest rate cannot be negative\");\n        return 0.0;\n    }\n    \n    if months <= 0 {\n        println(\"Error: Loan term must be positive\");\n        return 0.0;\n    }\n    \n    // Handle edge case of zero interest\n    if rate == 0.0 {\n        return principal / (months as f64);\n    }\n    \n    // Calculate monthly payment\n    let monthly_rate = rate / 12.0;\n    let payment = principal * monthly_rate * \n        ((1.0 + monthly_rate).powf(months as f64)) /\n        (((1.0 + monthly_rate).powf(months as f64)) - 1.0);\n    \n    // Postcondition - validate result\n    if payment <= 0.0 {\n        println(\"Error: Calculated payment is invalid\");\n        return 0.0;\n    }\n    \n    payment\n}\n\nfun main() {\n    let payment1 = calculate_monthly_payment(100000.0, 0.05, 360);\n    let payment2 = calculate_monthly_payment(-1000.0, 0.05, 360);\n    let payment3 = calculate_monthly_payment(50000.0, 0.0, 60);\n    \n    println(\"Monthly payments: {:.2}, {:.2}, {:.2}\", payment1, payment2, payment3);\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch01-02-hello-world-tdd": {
      "chapter": "ch01-02-hello-world-tdd",
      "total_examples": 6,
      "working_examples": 6,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun main() {\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 2,
          "line_number": 55,
          "code": "fun main() {\n    println(\"Hello,\");\n    println(\"World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 3,
          "line_number": 75,
          "code": "fun main() {\n    let greeting = \"Hello, World!\";\n    println(greeting);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 4,
          "line_number": 124,
          "code": "println(\"Your message here\");",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 5,
          "line_number": 132,
          "code": "let message = \"Your message\";\nprintln(message);",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 6,
          "line_number": 141,
          "code": "println(\"First line\");\nprintln(\"Second line\");",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch10-00-input-output-tdd": {
      "chapter": "ch10-00-input-output-tdd",
      "total_examples": 15,
      "working_examples": 15,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 1,
          "line_number": 51,
          "code": "fun main() {\n    println(\"=== Output Demo ===\");\n    println(\"Number: \");\n    println(42);\n    println(\"Boolean: \");\n    println(true);\n    println(\"=== End Demo ===\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 2,
          "line_number": 79,
          "code": "fun main() {\n    let name = \"Alice\";\n    let age = 30;\n    let height = 5.6;\n    \n    println(\"=== User Profile ===\");\n    println(\"Name:\");\n    println(name);\n    println(\"Age:\");\n    println(age);\n    println(\"Height:\");\n    println(height);\n    println(\"================\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 3,
          "line_number": 115,
          "code": "fun display_menu() {\n    println(\"=== Main Menu ===\");\n    println(\"1. View Profile\");\n    println(\"2. Settings\");\n    println(\"3. Exit\");\n    println(\"=================\");\n}\n\nfun main() {\n    display_menu();\n    println(\"Menu displayed successfully\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 4,
          "line_number": 147,
          "code": "fun main() {\n    let name = \"Bob\"\n    let score = 95\n    println(f\"Player: {name}\")\n    println(f\"Score: {score}\")\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 5,
          "line_number": 169,
          "code": "fun main() {\n    let x = 10\n    let y = 20\n    let sum = x + y\n    println(f\"Result: {x} + {y} = {sum}\")\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 6,
          "line_number": 190,
          "code": "fun display_report(title: &str, value: i32) {\n    println(\"=== Report ===\")\n    println(title)\n    println(value)\n    println(\"==============\")\n}\n\nfun main() {\n    display_report(\"Sales Total\", 1000)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 7,
          "line_number": 218,
          "code": "fun main() {\n    let numbers = [1, 2, 3, 4, 5]\n    println(\"Array:\")\n    println(numbers)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 8,
          "line_number": 239,
          "code": "fun main() {\n    let person = (\"Alice\", 30, true)\n    println(\"Person data:\")\n    println(person)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 9,
          "line_number": 289,
          "code": "fun main() {\n    let variable = \"Hello World\";\n    println(\"text message\");\n    println(variable);\n    println(42);\n    println(true);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 10,
          "line_number": 300,
          "code": "fun main() {\n    let value = \"Important Data\";\n    let data = value;\n    println(\"Label:\");\n    println(data);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 11,
          "line_number": 310,
          "code": "fun display_options() {\n    println(\"=== Menu ===\");\n    println(\"1. Option One\");\n    println(\"2. Option Two\");\n    println(\"============\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 12,
          "line_number": 337,
          "code": "let value = 100;\nprintln(\"Result:\");\nprintln(value);",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 13,
          "line_number": 347,
          "code": "fun display_report(title: &str, data: i32) {\n    println(\"=== Report ===\")\n    println(title)\n    println(data)\n    println(\"==============\")\n}\n\nfun main() {\n    display_report(\"Monthly Sales\", 50000)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 14,
          "line_number": 361,
          "code": "println(\"Processing...\");\n// ... do work ...\nprintln(\"Complete!\");",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 15,
          "line_number": 371,
          "code": "fun show_options() {\n    println(\"Choose an option:\");\n    println(\"1. Start\");\n    println(\"2. Stop\");\n    println(\"3. Help\");\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch18-00-dataframes-data-processing": {
      "chapter": "ch18-00-dataframes-data-processing",
      "total_examples": 4,
      "working_examples": 0,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch18-00-dataframes-data-processing.md",
          "example_number": 1,
          "line_number": 38,
          "code": "fun create_dataframe() {\n    let df = df![\n        \"employee_id\" => [101, 102, 103, 104],\n        \"name\" => [\"Alice\", \"Bob\", \"Charlie\", \"Diana\"],\n        \"department\" => [\"Engineering\", \"Sales\", \"Engineering\", \"HR\"],\n        \"salary\" => [95000, 75000, 105000, 65000]\n    ];\n\n    // Display the DataFrame (returns as last expression)\n    df\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Cargo build failed:\n    Updating crates.io index\n     Locking 162 packages to latest compatible versions\n      Adding polars v0.35.4 (available: v0.51.0)\n   Compiling version_check v0.9.5\n   Compiling proc-macro2 v1.0.101\n   Compiling libc v0.2.177\n   Compiling unicode-ident v1.0.19\n   Compiling quote v1.0.41\n   Compiling cfg-if v1.0.3\n   Compiling autocfg v1.5.0\n   Compiling libm v0.2.15\n   Compiling zerocopy v0.8.27\n   Compiling crossbeam-utils v0.8.21\n   Compiling memchr v2.7.6\n   Compiling num-traits v0.2.19\n   Compiling target-features v0.1.6\n   Compiling getrandom v0.3.3\n   Compiling rayon-core v1.13.0\n   Compiling crossbeam-epoch v0.9.18\n   Compiling aho-corasick v1.1.3\n   Compiling ahash v0.8.12\n   Compiling regex-syntax v0.8.8\n   Compiling crossbeam-deque v0.8.6\n   Compiling thiserror v1.0.69\n   Compiling syn v1.0.109\n   Compiling syn v2.0.106\n   Compiling smartstring v1.0.1\n   Compiling once_cell v1.21.3\n   Compiling parking_lot_core v0.9.12\n   Compiling either v1.15.0\n   Compiling regex-automata v0.4.13\n   Compiling rayon v1.11.0\n   Compiling getrandom v0.2.16\n   Compiling thiserror-impl v1.0.69\n   Compiling bytemuck_derive v1.10.2\n   Compiling polars-utils v0.35.4\n   Compiling simdutf8 v0.1.5\n   Compiling rustix v1.1.2\n   Compiling equivalent v1.0.2\n   Compiling regex v1.12.2\n   Compiling allocator-api2 v0.2.21\n   Compiling hashbrown v0.16.0\n   Compiling iana-time-zone v0.1.64\n   Compiling static_assertions v1.1.0\n   Compiling smallvec v1.15.1\n   Compiling scopeguard v1.2.0\n   Compiling chrono v0.4.42\n   Compiling indexmap v2.11.4\n   Compiling lock_api v0.4.14\n   Compiling hashbrown v0.14.5\n   Compiling multiversion-macros v0.7.4\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling bytemuck v1.24.0\n   Compiling litrs v0.4.2\n   Compiling polars-error v0.35.4\n   Compiling linux-raw-sys v0.11.0\n   Compiling ryu v1.0.20\n   Compiling itoa v1.0.15\n   Compiling bitflags v2.9.4\n   Compiling document-features v0.2.11\n   Compiling rand_chacha v0.3.1\n   Compiling parking_lot v0.12.5\n   Compiling ethnum v1.5.2\n   Compiling fast-float v0.2.0\n   Compiling foreign_vec v0.1.0\n   Compiling strength_reduce v0.2.4\n   Compiling streaming-iterator v0.1.9\n   Compiling dyn-clone v1.0.20\n   Compiling atoi_simd v0.15.6\n   Compiling rand v0.8.5\n   Compiling multiversion v0.7.4\n   Compiling polars-core v0.35.4\n   Compiling crossterm v0.29.0\n   Compiling unicode-segmentation v1.12.0\n   Compiling unicode-width v0.2.2\n   Compiling polars-ops v0.35.4\n   Compiling xxhash-rust v0.8.15\n   Compiling rand_distr v0.4.3\n   Compiling argminmax v0.6.3\n   Compiling rustversion v1.0.22\n   Compiling now v0.1.3\n   Compiling polars-arrow v0.35.4\n   Compiling atoi v2.0.0\n   Compiling comfy-table v7.2.1\n   Compiling memmap2 v0.7.1\n   Compiling polars-plan v0.35.4\n   Compiling home v0.5.11\n   Compiling percent-encoding v2.3.2\n   Compiling bytes v1.10.1\n   Compiling serde_core v1.0.228\n   Compiling heck v0.4.1\n   Compiling polars-lazy v0.35.4\n   Compiling polars v0.35.4\n   Compiling serde v1.0.228\n   Compiling serde_json v1.0.145\n   Compiling glob v0.3.3\n   Compiling serde_derive v1.0.228\n   Compiling strum_macros v0.25.3\n   Compiling polars-row v0.35.4\n   Compiling polars-time v0.35.4\n   Compiling polars-io v0.35.4\n   Compiling ruchy_binary v0.1.0 (/tmp/.tmpiNS6b0)\nerror[E0308]: mismatched types\n --> src/main.rs:1:725\n  |\n1 | ...-> i32 { let df = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"employee_id\" , vec ! [101 , 102 , 103 , 104]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"name\" , vec ! [\"Alice\" , \"Bob\" , \"Charlie\" , \"Diana\"]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"department\" , vec ! [\"Engineering\" , \"Sales\" , \"Engineering\" , \"HR\"]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"salary\" , vec ! [95000 , 75000 , 105000 , 65000]) }]) . expect (\"Failed to create DataFrame from columns\") } ; df } ...\n  |       --- expected `i32` because of return type                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^^ expected `i32`, found `DataFrame`\n\nwarning: unused import: `polars :: prelude :: NamedFrom`\n --> src/main.rs:1:48\n  |\n1 | fn create_dataframe () -> i32 { let df = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ use polar...\n  |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `ruchy_binary` (bin \"ruchy_binary\") generated 1 warning\nerror: could not compile `ruchy_binary` (bin \"ruchy_binary\") due to 1 previous error; 1 warning emitted\n\nError: Cargo build failed:\n    Updating crates.io index\n     Locking 162 packages to latest compatible versions\n      Adding polars v0.35.4 (available: v0.51.0)\n   Compiling version_check v0.9.5\n   Compiling proc-macro2 v1.0.101\n   Compiling libc v0.2.177\n   Compiling unicode-ident v1.0.19\n   Compiling quote v1.0.41\n   Compiling cfg-if v1.0.3\n   Compiling autocfg v1.5.0\n   Compiling libm v0.2.15\n   Compiling zerocopy v0.8.27\n   Compiling crossbeam-utils v0.8.21\n   Compiling memchr v2.7.6\n   Compiling num-traits v0.2.19\n   Compiling target-features v0.1.6\n   Compiling getrandom v0.3.3\n   Compiling rayon-core v1.13.0\n   Compiling crossbeam-epoch v0.9.18\n   Compiling aho-corasick v1.1.3\n   Compiling ahash v0.8.12\n   Compiling regex-syntax v0.8.8\n   Compiling crossbeam-deque v0.8.6\n   Compiling thiserror v1.0.69\n   Compiling syn v1.0.109\n   Compiling syn v2.0.106\n   Compiling smartstring v1.0.1\n   Compiling once_cell v1.21.3\n   Compiling parking_lot_core v0.9.12\n   Compiling either v1.15.0\n   Compiling regex-automata v0.4.13\n   Compiling rayon v1.11.0\n   Compiling getrandom v0.2.16\n   Compiling thiserror-impl v1.0.69\n   Compiling bytemuck_derive v1.10.2\n   Compiling polars-utils v0.35.4\n   Compiling simdutf8 v0.1.5\n   Compiling rustix v1.1.2\n   Compiling equivalent v1.0.2\n   Compiling regex v1.12.2\n   Compiling allocator-api2 v0.2.21\n   Compiling hashbrown v0.16.0\n   Compiling iana-time-zone v0.1.64\n   Compiling static_assertions v1.1.0\n   Compiling smallvec v1.15.1\n   Compiling scopeguard v1.2.0\n   Compiling chrono v0.4.42\n   Compiling indexmap v2.11.4\n   Compiling lock_api v0.4.14\n   Compiling hashbrown v0.14.5\n   Compiling multiversion-macros v0.7.4\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling bytemuck v1.24.0\n   Compiling litrs v0.4.2\n   Compiling polars-error v0.35.4\n   Compiling linux-raw-sys v0.11.0\n   Compiling ryu v1.0.20\n   Compiling itoa v1.0.15\n   Compiling bitflags v2.9.4\n   Compiling document-features v0.2.11\n   Compiling rand_chacha v0.3.1\n   Compiling parking_lot v0.12.5\n   Compiling ethnum v1.5.2\n   Compiling fast-float v0.2.0\n   Compiling foreign_vec v0.1.0\n   Compiling strength_reduce v0.2.4\n   Compiling streaming-iterator v0.1.9\n   Compiling dyn-clone v1.0.20\n   Compiling atoi_simd v0.15.6\n   Compiling rand v0.8.5\n   Compiling multiversion v0.7.4\n   Compiling polars-core v0.35.4\n   Compiling crossterm v0.29.0\n   Compiling unicode-segmentation v1.12.0\n   Compiling unicode-width v0.2.2\n   Compiling polars-ops v0.35.4\n   Compiling xxhash-rust v0.8.15\n   Compiling rand_distr v0.4.3\n   Compiling argminmax v0.6.3\n   Compiling rustversion v1.0.22\n   Compiling now v0.1.3\n   Compiling polars-arrow v0.35.4\n   Compiling atoi v2.0.0\n   Compiling comfy-table v7.2.1\n   Compiling memmap2 v0.7.1\n   Compiling polars-plan v0.35.4\n   Compiling home v0.5.11\n   Compiling percent-encoding v2.3.2\n   Compiling bytes v1.10.1\n   Compiling serde_core v1.0.228\n   Compiling heck v0.4.1\n   Compiling polars-lazy v0.35.4\n   Compiling polars v0.35.4\n   Compiling serde v1.0.228\n   Compiling serde_json v1.0.145\n   Compiling glob v0.3.3\n   Compiling serde_derive v1.0.228\n   Compiling strum_macros v0.25.3\n   Compiling polars-row v0.35.4\n   Compiling polars-time v0.35.4\n   Compiling polars-io v0.35.4\n   Compiling ruchy_binary v0.1.0 (/tmp/.tmpiNS6b0)\nerror[E0308]: mismatched types\n --> src/main.rs:1:725\n  |\n1 | ...-> i32 { let df = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"employee_id\" , vec ! [101 , 102 , 103 , 104]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"name\" , vec ! [\"Alice\" , \"Bob\" , \"Charlie\" , \"Diana\"]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"department\" , vec ! [\"Engineering\" , \"Sales\" , \"Engineering\" , \"HR\"]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"salary\" , vec ! [95000 , 75000 , 105000 , 65000]) }]) . expect (\"Failed to create DataFrame from columns\") } ; df } ...\n  |       --- expected `i32` because of return type                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^^ expected `i32`, found `DataFrame`\n\nwarning: unused import: `polars :: prelude :: NamedFrom`\n --> src/main.rs:1:48\n  |\n1 | fn create_dataframe () -> i32 { let df = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ use polar...\n  |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `ruchy_binary` (bin \"ruchy_binary\") generated 1 warning\nerror: could not compile `ruchy_binary` (bin \"ruchy_binary\") due to 1 previous error; 1 warning emitted\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-dataframes-data-processing.md",
          "example_number": 2,
          "line_number": 56,
          "code": "fun main() {\n    let sales = df![\n        \"product\" => [\"Widget\", \"Gadget\", \"Gizmo\"],\n        \"quantity\" => [100, 150, 200],\n        \"revenue\" => [999.00, 1499.00, 1999.00]\n    ];\n\n    // Display the DataFrame\n    sales\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Cargo build failed:\n    Updating crates.io index\n     Locking 162 packages to latest compatible versions\n      Adding polars v0.35.4 (available: v0.51.0)\n   Compiling version_check v0.9.5\n   Compiling libc v0.2.177\n   Compiling proc-macro2 v1.0.101\n   Compiling quote v1.0.41\n   Compiling unicode-ident v1.0.19\n   Compiling cfg-if v1.0.3\n   Compiling autocfg v1.5.0\n   Compiling libm v0.2.15\n   Compiling zerocopy v0.8.27\n   Compiling crossbeam-utils v0.8.21\n   Compiling target-features v0.1.6\n   Compiling num-traits v0.2.19\n   Compiling memchr v2.7.6\n   Compiling rayon-core v1.13.0\n   Compiling getrandom v0.3.3\n   Compiling aho-corasick v1.1.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling ahash v0.8.12\n   Compiling thiserror v1.0.69\n   Compiling regex-syntax v0.8.8\n   Compiling crossbeam-deque v0.8.6\n   Compiling syn v1.0.109\n   Compiling syn v2.0.106\n   Compiling smartstring v1.0.1\n   Compiling either v1.15.0\n   Compiling once_cell v1.21.3\n   Compiling parking_lot_core v0.9.12\n   Compiling rayon v1.11.0\n   Compiling regex-automata v0.4.13\n   Compiling getrandom v0.2.16\n   Compiling polars-utils v0.35.4\n   Compiling thiserror-impl v1.0.69\n   Compiling bytemuck_derive v1.10.2\n   Compiling rustix v1.1.2\n   Compiling smallvec v1.15.1\n   Compiling equivalent v1.0.2\n   Compiling scopeguard v1.2.0\n   Compiling regex v1.12.2\n   Compiling static_assertions v1.1.0\n   Compiling iana-time-zone v0.1.64\n   Compiling simdutf8 v0.1.5\n   Compiling hashbrown v0.16.0\n   Compiling allocator-api2 v0.2.21\n   Compiling chrono v0.4.42\n   Compiling lock_api v0.4.14\n   Compiling multiversion-macros v0.7.4\n   Compiling hashbrown v0.14.5\n   Compiling indexmap v2.11.4\n   Compiling bytemuck v1.24.0\n   Compiling rand_core v0.6.4\n   Compiling polars-error v0.35.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling linux-raw-sys v0.11.0\n   Compiling itoa v1.0.15\n   Compiling bitflags v2.9.4\n   Compiling ryu v1.0.20\n   Compiling litrs v0.4.2\n   Compiling parking_lot v0.12.5\n   Compiling rand_chacha v0.3.1\n   Compiling atoi_simd v0.15.6\n   Compiling dyn-clone v1.0.20\n   Compiling document-features v0.2.11\n   Compiling foreign_vec v0.1.0\n   Compiling strength_reduce v0.2.4\n   Compiling fast-float v0.2.0\n   Compiling streaming-iterator v0.1.9\n   Compiling ethnum v1.5.2\n   Compiling rand v0.8.5\n   Compiling multiversion v0.7.4\n   Compiling polars-core v0.35.4\n   Compiling unicode-segmentation v1.12.0\n   Compiling unicode-width v0.2.2\n   Compiling polars-ops v0.35.4\n   Compiling crossterm v0.29.0\n   Compiling xxhash-rust v0.8.15\n   Compiling argminmax v0.6.3\n   Compiling rustversion v1.0.22\n   Compiling polars-arrow v0.35.4\n   Compiling rand_distr v0.4.3\n   Compiling now v0.1.3\n   Compiling atoi v2.0.0\n   Compiling memmap2 v0.7.1\n   Compiling comfy-table v7.2.1\n   Compiling polars-plan v0.35.4\n   Compiling bytes v1.10.1\n   Compiling percent-encoding v2.3.2\n   Compiling heck v0.4.1\n   Compiling serde_core v1.0.228\n   Compiling home v0.5.11\n   Compiling polars-lazy v0.35.4\n   Compiling polars v0.35.4\n   Compiling serde_json v1.0.145\n   Compiling glob v0.3.3\n   Compiling serde v1.0.228\n   Compiling serde_derive v1.0.228\n   Compiling strum_macros v0.25.3\n   Compiling polars-row v0.35.4\n   Compiling polars-time v0.35.4\n   Compiling polars-io v0.35.4\n   Compiling ruchy_binary v0.1.0 (/tmp/.tmpgToeDG)\nerror[E0308]: mismatched types\n --> src/main.rs:1:544\n  |\n1 | ... () { { let sales = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"product\" , vec ! [\"Widget\" , \"Gadget\" , \"Gizmo\"]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"quantity\" , vec ! [100 , 150 , 200]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"revenue\" , vec ! [999f64 , 1499f64 , 1999f64]) }]) . expect (\"Failed to create DataFrame from columns\") } ; sales } }\n  |       - expected `()` because of default return type                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^^^^ expected `()`, found `DataFrame`\n\nwarning: unused import: `polars :: prelude :: NamedFrom`\n --> src/main.rs:1:34\n  |\n1 | fn main () { { let sales = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ use polars :: prelude :...\n  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `ruchy_binary` (bin \"ruchy_binary\") generated 1 warning\nerror: could not compile `ruchy_binary` (bin \"ruchy_binary\") due to 1 previous error; 1 warning emitted\n\nError: Cargo build failed:\n    Updating crates.io index\n     Locking 162 packages to latest compatible versions\n      Adding polars v0.35.4 (available: v0.51.0)\n   Compiling version_check v0.9.5\n   Compiling libc v0.2.177\n   Compiling proc-macro2 v1.0.101\n   Compiling quote v1.0.41\n   Compiling unicode-ident v1.0.19\n   Compiling cfg-if v1.0.3\n   Compiling autocfg v1.5.0\n   Compiling libm v0.2.15\n   Compiling zerocopy v0.8.27\n   Compiling crossbeam-utils v0.8.21\n   Compiling target-features v0.1.6\n   Compiling num-traits v0.2.19\n   Compiling memchr v2.7.6\n   Compiling rayon-core v1.13.0\n   Compiling getrandom v0.3.3\n   Compiling aho-corasick v1.1.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling ahash v0.8.12\n   Compiling thiserror v1.0.69\n   Compiling regex-syntax v0.8.8\n   Compiling crossbeam-deque v0.8.6\n   Compiling syn v1.0.109\n   Compiling syn v2.0.106\n   Compiling smartstring v1.0.1\n   Compiling either v1.15.0\n   Compiling once_cell v1.21.3\n   Compiling parking_lot_core v0.9.12\n   Compiling rayon v1.11.0\n   Compiling regex-automata v0.4.13\n   Compiling getrandom v0.2.16\n   Compiling polars-utils v0.35.4\n   Compiling thiserror-impl v1.0.69\n   Compiling bytemuck_derive v1.10.2\n   Compiling rustix v1.1.2\n   Compiling smallvec v1.15.1\n   Compiling equivalent v1.0.2\n   Compiling scopeguard v1.2.0\n   Compiling regex v1.12.2\n   Compiling static_assertions v1.1.0\n   Compiling iana-time-zone v0.1.64\n   Compiling simdutf8 v0.1.5\n   Compiling hashbrown v0.16.0\n   Compiling allocator-api2 v0.2.21\n   Compiling chrono v0.4.42\n   Compiling lock_api v0.4.14\n   Compiling multiversion-macros v0.7.4\n   Compiling hashbrown v0.14.5\n   Compiling indexmap v2.11.4\n   Compiling bytemuck v1.24.0\n   Compiling rand_core v0.6.4\n   Compiling polars-error v0.35.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling linux-raw-sys v0.11.0\n   Compiling itoa v1.0.15\n   Compiling bitflags v2.9.4\n   Compiling ryu v1.0.20\n   Compiling litrs v0.4.2\n   Compiling parking_lot v0.12.5\n   Compiling rand_chacha v0.3.1\n   Compiling atoi_simd v0.15.6\n   Compiling dyn-clone v1.0.20\n   Compiling document-features v0.2.11\n   Compiling foreign_vec v0.1.0\n   Compiling strength_reduce v0.2.4\n   Compiling fast-float v0.2.0\n   Compiling streaming-iterator v0.1.9\n   Compiling ethnum v1.5.2\n   Compiling rand v0.8.5\n   Compiling multiversion v0.7.4\n   Compiling polars-core v0.35.4\n   Compiling unicode-segmentation v1.12.0\n   Compiling unicode-width v0.2.2\n   Compiling polars-ops v0.35.4\n   Compiling crossterm v0.29.0\n   Compiling xxhash-rust v0.8.15\n   Compiling argminmax v0.6.3\n   Compiling rustversion v1.0.22\n   Compiling polars-arrow v0.35.4\n   Compiling rand_distr v0.4.3\n   Compiling now v0.1.3\n   Compiling atoi v2.0.0\n   Compiling memmap2 v0.7.1\n   Compiling comfy-table v7.2.1\n   Compiling polars-plan v0.35.4\n   Compiling bytes v1.10.1\n   Compiling percent-encoding v2.3.2\n   Compiling heck v0.4.1\n   Compiling serde_core v1.0.228\n   Compiling home v0.5.11\n   Compiling polars-lazy v0.35.4\n   Compiling polars v0.35.4\n   Compiling serde_json v1.0.145\n   Compiling glob v0.3.3\n   Compiling serde v1.0.228\n   Compiling serde_derive v1.0.228\n   Compiling strum_macros v0.25.3\n   Compiling polars-row v0.35.4\n   Compiling polars-time v0.35.4\n   Compiling polars-io v0.35.4\n   Compiling ruchy_binary v0.1.0 (/tmp/.tmpgToeDG)\nerror[E0308]: mismatched types\n --> src/main.rs:1:544\n  |\n1 | ... () { { let sales = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"product\" , vec ! [\"Widget\" , \"Gadget\" , \"Gizmo\"]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"quantity\" , vec ! [100 , 150 , 200]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"revenue\" , vec ! [999f64 , 1499f64 , 1999f64]) }]) . expect (\"Failed to create DataFrame from columns\") } ; sales } }\n  |       - expected `()` because of default return type                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^^^^ expected `()`, found `DataFrame`\n\nwarning: unused import: `polars :: prelude :: NamedFrom`\n --> src/main.rs:1:34\n  |\n1 | fn main () { { let sales = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ use polars :: prelude :...\n  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `ruchy_binary` (bin \"ruchy_binary\") generated 1 warning\nerror: could not compile `ruchy_binary` (bin \"ruchy_binary\") due to 1 previous error; 1 warning emitted\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-dataframes-data-processing.md",
          "example_number": 3,
          "line_number": 71,
          "code": "fun work_with_multiple_dataframes() {\n    let customers = df![\n        \"customer_id\" => [1, 2, 3],\n        \"name\" => [\"Alice\", \"Bob\", \"Charlie\"],\n        \"city\" => [\"New York\", \"Los Angeles\", \"Chicago\"]\n    ];\n\n    let orders = df![\n        \"order_id\" => [101, 102, 103],\n        \"customer_id\" => [1, 2, 1],\n        \"amount\" => [99.99, 149.99, 79.99]\n    ];\n\n    // Display both DataFrames\n    customers\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Cargo build failed:\n    Updating crates.io index\n     Locking 162 packages to latest compatible versions\n      Adding polars v0.35.4 (available: v0.51.0)\n   Compiling version_check v0.9.5\n   Compiling libc v0.2.177\n   Compiling proc-macro2 v1.0.101\n   Compiling quote v1.0.41\n   Compiling unicode-ident v1.0.19\n   Compiling cfg-if v1.0.3\n   Compiling autocfg v1.5.0\n   Compiling zerocopy v0.8.27\n   Compiling libm v0.2.15\n   Compiling crossbeam-utils v0.8.21\n   Compiling num-traits v0.2.19\n   Compiling target-features v0.1.6\n   Compiling memchr v2.7.6\n   Compiling rayon-core v1.13.0\n   Compiling getrandom v0.3.3\n   Compiling aho-corasick v1.1.3\n   Compiling ahash v0.8.12\n   Compiling crossbeam-epoch v0.9.18\n   Compiling syn v1.0.109\n   Compiling thiserror v1.0.69\n   Compiling syn v2.0.106\n   Compiling regex-syntax v0.8.8\n   Compiling crossbeam-deque v0.8.6\n   Compiling smartstring v1.0.1\n   Compiling either v1.15.0\n   Compiling once_cell v1.21.3\n   Compiling parking_lot_core v0.9.12\n   Compiling thiserror-impl v1.0.69\n   Compiling bytemuck_derive v1.10.2\n   Compiling rayon v1.11.0\n   Compiling regex-automata v0.4.13\n   Compiling getrandom v0.2.16\n   Compiling polars-utils v0.35.4\n   Compiling static_assertions v1.1.0\n   Compiling iana-time-zone v0.1.64\n   Compiling simdutf8 v0.1.5\n   Compiling rustix v1.1.2\n   Compiling equivalent v1.0.2\n   Compiling regex v1.12.2\n   Compiling hashbrown v0.16.0\n   Compiling allocator-api2 v0.2.21\n   Compiling scopeguard v1.2.0\n   Compiling smallvec v1.15.1\n   Compiling multiversion-macros v0.7.4\n   Compiling hashbrown v0.14.5\n   Compiling lock_api v0.4.14\n   Compiling indexmap v2.11.4\n   Compiling bytemuck v1.24.0\n   Compiling chrono v0.4.42\n   Compiling polars-error v0.35.4\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling linux-raw-sys v0.11.0\n   Compiling litrs v0.4.2\n   Compiling itoa v1.0.15\n   Compiling ryu v1.0.20\n   Compiling bitflags v2.9.4\n   Compiling rand_chacha v0.3.1\n   Compiling parking_lot v0.12.5\n   Compiling streaming-iterator v0.1.9\n   Compiling document-features v0.2.11\n   Compiling fast-float v0.2.0\n   Compiling atoi_simd v0.15.6\n   Compiling ethnum v1.5.2\n   Compiling dyn-clone v1.0.20\n   Compiling foreign_vec v0.1.0\n   Compiling strength_reduce v0.2.4\n   Compiling multiversion v0.7.4\n   Compiling rand v0.8.5\n   Compiling polars-core v0.35.4\n   Compiling unicode-segmentation v1.12.0\n   Compiling unicode-width v0.2.2\n   Compiling polars-ops v0.35.4\n   Compiling xxhash-rust v0.8.15\n   Compiling argminmax v0.6.3\n   Compiling crossterm v0.29.0\n   Compiling polars-arrow v0.35.4\n   Compiling rustversion v1.0.22\n   Compiling rand_distr v0.4.3\n   Compiling now v0.1.3\n   Compiling atoi v2.0.0\n   Compiling memmap2 v0.7.1\n   Compiling comfy-table v7.2.1\n   Compiling polars-plan v0.35.4\n   Compiling bytes v1.10.1\n   Compiling heck v0.4.1\n   Compiling serde_core v1.0.228\n   Compiling home v0.5.11\n   Compiling percent-encoding v2.3.2\n   Compiling polars-lazy v0.35.4\n   Compiling polars v0.35.4\n   Compiling serde v1.0.228\n   Compiling serde_json v1.0.145\n   Compiling glob v0.3.3\n   Compiling strum_macros v0.25.3\n   Compiling serde_derive v1.0.228\n   Compiling polars-row v0.35.4\n   Compiling polars-time v0.35.4\n   Compiling polars-io v0.35.4\n   Compiling ruchy_binary v0.1.0 (/tmp/.tmpVEDPAg)\nerror[E0308]: mismatched types\n --> src/main.rs:1:1100\n  |\n1 | ...-> i32 { { let customers = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"customer_id\" , vec ! [1 , 2 , 3]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"name\" , vec ! [\"Alice\" , \"Bob\" , \"Charlie\"]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"city\" , vec ! [\"New York\" , \"Los Angeles\" , \"Chicago\"]) }]) . expect (\"Failed to create DataFrame from columns\") } ; { let orders = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"order_id\" , vec ! [101 , 102 , 103]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"customer_id\" , vec ! [1 , 2 , 1]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"amount\" , vec ! [99.99f64 , 149.99f64 , 79.99f64]) }]) . expect (\"Failed to create DataFrame from columns\") } ; customers } ...\n  |       --- expected `i32` because of return type                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^^^^^^^^^ expected `i32`, found `DataFrame`\n\nwarning: unused import: `polars :: prelude :: NamedFrom`\n --> src/main.rs:1:70\n  |\n1 | fn work_with_multiple_dataframes () -> i32 { { let customers = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: n...\n  |                                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\nwarning: unused import: `polars :: prelude :: NamedFrom`\n --> src/main.rs:1:602\n  |\n1 | ...e DataFrame from columns\") } ; { let orders = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ u...\n  |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `ruchy_binary` (bin \"ruchy_binary\") generated 2 warnings\nerror: could not compile `ruchy_binary` (bin \"ruchy_binary\") due to 1 previous error; 2 warnings emitted\n\nError: Cargo build failed:\n    Updating crates.io index\n     Locking 162 packages to latest compatible versions\n      Adding polars v0.35.4 (available: v0.51.0)\n   Compiling version_check v0.9.5\n   Compiling libc v0.2.177\n   Compiling proc-macro2 v1.0.101\n   Compiling quote v1.0.41\n   Compiling unicode-ident v1.0.19\n   Compiling cfg-if v1.0.3\n   Compiling autocfg v1.5.0\n   Compiling zerocopy v0.8.27\n   Compiling libm v0.2.15\n   Compiling crossbeam-utils v0.8.21\n   Compiling num-traits v0.2.19\n   Compiling target-features v0.1.6\n   Compiling memchr v2.7.6\n   Compiling rayon-core v1.13.0\n   Compiling getrandom v0.3.3\n   Compiling aho-corasick v1.1.3\n   Compiling ahash v0.8.12\n   Compiling crossbeam-epoch v0.9.18\n   Compiling syn v1.0.109\n   Compiling thiserror v1.0.69\n   Compiling syn v2.0.106\n   Compiling regex-syntax v0.8.8\n   Compiling crossbeam-deque v0.8.6\n   Compiling smartstring v1.0.1\n   Compiling either v1.15.0\n   Compiling once_cell v1.21.3\n   Compiling parking_lot_core v0.9.12\n   Compiling thiserror-impl v1.0.69\n   Compiling bytemuck_derive v1.10.2\n   Compiling rayon v1.11.0\n   Compiling regex-automata v0.4.13\n   Compiling getrandom v0.2.16\n   Compiling polars-utils v0.35.4\n   Compiling static_assertions v1.1.0\n   Compiling iana-time-zone v0.1.64\n   Compiling simdutf8 v0.1.5\n   Compiling rustix v1.1.2\n   Compiling equivalent v1.0.2\n   Compiling regex v1.12.2\n   Compiling hashbrown v0.16.0\n   Compiling allocator-api2 v0.2.21\n   Compiling scopeguard v1.2.0\n   Compiling smallvec v1.15.1\n   Compiling multiversion-macros v0.7.4\n   Compiling hashbrown v0.14.5\n   Compiling lock_api v0.4.14\n   Compiling indexmap v2.11.4\n   Compiling bytemuck v1.24.0\n   Compiling chrono v0.4.42\n   Compiling polars-error v0.35.4\n   Compiling rand_core v0.6.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling linux-raw-sys v0.11.0\n   Compiling litrs v0.4.2\n   Compiling itoa v1.0.15\n   Compiling ryu v1.0.20\n   Compiling bitflags v2.9.4\n   Compiling rand_chacha v0.3.1\n   Compiling parking_lot v0.12.5\n   Compiling streaming-iterator v0.1.9\n   Compiling document-features v0.2.11\n   Compiling fast-float v0.2.0\n   Compiling atoi_simd v0.15.6\n   Compiling ethnum v1.5.2\n   Compiling dyn-clone v1.0.20\n   Compiling foreign_vec v0.1.0\n   Compiling strength_reduce v0.2.4\n   Compiling multiversion v0.7.4\n   Compiling rand v0.8.5\n   Compiling polars-core v0.35.4\n   Compiling unicode-segmentation v1.12.0\n   Compiling unicode-width v0.2.2\n   Compiling polars-ops v0.35.4\n   Compiling xxhash-rust v0.8.15\n   Compiling argminmax v0.6.3\n   Compiling crossterm v0.29.0\n   Compiling polars-arrow v0.35.4\n   Compiling rustversion v1.0.22\n   Compiling rand_distr v0.4.3\n   Compiling now v0.1.3\n   Compiling atoi v2.0.0\n   Compiling memmap2 v0.7.1\n   Compiling comfy-table v7.2.1\n   Compiling polars-plan v0.35.4\n   Compiling bytes v1.10.1\n   Compiling heck v0.4.1\n   Compiling serde_core v1.0.228\n   Compiling home v0.5.11\n   Compiling percent-encoding v2.3.2\n   Compiling polars-lazy v0.35.4\n   Compiling polars v0.35.4\n   Compiling serde v1.0.228\n   Compiling serde_json v1.0.145\n   Compiling glob v0.3.3\n   Compiling strum_macros v0.25.3\n   Compiling serde_derive v1.0.228\n   Compiling polars-row v0.35.4\n   Compiling polars-time v0.35.4\n   Compiling polars-io v0.35.4\n   Compiling ruchy_binary v0.1.0 (/tmp/.tmpVEDPAg)\nerror[E0308]: mismatched types\n --> src/main.rs:1:1100\n  |\n1 | ...-> i32 { { let customers = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"customer_id\" , vec ! [1 , 2 , 3]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"name\" , vec ! [\"Alice\" , \"Bob\" , \"Charlie\"]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"city\" , vec ! [\"New York\" , \"Los Angeles\" , \"Chicago\"]) }]) . expect (\"Failed to create DataFrame from columns\") } ; { let orders = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"order_id\" , vec ! [101 , 102 , 103]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"customer_id\" , vec ! [1 , 2 , 1]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"amount\" , vec ! [99.99f64 , 149.99f64 , 79.99f64]) }]) . expect (\"Failed to create DataFrame from columns\") } ; customers } ...\n  |       --- expected `i32` because of return type                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^^^^^^^^^ expected `i32`, found `DataFrame`\n\nwarning: unused import: `polars :: prelude :: NamedFrom`\n --> src/main.rs:1:70\n  |\n1 | fn work_with_multiple_dataframes () -> i32 { { let customers = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: n...\n  |                                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\nwarning: unused import: `polars :: prelude :: NamedFrom`\n --> src/main.rs:1:602\n  |\n1 | ...e DataFrame from columns\") } ; { let orders = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ u...\n  |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `ruchy_binary` (bin \"ruchy_binary\") generated 2 warnings\nerror: could not compile `ruchy_binary` (bin \"ruchy_binary\") due to 1 previous error; 2 warnings emitted\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-dataframes-data-processing.md",
          "example_number": 4,
          "line_number": 92,
          "code": "fun conditional_processing() {\n    let df = df![\n        \"status\" => [\"active\", \"pending\", \"closed\"],\n        \"value\" => [1000, 500, 1500]\n    ];\n\n    // Display the DataFrame\n    df\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Cargo build failed:\n    Updating crates.io index\n     Locking 162 packages to latest compatible versions\n      Adding polars v0.35.4 (available: v0.51.0)\n   Compiling version_check v0.9.5\n   Compiling libc v0.2.177\n   Compiling proc-macro2 v1.0.101\n   Compiling unicode-ident v1.0.19\n   Compiling quote v1.0.41\n   Compiling cfg-if v1.0.3\n   Compiling autocfg v1.5.0\n   Compiling zerocopy v0.8.27\n   Compiling libm v0.2.15\n   Compiling crossbeam-utils v0.8.21\n   Compiling memchr v2.7.6\n   Compiling num-traits v0.2.19\n   Compiling target-features v0.1.6\n   Compiling getrandom v0.3.3\n   Compiling rayon-core v1.13.0\n   Compiling aho-corasick v1.1.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling ahash v0.8.12\n   Compiling syn v1.0.109\n   Compiling thiserror v1.0.69\n   Compiling crossbeam-deque v0.8.6\n   Compiling regex-syntax v0.8.8\n   Compiling syn v2.0.106\n   Compiling smartstring v1.0.1\n   Compiling parking_lot_core v0.9.12\n   Compiling either v1.15.0\n   Compiling once_cell v1.21.3\n   Compiling getrandom v0.2.16\n   Compiling rayon v1.11.0\n   Compiling regex-automata v0.4.13\n   Compiling polars-utils v0.35.4\n   Compiling thiserror-impl v1.0.69\n   Compiling bytemuck_derive v1.10.2\n   Compiling scopeguard v1.2.0\n   Compiling equivalent v1.0.2\n   Compiling hashbrown v0.16.0\n   Compiling iana-time-zone v0.1.64\n   Compiling static_assertions v1.1.0\n   Compiling simdutf8 v0.1.5\n   Compiling regex v1.12.2\n   Compiling allocator-api2 v0.2.21\n   Compiling smallvec v1.15.1\n   Compiling rustix v1.1.2\n   Compiling indexmap v2.11.4\n   Compiling hashbrown v0.14.5\n   Compiling chrono v0.4.42\n   Compiling multiversion-macros v0.7.4\n   Compiling lock_api v0.4.14\n   Compiling bytemuck v1.24.0\n   Compiling rand_core v0.6.4\n   Compiling polars-error v0.35.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling litrs v0.4.2\n   Compiling ryu v1.0.20\n   Compiling linux-raw-sys v0.11.0\n   Compiling bitflags v2.9.4\n   Compiling itoa v1.0.15\n   Compiling document-features v0.2.11\n   Compiling rand_chacha v0.3.1\n   Compiling parking_lot v0.12.5\n   Compiling atoi_simd v0.15.6\n   Compiling ethnum v1.5.2\n   Compiling dyn-clone v1.0.20\n   Compiling streaming-iterator v0.1.9\n   Compiling foreign_vec v0.1.0\n   Compiling fast-float v0.2.0\n   Compiling strength_reduce v0.2.4\n   Compiling multiversion v0.7.4\n   Compiling rand v0.8.5\n   Compiling polars-core v0.35.4\n   Compiling unicode-segmentation v1.12.0\n   Compiling crossterm v0.29.0\n   Compiling unicode-width v0.2.2\n   Compiling polars-ops v0.35.4\n   Compiling xxhash-rust v0.8.15\n   Compiling argminmax v0.6.3\n   Compiling polars-arrow v0.35.4\n   Compiling rustversion v1.0.22\n   Compiling rand_distr v0.4.3\n   Compiling now v0.1.3\n   Compiling comfy-table v7.2.1\n   Compiling atoi v2.0.0\n   Compiling memmap2 v0.7.1\n   Compiling polars-plan v0.35.4\n   Compiling bytes v1.10.1\n   Compiling heck v0.4.1\n   Compiling percent-encoding v2.3.2\n   Compiling home v0.5.11\n   Compiling serde_core v1.0.228\n   Compiling polars-lazy v0.35.4\n   Compiling polars v0.35.4\n   Compiling serde_json v1.0.145\n   Compiling glob v0.3.3\n   Compiling serde v1.0.228\n   Compiling serde_derive v1.0.228\n   Compiling strum_macros v0.25.3\n   Compiling polars-row v0.35.4\n   Compiling polars-time v0.35.4\n   Compiling polars-io v0.35.4\n   Compiling ruchy_binary v0.1.0 (/tmp/.tmpzasqcX)\nerror[E0308]: mismatched types\n --> src/main.rs:1:437\n  |\n1 | ...-> i32 { let df = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"status\" , vec ! [\"active\" , \"pending\" , \"closed\"]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"value\" , vec ! [1000 , 500 , 1500]) }]) . expect (\"Failed to create DataFrame from columns\") } ; df } ...\n  |       --- expected `i32` because of return type                                                                                                                                                                                                                                                                                                                                                                           ^^ expected `i32`, found `DataFrame`\n\nwarning: unused import: `polars :: prelude :: NamedFrom`\n --> src/main.rs:1:54\n  |\n1 | fn conditional_processing () -> i32 { let df = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ use...\n  |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `ruchy_binary` (bin \"ruchy_binary\") generated 1 warning\nerror: could not compile `ruchy_binary` (bin \"ruchy_binary\") due to 1 previous error; 1 warning emitted\n\nError: Cargo build failed:\n    Updating crates.io index\n     Locking 162 packages to latest compatible versions\n      Adding polars v0.35.4 (available: v0.51.0)\n   Compiling version_check v0.9.5\n   Compiling libc v0.2.177\n   Compiling proc-macro2 v1.0.101\n   Compiling unicode-ident v1.0.19\n   Compiling quote v1.0.41\n   Compiling cfg-if v1.0.3\n   Compiling autocfg v1.5.0\n   Compiling zerocopy v0.8.27\n   Compiling libm v0.2.15\n   Compiling crossbeam-utils v0.8.21\n   Compiling memchr v2.7.6\n   Compiling num-traits v0.2.19\n   Compiling target-features v0.1.6\n   Compiling getrandom v0.3.3\n   Compiling rayon-core v1.13.0\n   Compiling aho-corasick v1.1.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling ahash v0.8.12\n   Compiling syn v1.0.109\n   Compiling thiserror v1.0.69\n   Compiling crossbeam-deque v0.8.6\n   Compiling regex-syntax v0.8.8\n   Compiling syn v2.0.106\n   Compiling smartstring v1.0.1\n   Compiling parking_lot_core v0.9.12\n   Compiling either v1.15.0\n   Compiling once_cell v1.21.3\n   Compiling getrandom v0.2.16\n   Compiling rayon v1.11.0\n   Compiling regex-automata v0.4.13\n   Compiling polars-utils v0.35.4\n   Compiling thiserror-impl v1.0.69\n   Compiling bytemuck_derive v1.10.2\n   Compiling scopeguard v1.2.0\n   Compiling equivalent v1.0.2\n   Compiling hashbrown v0.16.0\n   Compiling iana-time-zone v0.1.64\n   Compiling static_assertions v1.1.0\n   Compiling simdutf8 v0.1.5\n   Compiling regex v1.12.2\n   Compiling allocator-api2 v0.2.21\n   Compiling smallvec v1.15.1\n   Compiling rustix v1.1.2\n   Compiling indexmap v2.11.4\n   Compiling hashbrown v0.14.5\n   Compiling chrono v0.4.42\n   Compiling multiversion-macros v0.7.4\n   Compiling lock_api v0.4.14\n   Compiling bytemuck v1.24.0\n   Compiling rand_core v0.6.4\n   Compiling polars-error v0.35.4\n   Compiling ppv-lite86 v0.2.21\n   Compiling litrs v0.4.2\n   Compiling ryu v1.0.20\n   Compiling linux-raw-sys v0.11.0\n   Compiling bitflags v2.9.4\n   Compiling itoa v1.0.15\n   Compiling document-features v0.2.11\n   Compiling rand_chacha v0.3.1\n   Compiling parking_lot v0.12.5\n   Compiling atoi_simd v0.15.6\n   Compiling ethnum v1.5.2\n   Compiling dyn-clone v1.0.20\n   Compiling streaming-iterator v0.1.9\n   Compiling foreign_vec v0.1.0\n   Compiling fast-float v0.2.0\n   Compiling strength_reduce v0.2.4\n   Compiling multiversion v0.7.4\n   Compiling rand v0.8.5\n   Compiling polars-core v0.35.4\n   Compiling unicode-segmentation v1.12.0\n   Compiling crossterm v0.29.0\n   Compiling unicode-width v0.2.2\n   Compiling polars-ops v0.35.4\n   Compiling xxhash-rust v0.8.15\n   Compiling argminmax v0.6.3\n   Compiling polars-arrow v0.35.4\n   Compiling rustversion v1.0.22\n   Compiling rand_distr v0.4.3\n   Compiling now v0.1.3\n   Compiling comfy-table v7.2.1\n   Compiling atoi v2.0.0\n   Compiling memmap2 v0.7.1\n   Compiling polars-plan v0.35.4\n   Compiling bytes v1.10.1\n   Compiling heck v0.4.1\n   Compiling percent-encoding v2.3.2\n   Compiling home v0.5.11\n   Compiling serde_core v1.0.228\n   Compiling polars-lazy v0.35.4\n   Compiling polars v0.35.4\n   Compiling serde_json v1.0.145\n   Compiling glob v0.3.3\n   Compiling serde v1.0.228\n   Compiling serde_derive v1.0.228\n   Compiling strum_macros v0.25.3\n   Compiling polars-row v0.35.4\n   Compiling polars-time v0.35.4\n   Compiling polars-io v0.35.4\n   Compiling ruchy_binary v0.1.0 (/tmp/.tmpzasqcX)\nerror[E0308]: mismatched types\n --> src/main.rs:1:437\n  |\n1 | ...-> i32 { let df = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"status\" , vec ! [\"active\" , \"pending\" , \"closed\"]) } , { use polars :: prelude :: NamedFrom ; polars :: prelude :: Series :: new (\"value\" , vec ! [1000 , 500 , 1500]) }]) . expect (\"Failed to create DataFrame from columns\") } ; df } ...\n  |       --- expected `i32` because of return type                                                                                                                                                                                                                                                                                                                                                                           ^^ expected `i32`, found `DataFrame`\n\nwarning: unused import: `polars :: prelude :: NamedFrom`\n --> src/main.rs:1:54\n  |\n1 | fn conditional_processing () -> i32 { let df = { use polars :: prelude :: NamedFrom ; polars :: prelude :: DataFrame :: new (vec ! [{ use...\n  |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `ruchy_binary` (bin \"ruchy_binary\") generated 1 warning\nerror: could not compile `ruchy_binary` (bin \"ruchy_binary\") due to 1 previous error; 1 warning emitted\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch05-00-control-flow-tdd": {
      "chapter": "ch05-00-control-flow-tdd",
      "total_examples": 17,
      "working_examples": 14,
      "failing_examples": 3,
      "examples": [
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 1,
          "line_number": 52,
          "code": "fun main() {\n    let x = 10;\n    if x > 5 {\n        println(\"x is greater than 5\");\n    } else {\n        println(\"x is not greater than 5\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 2,
          "line_number": 75,
          "code": "fun main() {\n    let score = 85;\n    if score >= 80 {\n        println(\"Great job!\");\n    }\n    println(\"Score processed\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 3,
          "line_number": 98,
          "code": "fun main() {\n    let grade = 75;\n    if grade >= 90 {\n        println(\"A grade\");\n    } else if grade >= 80 {\n        println(\"B grade\");\n    } else if grade >= 70 {\n        println(\"C grade\");\n    } else {\n        println(\"Below C\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 4,
          "line_number": 125,
          "code": "fun main() {\n    let mut i = 0;\n    while i < 3 {\n        println(i);\n        i = i + 1;\n    }\n    println(\"Done\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 5,
          "line_number": 151,
          "code": "fun main() {\n    for i in 0..3 {\n        println(i);\n    }\n    println(\"For loop done\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 6,
          "line_number": 175,
          "code": "fun main() {\n    let number = 2;\n    match number {\n        1 => println(\"One\"),\n        2 => println(\"Two\"),\n        3 => println(\"Three\"),\n        _ => println(\"Other\")\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 7,
          "line_number": 199,
          "code": "fun main() {\n    let mut i = 0;\n    while i < 10 {\n        i = i + 1;\n        if i == 3 {\n            continue;\n        }\n        if i == 6 {\n            break;\n        }\n        println(i);\n    }\n    println(\"Loop ended\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 8,
          "line_number": 256,
          "code": "fun main() {\n    let x = 10;\n    let y = 5;\n\n    if x > y {\n        println(\"x is greater\");\n    } else if x < y {\n        println(\"y is greater\");\n    } else {\n        println(\"they are equal\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 9,
          "line_number": 272,
          "code": "fun main() {\n    // While loop\n    let mut count = 0;\n    while count < 3 {\n        println(\"Count: \" + count);\n        count = count + 1;\n    }\n\n    // For loop with range\n    for i in 1..4 {\n        println(\"Iteration: \" + i);\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 10,
          "line_number": 289,
          "code": "fun main() {\n    let number = 2;\n    match number {\n        1 => println(\"One\"),\n        2 => println(\"Two\"),\n        3 => println(\"Three\"),\n        _ => println(\"Other\")\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 11,
          "line_number": 316,
          "code": "fun main() {\n    let user_input = 75;\n    let threshold = 50;\n\n    if user_input > threshold {\n        println(\"High value: \" + user_input);\n    } else {\n        println(\"Normal value: \" + user_input);\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 12,
          "line_number": 330,
          "code": "fun main() {\n    let mut count = 0;\n    while count < 10 {\n        println(\"Count is: \" + count);\n        count = count + 1;\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 13,
          "line_number": 341,
          "code": "fun main() {\n    for i in 1..5 {\n        println(\"Processing item \" + i);\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 14,
          "line_number": 350,
          "code": "fun main() {\n    let status_code = 200;\n    match status_code {\n        200 => println(\"Success\"),\n        404 => println(\"Not Found\"),\n        500 => println(\"Server Error\"),\n        _ => println(\"Unknown Status\")\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 15,
          "line_number": 363,
          "code": "fun main() {\n    let df = DataFrame::from_csv(\"sales.csv\");\n    \n    // Filter based on conditions\n    if df.rows() > 0 {\n        let high_value = df.filter(|row| {\n            if row[\"amount\"] > 1000 {\n                row[\"status\"] == \"active\"\n            } else {\n                false\n            }\n        });\n        \n        println(\"Found {} high-value active sales\", high_value.rows());\n    } else {\n        println(\"No data to process\");\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmpUGzstn/main.rs:1:23\n  |\n1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"sales.csv\") . expect (\"Failed to open CSV file\") . finish () . expect...\n  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nerror[E0282]: type annotations needed\n --> /tmp/.tmpUGzstn/main.rs:1:242\n  |\n1 | ...high_value = df . lazy () . filter (move | row | { if row . get (\"amount\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))...\n  |                                               ^^^        --- type must be known at this point\n  |\nhelp: consider giving this closure parameter an explicit type\n  |\n1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"sales.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; if df . height () > 0 { { let high_value = df . lazy () . filter (move | row: /* Type */ | { if row . get (\"amount\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) > 1000 { row . get (\"status\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) == \"active\" } else { false } }) . collect () . expect (\"DataFrame lazy operation collection should not fail\") ; println ! (\"Found {} high-value active sales\" , high_value . rows ()) } } else { println ! (\"No data to process\") } ; }\n  |                                                                                                                                                                                                                                                     ++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0282, E0433.\nFor more information about an error, try `rustc --explain E0282`.\n\nError: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmpUGzstn/main.rs:1:23\n  |\n1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"sales.csv\") . expect (\"Failed to open CSV file\") . finish () . expect...\n  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nerror[E0282]: type annotations needed\n --> /tmp/.tmpUGzstn/main.rs:1:242\n  |\n1 | ...high_value = df . lazy () . filter (move | row | { if row . get (\"amount\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))...\n  |                                               ^^^        --- type must be known at this point\n  |\nhelp: consider giving this closure parameter an explicit type\n  |\n1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"sales.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; if df . height () > 0 { { let high_value = df . lazy () . filter (move | row: /* Type */ | { if row . get (\"amount\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) > 1000 { row . get (\"status\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) == \"active\" } else { false } }) . collect () . expect (\"DataFrame lazy operation collection should not fail\") ; println ! (\"Found {} high-value active sales\" , high_value . rows ()) } } else { println ! (\"No data to process\") } ; }\n  |                                                                                                                                                                                                                                                     ++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0282, E0433.\nFor more information about an error, try `rustc --explain E0282`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 16,
          "line_number": 385,
          "code": "fun main() {\n    let df = DataFrame::from_csv(\"inventory.csv\");\n    \n    // Process each row with for loop\n    for row in df.iter_rows() {\n        if row[\"quantity\"] < 10 {\n            println(\"Low stock alert: {} ({})\", row[\"product\"], row[\"quantity\"]);\n        }\n    }\n    \n    // Conditional aggregation\n    let mut total = 0.0;\n    for value in df[\"price\"].iter() {\n        if value > 0.0 {\n            total = total + value;\n        }\n    }\n    println(\"Total positive prices: {}\", total);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmpIDZjzF/main.rs:1:23\n  |\n1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . ex...\n  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpIDZjzF/main.rs:1:204\n  |\n1 | ... { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                              ^^\n  |\n  = note: `#[warn(unused_braces)]` (part of `#[warn(unused)]`) on by default\nhelp: remove these braces\n  |\n1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; for row in df . iter_rows () { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } } ; let mut total = 0f64 ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! (\"Total positive prices: {}\" , total) ; }\n1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; for row in df . iter_rows () { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) }  } ; let mut total = 0f64 ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! (\"Total positive prices: {}\" , total) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpIDZjzF/main.rs:1:642\n  |\n1 | ... (|| panic ! (\"Key not found\")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! (\"Total positive prices: {}\" ,...\n  |                                                ^^                                         ^^\n  |\nhelp: remove these braces\n  |\n1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; for row in df . iter_rows () { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } } ; let mut total = 0f64 ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! (\"Total positive prices: {}\" , total) ; }\n1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; for row in df . iter_rows () { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } } ; let mut total = 0f64 ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) . iter () { if value > 0f64 { total = total + value }  } ; println ! (\"Total positive prices: {}\" , total) ; }\n  |\n\nerror[E0282]: type annotations needed\n --> /tmp/.tmpIDZjzF/main.rs:1:209\n  |\n1 | ...o read CSV file\") ; for row in df . iter_rows () { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not foun...\n  |                                                            ^^^ cannot infer type\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0282, E0433.\nFor more information about an error, try `rustc --explain E0282`.\n\nError: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmpIDZjzF/main.rs:1:23\n  |\n1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . ex...\n  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpIDZjzF/main.rs:1:204\n  |\n1 | ... { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                              ^^\n  |\n  = note: `#[warn(unused_braces)]` (part of `#[warn(unused)]`) on by default\nhelp: remove these braces\n  |\n1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; for row in df . iter_rows () { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } } ; let mut total = 0f64 ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! (\"Total positive prices: {}\" , total) ; }\n1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; for row in df . iter_rows () { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) }  } ; let mut total = 0f64 ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! (\"Total positive prices: {}\" , total) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpIDZjzF/main.rs:1:642\n  |\n1 | ... (|| panic ! (\"Key not found\")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! (\"Total positive prices: {}\" ,...\n  |                                                ^^                                         ^^\n  |\nhelp: remove these braces\n  |\n1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; for row in df . iter_rows () { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } } ; let mut total = 0f64 ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! (\"Total positive prices: {}\" , total) ; }\n1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; for row in df . iter_rows () { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } } ; let mut total = 0f64 ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) . iter () { if value > 0f64 { total = total + value }  } ; println ! (\"Total positive prices: {}\" , total) ; }\n  |\n\nerror[E0282]: type annotations needed\n --> /tmp/.tmpIDZjzF/main.rs:1:209\n  |\n1 | ...o read CSV file\") ; for row in df . iter_rows () { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not foun...\n  |                                                            ^^^ cannot infer type\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0282, E0433.\nFor more information about an error, try `rustc --explain E0282`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 17,
          "line_number": 408,
          "code": "fun main() {\n    let df = DataFrame::from_csv(\"customers.csv\");\n    \n    for row in df.iter_rows() {\n        let category = match row[\"total_purchases\"] {\n            v if v > 10000 => \"Platinum\",\n            v if v > 5000 => \"Gold\",\n            v if v > 1000 => \"Silver\",\n            _ => \"Bronze\"\n        };\n        \n        println(\"Customer {} is {} tier\", row[\"name\"], category);\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmp5RKNB2/main.rs:1:23\n  |\n1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"customers.csv\") . expect (\"Failed to open CSV file\") . finish () . ex...\n  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5RKNB2/main.rs:1:204\n  |\n1 | ... { { { let category = match row . get (\"total_purchases\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) { v if v > 10000 => \"Platinum\" , v if v > 5000 => \"Gold\" , v if v > 1000 => \"Silver\" , _ => \"Bronze\" , } ; println ! (\"Customer {} is {} tier\" , row . get (\"name\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , category) } } } ; }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                              ^^\n  |\n  = note: `#[warn(unused_braces)]` (part of `#[warn(unused)]`) on by default\nhelp: remove these braces\n  |\n1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"customers.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; for row in df . iter_rows () { { { let category = match row . get (\"total_purchases\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) { v if v > 10000 => \"Platinum\" , v if v > 5000 => \"Gold\" , v if v > 1000 => \"Silver\" , _ => \"Bronze\" , } ; println ! (\"Customer {} is {} tier\" , row . get (\"name\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , category) } } } ; }\n1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"customers.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; for row in df . iter_rows () { { let category = match row . get (\"total_purchases\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) { v if v > 10000 => \"Platinum\" , v if v > 5000 => \"Gold\" , v if v > 1000 => \"Silver\" , _ => \"Bronze\" , } ; println ! (\"Customer {} is {} tier\" , row . get (\"name\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , category) }  } ; }\n  |\n\nerror[E0282]: type annotations needed\n --> /tmp/.tmp5RKNB2/main.rs:1:229\n  |\n1 | ...for row in df . iter_rows () { { { let category = match row . get (\"total_purchases\") . cloned () . unwrap_or_else (|| panic ! (\"Key n...\n  |                                                            ^^^ cannot infer type\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0282, E0433.\nFor more information about an error, try `rustc --explain E0282`.\n\nError: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmp5RKNB2/main.rs:1:23\n  |\n1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"customers.csv\") . expect (\"Failed to open CSV file\") . finish () . ex...\n  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5RKNB2/main.rs:1:204\n  |\n1 | ... { { { let category = match row . get (\"total_purchases\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) { v if v > 10000 => \"Platinum\" , v if v > 5000 => \"Gold\" , v if v > 1000 => \"Silver\" , _ => \"Bronze\" , } ; println ! (\"Customer {} is {} tier\" , row . get (\"name\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , category) } } } ; }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                              ^^\n  |\n  = note: `#[warn(unused_braces)]` (part of `#[warn(unused)]`) on by default\nhelp: remove these braces\n  |\n1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"customers.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; for row in df . iter_rows () { { { let category = match row . get (\"total_purchases\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) { v if v > 10000 => \"Platinum\" , v if v > 5000 => \"Gold\" , v if v > 1000 => \"Silver\" , _ => \"Bronze\" , } ; println ! (\"Customer {} is {} tier\" , row . get (\"name\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , category) } } } ; }\n1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"customers.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; for row in df . iter_rows () { { let category = match row . get (\"total_purchases\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) { v if v > 10000 => \"Platinum\" , v if v > 5000 => \"Gold\" , v if v > 1000 => \"Silver\" , _ => \"Bronze\" , } ; println ! (\"Customer {} is {} tier\" , row . get (\"name\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , category) }  } ; }\n  |\n\nerror[E0282]: type annotations needed\n --> /tmp/.tmp5RKNB2/main.rs:1:229\n  |\n1 | ...for row in df . iter_rows () { { { let category = match row . get (\"total_purchases\") . cloned () . unwrap_or_else (|| panic ! (\"Key n...\n  |                                                            ^^^ cannot infer type\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0282, E0433.\nFor more information about an error, try `rustc --explain E0282`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch19-00-structs-oop": {
      "chapter": "ch19-00-structs-oop",
      "total_examples": 9,
      "working_examples": 6,
      "failing_examples": 3,
      "examples": [
        {
          "file": "src/ch19-00-structs-oop.md",
          "example_number": 1,
          "line_number": 42,
          "code": "struct Point {\n    x: i32,\n    y: i32\n}\n\n// Create an instance\nlet p = Point { x: 10, y: 20 }\nprintln(p.x)  // 10\nprintln(p.y)  // 20",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch19-00-structs-oop.md",
          "example_number": 2,
          "line_number": 58,
          "code": "struct Person {\n    name: String,\n    age: i32,\n    height: f64\n}\n\nlet alice = Person {\n    name: \"Alice\",\n    age: 30,\n    height: 5.6\n}\n\nprintln(alice.name)    // Alice\nprintln(alice.age)     // 30\nprintln(alice.height)  // 5.6",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch19-00-structs-oop.md",
          "example_number": 3,
          "line_number": 80,
          "code": "struct Counter {\n    count: i32\n}\n\nlet mut c = Counter { count: 0 }\nprintln(c.count)  // 0\n\n// Field mutation now works!\nc.count = 5\nprintln(c.count)  // 5\n\nc.count = c.count + 1\nprintln(c.count)  // 6",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch19-00-structs-oop.md",
          "example_number": 4,
          "line_number": 104,
          "code": "struct Node {\n    value: i32,\n    next: Option<Node>\n}\n\n// Leaf node\nlet leaf = Node {\n    value: 3,\n    next: None\n}\n\n// Node with a child\nlet parent = Node {\n    value: 1,\n    next: Some(leaf)\n}\n\nprintln(parent.value)  // 1",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0072]: recursive type `Node` has infinite size\n --> /tmp/.tmp3z62UD/main.rs:1:1\n  |\n1 | struct Node { value : i32 , next : Option < Node > , } fn main () { let leaf = Node { value : 3 , next : None , } ; let parent = Node { v...\n  | ^^^^^^^^^^^                                 ---- recursive without indirection\n  |\nhelp: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n  |\n1 | struct Node { value : i32 , next : Option < Box<Node> > , } fn main () { let leaf = Node { value : 3 , next : None , } ; let parent = Node { value : 1 , next : Some (leaf) , } ; println ! (\"{:?}\" , parent . value) ; }\n  |                                             ++++    +\n\nerror[E0391]: cycle detected when computing layout of `Node`\n  |\n  = note: ...which requires computing layout of `core::option::Option<Node>`...\n  = note: ...which again requires computing layout of `Node`, completing the cycle\nnote: cycle used when elaborating drops for `main`\n --> /tmp/.tmp3z62UD/main.rs:1:56\n  |\n1 | struct Node { value : i32 , next : Option < Node > , } fn main () { let leaf = Node { value : 3 , next : None , } ; let parent = Node { v...\n  |                                                        ^^^^^^^^^^\n  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0072, E0391.\nFor more information about an error, try `rustc --explain E0072`.\n\nError: Compilation failed:\nerror[E0072]: recursive type `Node` has infinite size\n --> /tmp/.tmp3z62UD/main.rs:1:1\n  |\n1 | struct Node { value : i32 , next : Option < Node > , } fn main () { let leaf = Node { value : 3 , next : None , } ; let parent = Node { v...\n  | ^^^^^^^^^^^                                 ---- recursive without indirection\n  |\nhelp: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n  |\n1 | struct Node { value : i32 , next : Option < Box<Node> > , } fn main () { let leaf = Node { value : 3 , next : None , } ; let parent = Node { value : 1 , next : Some (leaf) , } ; println ! (\"{:?}\" , parent . value) ; }\n  |                                             ++++    +\n\nerror[E0391]: cycle detected when computing layout of `Node`\n  |\n  = note: ...which requires computing layout of `core::option::Option<Node>`...\n  = note: ...which again requires computing layout of `Node`, completing the cycle\nnote: cycle used when elaborating drops for `main`\n --> /tmp/.tmp3z62UD/main.rs:1:56\n  |\n1 | struct Node { value : i32 , next : Option < Node > , } fn main () { let leaf = Node { value : 3 , next : None , } ; let parent = Node { v...\n  |                                                        ^^^^^^^^^^\n  = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0072, E0391.\nFor more information about an error, try `rustc --explain E0072`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch19-00-structs-oop.md",
          "example_number": 5,
          "line_number": 133,
          "code": "struct Config {\n    debug: bool,\n    port: i32,\n    host: String\n}\n\nlet default_config = Config {\n    debug: false,\n    port: 8080,\n    host: \"localhost\"\n}\n\n// Create a new config with some fields changed\nlet prod_config = Config {\n    debug: false,\n    port: 443,\n    host: \"production.com\"\n}\n\nprintln(prod_config.port)  // 443",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch19-00-structs-oop.md",
          "example_number": 6,
          "line_number": 160,
          "code": "struct Settings {\n    theme: String = \"dark\",\n    font_size: i32 = 14,\n    auto_save: bool = true\n}\n\n// Use all defaults\nlet default_settings = Settings {}\nprintln(default_settings.theme)      // dark\nprintln(default_settings.font_size)  // 14\n\n// Override specific fields\nlet custom = Settings {\n    font_size: 16\n}\nprintln(custom.font_size)  // 16\nprintln(custom.theme)      // dark (default)",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0308]: mismatched types\n --> /tmp/.tmpINtCkS/main.rs:1:142\n  |\n1 | ...ttings { fn default () -> Self { Self { theme : \"dark\" , font_size : 14 , auto_save : true , } } } fn main () { let default_settings =...\n  |                                                    ^^^^^^ expected `String`, found `&str`\n  |\nhelp: try using a conversion method\n  |\n1 | struct Settings { theme : String , font_size : i32 , auto_save : bool , } impl Default for Settings { fn default () -> Self { Self { theme : \"dark\".to_string() , font_size : 14 , auto_save : true , } } } fn main () { let default_settings = Settings { } ; println ! (\"{:?}\" , default_settings . theme) ; println ! (\"{:?}\" , default_settings . font_size) ; let custom = Settings { font_size : 16 , } ; println ! (\"{:?}\" , custom . font_size) ; println ! (\"{:?}\" , custom . theme) ; }\n  |                                                                                                                                                    ++++++++++++\n\nerror[E0063]: missing fields `auto_save`, `font_size` and `theme` in initializer of `Settings`\n --> /tmp/.tmpINtCkS/main.rs:1:229\n  |\n1 | ...} } fn main () { let default_settings = Settings { } ; println ! (\"{:?}\" , default_settings . theme) ; println ! (\"{:?}\" , default_set...\n  |                                            ^^^^^^^^ missing `auto_save`, `font_size` and `theme`\n\nerror[E0063]: missing fields `auto_save` and `theme` in initializer of `Settings`\n --> /tmp/.tmpINtCkS/main.rs:1:357\n  |\n1 | ..., default_settings . font_size) ; let custom = Settings { font_size : 16 , } ; println ! (\"{:?}\" , custom . font_size) ; println ! (\"{...\n  |                                                   ^^^^^^^^ missing `auto_save` and `theme`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0063, E0308.\nFor more information about an error, try `rustc --explain E0063`.\n\nError: Compilation failed:\nerror[E0308]: mismatched types\n --> /tmp/.tmpINtCkS/main.rs:1:142\n  |\n1 | ...ttings { fn default () -> Self { Self { theme : \"dark\" , font_size : 14 , auto_save : true , } } } fn main () { let default_settings =...\n  |                                                    ^^^^^^ expected `String`, found `&str`\n  |\nhelp: try using a conversion method\n  |\n1 | struct Settings { theme : String , font_size : i32 , auto_save : bool , } impl Default for Settings { fn default () -> Self { Self { theme : \"dark\".to_string() , font_size : 14 , auto_save : true , } } } fn main () { let default_settings = Settings { } ; println ! (\"{:?}\" , default_settings . theme) ; println ! (\"{:?}\" , default_settings . font_size) ; let custom = Settings { font_size : 16 , } ; println ! (\"{:?}\" , custom . font_size) ; println ! (\"{:?}\" , custom . theme) ; }\n  |                                                                                                                                                    ++++++++++++\n\nerror[E0063]: missing fields `auto_save`, `font_size` and `theme` in initializer of `Settings`\n --> /tmp/.tmpINtCkS/main.rs:1:229\n  |\n1 | ...} } fn main () { let default_settings = Settings { } ; println ! (\"{:?}\" , default_settings . theme) ; println ! (\"{:?}\" , default_set...\n  |                                            ^^^^^^^^ missing `auto_save`, `font_size` and `theme`\n\nerror[E0063]: missing fields `auto_save` and `theme` in initializer of `Settings`\n --> /tmp/.tmpINtCkS/main.rs:1:357\n  |\n1 | ..., default_settings . font_size) ; let custom = Settings { font_size : 16 , } ; println ! (\"{:?}\" , custom . font_size) ; println ! (\"{...\n  |                                                   ^^^^^^^^ missing `auto_save` and `theme`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0063, E0308.\nFor more information about an error, try `rustc --explain E0063`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch19-00-structs-oop.md",
          "example_number": 7,
          "line_number": 184,
          "code": "struct BankAccount {\n    pub owner: String,       // Public field\n    balance: f64,           // Private field (default)\n    pub(crate) id: i32      // Crate-visible field\n}\n\nlet account = BankAccount {\n    owner: \"Alice\",\n    balance: 1000.0,\n    id: 123\n}\n\nprintln(account.owner)  // OK - public field\n// println(account.balance)  // Error - private field",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch19-00-structs-oop.md",
          "example_number": 8,
          "line_number": 205,
          "code": "struct Task {\n    id: i32,\n    title: String,\n    completed: bool\n}\n\nlet tasks = [\n    Task { id: 1, title: \"Write docs\", completed: false },\n    Task { id: 2, title: \"Review PR\", completed: true },\n    Task { id: 3, title: \"Fix bug\", completed: false }\n]\n\n// Count completed tasks\nlet mut completed_count = 0\nfor task in tasks {\n    if task.completed {\n        completed_count = completed_count + 1\n    }\n}\nprintln(completed_count)  // 1",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch19-00-structs-oop.md",
          "example_number": 9,
          "line_number": 232,
          "code": "// PLANNED FEATURE - Not yet working\nmatch point {\n    Point { x: 0, y: 0 } => println(\"Origin\"),\n    Point { x: 0, y } => println(\"On Y axis\"),\n    Point { x, y: 0 } => println(\"On X axis\"),\n    Point { x, y } => println(\"General point\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `point` in this scope\n --> /tmp/.tmpO3WXXC/main.rs:1:33\n  |\n1 | fn main () { let result = match point { Point { x : 0 , y : 0 } => println ! (\"Origin\") , Point { x : 0 , y } => println ! (\"On Y axis\") ...\n  |                                 ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmpO3WXXC/main.rs:1:41\n  |\n1 | fn main () { let result = match point { Point { x : 0 , y : 0 } => println ! (\"Origin\") , Point { x : 0 , y } => println ! (\"On Y axis\") ...\n  |                                         ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmpO3WXXC/main.rs:1:91\n  |\n1 | fn main () { let result = match point { Point { x : 0 , y : 0 } => println ! (\"Origin\") , Point { x : 0 , y } => println ! (\"On Y axis\") ...\n  |                                                                                           ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmpO3WXXC/main.rs:1:140\n  |\n1 | ... , Point { x : 0 , y } => println ! (\"On Y axis\") , Point { x , y : 0 } => println ! (\"On X axis\") , Point { x , y } => println ! (\"Ge...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmpO3WXXC/main.rs:1:189\n  |\n1 | ... , Point { x , y : 0 } => println ! (\"On X axis\") , Point { x , y } => println ! (\"General point\") , } ; if std :: any :: type_name_of...\n  |                                                        ^^^^^ not found in this scope\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0422, E0425.\nFor more information about an error, try `rustc --explain E0422`.\n\nError: Compilation failed:\nerror[E0425]: cannot find value `point` in this scope\n --> /tmp/.tmpO3WXXC/main.rs:1:33\n  |\n1 | fn main () { let result = match point { Point { x : 0 , y : 0 } => println ! (\"Origin\") , Point { x : 0 , y } => println ! (\"On Y axis\") ...\n  |                                 ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmpO3WXXC/main.rs:1:41\n  |\n1 | fn main () { let result = match point { Point { x : 0 , y : 0 } => println ! (\"Origin\") , Point { x : 0 , y } => println ! (\"On Y axis\") ...\n  |                                         ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmpO3WXXC/main.rs:1:91\n  |\n1 | fn main () { let result = match point { Point { x : 0 , y : 0 } => println ! (\"Origin\") , Point { x : 0 , y } => println ! (\"On Y axis\") ...\n  |                                                                                           ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmpO3WXXC/main.rs:1:140\n  |\n1 | ... , Point { x : 0 , y } => println ! (\"On Y axis\") , Point { x , y : 0 } => println ! (\"On X axis\") , Point { x , y } => println ! (\"Ge...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmpO3WXXC/main.rs:1:189\n  |\n1 | ... , Point { x , y : 0 } => println ! (\"On X axis\") , Point { x , y } => println ! (\"General point\") , } ; if std :: any :: type_name_of...\n  |                                                        ^^^^^ not found in this scope\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0422, E0425.\nFor more information about an error, try `rustc --explain E0422`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    }
  }
}