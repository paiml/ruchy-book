{
  "timestamp": "2025-08-29T14:40:49.020Z",
  "ruchy_version": "ruchy 1.26.0",
  "chapters_processed": 22,
  "examples_found": 201,
  "examples_working": 104,
  "examples_failing": 97,
  "success_rate": 52,
  "chapters": {
    "ch02-00-variables-types-tdd": {
      "chapter": "ch02-00-variables-types-tdd",
      "total_examples": 8,
      "working_examples": 6,
      "failing_examples": 2,
      "examples": [
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun main() {\n    let x = 42;\n    println(x);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 2,
          "line_number": 51,
          "code": "fun main() {\n    let name = \"Ruchy\";\n    println(name);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 3,
          "line_number": 70,
          "code": "fun main() {\n    let x = 10;\n    let y = 20;\n    let sum = x + y;\n    println(sum);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 4,
          "line_number": 91,
          "code": "fun main() {\n    let pi = 3.14159;\n    let radius = 5.0;\n    let area = pi * radius * radius;\n    println(area);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 5,
          "line_number": 136,
          "code": "fun main() {\n    let outer = 100;\n    // outer is accessible here\n    println(outer);\n}\n// outer is NOT accessible here",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 6,
          "line_number": 163,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nlet result = value1 + value2;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found `let` statement\n --> /tmp/.tmpRRSIIe/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; ; if let Some (s) = (& result as & dyn std :...\n  |                                                               ^^^\n  |\n  = note: only supported directly in conditions of `if` and `while` expressions\n\nerror[E0425]: cannot find value `value1` in this scope\n --> /tmp/.tmpRRSIIe/main.rs:1:76\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; ; if let Some (s) = (& result as & dyn std :...\n  |                                                                            ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `value2` in this scope\n --> /tmp/.tmpRRSIIe/main.rs:1:85\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; ; if let Some (s) = (& result as & dyn std :...\n  |                                                                                     ^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpRRSIIe/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; ; if let Some (s) = (& result as & dyn std :...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpRRSIIe/main.rs:1:94\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let result = value1 + value2 ; ; if let Some (s) = (& result as & dyn std :...\n  |                                                                                              ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 7,
          "line_number": 171,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nlet step1 = initial_value * factor;\nlet step2 = step1 + adjustment;\nlet final_result = step2 / divisor;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `initial_value` in this scope\n --> /tmp/.tmpw0eAz6/main.rs:1:62\n  |\n1 | use std :: collections :: HashMap ; fn main () { let step1 = initial_value * factor ; ; let step2 = step1 + adjustment ; ; let final_resu...\n  |                                                              ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `factor` in this scope\n --> /tmp/.tmpw0eAz6/main.rs:1:78\n  |\n1 | use std :: collections :: HashMap ; fn main () { let step1 = initial_value * factor ; ; let step2 = step1 + adjustment ; ; let final_resu...\n  |                                                                              ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `adjustment` in this scope\n --> /tmp/.tmpw0eAz6/main.rs:1:109\n  |\n1 | ... = initial_value * factor ; ; let step2 = step1 + adjustment ; ; let final_result = step2 / divisor ; ; }\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `divisor` in this scope\n --> /tmp/.tmpw0eAz6/main.rs:1:151\n  |\n1 | ... step1 + adjustment ; ; let final_result = step2 / divisor ; ; }\n  |                                                       ^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpw0eAz6/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let step1 = initial_value * factor ; ; let step2 = step1 + adjustment ; ; let final_resu...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpw0eAz6/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn main () { let step1 = initial_value * factor ; ; let step2 = step1 + adjustment ; ; let final_resu...\n  |                                                                                       ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpw0eAz6/main.rs:1:122\n  |\n1 | ...value * factor ; ; let step2 = step1 + adjustment ; ; let final_result = step2 / divisor ; ; }\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpw0eAz6/main.rs:1:161\n  |\n1 | ...adjustment ; ; let final_result = step2 / divisor ; ; }\n  |                                                        ^ help: remove this semicolon\n\nerror: aborting due to 4 previous errors; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 8,
          "line_number": 181,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nlet PI = 3.14159;\nlet GRAVITY = 9.81;",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch04-00-modules-tdd": {
      "chapter": "ch04-00-modules-tdd",
      "total_examples": 6,
      "working_examples": 2,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "mod math {\n    pub fun add(a: i32, b: i32) -> i32 {\n        a + b\n    }\n}\n\nfun main() {\n    let result = math::add(5, 3);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 2,
          "line_number": 57,
          "code": "mod utils {\n    pub fun greet() {\n        println(\"Hello from module!\");\n    }\n}\n\nfun main() {\n    utils::greet();\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 3,
          "line_number": 97,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nmod module_name {\n    pub fun public_function() {\n        // Accessible from outside\n    }\n    \n    fun private_function() {\n        // Only accessible within module\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found keyword `mod`\n --> /tmp/.tmpOonDno/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...\n  |                                                               ^^^ expected expression\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpOonDno/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 4,
          "line_number": 113,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nfun main() {\n    module_name::public_function();  // Works\n    // module_name::private_function();  // Would fail - not public\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpL22HhU/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpL22HhU/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }\n  |                                                  ^^                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }\n1 + use std :: collections :: HashMap ; fn main () { module_name :: public_function () }\n  |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `module_name`\n --> /tmp/.tmpL22HhU/main.rs:1:52\n  |\n1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }\n  |                                                    ^^^^^^^^^^^ use of unresolved module or unlinked crate `module_name`\n  |\n  = help: you might be missing a crate named `module_name`\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 5,
          "line_number": 140,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nmod math {\n    pub fun add(a: i32, b: i32) -> i32 { a + b }\n    pub fun subtract(a: i32, b: i32) -> i32 { a - b }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found keyword `mod`\n --> /tmp/.tmpBGWtUA/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...\n  |                                                               ^^^ expected expression\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpBGWtUA/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 6,
          "line_number": 152,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nmod strings {\n    pub fun greet() { println(\"Hello!\"); }\n    pub fun farewell() { println(\"Goodbye!\"); }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found keyword `mod`\n --> /tmp/.tmpD2v69Y/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! (\"Hello!\") } } ; pub fn farew...\n  |                                                               ^^^ expected expression\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpD2v69Y/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! (\"Hello!\") } } ; pub fn farew...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch09-00-collections-tdd": {
      "chapter": "ch09-00-collections-tdd",
      "total_examples": 10,
      "working_examples": 4,
      "failing_examples": 6,
      "examples": [
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun main() {\n    println(\"Counting to 5:\");\n    for i in 0..5 {\n        println(i);\n    }\n    println(\"Done counting\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 2,
          "line_number": 60,
          "code": "fun main() {\n    let mut sum = 0;\n    let mut i = 1;\n    while i <= 5 {\n        sum = sum + i;\n        i = i + 1;\n    }\n    println(\"Sum of 1-5:\");\n    println(sum);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 3,
          "line_number": 86,
          "code": "fun main() {\n    println(\"Pattern:\");\n    for row in 0..3 {\n        for col in 0..3 {\n            if (row + col) % 2 == 0 {\n                print(\"*\");\n            } else {\n                print(\" \");\n            }\n        }\n        println(\"\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 4,
          "line_number": 134,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nfor variable in start..end {\n    // Process each value\n    println(variable);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `start` in this scope\n --> /tmp/.tmp3IItyR/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{:?}\" , variable) } } ; if let...\n  |                                                                               ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `end` in this scope\n --> /tmp/.tmp3IItyR/main.rs:1:88\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{:?}\" , variable) } } ; if let...\n  |                                                                                        ^^^ not found in this scope\n  |\nhelp: you might have meant to write `.` instead of `..`\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{:?}\" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start.end { { println ! (\"{:?}\" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp3IItyR/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{:?}\" , variable) } } ; if let...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp3IItyR/main.rs:1:94\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{:?}\" , variable) } } ; if let...\n  |                                                                                              ^^                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{:?}\" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { println ! (\"{:?}\" , variable) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 5,
          "line_number": 145,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nlet mut accumulator = initial_value;\nlet mut counter = start;\nwhile counter <= end {\n    accumulator = update(accumulator, counter);\n    counter = counter + 1;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `initial_value` in this scope\n --> /tmp/.tmpN7lJNA/main.rs:1:72\n  |\n1 | use std :: collections :: HashMap ; fn main () { let mut accumulator = initial_value ; ; let mut counter = start ; ; while counter <= end...\n  |                                                                        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `start` in this scope\n --> /tmp/.tmpN7lJNA/main.rs:1:108\n  |\n1 | ...t accumulator = initial_value ; ; let mut counter = start ; ; while counter <= end { { accumulator = update (accumulator , counter) ; ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `end` in this scope\n --> /tmp/.tmpN7lJNA/main.rs:1:135\n  |\n1 | ...lue ; ; let mut counter = start ; ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 }...\n  |                                                         ^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpN7lJNA/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let mut accumulator = initial_value ; ; let mut counter = start ; ; while counter <= end...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpN7lJNA/main.rs:1:88\n  |\n1 | use std :: collections :: HashMap ; fn main () { let mut accumulator = initial_value ; ; let mut counter = start ; ; while counter <= end...\n  |                                                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpN7lJNA/main.rs:1:116\n  |\n1 | ...lator = initial_value ; ; let mut counter = start ; ; while counter <= end { { accumulator = update (accumulator , counter) ; counter ...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `update` in this scope\n --> /tmp/.tmpN7lJNA/main.rs:1:157\n  |\n1 | ... = start ; ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 } } ; }\n  |                                                        ^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 6,
          "line_number": 158,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nfor outer in 0..height {\n    for inner in 0..width {\n        // Process (outer, inner) coordinate\n        process(outer, inner);\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `height` in this scope\n --> /tmp/.tmpEwQDxn/main.rs:1:84\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...\n  |                                                                                    ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `width` in this scope\n --> /tmp/.tmpEwQDxn/main.rs:1:116\n  |\n1 | ...or outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn s...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpEwQDxn/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEwQDxn/main.rs:1:93\n  |\n1 | ...ult = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as ...\n  |                                        ^^                                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { for inner in 0i32 .. width { { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEwQDxn/main.rs:1:124\n  |\n1 | ...r in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: a...\n  |                                                         ^^                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `process` in this scope\n --> /tmp/.tmpEwQDxn/main.rs:1:126\n  |\n1 | ... 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 7,
          "line_number": 185,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nfor i in 1..10 {\n    let result = process(i);\n    println(result);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpIuptBg/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! (\"{:?}\" ,...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpIuptBg/main.rs:1:88\n  |\n1 | ...t result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! (\"{:?}\" , result) } } } ; if let Some (s) = (& result as ...\n  |                                        ^^                                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! (\"{:?}\" , result) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { let result = process (i) ; println ! (\"{:?}\" , result) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `process` in this scope\n --> /tmp/.tmpIuptBg/main.rs:1:105\n  |\n1 | ...result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! (\"{:?}\" , result) } } } ; if let Some (s) = (& result as & ...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 8,
          "line_number": 196,
          "code": "let mut total = 0;\nfor value in 1..100 {\n    total = total + value;\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 9,
          "line_number": 207,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nfor row in 0..height {\n    for col in 0..width {\n        let value = calculate(row, col);\n        display(value);\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `height` in this scope\n --> /tmp/.tmpi13Npe/main.rs:1:82\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...\n  |                                                                                  ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `width` in this scope\n --> /tmp/.tmpi13Npe/main.rs:1:112\n  |\n1 | ... = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpi13Npe/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpi13Npe/main.rs:1:91\n  |\n1 | ... in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) ...\n  |                         ^^                                                                                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpi13Npe/main.rs:1:120\n  |\n1 | ...eight { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result a...\n  |                                         ^^                                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `calculate` in this scope\n --> /tmp/.tmpi13Npe/main.rs:1:136\n  |\n1 | ...ht { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as &...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `display` in this scope\n --> /tmp/.tmpi13Npe/main.rs:1:160\n  |\n1 | ..... width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any)...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 10,
          "line_number": 220,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nlet mut count = 0;\nfor i in 1..100 {\n    if condition(i) {\n        count = count + 1;\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpjSHmRr/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpjSHmRr/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count ...\n  |                                                                         ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpjSHmRr/main.rs:1:101\n  |\n1 | ...ount = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } ; }\n  |                                              ^^                                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } ; }\n1 + use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { if condition (i) { { count = count + 1i32 } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpjSHmRr/main.rs:1:122\n  |\n1 | ...i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } ; }\n  |                                                           ^^                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } ; }\n1 + use std :: collections :: HashMap ; fn main () { let mut count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { count = count + 1i32 } } } ; }\n  |\n\nerror[E0425]: cannot find function `condition` in this scope\n --> /tmp/.tmpjSHmRr/main.rs:1:106\n  |\n1 | ...t count = 0i32 ; ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } ; }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch21-00-professional-tooling-tdd": {
      "chapter": "ch21-00-professional-tooling-tdd",
      "total_examples": 1,
      "working_examples": 1,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch21-00-professional-tooling-tdd.md",
          "example_number": 1,
          "line_number": 23,
          "code": "// test/tooling/simple_test.ruchy - ✓ VERIFIED WORKING\nfun add(a: i32, b: i32) -> i32 {\n    a + b\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "conclusion": {
      "chapter": "conclusion",
      "total_examples": 2,
      "working_examples": 1,
      "failing_examples": 1,
      "examples": [
        {
          "file": "src/conclusion.md",
          "example_number": 1,
          "line_number": 205,
          "code": "fun calculate(x: i32, y: i32) -> i32 {\n    return x + y;\n}\n\nfun main() {\n    let result = calculate(10, 20);\n    println(result);  // Output: 30\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/conclusion.md",
          "example_number": 2,
          "line_number": 220,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\n// Arrays - NOT YET\nlet arr = [1, 2, 3];\n\n// User Input - NOT YET  \nlet name = input(\"Enter name: \");\n\n// File I/O - NOT YET\nlet contents = fs::read_to_string(\"file.txt\");\n\n// Closures - NOT YET\nlet add_one = |x| x + 1;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n --> /tmp/.tmpIwsYml/main.rs:1:455\n  |\n1 | .... pop () ; } } input } ; ; let contents = fs :: read_to_string (\"file.txt\" . to_string ()) ; ; let add_one = | x | x + 1i32 ; ; }\n  |                                              ^^ use of unresolved module or unlinked crate `fs`\n  |\n  = help: you might be missing a crate named `fs`\nhelp: consider importing this module\n  |\n1 + use std::fs;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpIwsYml/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let arr = vec ! [1i32 , 2i32 , 3i32] ; ; let name = { print ! (\"{}\" , \"Enter name: \") ; ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpIwsYml/main.rs:1:89\n  |\n1 | use std :: collections :: HashMap ; fn main () { let arr = vec ! [1i32 , 2i32 , 3i32] ; ; let name = { print ! (\"{}\" , \"Enter name: \") ; ...\n  |                                                                                         ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpIwsYml/main.rs:1:438\n  |\n1 | .... ends_with ('\\r') { input . pop () ; } } input } ; ; let contents = fs :: read_to_string (\"file.txt\" . to_string ()) ; ; let add_one ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpIwsYml/main.rs:1:506\n  |\n1 | ... fs :: read_to_string (\"file.txt\" . to_string ()) ; ; let add_one = | x | x + 1i32 ; ; }\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpIwsYml/main.rs:1:539\n  |\n1 | ... . to_string ()) ; ; let add_one = | x | x + 1i32 ; ; }\n  |                                                        ^ help: remove this semicolon\n\nerror: aborting due to 1 previous error; 5 warnings emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch10-00-input-output-tdd": {
      "chapter": "ch10-00-input-output-tdd",
      "total_examples": 10,
      "working_examples": 7,
      "failing_examples": 3,
      "examples": [
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun main() {\n    println(\"=== Output Demo ===\");\n    println(\"Number: \");\n    println(42);\n    println(\"Boolean: \");\n    println(true);\n    println(\"=== End Demo ===\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 2,
          "line_number": 60,
          "code": "fun main() {\n    let name = \"Alice\";\n    let age = 30;\n    let height = 5.6;\n    \n    println(\"=== User Profile ===\");\n    println(\"Name:\");\n    println(name);\n    println(\"Age:\");\n    println(age);\n    println(\"Height:\");\n    println(height);\n    println(\"================\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 3,
          "line_number": 96,
          "code": "fun display_menu() {\n    println(\"=== Main Menu ===\");\n    println(\"1. View Profile\");\n    println(\"2. Settings\");\n    println(\"3. Exit\");\n    println(\"=================\");\n}\n\nfun main() {\n    display_menu();\n    println(\"Menu displayed successfully\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 4,
          "line_number": 147,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nprintln(\"text message\");\nprintln(variable);\nprintln(42);\nprintln(true);",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `variable` in this scope\n --> /tmp/.tmputXKTi/main.rs:1:99\n  |\n1 | use std :: collections :: HashMap ; fn main () { println ! (\"text message\") ; println ! (\"{:?}\" , variable) ; println ! (\"{:?}\" , 42i32) ...\n  |                                                                                                   ^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmputXKTi/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { println ! (\"text message\") ; println ! (\"{:?}\" , variable) ; println ! (\"{:?}\" , 42i32) ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 5,
          "line_number": 158,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nlet data = value;\nprintln(\"Label:\");\nprintln(data);",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `value` in this scope\n --> /tmp/.tmpzrwVYe/main.rs:1:61\n  |\n1 | use std :: collections :: HashMap ; fn main () { let data = value ; ; println ! (\"Label:\") ; println ! (\"{:?}\" , data) ; }\n  |                                                             ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpzrwVYe/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let data = value ; ; println ! (\"Label:\") ; println ! (\"{:?}\" , data) ; }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpzrwVYe/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let data = value ; ; println ! (\"Label:\") ; println ! (\"{:?}\" , data) ; }\n  |                                                                     ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 6,
          "line_number": 168,
          "code": "fun display_options() {\n    println(\"=== Menu ===\");\n    println(\"1. Option One\");\n    println(\"2. Option Two\");\n    println(\"============\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 7,
          "line_number": 195,
          "code": "let value = 100;\nprintln(\"Result:\");\nprintln(value);",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 8,
          "line_number": 205,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun display_report(title: &str, data: i32) {\n    println(\"=== Report ===\");\n    println(title);\n    println(data);\n    println(\"==============\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 9,
          "line_number": 218,
          "code": "println(\"Processing...\");\n// ... do work ...\nprintln(\"Complete!\");",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 10,
          "line_number": 228,
          "code": "fun show_options() {\n    println(\"Choose an option:\");\n    println(\"1. Start\");\n    println(\"2. Stop\");\n    println(\"3. Help\");\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch01-03-interpreter-scripting": {
      "chapter": "ch01-03-interpreter-scripting",
      "total_examples": 15,
      "working_examples": 9,
      "failing_examples": 6,
      "examples": [
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 1,
          "line_number": 28,
          "code": "ruchy -e \"2 + 2\"\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `ruchy` in this scope\n --> /tmp/.tmpKzAIqx/main.rs:1:65\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"2 + 2\" } ; if let Some (s) = (& result as & dyn std :: any :...\n  |                                                                 ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `e` in this scope\n --> /tmp/.tmpKzAIqx/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"2 + 2\" } ; if let Some (s) = (& result as & dyn std :: any :...\n  |                                                                         ^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpKzAIqx/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"2 + 2\" } ; if let Some (s) = (& result as & dyn std :: any :...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 2,
          "line_number": 41,
          "code": "ruchy -e \"let name = \\\"World\\\"; \\\"Hello \\\" + name + \\\"!\\\"\"\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `ruchy` in this scope\n --> /tmp/.tmp6jTcrZ/main.rs:1:65\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let name = \\\"World\\\"; \\\"Hello \\\" + name + \\\"!\\\"\" } ; if let ...\n  |                                                                 ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `e` in this scope\n --> /tmp/.tmp6jTcrZ/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let name = \\\"World\\\"; \\\"Hello \\\" + name + \\\"!\\\"\" } ; if let ...\n  |                                                                         ^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp6jTcrZ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let name = \\\"World\\\"; \\\"Hello \\\" + name + \\\"!\\\"\" } ; if let ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 3,
          "line_number": 54,
          "code": "ruchy -e \"let nums = [1, 2, 3]; nums[1]\"\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `ruchy` in this scope\n --> /tmp/.tmpVYihbB/main.rs:1:65\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let nums = [1, 2, 3]; nums[1]\" } ; if let Some (s) = (& resu...\n  |                                                                 ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `e` in this scope\n --> /tmp/.tmpVYihbB/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let nums = [1, 2, 3]; nums[1]\" } ; if let Some (s) = (& resu...\n  |                                                                         ^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpVYihbB/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let nums = [1, 2, 3]; nums[1]\" } ; if let Some (s) = (& resu...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 4,
          "line_number": 85,
          "code": "fun main() {\n    // Integer values\n    let small_int = 42\n    let result = small_int * 2\n\n    // Floating point numbers  \n    let pi = 3.14159\n    let area = pi * 5.0 * 5.0\n\n    // String operations\n    let greeting = \"Hello\"\n    let name = \"Ruchy\"\n\n    // Arrays with indexing\n    let data = [1, 2, 3, 4, 5]\n    println(data[2])\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 5,
          "line_number": 133,
          "code": "// calculator.ruchy - Basic calculator functionality\n\nfun add(a, b) {\n    a + b\n}\n\nfun subtract(a, b) {\n    a - b\n}\n\nfun multiply(a, b) {\n    a * b\n}\n\nfun divide(a, b) {\n    if b == 0 {\n        println(\"Error: Division by zero\")\n        0\n    } else {\n        a / b\n    }\n}\n\nfun main() {\n    // Test our calculator\n    let x = 10\n    let y = 3\n\n    println(\"Addition:\")\n    println(add(x, y))\n    println(\"Subtraction:\")\n    println(subtract(x, y))\n    println(\"Multiplication:\")\n    println(multiply(x, y))\n    println(\"Division:\")\n    println(divide(x, y))\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 6,
          "line_number": 187,
          "code": "// data_processing.ruchy - Array manipulation examples\n\nfun main() {\n    let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    // Access elements\n    println(\"First:\")\n    println(numbers[0])\n    println(\"Last:\")\n    println(numbers[9])\n\n    // Simple iteration (manual)\n    let mut sum = 0\n    let mut i = 0\n    while i < 10 {\n        sum = sum + numbers[i]\n        i = i + 1\n    }\n    println(\"Sum:\")\n    println(sum)\n\n    // Calculate average\n    let average = sum / 10\n    println(\"Average:\")\n    println(average)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 7,
          "line_number": 227,
          "code": "// scoping.ruchy - Variable scope examples\n\nlet global_var = \"I'm global\"\n\nfun demonstrate_scope() {\n    let local_var = \"I'm local\"\n    println(global_var)  // Can access global\n    println(local_var)   // Can access local\n    \n    // Nested function\n    fun nested() {\n        println(global_var)  // Can access global\n        println(local_var)   // Can access parent local\n        let nested_var = \"I'm nested\"\n        println(nested_var)\n    }\n    \n    nested()\n}\n\nfun main() {\n    demonstrate_scope()\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0434]: can't capture dynamic environment in a fn item\n --> /tmp/.tmpUZw7BI/main.rs:1:259\n  |\n1 | ... () { { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; { let nested_var = \"I'm nested\" . to_string () ; println ! ...\n  |                                                                  ^^^^^^^^^\n  |\n  = help: use the `|| { ... }` closure form instead\n\nerror[E0425]: cannot find value `global_var` in this scope\n --> /tmp/.tmpUZw7BI/main.rs:1:141\n  |\n1 | ...ng () ; { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; fn nested () { { println ! (\"{:?}\" , global_var) ; printl...\n  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`\n\nerror[E0425]: cannot find value `global_var` in this scope\n --> /tmp/.tmpUZw7BI/main.rs:1:225\n  |\n1 | ...ed () { { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; { let nested_var = \"I'm nested\" . to_string () ; println ...\n  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpUZw7BI/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = \"I'm local\" . to_string () ; { println ! (\"{:?}\"...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpUZw7BI/main.rs:1:70\n  |\n1 | ... { { { let local_var = \"I'm local\" . to_string () ; { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; fn nested () { { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; { let nested_var = \"I'm nested\" . to_string () ; println ! (\"{:?}\" , nested_var) } } } ; nested () } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = \"I'm local\" . to_string () ; { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; fn nested () { { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; { let nested_var = \"I'm nested\" . to_string () ; println ! (\"{:?}\" , nested_var) } } } ; nested () } } } } fn main () { let global_var = \"I'm global\" . to_string () ; ; { demonstrate_scope () } }\n1 + use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { let local_var = \"I'm local\" . to_string () ; { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; fn nested () { { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; { let nested_var = \"I'm nested\" . to_string () ; println ! (\"{:?}\" , nested_var) } } } ; nested () } } } fn main () { let global_var = \"I'm global\" . to_string () ; ; { demonstrate_scope () } }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpUZw7BI/main.rs:1:359\n  |\n1 | ...o_string () ; println ! (\"{:?}\" , nested_var) } } } ; nested () } } } } fn main () { let global_var = \"I'm global\" . to_string () ; ; ...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpUZw7BI/main.rs:1:439\n  |\n1 | ...() { let global_var = \"I'm global\" . to_string () ; ; { demonstrate_scope () } }\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpUZw7BI/main.rs:1:441\n  |\n1 | ... () { let global_var = \"I'm global\" . to_string () ; ; { demonstrate_scope () } }\n  |                                                           ^^                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = \"I'm local\" . to_string () ; { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; fn nested () { { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; { let nested_var = \"I'm nested\" . to_string () ; println ! (\"{:?}\" , nested_var) } } } ; nested () } } } } fn main () { let global_var = \"I'm global\" . to_string () ; ; { demonstrate_scope () } }\n1 + use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = \"I'm local\" . to_string () ; { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; fn nested () { { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; { let nested_var = \"I'm nested\" . to_string () ; println ! (\"{:?}\" , nested_var) } } } ; nested () } } } } fn main () { let global_var = \"I'm global\" . to_string () ; ; demonstrate_scope () }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpUZw7BI/main.rs:1:361\n  |\n1 | ...-> i32 { { { let local_var = \"I'm local\" . to_string () ; { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; fn nested () { { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; { let nested_var = \"I'm nested\" . to_string () ; println ! (\"{:?}\" , nested_var) } } } ; nested () } ...\n  |       --- expected `i32` because of return type                                                                                                                                                                                                                                                                ^^^^^^^^^ expected `i32`, found `()`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpUZw7BI/main.rs:1:443\n  |\n1 | ... main () { let global_var = \"I'm global\" . to_string () ; ; { demonstrate_scope () } }\n  |            -                                                     ^^^^^^^^^^^^^^^^^^^^- help: consider using a semicolon here: `;`\n  |            |                                                     |\n  |            expected `()` because of default return type          expected `()`, found `i32`\n\nerror: aborting due to 5 previous errors; 5 warnings emitted\n\nSome errors have detailed explanations: E0308, E0425, E0434.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 8,
          "line_number": 266,
          "code": "fun main() {\n    let arr = [1, 2, 3]\n\n    // Unsafe - may cause error if index is out of bounds\n    // println(arr[5])\n\n    // Better approach\n    if 5 < arr.len() {\n        println(arr[5])\n    } else {\n        println(\"Index out of bounds\")\n    }\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpbx9UMo/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpbx9UMo/main.rs:1:50\n  |\n1 | ... { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"Index out of bounds\") } } } } }\n  |       ^^                                                                                                                                                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"Index out of bounds\") } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"Index out of bounds\") } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpbx9UMo/main.rs:1:118\n  |\n1 | ...32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"Index out of bounds\")...\n  |                                                 ^^                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"Index out of bounds\") } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { println ! (\"{:?}\" , arr [5i32 as usize]) } else { { println ! (\"Index out of bounds\") } } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpbx9UMo/main.rs:1:172\n  |\n1 | ...tln ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"Index out of bounds\") } } } } }\n  |                                                    ^^                                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"Index out of bounds\") } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { println ! (\"Index out of bounds\") } } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpbx9UMo/main.rs:1:103\n  |\n1 | ...let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"In...\n  |                                              ----   ^^^^^^^^^^^^ expected `i32`, found `usize`\n  |                                              |\n  |                                              expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len ().try_into().unwrap() { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"Index out of bounds\") } } } } }\n  |                                                                                                                   ++++++++++++++++++++\n\nerror: aborting due to 1 previous error; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 9,
          "line_number": 293,
          "code": "fun main() {\n    let x = 5\n    // x = 10  // Error! x is immutable\n\n    // Use mut for mutable variables\n    let mut y = 5\n    y = 10  // OK\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 10,
          "line_number": 315,
          "code": "fun get_double(x) {\n    x * 2  // This is returned (no semicolon)\n}\n\nfun process_and_print(x) {\n    let doubled = x * 2\n    println(\"Doubled:\")\n    println(doubled)\n    // No explicit return - returns unit type ()\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 11,
          "line_number": 381,
          "code": "// Good: Clear, functional style\nfun calculate_tax(income, rate) {\n    income * rate\n}\n\n// Avoid: Complex nested logic (for now)",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 12,
          "line_number": 398,
          "code": "// Good\nlet user_count = 42\nlet total_price = calculate_price(items)\n\n// Avoid\nlet x = 42\nlet y = calc(z)\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `items` in this scope\n --> /tmp/.tmpgalo48/main.rs:1:112\n  |\n1 | ...ount = 42i32 ; ; let total_price = calculate_price (items) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `z` in this scope\n --> /tmp/.tmpgalo48/main.rs:1:155\n  |\n1 | ...s) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }\n  |                                           ^ help: a local variable with a similar name exists: `x`\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpgalo48/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let user_count = 42i32 ; ; let total_price = calculate_price (items) ; ; let x = 42i32 ;...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpgalo48/main.rs:1:75\n  |\n1 | use std :: collections :: HashMap ; fn main () { let user_count = 42i32 ; ; let total_price = calculate_price (items) ; ; let x = 42i32 ;...\n  |                                                                           ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpgalo48/main.rs:1:121\n  |\n1 | ...i32 ; ; let total_price = calculate_price (items) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpgalo48/main.rs:1:139\n  |\n1 | ...price = calculate_price (items) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpgalo48/main.rs:1:160\n  |\n1 | ...ce (items) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `calculate_price` in this scope\n --> /tmp/.tmpgalo48/main.rs:1:95\n  |\n1 | use std :: collections :: HashMap ; fn main () { let user_count = 42i32 ; ; let total_price = calculate_price (items) ; ; let x = 42i32 ;...\n  |                                                                                               ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `calc` in this scope\n --> /tmp/.tmpgalo48/main.rs:1:149\n  |\n1 | ...alculate_price (items) ; ; let x = 42i32 ; ; let y = calc (z) ; ; }\n  |                                                         ^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 5 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 13,
          "line_number": 418,
          "code": "fun main() {\n    let grades = [95, 87, 92, 78, 89]\n    let first_grade = grades[0]\n    let last_grade = grades[4]\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 14,
          "line_number": 436,
          "code": "// Add functions\nfun double(n) { n * 2 }\n\nfun main() {\n    // Start simple\n    let x = 5\n\n    // Combine\n    let result = double(x)\n    println(result)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 15,
          "line_number": 461,
          "code": "// test_calculator.ruchy\nfun add(a, b) { a + b }\n\nfun main() {\n    // Test cases\n    let test1 = add(2, 3) == 5\n    let test2 = add(0, 0) == 0\n    let test3 = add(-1, 1) == 0\n\n    if test1 && test2 && test3 {\n        println(\"All tests passed!\")\n    } else {\n        println(\"Some tests failed\")\n    }\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch07-00-building-applications": {
      "chapter": "ch07-00-building-applications",
      "total_examples": 9,
      "working_examples": 0,
      "failing_examples": 9,
      "examples": [
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 1,
          "line_number": 48,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: note_keeper.ruchy\n// A complete note-taking application\n\nlet APP_NAME = \"NoteKeeper\"\nlet VERSION = \"1.0.0\"\nlet NOTES_DIR = expand_home(\"~/.notes\")\nlet NOTES_INDEX = join_path(NOTES_DIR, \"index.json\")\n\n// Initialize application\nfun init_app() {\n    if !dir_exists(NOTES_DIR) {\n        create_dir_all(NOTES_DIR)\n        println(\"Created notes directory: \" + NOTES_DIR)\n    }\n    \n    if !file_exists(NOTES_INDEX) {\n        let initial_index = {\n            \"version\": VERSION,\n            \"notes\": [],\n            \"tags\": [],\n            \"last_modified\": current_datetime()\n        }\n        save_index(initial_index)\n    }\n}\n\nfun load_index() {\n    let content = read_file(NOTES_INDEX)\n    return parse_json(content)\n}\n\nfun save_index(index) {\n    index.last_modified = current_datetime()\n    let json = to_json_pretty(index)\n    write_file(NOTES_INDEX, json)\n}\n\nfun create_note() {\n    println(\"\\n📝 Create New Note\")\n    let title = input(\"Title: \")\n    let content = input_multiline(\"Content (end with empty line):\\n\")\n    let tags = input(\"Tags (comma-separated): \").split(\",\").map(|t| t.trim())\n    \n    let note_id = generate_id()\n    let note_file = join_path(NOTES_DIR, note_id + \".md\")\n    \n    let note = {\n        \"id\": note_id,\n        \"title\": title,\n        \"created\": current_datetime(),\n        \"modified\": current_datetime(),\n        \"tags\": tags,\n        \"file\": note_file\n    }\n    \n    // Save note content\n    let markdown = \"# \" + title + \"\\n\\nCreated: \" + note.created + \"\\nTags: \" + tags.join(\", \") + \"\\n\\n---\\n\\n\" + content\n    \n    write_file(note_file, markdown)\n    \n    // Update index\n    let index = load_index()\n    index.notes.push(note)\n    index.tags = index.tags.union(tags)\n    save_index(index)\n    \n    println(\"✅ Note created: \" + title)\n}\n\nfun list_notes(filter_tag = null) {\n    let index = load_index()\n    let notes = index.notes\n    \n    if filter_tag {\n        notes = notes.filter(|n| n.tags.contains(filter_tag))\n        println(f\"\\n📋 Notes tagged '{filter_tag}':\")\n    } else {\n        println(f\"\\n📋 All Notes ({notes.len()} total):\")\n    }\n    \n    if notes.is_empty() {\n        println(\"  No notes found\")\n        return\n    }\n    \n    for i, note in notes.enumerate() {\n        let age = time_ago(note.created)\n        println((i+1).to_s() + \". \" + note.title)\n        println(\"     Tags: \" + note.tags.join(\", \") + \" | Created: \" + age)\n    }\n}\n\nfun search_notes(query) {\n    let index = load_index()\n    let results = []\n    \n    for note in index.notes {\n        // Search in title\n        if note.title.lower().contains(query.lower()) {\n            results.push(note)\n            continue\n        }\n        \n        // Search in content\n        let content = read_file(note.file)\n        if content.lower().contains(query.lower()) {\n            results.push(note)\n        }\n    }\n    \n    println(f\"\\n🔍 Search results for '{query}': {results.len()} matches\")\n    \n    for note in results {\n        println(\"  • \" + note.title)\n        \n        // Show context\n        let content = read_file(note.file)\n        let lines = content.lines()\n        for line in lines {\n            if line.lower().contains(query.lower()) {\n                println(f\"    ...{line.trim()}...\")\n                break\n            }\n        }\n    }\n}\n\nfun view_note(index_num) {\n    let index = load_index()\n    \n    if index_num < 1 || index_num > index.notes.len() {\n        println(\"❌ Invalid note number\")\n        return\n    }\n    \n    let note = index.notes[index_num - 1]\n    let content = read_file(note.file)\n    \n    println(\"\\n\" + \"=\"*50)\n    println(content)\n    println(\"=\"*50)\n}\n\nfun export_notes(format) {\n    let index = load_index()\n    let export_file = \"notes_export_\" + current_date() + \".\" + format\n    \n    match format {\n        \"json\" => {\n            let data = {\n                \"exported\": current_datetime(),\n                \"notes\": []\n            }\n            \n            for note in index.notes {\n                let content = read_file(note.file)\n                data.notes.push({\n                    \"title\": note.title,\n                    \"content\": content,\n                    \"tags\": note.tags,\n                    \"created\": note.created\n                })\n            }\n            \n            write_file(export_file, to_json_pretty(data))\n        }\n        \"markdown\" => {\n            let markdown = f\"# My Notes\nExported: {current_datetime()}\n\n\"\n            for note in index.notes {\n                let content = read_file(note.file)\n                markdown += f\"\n\n---\n\n{content}\n\"\n            }\n            \n            write_file(export_file, markdown)\n        }\n        _ => {\n            println(\"❌ Unsupported format: \" + format)\n            return\n        }\n    }\n    \n    println(\"✅ Exported \" + index.notes.len().to_s() + \" notes to \" + export_file)\n}\n\nfun show_menu() {\n    println(f\"\\n=== {APP_NAME} v{VERSION} ===\")\n    println(\"1. Create note\")\n    println(\"2. List all notes\")\n    println(\"3. Search notes\")\n    println(\"4. View note\")\n    println(\"5. List by tag\")\n    println(\"6. Export notes\")\n    println(\"7. Statistics\")\n    println(\"8. Quit\")\n}\n\nfun show_statistics() {\n    let index = load_index()\n    let total_notes = index.notes.len()\n    let total_tags = index.tags.len()\n    \n    // Calculate word count\n    let total_words = 0\n    for note in index.notes {\n        let content = read_file(note.file)\n        total_words += content.split_whitespace().len()\n    }\n    \n    // Find most used tags\n    let tag_counts = {}\n    for note in index.notes {\n        for tag in note.tags {\n            tag_counts[tag] = tag_counts.get(tag, 0) + 1\n        }\n    }\n    \n    println(f\"\\n📊 NoteKeeper Statistics\")\n    println(\"Total notes: \" + total_notes.to_s())\n    println(\"Total words: \" + total_words.to_s())\n    println(\"Average words per note: \" + (total_words / max(total_notes, 1)).to_s())\n    println(\"Unique tags: \" + total_tags.to_s())\n    \n    if !tag_counts.is_empty() {\n        println(\"\\nTop tags:\")\n        let sorted_tags = tag_counts.items().sort_by(|item| -item.value)\n        for tag, count in sorted_tags[..min(5, sorted_tags.len())] {\n            println(f\"  • {tag}: {count} notes\")\n        }\n    }\n}\n\n// Main application loop\nfun main() {\n    init_app()\n    \n    println(f\"Welcome to {APP_NAME}!\")\n    println(\"Your personal note-taking assistant\")\n    \n    loop {\n        show_menu()\n        let choice = input(\"\\nChoice: \")\n        \n        match choice {\n            \"1\" => create_note()\n            \"2\" => list_notes()\n            \"3\" => {\n                let query = input(\"Search for: \")\n                search_notes(query)\n            }\n            \"4\" => {\n                list_notes()\n                let num = input(\"\\nNote number to view: \").to_i()\n                view_note(num)\n            }\n            \"5\" => {\n                let index = load_index()\n                println(\"\\nAvailable tags:\")\n                for tag in index.tags {\n                    println(\"  • \" + tag)\n                }\n                let tag = input(\"\\nFilter by tag: \")\n                list_notes(tag)\n            }\n            \"6\" => {\n                let format = input(\"Export format (json/markdown): \")\n                export_notes(format)\n            }\n            \"7\" => show_statistics()\n            \"8\" => {\n                println(\"👋 Thanks for using NoteKeeper!\")\n                break\n            }\n            _ => println(\"❌ Invalid choice\")\n        }\n    }\n}\n\n// Run the application\nmain()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 2,
          "line_number": 353,
          "code": "// Application structure\nlet APP = {\n    \"name\": \"MyApp\",\n    \"version\": \"1.0.0\",\n    \"config_dir\": \"~/.config/myapp\",\n    \"data_dir\": \"~/.local/share/myapp\",\n    \"cache_dir\": \"~/.cache/myapp\"\n}\n\n// Separate concerns into modules\n// models.ruchy - Data structures\nlet User = {\n    \"id\": null,\n    \"name\": \"\",\n    \"email\": \"\",\n    \"created\": null\n}\n\n// services.ruchy - Business logic\nfun create_user(name, email) {\n    let user = User.copy()\n    user.id = generate_uuid()\n    user.name = name\n    user.email = email\n    user.created = current_datetime()\n    return user\n}\n\n// ui.ruchy - User interface\nfun display_user(user) {\n    println(f\"User: {user.name} ({user.email})\")\n    println(\"Member since: \" + user.created)\n}\n\n// main.ruchy - Application entry point\nfun main() {\n    init_app()\n    load_config()\n    run_event_loop()\n    cleanup()\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `User` in this scope\n --> /tmp/.tmpyr3xbI/main.rs:1:109\n  |\n1 | ...e : String , email : String) -> i32 { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . ema...\n  |                                                         ^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpyr3xbI/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn create_user (name : String , email : String) -> i32 { { { let user = User . copy () ; { user . id ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpyr3xbI/main.rs:1:94\n  |\n1 | ... { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } ...\n  |       ^^                                                                                                                                                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn create_user (name : String , email : String) -> i32 { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user (user : String) { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Member since: \" , user . created)) } } fn main () { let APP = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"name\" . to_string () , (\"MyApp\") . to_string ()) ; map . insert (\"version\" . to_string () , (\"1.0.0\") . to_string ()) ; map . insert (\"config_dir\" . to_string () , (\"~/.config/myapp\") . to_string ()) ; map . insert (\"data_dir\" . to_string () , (\"~/.local/share/myapp\") . to_string ()) ; map . insert (\"cache_dir\" . to_string () , (\"~/.cache/myapp\") . to_string ()) ; map } ; ; let User = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"id\" . to_string () , (None) . to_string ()) ; map . insert (\"name\" . to_string () , (\"\") . to_string ()) ; map . insert (\"email\" . to_string () , (\"\") . to_string ()) ; map . insert (\"created\" . to_string () , (None) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n1 + use std :: collections :: HashMap ; fn create_user (name : String , email : String) -> i32 { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } fn display_user (user : String) { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Member since: \" , user . created)) } } fn main () { let APP = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"name\" . to_string () , (\"MyApp\") . to_string ()) ; map . insert (\"version\" . to_string () , (\"1.0.0\") . to_string ()) ; map . insert (\"config_dir\" . to_string () , (\"~/.config/myapp\") . to_string ()) ; map . insert (\"data_dir\" . to_string () , (\"~/.local/share/myapp\") . to_string ()) ; map . insert (\"cache_dir\" . to_string () , (\"~/.cache/myapp\") . to_string ()) ; map } ; ; let User = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"id\" . to_string () , (None) . to_string ()) ; map . insert (\"name\" . to_string () , (\"\") . to_string ()) ; map . insert (\"email\" . to_string () , (\"\") . to_string ()) ; map . insert (\"created\" . to_string () , (None) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpyr3xbI/main.rs:1:959\n  |\n1 | ...g () , (\"~/.cache/myapp\") . to_string ()) ; map } ; ; let User = { let mut map : std :: collections :: HashMap < String , String > = s...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpyr3xbI/main.rs:1:1340\n  |\n1 | ...\" . to_string () , (None) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `generate_uuid` in this scope\n --> /tmp/.tmpyr3xbI/main.rs:1:140\n  |\n1 | ...{ { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = curren...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `current_datetime` in this scope\n --> /tmp/.tmpyr3xbI/main.rs:1:220\n  |\n1 | ...name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user (user : String) { { println !...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0609]: no field `name` on type `String`\n --> /tmp/.tmpyr3xbI/main.rs:1:334\n  |\n1 | ...r (user : String) { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Member since:...\n  |                                                              ^^^^ unknown field\n\nerror[E0609]: no field `email` on type `String`\n --> /tmp/.tmpyr3xbI/main.rs:1:348\n  |\n1 | ...g) { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Member since: \" , user . cre...\n  |                                                             ^^^^^ unknown field\n\nerror[E0609]: no field `created` on type `String`\n --> /tmp/.tmpyr3xbI/main.rs:1:422\n  |\n1 | ... (\"{:?}\" , format ! (\"{}{}\" , \"Member since: \" , user . created)) } } fn main () { let APP = { let mut map : std :: collections :: Has...\n  |                                                            ^^^^^^^ unknown field\n\nerror[E0599]: the method `to_string` exists for enum `Option<_>`, but its trait bounds were not satisfied\n   --> /tmp/.tmpyr3xbI/main.rs:1:1127\n    |\n1   | ... . to_string () , (None) . to_string ()) ; map . insert (\"name\" . to_string () , (\"\") . to_string ()) ; map . insert (\"email\" . to_str...\n    |                               ^^^^^^^^^ method cannot be called on `Option<_>` due to unsatisfied trait bounds\n    |\n   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:591:1\n    |\n591 | pub enum Option<T> {\n    | ------------------ doesn't satisfy `Option<_>: ToString` or `Option<_>: std::fmt::Display`\n    |\n    = note: the following trait bounds were not satisfied:\n            `Option<_>: std::fmt::Display`\n            which is required by `Option<_>: ToString`\n\nerror[E0599]: the method `to_string` exists for enum `Option<_>`, but its trait bounds were not satisfied\n   --> /tmp/.tmpyr3xbI/main.rs:1:1316\n    |\n1   | ... . to_string () , (None) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n    |                               ^^^^^^^^^ method cannot be called on `Option<_>` due to unsatisfied trait bounds\n    |\n   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:591:1\n    |\n591 | pub enum Option<T> {\n    | ------------------ doesn't satisfy `Option<_>: ToString` or `Option<_>: std::fmt::Display`\n    |\n    = note: the following trait bounds were not satisfied:\n            `Option<_>: std::fmt::Display`\n            which is required by `Option<_>: ToString`\n\nerror[E0425]: cannot find function `init_app` in this scope\n --> /tmp/.tmpyr3xbI/main.rs:1:1344\n  |\n1 | ...o_string () , (None) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `load_config` in this scope\n --> /tmp/.tmpyr3xbI/main.rs:1:1358\n  |\n1 | ...one) . to_string ()) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `run_event_loop` in this scope\n --> /tmp/.tmpyr3xbI/main.rs:1:1375\n  |\n1 | ...)) ; map } ; ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `cleanup` in this scope\n --> /tmp/.tmpyr3xbI/main.rs:1:1395\n  |\n1 | ...init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 12 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0425, E0599, E0609.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 3,
          "line_number": 410,
          "code": "// Global application state\nlet STATE = {\n    \"users\": [],\n    \"current_user\": null,\n    \"settings\": {},\n    \"cache\": {},\n    \"dirty\": false\n}\n\nfun update_state(key, value) {\n    STATE[key] = value\n    STATE.dirty = true\n    trigger_save()\n}\n\nfun save_state() {\n    if STATE.dirty {\n        let state_file = join_path(APP.data_dir, \"state.json\")\n        write_file(state_file, to_json(STATE))\n        STATE.dirty = false\n    }\n}\n\nfun load_state() {\n    let state_file = join_path(APP.data_dir, \"state.json\")\n    if file_exists(state_file) {\n        STATE = parse_json(read_file(state_file))\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpchvUJx/main.rs:1:96\n  |\n1 | use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dir...\n  |                                                                                                ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpchvUJx/main.rs:1:127\n  |\n1 | ...: String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty {...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpchvUJx/main.rs:1:194\n  |\n1 | ... true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP` in this scope\n --> /tmp/.tmpchvUJx/main.rs:1:242\n  |\n1 | ...{ if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_jso...\n  |                                                         ^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpchvUJx/main.rs:1:326\n  |\n1 | ...to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpchvUJx/main.rs:1:336\n  |\n1 | ...()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_pat...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP` in this scope\n --> /tmp/.tmpchvUJx/main.rs:1:421\n  |\n1 | ...} fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { S...\n  |                                                         ^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpchvUJx/main.rs:1:501\n  |\n1 | ...\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { l...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpchvUJx/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dir...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpchvUJx/main.rs:1:189\n  |\n1 | ... { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } ...\n  |       ^^                                                                                                                                                                              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"users\" . to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (None) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; ; }\n1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"users\" . to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (None) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpchvUJx/main.rs:1:210\n  |\n1 | ... { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } ...\n  |       ^^                                                                                                                                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"users\" . to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (None) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; ; }\n1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"users\" . to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (None) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpchvUJx/main.rs:1:389\n  |\n1 | ... { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } ...\n  |       ^^                                                                                                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"users\" . to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (None) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; ; }\n1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"users\" . to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (None) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpchvUJx/main.rs:1:499\n  |\n1 | ...string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut ...\n  |                                               ^^                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"users\" . to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (None) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; ; }\n1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { STATE = parse_json (read_file (state_file)) } } } } fn main () { let STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"users\" . to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (None) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpchvUJx/main.rs:1:1029\n  |\n1 | ... . to_string () , (false) . to_string ()) ; map } ; ; }\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror[E0425]: cannot find function `trigger_save` in this scope\n --> /tmp/.tmpchvUJx/main.rs:1:150\n  |\n1 | ... [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0605]: non-primitive cast: `String` as `usize`\n --> /tmp/.tmpchvUJx/main.rs:1:103\n  |\n1 | ...ATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = j...\n  |         ^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpchvUJx/main.rs:1:231\n  |\n1 | ...te () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_json` in this scope\n --> /tmp/.tmpchvUJx/main.rs:1:317\n  |\n1 | ...json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let sta...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpchvUJx/main.rs:1:292\n  |\n1 | ...ate.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let...\n  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `state_file`\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpchvUJx/main.rs:1:410\n  |\n1 | ...} } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_fil...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpchvUJx/main.rs:1:472\n  |\n1 | ...P . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpchvUJx/main.rs:1:521\n  |\n1 | ... file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map : std :: co...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `parse_json` in this scope\n --> /tmp/.tmpchvUJx/main.rs:1:509\n  |\n1 | ...ing ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let STATE = { let mut map...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0599]: the method `to_string` exists for struct `Vec<_>`, but its trait bounds were not satisfied\n   --> /tmp/.tmpchvUJx/main.rs:1:742\n    |\n1   | ...to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (None) . to_string ()) ; map . insert (\"sett...\n    |                                ^^^^^^^^^ method cannot be called on `Vec<_>` due to unsatisfied trait bounds\n    |\n   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1\n    |\n414 | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<_>: ToString` or `Vec<_>: std::fmt::Display`\n    |\n    = note: the following trait bounds were not satisfied:\n            `Vec<_>: std::fmt::Display`\n            which is required by `Vec<_>: ToString`\n            `[_]: std::fmt::Display`\n            which is required by `[_]: ToString`\n\nerror[E0599]: the method `to_string` exists for enum `Option<_>`, but its trait bounds were not satisfied\n   --> /tmp/.tmpchvUJx/main.rs:1:813\n    |\n1   | ... . to_string () , (None) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to...\n    |                               ^^^^^^^^^ method cannot be called on `Option<_>` due to unsatisfied trait bounds\n    |\n   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:591:1\n    |\n591 | pub enum Option<T> {\n    | ------------------ doesn't satisfy `Option<_>: ToString` or `Option<_>: std::fmt::Display`\n    |\n    = note: the following trait bounds were not satisfied:\n            `Option<_>: std::fmt::Display`\n            which is required by `Option<_>: ToString`\n\nerror[E0599]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpchvUJx/main.rs:1:878\n  |\n1 | ...ings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to...\n  |                                  ^^^^^^^^^ method cannot be called on `()` due to unsatisfied trait bounds\n  |\n  = note: the following trait bounds were not satisfied:\n          `(): std::fmt::Display`\n          which is required by `(): ToString`\n\nerror[E0599]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpchvUJx/main.rs:1:940\n  |\n1 | ...ache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; ; }\n  |                                  ^^^^^^^^^ method cannot be called on `()` due to unsatisfied trait bounds\n  |\n  = note: the following trait bounds were not satisfied:\n          `(): std::fmt::Display`\n          which is required by `(): ToString`\n\nerror: aborting due to 21 previous errors; 6 warnings emitted\n\nSome errors have detailed explanations: E0425, E0599, E0605.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 4,
          "line_number": 455,
          "code": "fun safe_operation(operation_fn, fallback_value) {\n    try {\n        return operation_fn()\n    } catch error {\n        log_error(error)\n        return fallback_value\n    }\n}\n\nfun with_retry(operation_fn, max_attempts = 3) {\n    for attempt in range(max_attempts) {\n        try {\n            return operation_fn()\n        } catch error {\n            if attempt == max_attempts - 1 {\n                println(\"❌ Failed after \" + max_attempts.to_s() + \" attempts: \" + error.to_s())\n                throw error\n            }\n            \n            let wait_time = 2 ** attempt  // Exponential backoff\n            println(f\"⚠️  Attempt {attempt + 1} failed, retrying in {wait_time}s...\")\n            sleep(wait_time * 1000)\n        }\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 5,
          "line_number": 496,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\n// Simple password manager with encryption\nlet MASTER_KEY = null\nlet PASSWORDS_FILE = \"~/.passwords.enc\"\n\nfun encrypt(text, key) {\n    // Simple XOR encryption (use real encryption in production!)\n    let encrypted = []\n    for i, char in text.chars().enumerate() {\n        let key_char = key[i % key.len()]\n        encrypted.push(char.code() ^ key_char.code())\n    }\n    return base64_encode(encrypted)\n}\n\nfun decrypt(encrypted, key) {\n    let bytes = base64_decode(encrypted)\n    let decrypted = []\n    for i, byte in bytes.enumerate() {\n        let key_char = key[i % key.len()]\n        decrypted.push(char_from_code(byte ^ key_char.code()))\n    }\n    return decrypted.join(\"\")\n}\n\nfun add_password(site, username, password) {\n    let passwords = load_passwords()\n    passwords[site] = {\n        \"username\": username,\n        \"password\": encrypt(password, MASTER_KEY),\n        \"created\": current_datetime()\n    }\n    save_passwords(passwords)\n}\n\nfun get_password(site) {\n    let passwords = load_passwords()\n    if passwords.has_key(site) {\n        let entry = passwords[site]\n        let password = decrypt(entry.password, MASTER_KEY)\n        copy_to_clipboard(password)\n        println(\"✅ Password copied to clipboard!\")\n        \n        // Clear clipboard after 30 seconds\n        spawn_after(30000, || clear_clipboard())\n    } else {\n        println(\"❌ No password found for \" + site)\n    }\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `MASTER_KEY` in this scope\n --> /tmp/.tmpmr1vwH/main.rs:1:1055\n  |\n1 | ...(\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_dat...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `MASTER_KEY` in this scope\n --> /tmp/.tmpmr1vwH/main.rs:1:1412\n  |\n1 | ...e] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipb...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpmr1vwH/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpmr1vwH/main.rs:1:88\n  |\n1 | ... { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } ...\n  |       ^^                                                                                                                                                                                                                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpmr1vwH/main.rs:1:172\n  |\n1 | ...erate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return ...\n  |               ^^                                                                                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpmr1vwH/main.rs:1:382\n  |\n1 | ... { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpmr1vwH/main.rs:1:455\n  |\n1 | ...4_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len (...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpmr1vwH/main.rs:1:498\n  |\n1 | ...te () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; ret...\n  |            ^^                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } ; return decrypted . join (& \"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpmr1vwH/main.rs:1:741\n  |\n1 | ... { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpmr1vwH/main.rs:1:1251\n  |\n1 | ... { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpmr1vwH/main.rs:1:1323\n  |\n1 | ... { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } e...\n  |       ^^                                                                                                                                                                                                                                         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpmr1vwH/main.rs:1:1426\n  |\n1 | ...assword = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; sp...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpmr1vwH/main.rs:1:1569\n  |\n1 | ...lipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let MAS...\n  |                                ^^                                                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpmr1vwH/main.rs:1:1693\n  |\n1 | ...te)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpmr1vwH/main.rs:1:1752\n  |\n1 | ...ASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n  |                                                        ^ help: remove this semicolon\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmpmr1vwH/main.rs:1:196\n  |\n1 | ...merate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return...\n  |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0599]: no method named `code` found for type `char` in the current scope\n --> /tmp/.tmpmr1vwH/main.rs:1:250\n  |\n1 | ... key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn d...\n  |                                                       ^^^^ method not found in `char`\n\nerror[E0425]: cannot find function `base64_encode` in this scope\n --> /tmp/.tmpmr1vwH/main.rs:1:295\n  |\n1 | ... . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 {...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `base64_decode` in this scope\n --> /tmp/.tmpmr1vwH/main.rs:1:398\n  |\n1 | ... : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . e...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `char_from_code` in this scope\n --> /tmp/.tmpmr1vwH/main.rs:1:569\n  |\n1 | ...[i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } }...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `load_passwords` in this scope\n --> /tmp/.tmpmr1vwH/main.rs:1:761\n  |\n1 | ...password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `current_datetime` in this scope\n --> /tmp/.tmpmr1vwH/main.rs:1:1128\n  |\n1 | ...)) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn ge...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `save_passwords` in this scope\n --> /tmp/.tmpmr1vwH/main.rs:1:1175\n  |\n1 | ...(current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let pa...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0605]: non-primitive cast: `String` as `usize`\n --> /tmp/.tmpmr1vwH/main.rs:1:794\n  |\n1 | ...rds [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; ma...\n  |         ^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0425]: cannot find function `load_passwords` in this scope\n --> /tmp/.tmpmr1vwH/main.rs:1:1271\n  |\n1 | ... } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords ()...\n  |       ------------------------------------------------------------------------------ similarly named function `add_password` defined here                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_password`\n\nerror[E0425]: cannot find function `copy_to_clipboard` in this scope\n --> /tmp/.tmpmr1vwH/main.rs:1:1428\n  |\n1 | ...= decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_afte...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `clear_clipboard` in this scope\n --> /tmp/.tmpmr1vwH/main.rs:1:1534\n  |\n1 | ...d to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No passwo...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `spawn_after` in this scope\n --> /tmp/.tmpmr1vwH/main.rs:1:1507\n  |\n1 | ... println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , fo...\n  |                                                      ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpmr1vwH/main.rs:1:1571\n  |\n1 | ... } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let MASTER_KEY = None...\n  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0605]: non-primitive cast: `String` as `usize`\n --> /tmp/.tmpmr1vwH/main.rs:1:1350\n  |\n1 | ...rds [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Passwor...\n  |         ^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0282]: type annotations needed for `Option<_>`\n --> /tmp/.tmpmr1vwH/main.rs:1:1673\n  |\n1 | ...for \" , site)) } } } } } fn main () { let MASTER_KEY = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n  |                                              ^^^^^^^^^^   ---- type must be known at this point\n  |\nhelp: consider giving `MASTER_KEY` an explicit type, where the type for type parameter `T` is specified\n  |\n1 | use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let decrypted = vec ! [] ; ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (& \"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let password = decrypt (entry . password , MASTER_KEY) ; ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let MASTER_KEY: Option<T> = None ; ; let PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     +++++++++++\n\nerror: aborting due to 18 previous errors; 13 warnings emitted\n\nSome errors have detailed explanations: E0277, E0282, E0308, E0425, E0599, E0605.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: code()"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 6,
          "line_number": 556,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\n// Personal finance tracker\nlet TRANSACTIONS_FILE = \"~/.budget/transactions.csv\"\nlet CATEGORIES = [\"Food\", \"Transport\", \"Bills\", \"Entertainment\", \"Other\"]\n\nfun add_transaction(amount, category, description) {\n    let transaction = {\n        \"date\": current_date(),\n        \"amount\": amount,\n        \"category\": category,\n        \"description\": description\n    }\n    \n    append_csv(TRANSACTIONS_FILE, transaction)\n    \n    // Check budget alerts\n    let monthly_spent = get_monthly_total(category)\n    let budget_limit = get_budget_limit(category)\n    \n    if monthly_spent > budget_limit {\n        send_notification(f\"⚠️ Over budget for {category}!\")\n        println(\"Warning: \" + category + \" spending at $\" + monthly_spent.to_s() + \"/$\" + budget_limit.to_s())\n    }\n}\n\nfun generate_report(month) {\n    let transactions = load_transactions(month)\n    let by_category = group_by(transactions, \"category\")\n    \n    println(\"\\n📊 Budget Report for \" + month)\n    println(\"=\"*40)\n    \n    let total = 0\n    for category, items in by_category.items() {\n        let category_total = items.map(|t| t.amount).sum()\n        total += category_total\n        \n        let bar = \"█\" * (category_total / 50).to_i()\n        println(category + \" $\" + category_total.to_s() + \" \" + bar)\n    }\n    \n    println(\"=\"*40)\n    println(\"Total:          $\" + total.to_s())\n    \n    // Save report\n    let report_file = f\"budget_report_{month}.pdf\"\n    generate_pdf(report_file, report_data)\n    println(\"\\n📄 Report saved to \" + report_file)\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `TRANSACTIONS_FILE` in this scope\n --> /tmp/.tmpcJ8I9g/main.rs:1:559\n  |\n1 | ...tion) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; ...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `report_data` in this scope\n --> /tmp/.tmpcJ8I9g/main.rs:1:1998\n  |\n1 | ...{}.pdf\" , month) ; ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpcJ8I9g/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpcJ8I9g/main.rs:1:116\n  |\n1 | ... { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) . to_string ()) ; map . insert (\"category\" . to_string () , (category) . to_string ()) ; map . insert (\"description\" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") , monthly_spent . to_s ()) , \"/$\") , budget_limit . to_s ())) } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) . to_string ()) ; map . insert (\"category\" . to_string () , (category) . to_string ()) ; map . insert (\"description\" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") , monthly_spent . to_s ()) , \"/$\") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\" . to_string ()) ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{:?}\" , \"=\" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") , category_total . to_s ()) , \" \") , bar)) } } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" . to_string () ; ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; ; }\n1 + use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) . to_string ()) ; map . insert (\"category\" . to_string () , (category) . to_string ()) ; map . insert (\"description\" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") , monthly_spent . to_s ()) , \"/$\") , budget_limit . to_s ())) } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\" . to_string ()) ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{:?}\" , \"=\" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") , category_total . to_s ()) , \" \") , bar)) } } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" . to_string () ; ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpcJ8I9g/main.rs:1:645\n  |\n1 | ... let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_lim...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpcJ8I9g/main.rs:1:696\n  |\n1 | ... ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpcJ8I9g/main.rs:1:1078\n  |\n1 | ... { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\" . to_string ()) ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{:?}\" , \"=\" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") , category_total . to_s ()) , \" \") , bar)) } } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) . to_string ()) ; map . insert (\"category\" . to_string () , (category) . to_string ()) ; map . insert (\"description\" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") , monthly_spent . to_s ()) , \"/$\") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\" . to_string ()) ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{:?}\" , \"=\" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") , category_total . to_s ()) , \" \") , bar)) } } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" . to_string () ; ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; ; }\n1 + use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) . to_string ()) ; map . insert (\"category\" . to_string () , (category) . to_string ()) ; map . insert (\"description\" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") , monthly_spent . to_s ()) , \"/$\") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\" . to_string ()) ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{:?}\" , \"=\" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") , category_total . to_s ()) , \" \") , bar)) } } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } fn main () { let TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" . to_string () ; ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpcJ8I9g/main.rs:1:1203\n  |\n1 | ...oup_by (transactions , \"category\" . to_string ()) ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; print...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpcJ8I9g/main.rs:1:1335\n  |\n1 | ...intln ! (\"{:?}\" , \"=\" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone ()...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpcJ8I9g/main.rs:1:1968\n  |\n1 | ..._file = format ! (\"budget_report_{}.pdf\" , month) ; ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpcJ8I9g/main.rs:1:1437\n  |\n1 | ... { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") , category_total . to_s ()) , \" \") , bar)) } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) . to_string ()) ; map . insert (\"category\" . to_string () , (category) . to_string ()) ; map . insert (\"description\" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") , monthly_spent . to_s ()) , \"/$\") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\" . to_string ()) ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{:?}\" , \"=\" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") , category_total . to_s ()) , \" \") , bar)) } } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" . to_string () ; ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; ; }\n1 + use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) . to_string ()) ; map . insert (\"category\" . to_string () , (category) . to_string ()) ; map . insert (\"description\" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") , monthly_spent . to_s ()) , \"/$\") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (month) ; { let by_category = group_by (transactions , \"category\" . to_string ()) ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{:?}\" , \"=\" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") , category_total . to_s ()) , \" \") , bar)) } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" . to_string () ; ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpcJ8I9g/main.rs:1:1622\n  |\n1 | ... let bar = \"█\" * category_total / 50i32 . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , for...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpcJ8I9g/main.rs:1:2182\n  |\n1 | ...ILE = \"~/.budget/transactions.csv\" . to_string () ; ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Othe...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpcJ8I9g/main.rs:1:2270\n  |\n1 | ...Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; ; }\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `current_date` in this scope\n --> /tmp/.tmpcJ8I9g/main.rs:1:287\n  |\n1 | ... new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) ....\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `append_csv` in this scope\n --> /tmp/.tmpcJ8I9g/main.rs:1:547\n  |\n1 | ...ng () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `get_monthly_total` in this scope\n --> /tmp/.tmpcJ8I9g/main.rs:1:614\n  |\n1 | ...ONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if m...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `get_budget_limit` in this scope\n --> /tmp/.tmpcJ8I9g/main.rs:1:666\n  |\n1 | ...onthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `send_notification` in this scope\n --> /tmp/.tmpcJ8I9g/main.rs:1:734\n  |\n1 | ...gory) ; ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `load_transactions` in this scope\n --> /tmp/.tmpcJ8I9g/main.rs:1:1101\n  |\n1 | ... ; fn add_transaction (amount : String , category : i32 , description : String) { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) . to_string ()) ; map . insert (\"category\" . to_string () , (category) . to_string ()) ; map . insert (\"description\" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let monthly_spent = get_monthly_total (category) ; ; let budget_limit = get_budget_limit (category) ; ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") , monthly_spent . to_s ()) , \"/$\") , budget_limit . to_s ())) } } } } } } fn generate_report (month : i32) { { { let transactions = load_transactions (m...\n  |       ---------------------------------------------------------------------------- similarly named function `add_transaction` defined here                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^^^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_transaction`\n\nerror[E0425]: cannot find function `group_by` in this scope\n --> /tmp/.tmpcJ8I9g/main.rs:1:1149\n  |\n1 | ... = load_transactions (month) ; { let by_category = group_by (transactions , \"category\" . to_string ()) ; ; println ! (\"{:?}\" , format ...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot multiply `&str` by `i32`\n --> /tmp/.tmpcJ8I9g/main.rs:1:1305\n  |\n1 | ..., \"\\n📊 Budget Report for \" , month)) ; println ! (\"{:?}\" , \"=\" * 40i32) ; let total = 0i32 ; ; for (category , items) in by_category . ...\n  |                                                                --- ^ ----- i32\n  |                                                                |\n  |                                                                &str\n\nerror[E0599]: no method named `to_i` found for type `i32` in the current scope\n --> /tmp/.tmpcJ8I9g/main.rs:1:1612\n  |\n1 | ...ry_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpcJ8I9g/main.rs:1:1575\n  |\n1 | ... . sum () ; { total += category_total ; let bar = \"█\" * category_total / 50i32 . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , fo...\n  |                                                ^^^ doesn't have a size known at compile-time\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: all local variables must have a statically known size\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpcJ8I9g/main.rs:1:1774\n  |\n1 | ... (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") , category_total . to_s ()) , \" \") , bar)) } } } ...\n  |         -- required by this formatting parameter                                                                             ^^^ doesn't have a size known at compile-time\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0369]: cannot multiply `&str` by `i32`\n --> /tmp/.tmpcJ8I9g/main.rs:1:1814\n  |\n1 | ...al . to_s ()) , \" \") , bar)) } } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total:          $\" ,...\n  |                                                               --- ^ ----- i32\n  |                                                               |\n  |                                                               &str\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpcJ8I9g/main.rs:1:1894\n  |\n1 | ... , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let report_file = format ! (\"budget_report_{}.pdf\" , month) ; ; genera...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0425]: cannot find function `generate_pdf` in this scope\n --> /tmp/.tmpcJ8I9g/main.rs:1:1970\n  |\n1 | ... = format ! (\"budget_report_{}.pdf\" , month) ; ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nwarning: unused variable: `TRANSACTIONS_FILE`\n --> /tmp/.tmpcJ8I9g/main.rs:1:2116\n  |\n1 | ... fn main () { let TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" . to_string () ; ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"...\n  |                      ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_TRANSACTIONS_FILE`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `CATEGORIES`\n --> /tmp/.tmpcJ8I9g/main.rs:1:2188\n  |\n1 | ...\" . to_string () ; ; let CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; ; }\n  |                             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_CATEGORIES`\n\nerror: aborting due to 16 previous errors; 14 warnings emitted\n\nSome errors have detailed explanations: E0277, E0369, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_i()"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 7,
          "line_number": 616,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Development project scaffolding tool\nlet TEMPLATES = {\n    \"python\": {\n        \"files\": [\"main.py\", \"requirements.txt\", \"README.md\", \".gitignore\"],\n        \"folders\": [\"src\", \"tests\", \"docs\"]\n    },\n    \"javascript\": {\n        \"files\": [\"index.js\", \"package.json\", \"README.md\", \".gitignore\"],\n        \"folders\": [\"src\", \"test\", \"public\"]\n    },\n    \"ruchy\": {\n        \"files\": [\"main.ruchy\", \"Cargo.toml\", \"README.md\", \".gitignore\"],\n        \"folders\": [\"src\", \"tests\", \"docs\"]\n    }\n}\n\nfun create_project(name, language) {\n    let project_dir = name\n    \n    if dir_exists(project_dir) {\n        println(f\"❌ Directory {project_dir} already exists\")\n        return\n    }\n    \n    create_dir(project_dir)\n    println(\"📁 Created project: \" + name)\n    \n    let template = TEMPLATES[language]\n    \n    // Create folder structure\n    for folder in template.folders {\n        create_dir(join_path(project_dir, folder))\n        println(f\"  📂 {folder}/\")\n    }\n    \n    // Create files from templates\n    for file in template.files {\n        let template_content = get_template_content(language, file)\n        let content = template_content\n            .replace(\"{{PROJECT_NAME}}\", name)\n            .replace(\"{{DATE}}\", current_date())\n            .replace(\"{{AUTHOR}}\", get_git_user())\n        \n        write_file(join_path(project_dir, file), content)\n        println(\"  📄 \" + file)\n    }\n    \n    // Initialize git\n    run_command(\"git init\", project_dir)\n    run_command(\"git add .\", project_dir)\n    run_command('git commit -m \"Initial commit\"', project_dir)\n    \n    println(f\"\\n✅ Project {name} created successfully!\")\n    println(f\"Next steps:\")\n    println(\"  cd \" + project_dir)\n    println(\"  \" + get_run_command(language))\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 8,
          "line_number": 687,
          "code": "// test_app.ruchy - Application test suite\n\nfun test_user_creation() {\n    let user = create_user(\"Alice\", \"alice@example.com\")\n    \n    assert(user.name == \"Alice\", \"Name should be set\")\n    assert(user.email == \"alice@example.com\", \"Email should be set\")\n    assert(user.id != null, \"ID should be generated\")\n    \n    println(\"✅ test_user_creation passed\")\n}\n\nfun test_data_persistence() {\n    let test_data = {\"test\": \"value\"}\n    let test_file = \"test_data.json\"\n    \n    // Save data\n    save_json(test_file, test_data)\n    assert(file_exists(test_file), \"File should be created\")\n    \n    // Load data\n    let loaded = load_json(test_file)\n    assert(loaded.test == \"value\", \"Data should persist\")\n    \n    // Cleanup\n    remove_file(test_file)\n    \n    println(\"✅ test_data_persistence passed\")\n}\n\nfun run_all_tests() {\n    println(\"🧪 Running application tests...\")\n    \n    test_user_creation()\n    test_data_persistence()\n    test_error_handling()\n    test_performance()\n    \n    println(\"\\n✅ All tests passed!\")\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `remove_file` in this scope\n --> /tmp/.tmpLEdVl4/main.rs:1:921\n  |\n1 | ...est == \"value\" , \"{}\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_file;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpLEdVl4/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" ....\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpLEdVl4/main.rs:1:64\n  |\n1 | ... { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert ! (user . name == \"Alice\" , \"{}\" , \"Name should be set\") ; assert ! (user . email == \"alice@example.com\" , \"{}\" , \"Email should be set\") ; assert ! (user . id != None , \"{}\" , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } f...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                            ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert ! (user . name == \"Alice\" , \"{}\" , \"Name should be set\") ; assert ! (user . email == \"alice@example.com\" , \"{}\" , \"Email should be set\") ; assert ! (user . id != None , \"{}\" , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } fn test_data_persistence () { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"test\" . to_string () , (\"value\") . to_string ()) ; map } ; { let test_file = \"test_data.json\" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , \"{}\" , \"File should be created\") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == \"value\" , \"{}\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test_user_creation () { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert ! (user . name == \"Alice\" , \"{}\" , \"Name should be set\") ; assert ! (user . email == \"alice@example.com\" , \"{}\" , \"Email should be set\") ; assert ! (user . id != None , \"{}\" , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } fn test_data_persistence () { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"test\" . to_string () , (\"value\") . to_string ()) ; map } ; { let test_file = \"test_data.json\" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , \"{}\" , \"File should be created\") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == \"value\" , \"{}\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpLEdVl4/main.rs:1:448\n  |\n1 | ... { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"test\" . to_string () , (\"value\") . to_string ()) ; map } ; { let test_file = \"test_data.json\" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , \"{}\" , \"File should be created\") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == \"value\" , \"{}\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } f...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert ! (user . name == \"Alice\" , \"{}\" , \"Name should be set\") ; assert ! (user . email == \"alice@example.com\" , \"{}\" , \"Email should be set\") ; assert ! (user . id != None , \"{}\" , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } fn test_data_persistence () { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"test\" . to_string () , (\"value\") . to_string ()) ; map } ; { let test_file = \"test_data.json\" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , \"{}\" , \"File should be created\") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == \"value\" , \"{}\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert ! (user . name == \"Alice\" , \"{}\" , \"Name should be set\") ; assert ! (user . email == \"alice@example.com\" , \"{}\" , \"Email should be set\") ; assert ! (user . id != None , \"{}\" , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } fn test_data_persistence () { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"test\" . to_string () , (\"value\") . to_string ()) ; map } ; { let test_file = \"test_data.json\" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , \"{}\" , \"File should be created\") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == \"value\" , \"{}\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpLEdVl4/main.rs:1:704\n  |\n1 | ...{ let test_file = \"test_data.json\" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , \"{}\" , \"...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpLEdVl4/main.rs:1:850\n  |\n1 | ...be created\") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == \"value\" , \"{}\" , \"Data should persist\") ; remove_file...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `create_user` in this scope\n --> /tmp/.tmpLEdVl4/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" ....\n  |                                                                               ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `save_json` in this scope\n --> /tmp/.tmpLEdVl4/main.rs:1:706\n  |\n1 | ...t test_file = \"test_data.json\" . to_string () ; ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , \"{}\" , \"File...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpLEdVl4/main.rs:1:752\n  |\n1 | ... ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , \"{}\" , \"File should be created\") ; let loaded = load_json (...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `load_json` in this scope\n --> /tmp/.tmpLEdVl4/main.rs:1:826\n  |\n1 | ..., \"{}\" , \"File should be created\") ; let loaded = load_json (test_file) ; ; assert ! (loaded . test == \"value\" , \"{}\" , \"Data should p...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `test_error_handling` in this scope\n --> /tmp/.tmpLEdVl4/main.rs:1:1122\n  |\n1 | ...ser_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn ...\n  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `test_performance` in this scope\n --> /tmp/.tmpLEdVl4/main.rs:1:1147\n  |\n1 | ...data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 7 previous errors; 5 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 9,
          "line_number": 743,
          "code": "// build.ruchy - Build and package script\n\nfun build_release() {\n    println(\"🔨 Building release version...\")\n    \n    // Run tests first\n    run_tests()\n    \n    // Create release directory\n    let release_dir = \"release_\" + VERSION\n    create_dir_all(release_dir)\n    \n    // Copy application files\n    copy_file(\"main.ruchy\", join_path(release_dir, APP_NAME))\n    copy_dir(\"resources\", join_path(release_dir, \"resources\"))\n    \n    // Generate documentation\n    generate_docs(join_path(release_dir, \"docs\"))\n    \n    // Create installer script\n    let installer = f\"#!/bin/bash\necho 'Installing {APP_NAME} v{VERSION}'\nmkdir -p ~/.local/bin\ncp {APP_NAME} ~/.local/bin/\nchmod +x ~/.local/bin/{APP_NAME}\necho 'Installation complete! Run {APP_NAME} to start.'\n\"\n    write_file(join_path(release_dir, \"install.sh\"), installer)\n    \n    // Package as archive\n    create_archive(f\"{APP_NAME}-{VERSION}.tar.gz\", release_dir)\n    \n    println(f\"✅ Release built: {APP_NAME}-{VERSION}.tar.gz\")\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `VERSION` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:174\n  |\n1 | ... let release_dir = format ! (\"{}{}\" , \"release_\" , VERSION) ; { create_dir_all (release_dir) ; copy_file (\"main.ruchy\" . to_string () ...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `create_dir_all` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:187\n  |\n1 | ... = format ! (\"{}{}\" , \"release_\" , VERSION) ; { create_dir_all (release_dir) ; copy_file (\"main.ruchy\" . to_string () , join_path (rel...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::create_dir_all;\n  |\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:284\n  |\n1 | ...n.ruchy\" . to_string () , join_path (release_dir , APP_NAME)) ; copy_dir (\"resources\" . to_string () , join_path (release_dir , \"resou...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:646\n  |\n1 | ...cho 'Installation complete! Run {} to start.'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (rel...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `VERSION` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:657\n  |\n1 | ...lation complete! Run {} to start.'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , ...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:667\n  |\n1 | ...plete! Run {} to start.'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , \"install.s...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:678\n  |\n1 | ...{} to start.'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , \"install.sh\" . to_str...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:689\n  |\n1 | ....'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , \"install.sh\" . to_string ()) , i...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:827\n  |\n1 | ...ller) ; create_archive (format ! (\"{}-{}.tar.gz\" , APP_NAME , VERSION) , release_dir) ; println ! (\"✅ Release built: {}-{}.tar.gz\" , AP...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `VERSION` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:838\n  |\n1 | ...ate_archive (format ! (\"{}-{}.tar.gz\" , APP_NAME , VERSION) , release_dir) ; println ! (\"✅ Release built: {}-{}.tar.gz\" , APP_NAME , VE...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:909\n  |\n1 | ...ir) ; println ! (\"✅ Release built: {}-{}.tar.gz\" , APP_NAME , VERSION) } } } } fn main () { }\n  |                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `VERSION` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:920\n  |\n1 | ...ln ! (\"✅ Release built: {}-{}.tar.gz\" , APP_NAME , VERSION) } } } } fn main () { }\n  |                                                        ^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpQn7b2a/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn build_release () { { println ! (\"🔨 Building release version...\") ; run_tests () ; { let release_dir...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpQn7b2a/main.rs:1:701\n  |\n1 | ..._NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , \"install.sh\" . to_string ()) , installer) ;...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror[E0425]: cannot find function `run_tests` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:107\n  |\n1 | ...{ { println ! (\"🔨 Building release version...\") ; run_tests () ; { let release_dir = format ! (\"{}{}\" , \"release_\" , VERSION) ; { creat...\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:259\n  |\n1 | ...e_dir) ; copy_file (\"main.ruchy\" . to_string () , join_path (release_dir , APP_NAME)) ; copy_dir (\"resources\" . to_string () , join_pa...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `copy_file` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:218\n  |\n1 | ...e_\" , VERSION) ; { create_dir_all (release_dir) ; copy_file (\"main.ruchy\" . to_string () , join_path (release_dir , APP_NAME)) ; copy_...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:336\n  |\n1 | ...P_NAME)) ; copy_dir (\"resources\" . to_string () , join_path (release_dir , \"resources\" . to_string ())) ; generate_docs (join_path (re...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `copy_dir` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:297\n  |\n1 | ..._string () , join_path (release_dir , APP_NAME)) ; copy_dir (\"resources\" . to_string () , join_path (release_dir , \"resources\" . to_st...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:407\n  |\n1 | ...r , \"resources\" . to_string ())) ; generate_docs (join_path (release_dir , \"docs\" . to_string ())) ; let installer = format ! (\"#!/bin...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `generate_docs` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:392\n  |\n1 | ...h (release_dir , \"resources\" . to_string ())) ; generate_docs (join_path (release_dir , \"docs\" . to_string ())) ; let installer = form...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:715\n  |\n1 | ..., APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , \"install.sh\" . to_string ()) , installer) ; create_archive ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:703\n  |\n1 | ...E , VERSION , APP_NAME , APP_NAME , APP_NAME) ; ; write_file (join_path (release_dir , \"install.sh\" . to_string ()) , installer) ; cre...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `create_archive` in this scope\n --> /tmp/.tmpQn7b2a/main.rs:1:784\n  |\n1 | ...r , \"install.sh\" . to_string ()) , installer) ; create_archive (format ! (\"{}-{}.tar.gz\" , APP_NAME , VERSION) , release_dir) ; printl...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 22 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch15-00-macros-metaprogramming": {
      "chapter": "ch15-00-macros-metaprogramming",
      "total_examples": 2,
      "working_examples": 1,
      "failing_examples": 1,
      "examples": [
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 1,
          "line_number": 50,
          "code": "// Instead of a macro, use a function\nfun create_user(name: String, age: i32) -> String {\n    \"User: \" + name + \", Age: \" + age.to_string()\n}\n\n// Works today!\nlet user = create_user(\"Alice\", 30)\nprintln(user)",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 2,
          "line_number": 63,
          "code": "// Instead of #[derive(Debug)], implement manually\nstruct User {\n    name: String,\n    age: i32\n}\n\nfun debug_user(user: User) -> String {\n    \"User { name: \" + user.name + \", age: \" + user.age.to_string() + \" }\"\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `User` in this scope\n --> /tmp/.tmpJmurY6/main.rs:1:59\n  |\n1 | use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , fo...\n  |                                                           ^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpJmurY6/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , fo...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpJmurY6/main.rs:1:77\n  |\n1 | ... { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"User { name: \" , user . name) , \", age: \") , user . age . to_string ()) , \" }\") } } ...\n  |       ^^                                                                                                                                                            ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"User { name: \" , user . name) , \", age: \") , user . age . to_string ()) , \" }\") } } fn main () { struct User { name : String , age : i32 , } ; }\n1 + use std :: collections :: HashMap ; fn debug_user (user : User) -> String { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"User { name: \" , user . name) , \", age: \") , user . age . to_string ()) , \" }\") } fn main () { struct User { name : String , age : i32 , } ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpJmurY6/main.rs:1:297\n  |\n1 | ...in () { struct User { name : String , age : i32 , } ; }\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror: aborting due to 1 previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch07-00-error-handling-tdd": {
      "chapter": "ch07-00-error-handling-tdd",
      "total_examples": 9,
      "working_examples": 3,
      "failing_examples": 6,
      "examples": [
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun main() {\n    println(\"Before operation\");\n    if true {\n        println(\"Operation successful\");\n    }\n    println(\"After operation\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 2,
          "line_number": 56,
          "code": "fun main() {\n    let number = 5;\n    if number > 0 {\n        println(\"Valid number\");\n    } else {\n        println(\"Invalid number\");\n    }\n    \n    let zero = 0;\n    if zero == 0 {\n        println(\"Warning: Zero value detected\");\n    } else {\n        println(\"Non-zero value\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 3,
          "line_number": 87,
          "code": "fun main() {\n    let age = 25;\n    match age {\n        0 => println(\"Error: Age cannot be zero\"),\n        1..=17 => println(\"Minor\"),\n        18..=65 => println(\"Adult\"),\n        _ => println(\"Senior\")\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 4,
          "line_number": 130,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nif value > 0 {\n    println(\"Valid\");\n} else {\n    println(\"Invalid\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `value` in this scope\n --> /tmp/.tmp3KNQZ6/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") ...\n  |                                                                  ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp3KNQZ6/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp3KNQZ6/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") ...\n  |                                                                                 ^^                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { println ! (\"Valid\") } else { { println ! (\"Invalid\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp3KNQZ6/main.rs:1:114\n  |\n1 | ... = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") } } ; if let Some (s) = (& result as & dyn std :: any ::...\n  |                                                          ^^                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { println ! (\"Invalid\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror: aborting due to 1 previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 5,
          "line_number": 142,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nmatch status {\n    0 => println(\"Error\"),\n    1 => println(\"Warning\"),\n    2 => println(\"Success\"),\n    _ => println(\"Unknown\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `status` in this scope\n --> /tmp/.tmpl7ROlO/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! (\"Error\") , 1i32 => println ! (\"Warning\") ...\n  |                                                                     ^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpl7ROlO/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! (\"Error\") , 1i32 => println ! (\"Warning\") ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 6,
          "line_number": 155,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nmatch age {\n    0 => println(\"Invalid age\"),\n    1..=17 => println(\"Minor\"),\n    18..=65 => println(\"Adult\"),\n    _ => println(\"Senior\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `age` in this scope\n --> /tmp/.tmpllgxQM/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! (\"Invalid age\") , 1i32 ..= 17i32 => println !...\n  |                                                                     ^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpllgxQM/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! (\"Invalid age\") , 1i32 ..= 17i32 => println !...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 7,
          "line_number": 182,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nif input < 0 {\n    println(\"Error: Negative input not allowed\");\n} else {\n    process_input(input);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `input` in this scope\n --> /tmp/.tmpvQiePi/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } els...\n  |                                                                  ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `input` in this scope\n --> /tmp/.tmpvQiePi/main.rs:1:159\n  |\n1 | ...ive input not allowed\") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_re...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpvQiePi/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } els...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpvQiePi/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } els...\n  |                                                                                 ^^                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { println ! (\"Error: Negative input not allowed\") } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpvQiePi/main.rs:1:142\n  |\n1 | ...ln ! (\"Error: Negative input not allowed\") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any ::...\n  |                                                          ^^                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } else { process_input (input) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `process_input` in this scope\n --> /tmp/.tmpvQiePi/main.rs:1:144\n  |\n1 | ...rror: Negative input not allowed\") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 8,
          "line_number": 194,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nmatch score {\n    0..=59 => println(\"Fail\"),\n    60..=79 => println(\"Pass\"),\n    80..=100 => println(\"Excellent\"),\n    _ => println(\"Invalid score\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `score` in this scope\n --> /tmp/.tmpJS97Jk/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! (\"Fail\") , 60i32 ..= 79i32 => pri...\n  |                                                                     ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpJS97Jk/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! (\"Fail\") , 60i32 ..= 79i32 => pri...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 9,
          "line_number": 207,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nif system_ready {\n    println(\"System operational\");\n} else {\n    println(\"System not ready\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `system_ready` in this scope\n --> /tmp/.tmpBtmbvp/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { { println !...\n  |                                                                  ^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpBtmbvp/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { { println !...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpBtmbvp/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { { println !...\n  |                                                                                 ^^                                ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { { println ! (\"System not ready\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { println ! (\"System operational\") } else { { println ! (\"System not ready\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpBtmbvp/main.rs:1:127\n  |\n1 | ...y { { println ! (\"System operational\") } } else { { println ! (\"System not ready\") } } ; if let Some (s) = (& result as & dyn std :: a...\n  |                                                      ^^                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { { println ! (\"System not ready\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { println ! (\"System not ready\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror: aborting due to 1 previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch08-00-advanced-functions-tdd": {
      "chapter": "ch08-00-advanced-functions-tdd",
      "total_examples": 9,
      "working_examples": 5,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun double(x: i32) -> i32 {\n    return x * 2;\n}\n\nfun add_ten(x: i32) -> i32 {\n    return x + 10;\n}\n\nfun main() {\n    let x = 5;\n    let doubled = double(x);\n    let result = add_ten(doubled);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 2,
          "line_number": 61,
          "code": "fun classify_number(x: i32) -> i32 {\n    if x < 0 {\n        return -1;\n    }\n    if x == 0 {\n        return 0;\n    }\n    return 1;\n}\n\nfun main() {\n    println(classify_number(-5));\n    println(classify_number(0));\n    println(classify_number(10));\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 3,
          "line_number": 93,
          "code": "fun factorial(n: i32) -> i32 {\n    if n <= 1 {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nfun main() {\n    println(factorial(1));\n    println(factorial(3));\n    println(factorial(5));\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 4,
          "line_number": 141,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun step_one(x: Type) -> Type { ... }\nfun step_two(x: Type) -> Type { ... }\n\n// Usage\nlet intermediate = step_one(input);\nlet result = step_two(intermediate);",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 5,
          "line_number": 154,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nfun categorize(input: Type) -> ResultType {\n    if condition1 {\n        return result1;\n    }\n    if condition2 {\n        return result2;\n    }\n    return default_result;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `Type` in this scope\n --> /tmp/.tmpTHTbsD/main.rs:1:60\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |                                                            ^^^^ not found in this scope\n\nerror[E0412]: cannot find type `ResultType` in this scope\n --> /tmp/.tmpTHTbsD/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |                                                                     ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `condition1` in this scope\n --> /tmp/.tmpTHTbsD/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |                                                                                       ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `result1` in this scope\n --> /tmp/.tmpTHTbsD/main.rs:1:109\n  |\n1 | ...: Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn m...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `condition2` in this scope\n --> /tmp/.tmpTHTbsD/main.rs:1:126\n  |\n1 | ...ype { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `result2` in this scope\n --> /tmp/.tmpTHTbsD/main.rs:1:148\n  |\n1 | ... { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `default_result` in this scope\n --> /tmp/.tmpTHTbsD/main.rs:1:169\n  |\n1 | ...; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpTHTbsD/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTHTbsD/main.rs:1:100\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |                                                                                                    ^^              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { return result1 } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTHTbsD/main.rs:1:139\n  |\n1 | ... { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |                                                              ^^              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { return result2 } ; return default_result } } fn main () { }\n  |\n\nerror: aborting due to 7 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 6,
          "line_number": 170,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nfun recursive_func(n: Type) -> Type {\n    if base_condition {\n        return base_value;\n    }\n    return combine(n, recursive_func(reduce(n)));\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `Type` in this scope\n --> /tmp/.tmpODki6e/main.rs:1:60\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |                                                            ^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Type` in this scope\n --> /tmp/.tmpODki6e/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |                                                                     ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `base_condition` in this scope\n --> /tmp/.tmpODki6e/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |                                                                                 ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `base_value` in this scope\n --> /tmp/.tmpODki6e/main.rs:1:107\n  |\n1 | ... : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpODki6e/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpODki6e/main.rs:1:98\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |                                                                                                  ^^                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { return base_value } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n  |\n\nerror[E0425]: cannot find function `reduce` in this scope\n --> /tmp/.tmpODki6e/main.rs:1:160\n  |\n1 | ...ase_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `combine` in this scope\n --> /tmp/.tmpODki6e/main.rs:1:131\n  |\n1 | ... base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 7,
          "line_number": 197,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun validate(input: i32) -> i32 { ... }\nfun normalize(input: i32) -> i32 { ... }\nfun process(input: i32) -> i32 { ... }\n\n// Usage\nlet clean_input = validate(raw_input);\nlet normal_input = normalize(clean_input);\nlet result = process(normal_input);",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 8,
          "line_number": 212,
          "code": "fun get_grade(score: i32) -> i32 {\n    if score >= 90 {\n        return 4; // A\n    }\n    if score >= 80 {\n        return 3; // B\n    }\n    if score >= 70 {\n        return 2; // C\n    }\n    return 1; // D/F\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 9,
          "line_number": 231,
          "code": "fun countdown(n: i32) -> i32 {\n    if n <= 0 {\n        return 0;\n    }\n    println(n);\n    return countdown(n - 1);\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch04-00-command-line-tools": {
      "chapter": "ch04-00-command-line-tools",
      "total_examples": 14,
      "working_examples": 2,
      "failing_examples": 12,
      "examples": [
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// File: word_counter.ruchy\n// Simple word counter tool\n\n// Get filename from user\nprintln(\"Word Counter Tool\")\nprint(\"Enter filename: \")\nlet filename = input()\n\n// Read and process file\nlet content = read_file(filename)\nlet words = content.split_whitespace()\nlet word_count = words.len()\nlet char_count = content.len()\nlet line_count = content.lines().len()\n\n// Display results\nprintln(\"\\nFile Analysis: \" + filename)\nprintln(\"Characters: \" + char_count.to_s())\nprintln(\"Words: \" + word_count.to_s())  \nprintln(\"Lines: \" + line_count.to_s())\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpNoLjmo/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { println ! (\"Word Counter Tool\") ; print ! (\"Enter filename: \") ; let filename = { let mu...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpNoLjmo/main.rs:1:359\n  |\n1 | .... ends_with ('\\r') { input . pop () ; } } input } ; ; let content = read_file (filename) ; ; let words = content . split_whitespace ()...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpNoLjmo/main.rs:1:398\n  |\n1 | ... } input } ; ; let content = read_file (filename) ; ; let words = content . split_whitespace () ; ; let word_count = words . len () ; ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpNoLjmo/main.rs:1:444\n  |\n1 | ...me) ; ; let words = content . split_whitespace () ; ; let word_count = words . len () ; ; let char_count = content . len () ; ; let li...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpNoLjmo/main.rs:1:480\n  |\n1 | ...whitespace () ; ; let word_count = words . len () ; ; let char_count = content . len () ; ; let line_count = content . lines () . len ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpNoLjmo/main.rs:1:518\n  |\n1 | ...ds . len () ; ; let char_count = content . len () ; ; let line_count = content . lines () . len () ; ; println ! (\"{:?}\" , format ! (\"...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpNoLjmo/main.rs:1:567\n  |\n1 | ... ; ; let line_count = content . lines () . len () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nFile Analysis: \" , filename)) ; printl...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpNoLjmo/main.rs:1:375\n  |\n1 | ... { input . pop () ; } } input } ; ; let content = read_file (filename) ; ; let words = content . split_whitespace () ; ; let word_coun...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 7 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 2,
          "line_number": 81,
          "code": "let name = input(\"What's your name? \")\nlet age = input(\"How old are you? \").to_i()\nlet is_student = input(\"Are you a student? (y/n) \") == \"y\"\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpwcYlAF/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let name = { print ! (\"{}\" , \"What's your name? \") ; std :: io :: Write :: flush (& mut ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpwcYlAF/main.rs:1:403\n  |\n1 | .... ends_with ('\\r') { input . pop () ; } } input } ; ; let age = { print ! (\"{}\" , \"How old are you? \") ; std :: io :: Write :: flush (...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpwcYlAF/main.rs:1:766\n  |\n1 | ...h ('\\r') { input . pop () ; } } input } . to_i () ; ; let is_student = { print ! (\"{}\" , \"Are you a student? (y/n) \") ; std :: io :: W...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpwcYlAF/main.rs:1:1141\n  |\n1 | ...with ('\\r') { input . pop () ; } } input } == \"y\" ; ; }\n  |                                                        ^ help: remove this semicolon\n\nerror[E0599]: no method named `to_i` found for struct `String` in the current scope\n --> /tmp/.tmpwcYlAF/main.rs:1:756\n  |\n1 | ...ends_with ('\\r') { input . pop () ; } } input } . to_i () ; ; let is_student = { print ! (\"{}\" , \"Are you a student? (y/n) \") ; std ::...\n  |                                                      ^^^^ method not found in `String`\n\nerror: aborting due to 1 previous error; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_i()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 3,
          "line_number": 99,
          "code": "// Reading files\nlet content = read_file(\"data.txt\")\nlet lines = read_lines(\"data.txt\")\n\n// Writing files\nwrite_file(\"output.txt\", \"Hello, World!\")\nappend_file(\"log.txt\", \"New entry: \" + timestamp())\n\n// File information\nlet exists = file_exists(\"config.txt\")\nlet size = file_size(\"data.txt\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmps3Sknt/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let content = read_file (\"data.txt\" . to_string ()) ; ; let lines = read_lines (\"data.tx...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmps3Sknt/main.rs:1:104\n  |\n1 | use std :: collections :: HashMap ; fn main () { let content = read_file (\"data.txt\" . to_string ()) ; ; let lines = read_lines (\"data.tx...\n  |                                                                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmps3Sknt/main.rs:1:159\n  |\n1 | ...et lines = read_lines (\"data.txt\" . to_string ()) ; ; write_file (\"output.txt\" . to_string () , \"Hello, World!\" . to_string ()) ; appe...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmps3Sknt/main.rs:1:386\n  |\n1 | ...xists = file_exists (\"config.txt\" . to_string ()) ; ; let size = file_size (\"data.txt\" . to_string ()) ; ; }\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmps3Sknt/main.rs:1:439\n  |\n1 | ... let size = file_size (\"data.txt\" . to_string ()) ; ; }\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmps3Sknt/main.rs:1:64\n  |\n1 | use std :: collections :: HashMap ; fn main () { let content = read_file (\"data.txt\" . to_string ()) ; ; let lines = read_lines (\"data.tx...\n  |                                                                ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_lines` in this scope\n --> /tmp/.tmps3Sknt/main.rs:1:118\n  |\n1 | ..._file (\"data.txt\" . to_string ()) ; ; let lines = read_lines (\"data.txt\" . to_string ()) ; ; write_file (\"output.txt\" . to_string () ,...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmps3Sknt/main.rs:1:161\n  |\n1 | ...ines = read_lines (\"data.txt\" . to_string ()) ; ; write_file (\"output.txt\" . to_string () , \"Hello, World!\" . to_string ()) ; append_f...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `timestamp` in this scope\n --> /tmp/.tmps3Sknt/main.rs:1:312\n  |\n1 | ...to_string () , format ! (\"{}{}\" , \"New entry: \" , timestamp ())) ; let exists = file_exists (\"config.txt\" . to_string ()) ; ; let size...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `append_file` in this scope\n --> /tmp/.tmps3Sknt/main.rs:1:237\n  |\n1 | ...to_string () , \"Hello, World!\" . to_string ()) ; append_file (\"log.txt\" . to_string () , format ! (\"{}{}\" , \"New entry: \" , timestamp ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmps3Sknt/main.rs:1:342\n  |\n1 | ... , \"New entry: \" , timestamp ())) ; let exists = file_exists (\"config.txt\" . to_string ()) ; ; let size = file_size (\"data.txt\" . to_s...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_size` in this scope\n --> /tmp/.tmps3Sknt/main.rs:1:399\n  |\n1 | ...ists (\"config.txt\" . to_string ()) ; ; let size = file_size (\"data.txt\" . to_string ()) ; ; }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 7 previous errors; 5 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 4,
          "line_number": 125,
          "code": "// Usage: ruchy run script.ruchy file1.txt file2.txt\nlet args = command_args()\nlet program_name = args[0]\nlet first_file = args[1]\nlet second_file = args[2]\n\nprintln(\"Processing: \" + first_file + \" and \" + second_file)\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpU4OaBk/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let args = command_args () ; ; let program_name = args [0i32 as usize] ; ; let first_fil...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpU4OaBk/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn main () { let args = command_args () ; ; let program_name = args [0i32 as usize] ; ; let first_fil...\n  |                                                                               ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpU4OaBk/main.rs:1:123\n  |\n1 | ...gs () ; ; let program_name = args [0i32 as usize] ; ; let first_file = args [1i32 as usize] ; ; let second_file = args [2i32 as usize]...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpU4OaBk/main.rs:1:165\n  |\n1 | ... usize] ; ; let first_file = args [1i32 as usize] ; ; let second_file = args [2i32 as usize] ; ; println ! (\"{:?}\" , format ! (\"{}{}\" ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpU4OaBk/main.rs:1:208\n  |\n1 | ...usize] ; ; let second_file = args [2i32 as usize] ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Pr...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `command_args` in this scope\n --> /tmp/.tmpU4OaBk/main.rs:1:61\n  |\n1 | use std :: collections :: HashMap ; fn main () { let args = command_args () ; ; let program_name = args [0i32 as usize] ; ; let first_fil...\n  |                                                             ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 5 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 5,
          "line_number": 148,
          "code": "// File: text_processor.ruchy\n// Processes text files with various operations\n\nprintln(\"=== Text Processor ===\")\nlet filename = input(\"Enter filename: \")\n\nif !file_exists(filename) {\n    println(\"Error: File '\" + filename + \"' not found!\")\n    exit(1)\n}\n\nlet content = read_file(filename)\nlet lines = content.lines()\n\nprintln(\"\\nChoose operation:\")\nprintln(\"1. Count lines\")\nprintln(\"2. Find and replace\")\nprintln(\"3. Convert to uppercase\") \nprintln(\"4. Remove empty lines\")\n\nlet choice = input(\"Enter choice (1-4): \").to_i()\n\nmatch choice {\n    1 => {\n        println(\"Total lines: \" + lines.len().to_s())\n    }\n    2 => {\n        let find = input(\"Find: \")\n        let replace = input(\"Replace with: \")\n        let new_content = content.replace(find, replace)\n        let output_file = filename.replace(\".txt\", \"_modified.txt\")\n        write_file(output_file, new_content)\n        println(\"Saved to: \" + output_file)\n    }\n    3 => {\n        let upper_content = content.to_uppercase()\n        let output_file = filename.replace(\".txt\", \"_upper.txt\")\n        write_file(output_file, upper_content)\n        println(\"Saved to: \" + output_file)\n    }\n    4 => {\n        let clean_lines = lines.filter(|line| !line.trim().is_empty())\n        let clean_content = clean_lines.join(\"\\n\")\n        let output_file = filename.replace(\".txt\", \"_clean.txt\")\n        write_file(output_file, clean_content)\n        println(\"Saved to: \" + output_file)\n    }\n    _ => {\n        println(\"Invalid choice!\")\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `exit` in this scope\n --> /tmp/.tmpOfKqZF/main.rs:1:585\n  |\n1 | ...\" , \"Error: File '\" , filename) , \"' not found!\")) ; exit (1i32) } } ; let content = read_file (filename) ; ; let lines = content . li...\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::process::exit;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpOfKqZF/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { println ! (\"=== Text Processor ===\") ; let filename = { print ! (\"{}\" , \"Enter filename:...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpOfKqZF/main.rs:1:444\n  |\n1 | .... ends_with ('\\r') { input . pop () ; } } input } ; ; if ! file_exists (filename) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! ...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpOfKqZF/main.rs:1:640\n  |\n1 | ...t (1i32) } } ; let content = read_file (filename) ; ; let lines = content . lines () ; ; println ! (\"\\nChoose operation:\") ; println !...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpOfKqZF/main.rs:1:675\n  |\n1 | ...ile (filename) ; ; let lines = content . lines () ; ; println ! (\"\\nChoose operation:\") ; println ! (\"1. Count lines\") ; println ! (\"2...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpOfKqZF/main.rs:1:1225\n  |\n1 | ...h ('\\r') { input . pop () ; } } input } . to_i () ; ; let result = match choice { 1i32 => { println ! (\"{:?}\" , format ! (\"{}{}\" , \"To...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpOfKqZF/main.rs:1:2060\n  |\n1 | .... ends_with ('\\r') { input . pop () ; } } input } ; ; let new_content = content . replace (find , replace) ; ; let output_file = filen...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpOfKqZF/main.rs:1:2117\n  |\n1 | ... new_content = content . replace (find , replace) ; ; let output_file = filename . replace (\".txt\" , \"_modified.txt\") ; ; write_file (...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpOfKqZF/main.rs:1:2185\n  |\n1 | ...e = filename . replace (\".txt\" , \"_modified.txt\") ; ; write_file (output_file , new_content) ; println ! (\"{:?}\" , format ! (\"{}{}\" , ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpOfKqZF/main.rs:1:2429\n  |\n1 | ...file = filename . replace (\".txt\" , \"_upper.txt\") ; ; write_file (output_file , upper_content) ; println ! (\"{:?}\" , format ! (\"{}{}\" ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpOfKqZF/main.rs:1:2735\n  |\n1 | ...{ let clean_content = clean_lines . join (& \"\\n\") ; ; let output_file = filename . replace (\".txt\" , \"_clean.txt\") ; ; write_file (out...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpOfKqZF/main.rs:1:2800\n  |\n1 | ...file = filename . replace (\".txt\" , \"_clean.txt\") ; ; write_file (output_file , clean_content) ; println ! (\"{:?}\" , format ! (\"{}{}\" ...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpOfKqZF/main.rs:1:451\n  |\n1 | ...h ('\\r') { input . pop () ; } } input } ; ; if ! file_exists (filename) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpOfKqZF/main.rs:1:617\n  |\n1 | ...' not found!\")) ; exit (1i32) } } ; let content = read_file (filename) ; ; let lines = content . lines () ; ; println ! (\"\\nChoose ope...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_i` found for struct `String` in the current scope\n --> /tmp/.tmpOfKqZF/main.rs:1:1215\n  |\n1 | ...ends_with ('\\r') { input . pop () ; } } input } . to_i () ; ; let result = match choice { 1i32 => { println ! (\"{:?}\" , format ! (\"{}{...\n  |                                                      ^^^^ method not found in `String`\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpOfKqZF/main.rs:1:2187\n  |\n1 | ...filename . replace (\".txt\" , \"_modified.txt\") ; ; write_file (output_file , new_content) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Sav...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpOfKqZF/main.rs:1:2431\n  |\n1 | ... = filename . replace (\".txt\" , \"_upper.txt\") ; ; write_file (output_file , upper_content) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"S...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpOfKqZF/main.rs:1:2802\n  |\n1 | ... = filename . replace (\".txt\" , \"_clean.txt\") ; ; write_file (output_file , clean_content) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"S...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpOfKqZF/main.rs:1:3100\n  |\n1 | .... contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter\n  |                                       |\n  |                                       required by this formatting parameter\n  |\n  = help: the trait `std::fmt::Display` is not implemented for `()`\n  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 8 previous errors; 11 warnings emitted\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_i()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 6,
          "line_number": 213,
          "code": "// File: log_analyzer.ruchy\n// Analyzes server log files\n\nprintln(\"=== Log Analyzer ===\")\nlet log_file = input(\"Enter log file path: \")\n\nlet lines = read_lines(log_file)\nlet total_requests = lines.len()\n\n// Count different status codes\nlet success_count = 0\nlet error_count = 0\nlet not_found_count = 0\n\nfor line in lines {\n    if line.contains(\" 200 \") {\n        success_count += 1\n    } else if line.contains(\" 404 \") {\n        not_found_count += 1\n    } else if line.contains(\" 500 \") {\n        error_count += 1\n    }\n}\n\n// Calculate percentages\nlet success_percent = (success_count * 100) / total_requests\nlet error_percent = (error_count * 100) / total_requests\nlet not_found_percent = (not_found_count * 100) / total_requests\n\nprintln(\"\\n=== Analysis Results ===\")\nprintln(\"Total Requests: \" + total_requests.to_s())\nprintln(\"Success (200): \" + success_count.to_s() + \" (\" + success_percent.to_s() + \"%)\")\nprintln(\"Not Found (404): \" + not_found_count.to_s() + \" (\" + not_found_percent.to_s() + \"%)\")\nprintln(\"Server Error (500): \" + error_count.to_s() + \" (\" + error_percent.to_s() + \"%)\")\n\n// Find busiest hour\nlet hour_counts = {}\nfor line in lines {\n    let timestamp = extract_hour(line)  // Custom function\n    hour_counts[timestamp] = hour_counts.get(timestamp, 0) + 1\n}\n\nlet busiest_hour = hour_counts.max_by_value().key\nprintln(\"Busiest Hour: \" + busiest_hour.to_s() + \":00\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpsIhChT/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { println ! (\"=== Log Analyzer ===\") ; let log_file = { print ! (\"{}\" , \"Enter log file pa...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpsIhChT/main.rs:1:447\n  |\n1 | .... ends_with ('\\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; le...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpsIhChT/main.rs:1:485\n  |\n1 | ...} } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_c...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpsIhChT/main.rs:1:525\n  |\n1 | ...log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpsIhChT/main.rs:1:554\n  |\n1 | ...sts = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpsIhChT/main.rs:1:581\n  |\n1 | ...t success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (\" 200 \"...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpsIhChT/main.rs:1:612\n  |\n1 | ...error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } }...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpsIhChT/main.rs:1:901\n  |\n1 | ...percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_perc...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpsIhChT/main.rs:1:963\n  |\n1 | ...r_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpsIhChT/main.rs:1:1033\n  |\n1 | ...rcent = not_found_count * 100i32 / total_requests ; ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpsIhChT/main.rs:1:1764\n  |\n1 | ...ercent . to_s ()) , \"%)\")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [times...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpsIhChT/main.rs:1:1984\n  |\n1 | ...usiest_hour = hour_counts . max_by_value () . key ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , bus...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpsIhChT/main.rs:1:634\n  |\n1 | ... { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ...\n  |       ^^                                                                                                                                                                                                  ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { println ! (\"=== Log Analyzer ===\") ; let log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") , success_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") , not_found_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") , error_percent . to_s ()) , \"%)\")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) ; }\n1 + use std :: collections :: HashMap ; fn main () { println ! (\"=== Log Analyzer ===\") ; let log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") , success_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") , not_found_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") , error_percent . to_s ()) , \"%)\")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpsIhChT/main.rs:1:667\n  |\n1 | ... for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_co...\n  |                                                          ^^                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { println ! (\"=== Log Analyzer ===\") ; let log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") , success_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") , not_found_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") , error_percent . to_s ()) , \"%)\")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) ; }\n1 + use std :: collections :: HashMap ; fn main () { println ! (\"=== Log Analyzer ===\") ; let log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (\" 200 \") { success_count += 1i32 } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") , success_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") , not_found_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") , error_percent . to_s ()) , \"%)\")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpsIhChT/main.rs:1:733\n  |\n1 | ...nt += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count...\n  |                                                         ^^                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { println ! (\"=== Log Analyzer ===\") ; let log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") , success_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") , not_found_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") , error_percent . to_s ()) , \"%)\")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) ; }\n1 + use std :: collections :: HashMap ; fn main () { println ! (\"=== Log Analyzer ===\") ; let log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { not_found_count += 1i32 } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") , success_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") , not_found_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") , error_percent . to_s ()) , \"%)\")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpsIhChT/main.rs:1:801\n  |\n1 | ...ount += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i3...\n  |                                                           ^^                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { println ! (\"=== Log Analyzer ===\") ; let log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") , success_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") , not_found_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") , error_percent . to_s ()) , \"%)\")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) ; }\n1 + use std :: collections :: HashMap ; fn main () { println ! (\"=== Log Analyzer ===\") ; let log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { error_count += 1i32 } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") , success_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") , not_found_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") , error_percent . to_s ()) , \"%)\")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpsIhChT/main.rs:1:1786\n  |\n1 | ... { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ...\n  |       ^^                                                                                                                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { println ! (\"=== Log Analyzer ===\") ; let log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") , success_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") , not_found_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") , error_percent . to_s ()) , \"%)\")) ; let hour_counts = () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) ; }\n1 + use std :: collections :: HashMap ; fn main () { println ! (\"=== Log Analyzer ===\") ; let log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count = 0i32 ; ; let error_count = 0i32 ; ; let not_found_count = 0i32 ; ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let success_percent = success_count * 100i32 / total_requests ; ; let error_percent = error_count * 100i32 / total_requests ; ; let not_found_percent = not_found_count * 100i32 / total_requests ; ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") , success_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") , not_found_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") , error_percent . to_s ()) , \"%)\")) ; let hour_counts = () ; ; for line in lines { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) ; }\n  |\n\nerror[E0425]: cannot find function `read_lines` in this scope\n --> /tmp/.tmpsIhChT/main.rs:1:461\n  |\n1 | ...') { input . pop () ; } } input } ; ; let lines = read_lines (log_file) ; ; let total_requests = lines . len () ; ; let success_count ...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpsIhChT/main.rs:1:1299\n  |\n1 | ...mat ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") , success_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , forma...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpsIhChT/main.rs:1:1336\n  |\n1 | ...uccess_count . to_s ()) , \" (\") , success_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , form...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpsIhChT/main.rs:1:1492\n  |\n1 | ...! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") , not_found_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , for...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpsIhChT/main.rs:1:1531\n  |\n1 | ...ound_count . to_s ()) , \" (\") , not_found_percent . to_s ()) , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , form...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpsIhChT/main.rs:1:1686\n  |\n1 | ... ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") , error_percent . to_s ()) , \"%)\")) ; let hour_counts = () ; ; fo...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpsIhChT/main.rs:1:1721\n  |\n1 | ... , error_count . to_s ()) , \" (\") , error_percent . to_s ()) , \"%)\")) ; let hour_counts = () ; ; for line in lines { { { let timestamp...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0425]: cannot find function `extract_hour` in this scope\n --> /tmp/.tmpsIhChT/main.rs:1:1806\n  |\n1 | ...= () ; ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `get` found for unit type `()` in the current scope\n    --> /tmp/.tmpsIhChT/main.rs:1:1877\n     |\n1    | ...t_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let busiest_hour = ...\n     |                                                                     ^^^\n     |\nhelp: there is a method `ge` with a similar name, but with different arguments\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1438:5\n     |\n1438 |     fn ge(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `max_by_value` found for unit type `()` in the current scope\n --> /tmp/.tmpsIhChT/main.rs:1:1960\n  |\n1 | ...+ 1i32 } } } ; let busiest_hour = hour_counts . max_by_value () . key ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"B...\n  |                                                    ^^^^^^^^^^^^ method not found in `()`\n\nerror: aborting due to 10 previous errors; 17 warnings emitted\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 7,
          "line_number": 271,
          "code": "// File: batch_renamer.ruchy  \n// Renames multiple files with patterns\n\nprintln(\"=== Batch File Renamer ===\")\nlet directory = input(\"Enter directory path: \")\nlet pattern = input(\"Enter pattern to find: \")\nlet replacement = input(\"Enter replacement: \")\n\nlet files = list_files(directory)\nlet renamed_count = 0\n\nfor file in files {\n    if file.contains(pattern) {\n        let new_name = file.replace(pattern, replacement)\n        let old_path = join_path(directory, file)\n        let new_path = join_path(directory, new_name)\n        \n        if rename_file(old_path, new_path) {\n            println(\"Renamed: \" + file + \" -> \" + new_name)\n            renamed_count += 1\n        } else {\n            println(\"Failed to rename: \" + file)\n        }\n    }\n}\n\nprintln(\"\\nRenamed \" + renamed_count.to_s() + \" files\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmplpky4e/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { println ! (\"=== Batch File Renamer ===\") ; let directory = { print ! (\"{}\" , \"Enter dire...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmplpky4e/main.rs:1:455\n  |\n1 | .... ends_with ('\\r') { input . pop () ; } } input } ; ; let pattern = { print ! (\"{}\" , \"Enter pattern to find: \") ; std :: io :: Write ...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmplpky4e/main.rs:1:818\n  |\n1 | .... ends_with ('\\r') { input . pop () ; } } input } ; ; let replacement = { print ! (\"{}\" , \"Enter replacement: \") ; std :: io :: Write ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmplpky4e/main.rs:1:1181\n  |\n1 | .... ends_with ('\\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmplpky4e/main.rs:1:1220\n  |\n1 | ... } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmplpky4e/main.rs:1:1249\n  |\n1 | ...st_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { { let new_name = file . r...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmplpky4e/main.rs:1:1271\n  |\n1 | ... { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") , new_name)) ; renamed_count += 1i32 } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { println ! (\"=== Batch File Renamer ===\") ; let directory = { print ! (\"{}\" , \"Enter directory path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let pattern = { print ! (\"{}\" , \"Enter pattern to find: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let replacement = { print ! (\"{}\" , \"Enter replacement: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") , new_name)) ; renamed_count += 1i32 } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) ; }\n1 + use std :: collections :: HashMap ; fn main () { println ! (\"=== Batch File Renamer ===\") ; let directory = { print ! (\"{}\" , \"Enter directory path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let pattern = { print ! (\"{}\" , \"Enter pattern to find: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let replacement = { print ! (\"{}\" , \"Enter replacement: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") , new_name)) ; renamed_count += 1i32 } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmplpky4e/main.rs:1:1304\n  |\n1 | ... { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") , new_name)) ; renamed_count += 1i32 } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { println ! (\"=== Batch File Renamer ===\") ; let directory = { print ! (\"{}\" , \"Enter directory path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let pattern = { print ! (\"{}\" , \"Enter pattern to find: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let replacement = { print ! (\"{}\" , \"Enter replacement: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") , new_name)) ; renamed_count += 1i32 } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) ; }\n1 + use std :: collections :: HashMap ; fn main () { println ! (\"=== Batch File Renamer ===\") ; let directory = { print ! (\"{}\" , \"Enter directory path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let pattern = { print ! (\"{}\" , \"Enter pattern to find: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let replacement = { print ! (\"{}\" , \"Enter replacement: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") , new_name)) ; renamed_count += 1i32 } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmplpky4e/main.rs:1:1412\n  |\n1 | ...) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , n...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmplpky4e/main.rs:1:1464\n  |\n1 | ...; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmplpky4e/main.rs:1:1662\n  |\n1 | ...named_count += 1i32 } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } } ; println ! (\"{:...\n  |                                   ^^                                                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { println ! (\"=== Batch File Renamer ===\") ; let directory = { print ! (\"{}\" , \"Enter directory path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let pattern = { print ! (\"{}\" , \"Enter pattern to find: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let replacement = { print ! (\"{}\" , \"Enter replacement: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") , new_name)) ; renamed_count += 1i32 } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) ; }\n1 + use std :: collections :: HashMap ; fn main () { println ! (\"=== Batch File Renamer ===\") ; let directory = { print ! (\"{}\" , \"Enter directory path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let pattern = { print ! (\"{}\" , \"Enter pattern to find: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let replacement = { print ! (\"{}\" , \"Enter replacement: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") , new_name)) ; renamed_count += 1i32 } } else { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) ; }\n  |\n\nerror[E0425]: cannot find function `list_files` in this scope\n --> /tmp/.tmplpky4e/main.rs:1:1195\n  |\n1 | ...') { input . pop () ; } } input } ; ; let files = list_files (directory) ; ; let renamed_count = 0i32 ; ; for file in files { { if fil...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmplpky4e/main.rs:1:1381\n  |\n1 | ...eplace (pattern , replacement) ; { let old_path = join_path (directory , file) ; ; let new_path = join_path (directory , new_name) ; ;...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmplpky4e/main.rs:1:1429\n  |\n1 | ...ory , file) ; ; let new_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , forma...\n  |                                   ^^^^^^^^^ help: a local variable with a similar name exists: `old_path`\n\nerror[E0425]: cannot find function `rename_file` in this scope\n --> /tmp/.tmplpky4e/main.rs:1:1469\n  |\n1 | ...w_path = join_path (directory , new_name) ; ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format !...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmplpky4e/main.rs:1:1840\n  |\n1 | ..., format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) ; }\n  |                                                        ^^^^ method not found in `i32`\n\nerror: aborting due to 5 previous errors; 11 warnings emitted\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 8,
          "line_number": 314,
          "code": "// Robust file processor with error handling\n\nfun process_file(filename) {\n    // Check if file exists\n    if !file_exists(filename) {\n        println(\"❌ Error: File '\" + filename + \"' does not exist\")\n        return false\n    }\n    \n    // Check if file is readable\n    if !file_readable(filename) {\n        println(\"❌ Error: Cannot read file '\" + filename + \"' (permission denied?)\")\n        return false\n    }\n    \n    // Try to read file\n    let content = try {\n        read_file(filename)\n    } catch error {\n        println(\"❌ Error reading file: \" + error.to_s())\n        return false\n    }\n    \n    // Process content\n    let word_count = content.split_whitespace().len()\n    println(\"✅ File processed: \" + word_count.to_s() + \" words\")\n    return true\n}\n\n// Main program\nlet filename = input(\"Enter filename: \")\nif process_file(filename) {\n    println(\"Processing completed successfully!\")\n} else {\n    println(\"Processing failed!\")\n    exit(1)\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 9,
          "line_number": 367,
          "code": "// Good CLI tool practices\n\nfun show_help() {\n    println(\"File Statistics Tool v1.0\")\n    println(\"\")\n    println(\"Usage:\")\n    println(\"  ruchy run file_stats.ruchy <filename>\")\n    println(\"\")\n    println(\"Examples:\")\n    println(\"  ruchy run file_stats.ruchy document.txt\")\n    println(\"  ruchy run file_stats.ruchy data/*.csv\")\n    println(\"\")\n    println(\"Options:\")\n    println(\"  --help     Show this help message\")\n    println(\"  --verbose  Show detailed output\")\n}\n\nfun process_with_progress(files) {\n    let total = files.len()\n    let mut i = 0\n    \n    while i < total {\n        let file = files[i]\n        let progress = ((i + 1) * 100) / total\n        print(\"\\rProcessing... [\" + progress.to_s() + \"%] \" + file)\n        \n        // Do the actual work\n        process_file(file)\n        \n        // Small delay to show progress\n        sleep(100)  // 100ms\n        i = i + 1\n    }\n    \n    println(\"\\n✅ All files processed!\")\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `sleep` in this scope\n --> /tmp/.tmpFD0oN9/main.rs:1:860\n  |\n1 | ... to_s ()) , \"%] \") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } ...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::sleep;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpFD0oN9/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ;...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpFD0oN9/main.rs:1:542\n  |\n1 | ... { { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } } } f...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ; println ! (\"  ruchy run file_stats.ruchy <filename>\") ; println ! (\"\") ; println ! (\"Examples:\") ; println ! (\"  ruchy run file_stats.ruchy document.txt\") ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\") ; println ! (\"\") ; println ! (\"Options:\") ; println ! (\"  --help     Show this help message\") ; println ! (\"  --verbose  Show detailed output\") } } fn process_with_progress (files : String) { { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ; println ! (\"  ruchy run file_stats.ruchy <filename>\") ; println ! (\"\") ; println ! (\"Examples:\") ; println ! (\"  ruchy run file_stats.ruchy document.txt\") ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\") ; println ! (\"\") ; println ! (\"Options:\") ; println ! (\"  --help     Show this help message\") ; println ! (\"  --verbose  Show detailed output\") } } fn process_with_progress (files : String) { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } } fn main () { }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpFD0oN9/main.rs:1:596\n  |\n1 | ...{ let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpFD0oN9/main.rs:1:616\n  |\n1 | ... { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ; println ! (\"  ruchy run file_stats.ruchy <filename>\") ; println ! (\"\") ; println ! (\"Examples:\") ; println ! (\"  ruchy run file_stats.ruchy document.txt\") ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\") ; println ! (\"\") ; println ! (\"Options:\") ; println ! (\"  --help     Show this help message\") ; println ! (\"  --verbose  Show detailed output\") } } fn process_with_progress (files : String) { { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ; println ! (\"  ruchy run file_stats.ruchy <filename>\") ; println ! (\"\") ; println ! (\"Examples:\") ; println ! (\"  ruchy run file_stats.ruchy document.txt\") ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\") ; println ! (\"\") ; println ! (\"Options:\") ; println ! (\"  --help     Show this help message\") ; println ! (\"  --verbose  Show detailed output\") } } fn process_with_progress (files : String) { { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } ; println ! (\"\\n✅ All files processed!\") } } } } fn main () { }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpFD0oN9/main.rs:1:699\n  |\n1 | ...e] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rPr...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpFD0oN9/main.rs:1:608\n  |\n1 | ... files . len () ; { let mut i = 0i32 ; ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / ...\n  |                                                   -   ^^^^^ expected `i32`, found `usize`\n  |                                                   |\n  |                                                   expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ; println ! (\"  ruchy run file_stats.ruchy <filename>\") ; println ! (\"\") ; println ! (\"Examples:\") ; println ! (\"  ruchy run file_stats.ruchy document.txt\") ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\") ; println ! (\"\") ; println ! (\"Options:\") ; println ! (\"  --help     Show this help message\") ; println ! (\"  --verbose  Show detailed output\") } } fn process_with_progress (files : String) { { { let total = files . len () ; { let mut i = 0i32 ; ; while i < total.try_into().unwrap() { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++++++++++++++++++++\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmpFD0oN9/main.rs:1:638\n  |\n1 | ... ; while i < total { { { let file = files [i as usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! (\"{:?}\" , format ! (...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpFD0oN9/main.rs:1:691\n  |\n1 | ... usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , ...\n  |                                                     ^^^^^ expected `i32`, found `usize`\n\nerror[E0277]: cannot divide `i32` by `usize`\n --> /tmp/.tmpFD0oN9/main.rs:1:689\n  |\n1 | ...s usize] ; { let progress = (i + 1i32) * 100i32 / total ; ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" ,...\n  |                                                    ^ no implementation for `i32 / usize`\n  |\n  = help: the trait `Div<usize>` is not implemented for `i32`\n  = help: the following other types implement trait `Div<Rhs>`:\n            `&i32` implements `Div<i32>`\n            `&i32` implements `Div`\n            `i32` implements `Div<&i32>`\n            `i32` implements `Div`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpFD0oN9/main.rs:1:809\n  |\n1 | ...format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 }...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0425]: cannot find function `process_file` in this scope\n --> /tmp/.tmpFD0oN9/main.rs:1:838\n  |\n1 | ...... [\" , progress . to_s ()) , \"%] \") , file)) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All file...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 7 previous errors; 5 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 10,
          "line_number": 422,
          "code": "// Example: Manual line counting implementation\n\nfun main() {\n    // Sample file content for demonstration\n    let content = \"line 1\\nline 2\\nline 3\";\n    \n    // Manual line counting implementation\n    let mut lines = 1;\n    let mut i = 0;\n    while i < content.len() {\n        if content[i] == '\\n' {\n            lines = lines + 1;\n        }\n        i = i + 1;\n    }\n    \n    println(\"File has\", lines, \"lines\");\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp8bGPDG/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" . to_string () ; { let mut lines = 1i32 ; ; l...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp8bGPDG/main.rs:1:50\n  |\n1 | ... { { { let content = \"line 1\\nline 2\\nline 3\" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {:?} {}\" , \"File has\" , lines , \"lines\") } } } }\n  |       ^^                                                                                                                                                                                                                                                                                      ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {:?} {}\" , \"File has\" , lines , \"lines\") } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let content = \"line 1\\nline 2\\nline 3\" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {:?} {}\" , \"File has\" , lines , \"lines\") } } }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp8bGPDG/main.rs:1:135\n  |\n1 | ...\\nline 3\" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp8bGPDG/main.rs:1:156\n  |\n1 | ... () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\\n' { { lines = lines...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp8bGPDG/main.rs:1:223\n  |\n1 | ...content . len () { { if content [i as usize] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {:?} {}\" , \"File...\n  |                                                           ^^                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {:?} {}\" , \"File has\" , lines , \"lines\") } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\\n' { lines = lines + 1i32 } ; i = i + 1i32 } } ; println ! (\"{} {:?} {}\" , \"File has\" , lines , \"lines\") } } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp8bGPDG/main.rs:1:168\n  |\n1 | ...nes = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len () { { if content [i as usize] == '\\n' { { lines = lines + 1i32 } } ; i = ...\n  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`\n  |                                              |\n  |                                              expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" . to_string () ; { let mut lines = 1i32 ; ; let mut i = 0i32 ; ; while i < content . len ().try_into().unwrap() { { if content [i as usize] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {:?} {}\" , \"File has\" , lines , \"lines\") } } } }\n  |                                                                                                                                                                                        ++++++++++++++++++++\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmp8bGPDG/main.rs:1:201\n  |\n1 | ...while i < content . len () { { if content [i as usize] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {:?} {...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror: aborting due to 2 previous errors; 5 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 11,
          "line_number": 524,
          "code": "// task_manager.ruchy - A simple but useful task management tool\n\nlet TASK_FILE = \"tasks.txt\"\n\nfun show_menu() {\n    println(\"\\n=== Task Manager ===\")\n    println(\"1. List tasks\")\n    println(\"2. Add task\")\n    println(\"3. Complete task\")\n    println(\"4. Delete task\")\n    println(\"5. Quit\")\n}\n\nfun load_tasks() {\n    if file_exists(TASK_FILE) {\n        return read_lines(TASK_FILE)\n    }\n    return []\n}\n\nfun save_tasks(tasks) {\n    let content = tasks.join(\"\\n\")\n    write_file(TASK_FILE, content)\n}\n\nfun list_tasks(tasks) {\n    if tasks.is_empty() {\n        println(\"\\n📝 No tasks yet!\")\n        return\n    }\n    \n    println(\"\\n📋 Your Tasks (\" + tasks.len().to_s() + \" items):\")\n    let mut i = 0\n    while i < tasks.len() {\n        let task = tasks[i]\n        let status = if task.starts_with(\"✅\") { \"DONE\" } else { \"PENDING\" }\n        println((i + 1).to_s() + \". \" + task)\n        i = i + 1\n    }\n}\n\nfun add_task(tasks) {\n    let new_task = input(\"\\nWhat do you want to add? \")\n    tasks.push(\"📌 \" + new_task)\n    save_tasks(tasks)\n    println(\"✅ Task added!\")\n}\n\nfun complete_task(tasks) {\n    list_tasks(tasks)\n    let index = input(\"\\nWhich task to complete? (number): \").to_i() - 1\n    \n    if index >= 0 && index < tasks.len() {\n        tasks[index] = tasks[index].replace(\"📌\", \"✅\")\n        save_tasks(tasks)\n        println(\"🎉 Task completed!\")\n    } else {\n        println(\"❌ Invalid task number\")\n    }\n}\n\n// Main program loop\nlet tasks = load_tasks()\n\nloop {\n    show_menu()\n    let choice = input(\"\\nChoose option: \")\n    \n    match choice {\n        \"1\" => list_tasks(tasks)\n        \"2\" => add_task(tasks)\n        \"3\" => complete_task(tasks)\n        \"4\" => {\n            list_tasks(tasks)\n            let index = input(\"Which task to delete? (number): \").to_i() - 1\n            if index >= 0 && index < tasks.len() {\n                tasks.remove(index)\n                save_tasks(tasks)\n                println(\"🗑️  Task deleted!\")\n            }\n        }\n        \"5\" => {\n            println(\"👋 Goodbye!\")\n            break\n        }\n        _ => println(\"❌ Invalid choice\")\n    }\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `TASK_FILE` in this scope\n --> /tmp/.tmpphnukZ/main.rs:1:288\n  |\n1 | ...) } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `TASK_FILE` in this scope\n --> /tmp/.tmpphnukZ/main.rs:1:322\n  |\n1 | ...if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `TASK_FILE` in this scope\n --> /tmp/.tmpphnukZ/main.rs:1:453\n  |\n1 | ...let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty ()...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpphnukZ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpphnukZ/main.rs:1:301\n  |\n1 | ..._tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : Str...\n  |                                                      ^^                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { return read_lines (TASK_FILE) } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpphnukZ/main.rs:1:399\n  |\n1 | ...s (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : St...\n  |                                ^^                                                                          ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpphnukZ/main.rs:1:730\n  |\n1 | ...n () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpphnukZ/main.rs:1:759\n  |\n1 | ... { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } }...\n  |       ^^                                                                                                                                                                                                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpphnukZ/main.rs:1:878\n  |\n1 | ..._with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \"....\n  |                                                         ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpphnukZ/main.rs:1:840\n  |\n1 | ...s [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}...\n  |                                                                   ^^      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { \"DONE\" } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpphnukZ/main.rs:1:860\n  |\n1 | ... status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\"...\n  |                                                                 ^^         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { \"PENDING\" } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpphnukZ/main.rs:1:1029\n  |\n1 | ... { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpphnukZ/main.rs:1:2141\n  |\n1 | ...) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" ...\n  |                                                    ^^                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { println ! (\"❌ Invalid task number\") } } } } fn main () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpphnukZ/main.rs:1:2247\n  |\n1 | ...n () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpphnukZ/main.rs:1:2277\n  |\n1 | ...txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; ...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpphnukZ/main.rs:1:275\n  |\n1 | ...! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } f...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_lines` in this scope\n --> /tmp/.tmpphnukZ/main.rs:1:310\n  |\n1 | ... -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `join` found for struct `String` in the current scope\n --> /tmp/.tmpphnukZ/main.rs:1:425\n  |\n1 | ...asks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String...\n  |                                                      ^^^^ method not found in `String`\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpphnukZ/main.rs:1:441\n  |\n1 | ...> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks ....\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_s` found for type `usize` in the current scope\n --> /tmp/.tmpphnukZ/main.rs:1:685\n  |\n1 | ... ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let ta...\n  |                                                        ^^^^ method not found in `usize`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpphnukZ/main.rs:1:742\n  |\n1 | ... \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_wi...\n  |                                               -   ^^^^^^^^^^^^^^ expected `i32`, found `usize`\n  |                                               |\n  |                                               expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len ().try_into().unwrap() { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ++++++++++++++++++++\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmpphnukZ/main.rs:1:781\n  |\n1 | ...i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" }...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpphnukZ/main.rs:1:949\n  |\n1 | ... , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `push` found for type `i32` in the current scope\n --> /tmp/.tmpphnukZ/main.rs:1:1409\n  |\n1 | ...h ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpphnukZ/main.rs:1:1466\n  |\n1 | ...! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) { { list_tasks (...\n  |                                     ----------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                     |           |\n  |                                     |           expected `String`, found `i32`\n  |                                     arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpphnukZ/main.rs:1:362\n  |\n1 | ... read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; wr...\n  |                                                         ^^^^^^^^^^  --------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpphnukZ/main.rs:1:1558\n  |\n1 | ...complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: ...\n  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                    |           |\n  |                                    |           expected `String`, found `i32`\n  |                                    arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpphnukZ/main.rs:1:483\n  |\n1 | ...(& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No task...\n  |                                                         ^^^^^^^^^^  --------------\n\nerror[E0599]: no method named `to_i` found for struct `String` in the current scope\n --> /tmp/.tmpphnukZ/main.rs:1:1941\n  |\n1 | ...ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usiz...\n  |                                                      ^^^^ method not found in `String`\n\nerror[E0599]: no method named `len` found for type `i32` in the current scope\n    --> /tmp/.tmpphnukZ/main.rs:1:1994\n     |\n1    | ...} input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (...\n     |                                                                     ^^^\n     |\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1402:5\n     |\n1402 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpphnukZ/main.rs:1:2089\n  |\n1 | ... usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } ...\n  |                                      ----------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                      |           |\n  |                                      |           expected `String`, found `i32`\n  |                                      arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpphnukZ/main.rs:1:362\n  |\n1 | ... read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; wr...\n  |                                                         ^^^^^^^^^^  --------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpphnukZ/main.rs:1:2674\n  |\n1 | ...'\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (task...\n  |                                                 ------   ^^^ expected `String`, found `&str`\n  |                                                 |\n  |                                                 this expression has type `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpphnukZ/main.rs:1:2702\n  |\n1 | .... pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { ...\n  |                                   ------                               ^^^ expected `String`, found `&str`\n  |                                   |\n  |                                   this expression has type `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpphnukZ/main.rs:1:2728\n  |\n1 | ...} input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (t...\n  |                      ------ this expression has type `String`                       ^^^ expected `String`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpphnukZ/main.rs:1:2759\n  |\n1 | ...nput } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (task...\n  |                   ------ this expression has type `String`                                                      ^^^ expected `String`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpphnukZ/main.rs:1:3318\n  |\n1 | ...ch choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" =>...\n  |       ------ this expression has type `String`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^^ expected `String`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpphnukZ/main.rs:1:2693\n  |\n1 | ...input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tas...\n  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                    |           |\n  |                                    |           expected `String`, found `i32`\n  |                                    arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpphnukZ/main.rs:1:483\n  |\n1 | ...(& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No task...\n  |                                                         ^^^^^^^^^^  --------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpphnukZ/main.rs:1:2780\n  |\n1 | ...omplete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :...\n  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                    |           |\n  |                                    |           expected `String`, found `i32`\n  |                                    arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpphnukZ/main.rs:1:483\n  |\n1 | ...(& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No task...\n  |                                                         ^^^^^^^^^^  --------------\n\nerror[E0599]: no method named `to_i` found for struct `String` in the current scope\n --> /tmp/.tmpphnukZ/main.rs:1:3159\n  |\n1 | ...ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (inde...\n  |                                                      ^^^^ method not found in `String`\n\nerror[E0599]: no method named `len` found for type `i32` in the current scope\n    --> /tmp/.tmpphnukZ/main.rs:1:3212\n     |\n1    | ...} input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"...\n     |                                                                     ^^^\n     |\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1402:5\n     |\n1402 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `remove` found for type `i32` in the current scope\n --> /tmp/.tmpphnukZ/main.rs:1:3231\n  |\n1 | ...- 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task dele...\n  |                                                                    ^^^^^^\n  |\nhelp: there is a method `rem` with a similar name\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") , task)) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let TASK_FILE = \"tasks.txt\" . to_string () ; ; let tasks = load_tasks () ; ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . rem (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpphnukZ/main.rs:1:3260\n  |\n1 | ...() { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\")...\n  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                    |           |\n  |                                    |           expected `String`, found `i32`\n  |                                    arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpphnukZ/main.rs:1:362\n  |\n1 | ... read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (& \"\\n\") ; wr...\n  |                                                         ^^^^^^^^^^  --------------\n\nerror: aborting due to 28 previous errors; 12 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: join()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 12,
          "line_number": 644,
          "code": "// ❌ This demonstrates what NOT to do - no error handling\n\nfun main() {\n    // Example of code that would fail without proper error checking\n    println(\"Example: Unsafe file operations\");\n    println(\"This pattern would crash if file doesn't exist:\");\n    println(\"// let content = read_file(\\\"missing.txt\\\");\");\n    \n    // Better approach would include error checking\n    println(\"Always check if operations can fail before using them\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 13,
          "line_number": 666,
          "code": "// ❌ Confusing and unhelpful\nprintln(\"Enter thing:\")\nlet thing = input()\n// What thing? What format?\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 14,
          "line_number": 683,
          "code": "// ❌ Only works on your computer\nlet data = read_file(\"/Users/noah/Desktop/data.txt\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found `let` statement\n --> /tmp/.tmpF1pOyp/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let data = read_file (\"/Users/noah/Desktop/data.txt\" . to_string ()) ; ; if...\n  |                                                               ^^^\n  |\n  = note: only supported directly in conditions of `if` and `while` expressions\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpF1pOyp/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let data = read_file (\"/Users/noah/Desktop/data.txt\" . to_string ()) ; ; if...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpF1pOyp/main.rs:1:134\n  |\n1 | ...e (\"/Users/noah/Desktop/data.txt\" . to_string ()) ; ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < Stri...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpF1pOyp/main.rs:1:74\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let data = read_file (\"/Users/noah/Desktop/data.txt\" . to_string ()) ; ; if...\n  |                                                                          ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch03-00-functions-tdd": {
      "chapter": "ch03-00-functions-tdd",
      "total_examples": 9,
      "working_examples": 8,
      "failing_examples": 1,
      "examples": [
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun greet() {\n    println(\"Hello from function!\");\n}\n\nfun main() {\n    greet();\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 2,
          "line_number": 54,
          "code": "fun add(a, b) {\n    a + b\n}\n\nfun main() {\n    let result = add(5, 3);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 3,
          "line_number": 77,
          "code": "fun multiply(x: i32, y: i32) -> i32 {\n    x * y\n}\n\nfun main() {\n    let product = multiply(6, 7);\n    println(product);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 4,
          "line_number": 100,
          "code": "fun square(n: i32) -> i32 {\n    n * n\n}\n\nfun sum_of_squares(a: i32, b: i32) -> i32 {\n    square(a) + square(b)\n}\n\nfun main() {\n    let result = sum_of_squares(3, 4);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 5,
          "line_number": 127,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nfun function_name(parameters) -> return_type {\n    // function body\n    return_expression\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `return_type` in this scope\n --> /tmp/.tmpe3khe3/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }\n  |                                                                               ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `return_expression` in this scope\n --> /tmp/.tmpe3khe3/main.rs:1:95\n  |\n1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }\n  |                                                                                               ^^^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpe3khe3/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpe3khe3/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }\n  |                                                                                             ^^                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }\n1 + use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { return_expression } fn main () { }\n  |\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 6,
          "line_number": 165,
          "code": "fun calculate(x: i32, y: i32) -> i32 {\n    x * 2 + y * 3\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 7,
          "line_number": 194,
          "code": "fun calculate(input: i32) -> i32 {\n    input * 2\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 8,
          "line_number": 204,
          "code": "fun combine(a: i32, b: i32, c: i32) -> i32 {\n    a + b + c\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 9,
          "line_number": 214,
          "code": "fun helper(x: i32) -> i32 {\n    x * x\n}\n\nfun main_calculation(n: i32) -> i32 {\n    helper(n) + helper(n + 1)\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch11-00-file-operations-tdd": {
      "chapter": "ch11-00-file-operations-tdd",
      "total_examples": 10,
      "working_examples": 6,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun read_config() -> i32 {\n    // Simulate reading a config value\n    return 42;\n}\n\nfun write_status(value: i32) -> bool {\n    // Simulate writing status\n    if value > 0 {\n        return true;\n    }\n    return false;\n}\n\nfun main() {\n    let config = read_config();\n    println(\"Config value:\");\n    println(config);\n    \n    let success = write_status(config);\n    println(\"Write success:\");\n    println(success);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 2,
          "line_number": 72,
          "code": "fun save_game_state(level: i32, score: i32) {\n    println(\"Saving game state...\");\n    println(\"Level:\");\n    println(level);\n    println(\"Score:\");\n    println(score);\n    println(\"State saved successfully\");\n}\n\nfun load_game_state() {\n    println(\"Loading game state...\");\n    println(\"Level: 5\");\n    println(\"Score: 1000\");\n    println(\"State loaded successfully\");\n}\n\nfun main() {\n    save_game_state(5, 1000);\n    println(\"---\");\n    load_game_state();\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 3,
          "line_number": 118,
          "code": "fun get_default_config() -> i32 {\n    return 100;\n}\n\nfun validate_config(value: i32) -> bool {\n    if value > 0 && value <= 1000 {\n        return true;\n    }\n    return false;\n}\n\nfun apply_config(value: i32) {\n    println(\"Applying configuration...\");\n    println(\"Config value:\");\n    println(value);\n    if validate_config(value) {\n        println(\"Configuration applied successfully\");\n    } else {\n        println(\"Invalid configuration\");\n    }\n}\n\nfun main() {\n    let config = get_default_config();\n    apply_config(config);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 4,
          "line_number": 181,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nfun read_data() -> DataType {\n    // Return simulated data\n    return default_value;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `DataType` in this scope\n --> /tmp/.tmpGg82ck/main.rs:1:56\n  |\n1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n  |                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `default_value` in this scope\n --> /tmp/.tmpGg82ck/main.rs:1:76\n  |\n1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n  |                                                                            ^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpGg82ck/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpGg82ck/main.rs:1:67\n  |\n1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n  |                                                                   ^^                    ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n1 + use std :: collections :: HashMap ; fn read_data () -> DataType { return default_value } fn main () { }\n  |\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 5,
          "line_number": 192,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nfun write_data(value: DataType) -> bool {\n    // Validate and \"write\"\n    if valid(value) {\n        return true;\n    }\n    return false;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `DataType` in this scope\n --> /tmp/.tmpoSttq3/main.rs:1:60\n  |\n1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...\n  |                                                            ^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpoSttq3/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpoSttq3/main.rs:1:101\n  |\n1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...\n  |                                                                                                     ^^           ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } fn main () { }\n1 + use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { return true } ; return false } } fn main () { }\n  |\n\nerror[E0425]: cannot find function `valid` in this scope\n --> /tmp/.tmpoSttq3/main.rs:1:85\n  |\n1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...\n  |                                                                                     ^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 6,
          "line_number": 206,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nfun load_config() -> ConfigType {\n    return default_config;\n}\n\nfun save_config(config: ConfigType) -> bool {\n    return validate(config);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `ConfigType` in this scope\n --> /tmp/.tmpTN9DT5/main.rs:1:58\n  |\n1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...\n  |                                                          ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `default_config` in this scope\n --> /tmp/.tmpTN9DT5/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...\n  |                                                                                ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `ConfigType` in this scope\n --> /tmp/.tmpTN9DT5/main.rs:1:124\n  |\n1 | ...eturn default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpTN9DT5/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTN9DT5/main.rs:1:71\n  |\n1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...\n  |                                                                       ^^                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { return default_config } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTN9DT5/main.rs:1:146\n  |\n1 | ...g } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n  |                                                         ^^                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { return validate (config) } fn main () { }\n  |\n\nerror[E0425]: cannot find function `validate` in this scope\n --> /tmp/.tmpTN9DT5/main.rs:1:155\n  |\n1 | ...ve_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 7,
          "line_number": 234,
          "code": "fun load_settings() -> i32 {\n    return 50; // Default volume\n}\n\nfun save_settings(volume: i32) -> bool {\n    return volume >= 0 && volume <= 100;\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 8,
          "line_number": 248,
          "code": "fun save_progress(level: i32, score: i32) {\n    println(\"Saving progress...\");\n    println(level);\n    println(score);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 9,
          "line_number": 260,
          "code": "fun get_cached_value(key: i32) -> i32 {\n    // Simulate cache lookup\n    if key == 1 {\n        return 100;\n    }\n    return 0;\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 10,
          "line_number": 274,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun log_event(message: &str, severity: i32) {\n    println(\"LOG:\");\n    println(message);\n    println(\"Severity:\");\n    println(severity);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch05-00-control-flow-tdd": {
      "chapter": "ch05-00-control-flow-tdd",
      "total_examples": 14,
      "working_examples": 10,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun main() {\n    let x = 10;\n    if x > 5 {\n        println(\"x is greater than 5\");\n    } else {\n        println(\"x is not greater than 5\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 2,
          "line_number": 55,
          "code": "fun main() {\n    let score = 85;\n    if score >= 80 {\n        println(\"Great job!\");\n    }\n    println(\"Score processed\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 3,
          "line_number": 78,
          "code": "fun main() {\n    let grade = 75;\n    if grade >= 90 {\n        println(\"A grade\");\n    } else if grade >= 80 {\n        println(\"B grade\");\n    } else if grade >= 70 {\n        println(\"C grade\");\n    } else {\n        println(\"Below C\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 4,
          "line_number": 105,
          "code": "fun main() {\n    let mut i = 0;\n    while i < 3 {\n        println(i);\n        i = i + 1;\n    }\n    println(\"Done\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 5,
          "line_number": 131,
          "code": "fun main() {\n    for i in 0..3 {\n        println(i);\n    }\n    println(\"For loop done\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 6,
          "line_number": 155,
          "code": "fun main() {\n    let number = 2;\n    match number {\n        1 => println(\"One\"),\n        2 => println(\"Two\"),\n        3 => println(\"Three\"),\n        _ => println(\"Other\")\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 7,
          "line_number": 179,
          "code": "fun main() {\n    let mut i = 0;\n    while i < 10 {\n        i = i + 1;\n        if i == 3 {\n            continue;\n        }\n        if i == 6 {\n            break;\n        }\n        println(i);\n    }\n    println(\"Loop ended\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 8,
          "line_number": 236,
          "code": "let x = 10;\nlet y = 5;\n\nif x > y {\n    println(\"x is greater\");\n} else if x < y {\n    println(\"y is greater\");\n} else {\n    println(\"they are equal\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpXAE3Lx/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! (\"x is greater\") ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpXAE3Lx/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! (\"x is greater\") ...\n  |                                                                  ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpXAE3Lx/main.rs:1:83\n  |\n1 | use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! (\"x is greater\") ...\n  |                                                                                   ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXAE3Lx/main.rs:1:109\n  |\n1 | ... 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! (\"x is greater\") } } else { if x < y { { println ! (\"y is greater\") } ...\n  |                                                        ^^                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! (\"x is greater\") } } else { if x < y { { println ! (\"y is greater\") } } else { { println ! (\"they are equal\") } } } ; match std :: any :: type_name_of_val (& result) { name if name . contains (\"String\") || name . contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n1 + use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { println ! (\"x is greater\") } else { if x < y { { println ! (\"y is greater\") } } else { { println ! (\"they are equal\") } } } ; match std :: any :: type_name_of_val (& result) { name if name . contains (\"String\") || name . contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXAE3Lx/main.rs:1:160\n  |\n1 | ... { println ! (\"x is greater\") } } else { if x < y { { println ! (\"y is greater\") } } else { { println ! (\"they are equal\") } } } ; mat...\n  |                                                        ^^                          ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! (\"x is greater\") } } else { if x < y { { println ! (\"y is greater\") } } else { { println ! (\"they are equal\") } } } ; match std :: any :: type_name_of_val (& result) { name if name . contains (\"String\") || name . contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n1 + use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! (\"x is greater\") } } else { if x < y { println ! (\"y is greater\") } else { { println ! (\"they are equal\") } } } ; match std :: any :: type_name_of_val (& result) { name if name . contains (\"String\") || name . contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXAE3Lx/main.rs:1:200\n  |\n1 | ...if x < y { { println ! (\"y is greater\") } } else { { println ! (\"they are equal\") } } } ; match std :: any :: type_name_of_val (& resu...\n  |                                                       ^^                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! (\"x is greater\") } } else { if x < y { { println ! (\"y is greater\") } } else { { println ! (\"they are equal\") } } } ; match std :: any :: type_name_of_val (& result) { name if name . contains (\"String\") || name . contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n1 + use std :: collections :: HashMap ; fn main () { let x = 10i32 ; ; let y = 5i32 ; ; let result = if x > y { { println ! (\"x is greater\") } } else { if x < y { { println ! (\"y is greater\") } } else { println ! (\"they are equal\") } } ; match std :: any :: type_name_of_val (& result) { name if name . contains (\"String\") || name . contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n  |\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpXAE3Lx/main.rs:1:373\n  |\n1 | .... contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter\n  |                                       |\n  |                                       required by this formatting parameter\n  |\n  = help: the trait `std::fmt::Display` is not implemented for `()`\n  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 1 previous error; 6 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 9,
          "line_number": 250,
          "code": "// While loop\nlet mut count = 0;\nwhile count < 3 {\n    println(\"Count: \" + count);\n    count = count + 1;\n}\n\n// For loop with range\nfor i in 1..4 {\n    println(\"Iteration: \" + i);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 10,
          "line_number": 265,
          "code": "let number = 2;\nmatch number {\n    1 => println(\"One\"),\n    2 => println(\"Two\"),\n    3 => println(\"Three\"),\n    _ => println(\"Other\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpEeLCBe/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let number = 2i32 ; ; let result = match number { 1i32 => println ! (\"One\") , 2i32 => pr...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpEeLCBe/main.rs:1:70\n  |\n1 | use std :: collections :: HashMap ; fn main () { let number = 2i32 ; ; let result = match number { 1i32 => println ! (\"One\") , 2i32 => pr...\n  |                                                                      ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpEeLCBe/main.rs:1:351\n  |\n1 | .... contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter\n  |                                       |\n  |                                       required by this formatting parameter\n  |\n  = help: the trait `std::fmt::Display` is not implemented for `()`\n  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 11,
          "line_number": 290,
          "code": "let user_input = 75;\nlet threshold = 50;\n\nif user_input > threshold {\n    println(\"High value: \" + user_input);\n} else {\n    println(\"Normal value: \" + user_input);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpjgX1MU/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let user_input = 75i32 ; ; let threshold = 50i32 ; ; let result = if user_input > thresh...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpjgX1MU/main.rs:1:75\n  |\n1 | use std :: collections :: HashMap ; fn main () { let user_input = 75i32 ; ; let threshold = 50i32 ; ; let result = if user_input > thresh...\n  |                                                                           ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpjgX1MU/main.rs:1:101\n  |\n1 | use std :: collections :: HashMap ; fn main () { let user_input = 75i32 ; ; let threshold = 50i32 ; ; let result = if user_input > thresh...\n  |                                                                                                     ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpjgX1MU/main.rs:1:144\n  |\n1 | ... = if user_input > threshold { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"High value: \" , user_input)) } } else { { println ! (\"{:?}\" ,...\n  |                                   ^^                                                                    ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let user_input = 75i32 ; ; let threshold = 50i32 ; ; let result = if user_input > threshold { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"High value: \" , user_input)) } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Normal value: \" , user_input)) } } ; match std :: any :: type_name_of_val (& result) { name if name . contains (\"String\") || name . contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n1 + use std :: collections :: HashMap ; fn main () { let user_input = 75i32 ; ; let threshold = 50i32 ; ; let result = if user_input > threshold { println ! (\"{:?}\" , format ! (\"{}{}\" , \"High value: \" , user_input)) } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Normal value: \" , user_input)) } } ; match std :: any :: type_name_of_val (& result) { name if name . contains (\"String\") || name . contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpjgX1MU/main.rs:1:226\n  |\n1 | ...: \" , user_input)) } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Normal value: \" , user_input)) } } ; match std :: any :: type_...\n  |                                  ^^                                                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let user_input = 75i32 ; ; let threshold = 50i32 ; ; let result = if user_input > threshold { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"High value: \" , user_input)) } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Normal value: \" , user_input)) } } ; match std :: any :: type_name_of_val (& result) { name if name . contains (\"String\") || name . contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n1 + use std :: collections :: HashMap ; fn main () { let user_input = 75i32 ; ; let threshold = 50i32 ; ; let result = if user_input > threshold { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"High value: \" , user_input)) } } else { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Normal value: \" , user_input)) } ; match std :: any :: type_name_of_val (& result) { name if name . contains (\"String\") || name . contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n  |\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpjgX1MU/main.rs:1:439\n  |\n1 | .... contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter\n  |                                       |\n  |                                       required by this formatting parameter\n  |\n  = help: the trait `std::fmt::Display` is not implemented for `()`\n  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 1 previous error; 5 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 12,
          "line_number": 302,
          "code": "let mut count = 0;\nwhile count < 10 {\n    println(\"Count is: \" + count);\n    count = count + 1;\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 13,
          "line_number": 311,
          "code": "for i in 1..5 {\n    println(\"Processing item \" + i);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 14,
          "line_number": 321,
          "code": "let status_code = 200;\nmatch status_code {\n    200 => println(\"Success\"),\n    404 => println(\"Not Found\"),\n    500 => println(\"Server Error\"),\n    _ => println(\"Unknown Status\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpd6j3ca/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let status_code = 200i32 ; ; let result = match status_code { 200i32 => println ! (\"Succ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpd6j3ca/main.rs:1:77\n  |\n1 | use std :: collections :: HashMap ; fn main () { let status_code = 200i32 ; ; let result = match status_code { 200i32 => println ! (\"Succ...\n  |                                                                             ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpd6j3ca/main.rs:1:395\n  |\n1 | .... contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter\n  |                                       |\n  |                                       required by this formatting parameter\n  |\n  = help: the trait `std::fmt::Display` is not implemented for `()`\n  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "appendix-c-troubleshooting": {
      "chapter": "appendix-c-troubleshooting",
      "total_examples": 20,
      "working_examples": 3,
      "failing_examples": 17,
      "examples": [
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 1,
          "line_number": 25,
          "code": "// ❌ Error\nlet x = 42\nlet y = 24\n\n// ✅ Fixed\nlet x = 42;\nlet y = 24;\n\n// Note: Semicolons needed for statements, not expressions\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 2,
          "line_number": 47,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Error\nif condition {\n    do_something()\n// Missing closing brace\n\n// ✅ Fixed  \nif condition {\n    do_something()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 3,
          "line_number": 67,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Error\nlet 123invalid = \"nope\"\nlet my-var = \"no hyphens\"\nlet fn = \"keyword\"\n\n// ✅ Fixed\nlet invalid_123 = \"ok\"\nlet my_var = \"underscores ok\"\nlet function_name = \"not keyword\"",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 4,
          "line_number": 89,
          "code": "// ❌ Error\nlet x: i32 = \"string\"\n\n\n\n// ✅ Fixed\nlet x: i32 = 42\n// or\nlet x = \"string\"  // Let compiler infer type\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 5,
          "line_number": 111,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Error\nlet s = String::from(\"hello\")\nlet r = &s\nlet moved = *r  // Cannot move out of borrowed content\n\n// ✅ Fixed\nlet s = String::from(\"hello\")\nlet r = &s\nlet copied = r.clone()  // Clone instead of move",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 6,
          "line_number": 131,
          "code": "// ❌ Error\nlet s = String::from(\"hello\")\ntakes_ownership(s)\nprintln(s)  \n\n// ✅ Fixed - Option 1: Clone\nlet s = String::from(\"hello\")\ntakes_ownership(s.clone())\nprintln(s)  // s still valid\n\n// ✅ Fixed - Option 2: Borrow\nlet s = String::from(\"hello\")\nborrows_value(&s)\nprintln(s)  // s still valid\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpzwfJcf/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let s = String :: from (\"hello\" . to_string ()) ; ; takes_ownership (s) ; println ! (\"{:...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpzwfJcf/main.rs:1:100\n  |\n1 | use std :: collections :: HashMap ; fn main () { let s = String :: from (\"hello\" . to_string ()) ; ; takes_ownership (s) ; println ! (\"{:...\n  |                                                                                                    ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpzwfJcf/main.rs:1:199\n  |\n1 | ...; let s = String :: from (\"hello\" . to_string ()) ; ; takes_ownership (s . clone ()) ; println ! (\"{:?}\" , s) ; let s = String :: from...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpzwfJcf/main.rs:1:309\n  |\n1 | ...; let s = String :: from (\"hello\" . to_string ()) ; ; borrows_value (& s) ; println ! (\"{:?}\" , s) ; }\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `takes_ownership` in this scope\n --> /tmp/.tmpzwfJcf/main.rs:1:102\n  |\n1 | ... = String :: from (\"hello\" . to_string ()) ; ; takes_ownership (s) ; println ! (\"{:?}\" , s) ; let s = String :: from (\"hello\" . to_str...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `takes_ownership` in this scope\n --> /tmp/.tmpzwfJcf/main.rs:1:201\n  |\n1 | ... = String :: from (\"hello\" . to_string ()) ; ; takes_ownership (s . clone ()) ; println ! (\"{:?}\" , s) ; let s = String :: from (\"hell...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `borrows_value` in this scope\n --> /tmp/.tmpzwfJcf/main.rs:1:311\n  |\n1 | ...s = String :: from (\"hello\" . to_string ()) ; ; borrows_value (& s) ; println ! (\"{:?}\" , s) ; }\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 7,
          "line_number": 160,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Error\nfun dangle() -> &String {\n    let s = String::from(\"hello\")\n    &s  // s goes out of scope\n}\n\n// ✅ Fixed - Return owned value\nfun not_dangle() -> String {\n    let s = String::from(\"hello\")\n    s  // Move ownership\n}\n\n// ✅ Fixed - Use static lifetime\nfun static_str() -> &'static str {\n    \"hello\"  // String literals have static lifetime\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 8,
          "line_number": 187,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Error\nlet mut s = String::from(\"hello\")\nlet r1 = &mut s\nlet r2 = &mut s  // Error: ✗ Compilation failed: Failed to parse Ruchy source\nprintln(r1)\nprintln(r2)\n\n// ✅ Fixed - Use references sequentially\nlet mut s = String::from(\"hello\")\n{\n    let r1 = &mut s\n    // r1 scope ends here\n}\nlet r2 = &mut s  // Now ok",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 9,
          "line_number": 216,
          "code": "// ❌ Runtime panic\nlet v = vec![1, 2, 3]\nlet item = v[5]  // Panic: index out of bounds\n\n// ✅ Safe access\nlet v = vec![1, 2, 3]\nmatch v.get(5) {\n    Some(item) => println(\"Item: {}\", item),\n    None => println(\"Index out of bounds\"),\n}\n\n// ✅ Or use safe indexing\nif let Some(item) = v.get(5) {\n    println(\"Item: {}\", item)\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpXqxhbI/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let v = vec ! [1i32 , 2i32 , 3i32] ; ; let item = v [5i32 as usize] ; ; let v = vec ! [1...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpXqxhbI/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn main () { let v = vec ! [1i32 , 2i32 , 3i32] ; ; let item = v [5i32 as usize] ; ; let v = vec ! [1...\n  |                                                                                       ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpXqxhbI/main.rs:1:120\n  |\n1 | ...2 , 2i32 , 3i32] ; ; let item = v [5i32 as usize] ; ; let v = vec ! [1i32 , 2i32 , 3i32] ; ; match v . get (5i32) . cloned () { Some (...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpXqxhbI/main.rs:1:159\n  |\n1 | ... as usize] ; ; let v = vec ! [1i32 , 2i32 , 3i32] ; ; match v . get (5i32) . cloned () { Some (item) => println ! (\"{:?} {:?}\" , forma...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXqxhbI/main.rs:1:381\n  |\n1 | ...item) = v . get (5i32) . cloned () { { println ! (\"{:?} {:?}\" , format ! (\"Item: {{}}\") , item) } } ; match std :: any :: type_name_of...\n  |                                         ^^                                                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let v = vec ! [1i32 , 2i32 , 3i32] ; ; let item = v [5i32 as usize] ; ; let v = vec ! [1i32 , 2i32 , 3i32] ; ; match v . get (5i32) . cloned () { Some (item) => println ! (\"{:?} {:?}\" , format ! (\"Item: {{}}\") , item) , None => println ! (\"Index out of bounds\") , } ; let result = if let Some (item) = v . get (5i32) . cloned () { { println ! (\"{:?} {:?}\" , format ! (\"Item: {{}}\") , item) } } ; match std :: any :: type_name_of_val (& result) { name if name . contains (\"String\") || name . contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n1 + use std :: collections :: HashMap ; fn main () { let v = vec ! [1i32 , 2i32 , 3i32] ; ; let item = v [5i32 as usize] ; ; let v = vec ! [1i32 , 2i32 , 3i32] ; ; match v . get (5i32) . cloned () { Some (item) => println ! (\"{:?} {:?}\" , format ! (\"Item: {{}}\") , item) , None => println ! (\"Index out of bounds\") , } ; let result = if let Some (item) = v . get (5i32) . cloned () { println ! (\"{:?} {:?}\" , format ! (\"Item: {{}}\") , item) } ; match std :: any :: type_name_of_val (& result) { name if name . contains (\"String\") || name . contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n  |\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n   --> /tmp/.tmpXqxhbI/main.rs:1:176\n    |\n1   | ...[1i32 , 2i32 , 3i32] ; ; match v . get (5i32) . cloned () { Some (item) => println ! (\"{:?} {:?}\" , format ! (\"Item: {{}}\") , item) , ...\n    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`\n    |                                       |\n    |                                       required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n    = help: the following other types implement trait `SliceIndex<T>`:\n              `usize` implements `SliceIndex<ByteStr>`\n              `usize` implements `SliceIndex<[T]>`\nnote: required by a bound in `core::slice::<impl [T]>::get`\n   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12\n    |\n571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>\n    |            --- required by a bound in this associated function\n572 |     where\n573 |         I: SliceIndex<Self>,\n    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n   --> /tmp/.tmpXqxhbI/main.rs:1:361\n    |\n1   | ... result = if let Some (item) = v . get (5i32) . cloned () { { println ! (\"{:?} {:?}\" , format ! (\"Item: {{}}\") , item) } } ; match std...\n    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`\n    |                                       |\n    |                                       required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n    = help: the following other types implement trait `SliceIndex<T>`:\n              `usize` implements `SliceIndex<ByteStr>`\n              `usize` implements `SliceIndex<[T]>`\nnote: required by a bound in `core::slice::<impl [T]>::get`\n   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12\n    |\n571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>\n    |            --- required by a bound in this associated function\n572 |     where\n573 |         I: SliceIndex<Self>,\n    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpXqxhbI/main.rs:1:580\n  |\n1 | .... contains (\"&str\") => println ! (\"{}\" , result) , _ => println ! (\"{:?}\" , result) } }\n  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter\n  |                                       |\n  |                                       required by this formatting parameter\n  |\n  = help: the trait `std::fmt::Display` is not implemented for `()`\n  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 3 previous errors; 5 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 10,
          "line_number": 244,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Runtime panic\nlet maybe_value: Option<i32> = None\nlet value = maybe_value.unwrap()  // Panic: called unwrap on None\n\n// ✅ Safe handling\nlet maybe_value: Option<i32> = None\nmatch maybe_value {\n    Some(value) => println(\"Value: {}\", value),\n    None => println(\"No value\"),\n}\n\n// ✅ Or provide default\nlet value = maybe_value.unwrap_or(0)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 11,
          "line_number": 268,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Runtime panic\nfun divide(a: i32, b: i32) -> i32 {\n    a / b  // Panic if b is 0\n}\n\n// ✅ Safe division\nfun safe_divide(a: i32, b: i32) -> Option<i32> {\n    if b != 0 {\n        Some(a / b)\n    } else {\n        None\n    }\n}\n\n// ✅ Or return Result\nfun divide_result(a: i32, b: i32) -> Result<i32, String> {\n    if b != 0 {\n        Ok(a / b)\n    } else {\n        Err(\"Division by zero\".to_string())\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 12,
          "line_number": 303,
          "code": "// ❌ Infinite recursion causes stack overflow\nfun infinite_recursion(n: i32) -> i32 {\n    infinite_recursion(n + 1)  // No base case\n}\n\n// ✅ Proper recursion with base case\nfun factorial(n: i32) -> i32 {\n    if n <= 1 {\n        1  // Base case\n    } else {\n        n * factorial(n - 1)\n    }\n}\n\n// ✅ Or use iteration\nfun factorial_iterative(n: i32) -> i32 {\n    let mut result = 1\n    for i in 1..=n {\n        result *= i\n    }\n    result\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 13,
          "line_number": 338,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ May cause stack overflow\nfun large_array() {\n    let big_array: [i32; 1_000_000] = [0; 1_000_000]  // 4MB on stack\n}\n\n// ✅ Use heap allocation\nfun large_vector() {\n    let big_vector: Vec<i32> = vec![0; 1_000_000]  // Allocated on heap\n}\n\n// ✅ Or use Box for single large items\nfun boxed_array() {\n    let big_array: Box<[i32; 1_000_000]> = Box::new([0; 1_000_000])\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 14,
          "line_number": 365,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Inefficient - unnecessary clones\nfun process_strings(strings: Vec<String>) -> Vec<String> {\n    strings.iter()\n        .map(|s| s.clone().to_uppercase())  // Unnecessary clone\n        .collect()\n}\n\n// ✅ More efficient - work with references\nfun process_strings_efficient(strings: &[String]) -> Vec<String> {\n    strings.iter()\n        .map(|s| s.to_uppercase())  // to_uppercase() works on &str\n        .collect()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 15,
          "line_number": 389,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Inefficient - creates many temporary strings\nfun concat_inefficient(strings: &[&str]) -> String {\n    let mut result = String::new()\n    for s in strings {\n        result = result + s  // Creates new string each time\n    }\n    result\n}\n\n// ✅ Efficient - reuses buffer\nfun concat_efficient(strings: &[&str]) -> String {\n    let mut result = String::new()\n    for s in strings {\n        result.push_str(s)  // Appends to existing string\n    }\n    result\n}\n\n// ✅ Even better - pre-allocate capacity\nfun concat_with_capacity(strings: &[&str]) -> String {\n    let total_len: usize = strings.iter().map(|s| s.len()).sum()\n    let mut result = String::with_capacity(total_len)\n    for s in strings {\n        result.push_str(s)\n    }\n    result\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 16,
          "line_number": 427,
          "code": "// ❌ Wrong collection for use case\nuse std::collections::VecDeque\n\nlet mut list = Vec::new()\n// Frequent insertions at beginning - O(n) for each insert\nfor i in 0..1000 {\n    list.insert(0, i)\n}\n\n// ✅ Better collection choice\nlet mut deque = VecDeque::new()\n// Efficient insertion at front - O(1)\nfor i in 0..1000 {\n    deque.push_front(i)\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpXNiccP/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .....\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpXNiccP/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .....\n  |                                                                                       ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpXNiccP/main.rs:1:120\n  |\n1 | ...ions :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecD...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpXNiccP/main.rs:1:219\n  |\n1 | ...i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXNiccP/main.rs:1:149\n  |\n1 | ... list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in ...\n  |                                                         ^^                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }\n1 + use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { list . insert (0i32 , i) } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXNiccP/main.rs:1:248\n  |\n1 | ...e = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }\n  |                                                          ^^                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }\n1 + use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { deque . push_front (i) } ; }\n  |\n\nerror[E0308]: mismatched types\n    --> /tmp/.tmpXNiccP/main.rs:1:166\n     |\n1    | ... () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { ...\n     |                                                ------  ^^^^ expected `usize`, found `i32`\n     |                                                |\n     |                                                arguments to this method are incorrect\n     |\nnote: method defined here\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2034:12\n     |\n2034 |     pub fn insert(&mut self, index: usize, element: T) {\n     |            ^^^^^^\nhelp: change the type of the numeric literal from `i32` to `usize`\n     |\n1    - use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }\n1    + use std :: collections :: HashMap ; fn main () { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; ; for i in 0i32 .. 1000i32 { { list . insert (0usize , i) } } ; let mut deque = VecDeque :: new () ; ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } ; }\n     |\n\nerror: aborting due to 1 previous error; 6 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 17,
          "line_number": 470,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\n// ❌ Error: no method named `json` found for type `Response`\nlet response = reqwest::get(url).await?\nlet data = response.json().await?  // Feature not enabled\n\n// ✅ Enable required features in Cargo.toml\n// [dependencies]\n// reqwest = { version = \"0.11\", features = [\"json\"] }",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `url` in this scope\n --> /tmp/.tmpdWMKtu/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { let response = reqwest :: get (url) . await ? ; ; let data = response . json () . await ...\n  |                                                                                 ^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpdWMKtu/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let response = reqwest :: get (url) . await ? ; ; let data = response . json () . await ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpdWMKtu/main.rs:1:98\n  |\n1 | use std :: collections :: HashMap ; fn main () { let response = reqwest :: get (url) . await ? ; ; let data = response . json () . await ...\n  |                                                                                                  ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpdWMKtu/main.rs:1:142\n  |\n1 | ...ait ? ; ; let data = response . json () . await ? ; ; }\n  |                                                        ^ help: remove this semicolon\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`\n --> /tmp/.tmpdWMKtu/main.rs:1:65\n  |\n1 | use std :: collections :: HashMap ; fn main () { let response = reqwest :: get (url) . await ? ; ; let data = response . json () . await ...\n  |                                                                 ^^^^^^^ use of unresolved module or unlinked crate `reqwest`\n  |\n  = help: you might be missing a crate named `reqwest`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 18,
          "line_number": 591,
          "code": "// Simple debug prints\nprintln!(\"Debug: x = {}\", x)\nprintln!(\"Debug: {:?}\", complex_struct)  // Debug formatting\nprintln!(\"Debug: {:#?}\", nested_struct)  // Pretty debug formatting\n\n// Conditional debug prints\n#[cfg(debug_assertions)]\nprintln!(\"This only prints in debug builds\")\n\n// Debug macro\ndebug!(\"Variable state: x={}, y={}\", x, y)\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 19,
          "line_number": 630,
          "code": "use log::{debug, info, warn, error}\n\nfun main() {\n    env_logger::init()\n    \n    debug!(\"This is a debug message\")\n    info!(\"This is info\")\n    warn!(\"This is a warning\")\n    error!(\"This is an error\")\n}\n\n// Control log level with environment variable\n// RUST_LOG=debug cargo run\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 20,
          "line_number": 656,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n#[cfg(test)]\nmod tests {\n    use super::*\n    \n    #[test]\n    fun test_with_debug_output() {\n        let result = my_function(42)\n        \n        // Print for debugging (use -- --nocapture to see output)\n        println!(\"Result: {:?}\", result)\n        \n        assert_eq!(result, expected)\n    }\n    \n    // Run with: cargo test -- --nocapture\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch05-00-data-processing": {
      "chapter": "ch05-00-data-processing",
      "total_examples": 10,
      "working_examples": 1,
      "failing_examples": 9,
      "examples": [
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 1,
          "line_number": 48,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: sales_analyzer.ruchy\n// Analyzes sales data from CSV file\n\nprintln(\"=== Sales Data Analyzer ===\")\n\n// Read CSV data (simplified - in practice you'd use CSV parser)\nlet sales_data = [\n    [\"Date\", \"Product\", \"Amount\", \"Region\"],\n    [\"2024-01-15\", \"Laptop\", \"1299\", \"North\"],\n    [\"2024-01-16\", \"Mouse\", \"25\", \"South\"], \n    [\"2024-01-17\", \"Keyboard\", \"79\", \"North\"],\n    [\"2024-01-18\", \"Laptop\", \"1299\", \"East\"],\n    [\"2024-01-19\", \"Monitor\", \"399\", \"West\"]\n]\n\n// Process data\nlet total_sales = 0\nlet product_counts = {}\nlet region_sales = {}\n\nfor row in sales_data[1..] {  // Skip header\n    let product = row[1]\n    let amount = row[2].to_f()\n    let region = row[3]\n    \n    // Calculate totals\n    total_sales += amount\n    \n    // Count products\n    product_counts[product] = product_counts.get(product, 0) + 1\n    \n    // Sum by region\n    region_sales[region] = region_sales.get(region, 0) + amount\n}\n\n// Display results\nprintln(\"Total Sales: $\" + total_sales.to_s())\nprintln(\"Average Sale: $\" + (total_sales / (sales_data.len() - 1)).to_s())\n\nprintln(\"\\nTop Products:\")\nfor product, count in product_counts.items() {\n    println(\"  \" + product + \": \" + count.to_s() + \" sales\")\n}\n\nprintln(\"\\nSales by Region:\")\nfor region, amount in region_sales.items() {\n    println(\"  \" + region + \": $\" + amount.to_s())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 2,
          "line_number": 132,
          "code": "// Arrays for sequences\nlet sales_amounts = [1299, 25, 79, 1299, 399]\nlet monthly_revenue = [45000, 52000, 48000, 61000]\n\n// Dictionaries for key-value mapping  \nlet customer_orders = {\n    \"alice@email.com\": 5,\n    \"bob@email.com\": 2,\n    \"carol@email.com\": 8\n}\n\n// Arrays of dictionaries for structured records\nlet transactions = [\n    {\"id\": 1001, \"amount\": 1299, \"customer\": \"alice@email.com\"},\n    {\"id\": 1002, \"amount\": 25, \"customer\": \"bob@email.com\"},\n    {\"id\": 1003, \"amount\": 79, \"customer\": \"alice@email.com\"}\n]",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 3,
          "line_number": 163,
          "code": "// Sum and averages\nlet total = numbers.sum()\nlet average = numbers.sum() / numbers.len()\nlet maximum = numbers.max()\nlet minimum = numbers.min()\n\n// Grouping and counting\nfun group_by_field(records, field) {\n    let groups = {}\n    for record in records {\n        let key = record[field]\n        if !groups.has_key(key) {\n            groups[key] = []\n        }\n        groups[key].push(record)\n    }\n    return groups\n}\n\n// Filtering and transformation\nlet high_value = transactions.filter(|t| t.amount > 100)\nlet customer_ids = transactions.map(|t| t.customer)\nlet amounts_only = transactions.map(|t| t.amount)\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmpWe47o9/main.rs:1:356\n  |\n1 | ...} ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maxi...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmpWe47o9/main.rs:1:391\n  |\n1 | ...) { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let mini...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmpWe47o9/main.rs:1:410\n  |\n1 | ...bers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmpWe47o9/main.rs:1:445\n  |\n1 | ...bers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactio...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmpWe47o9/main.rs:1:480\n  |\n1 | ...; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `transactions` in this scope\n --> /tmp/.tmpWe47o9/main.rs:1:518\n  |\n1 | ... minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec <...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `transactions` in this scope\n --> /tmp/.tmpWe47o9/main.rs:1:635\n  |\n1 | ...ollect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; le...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `transactions` in this scope\n --> /tmp/.tmpWe47o9/main.rs:1:737\n  |\n1 | ...ollect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpWe47o9/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpWe47o9/main.rs:1:100\n  |\n1 | ... { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } ...\n  |       ^^                                                                                                                                                                                                                                ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }\n1 + use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpWe47o9/main.rs:1:148\n  |\n1 | ... { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ...\n  |       ^^                                                                                                                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }\n1 + use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpWe47o9/main.rs:1:220\n  |\n1 | ...ield as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } ...\n  |                                                     ^^                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }\n1 + use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { groups [key as usize] = vec ! [] } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpWe47o9/main.rs:1:375\n  |\n1 | ...} } } } fn main () { let total = numbers . sum () ; ; let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . ma...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpWe47o9/main.rs:1:429\n  |\n1 | ...let average = numbers . sum () / numbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_v...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpWe47o9/main.rs:1:464\n  |\n1 | ...mbers . len () ; ; let maximum = numbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpWe47o9/main.rs:1:499\n  |\n1 | ...mbers . max () ; ; let minimum = numbers . min () ; ; let high_value = transactions . into_iter () . filter (| t | t . amount > 100i32...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpWe47o9/main.rs:1:614\n  |\n1 | ...t . amount > 100i32) . collect :: < Vec < _ >> () ; ; let customer_ids = transactions . iter () . map (| t | t . customer) . collect :...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpWe47o9/main.rs:1:716\n  |\n1 | ...(| t | t . customer) . collect :: < Vec < _ >> () ; ; let amounts_only = transactions . iter () . map (| t | t . amount) . collect :: ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpWe47o9/main.rs:1:816\n  |\n1 | ...p (| t | t . amount) . collect :: < Vec < _ >> () ; ; }\n  |                                                        ^ help: remove this semicolon\n\nerror[E0277]: `String` is not an iterator\n --> /tmp/.tmpWe47o9/main.rs:1:138\n  |\n1 | ...groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize...\n  |                                  ^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n  |\n  = help: the trait `Iterator` is not implemented for `String`\n  = note: required for `String` to implement `IntoIterator`\n\nerror[E0599]: no method named `has_key` found for unit type `()` in the current scope\n --> /tmp/.tmpWe47o9/main.rs:1:204\n  |\n1 | ...et key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . pu...\n  |                                                       ^^^^^^^ method not found in `()`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpWe47o9/main.rs:1:316\n  |\n1 | ...-> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } ...\n  |       --- expected `i32` because of return type                                                                                                                                                                                     ^^^^^^ expected `i32`, found `()`\n\nerror[E0605]: non-primitive cast: `String` as `usize`\n --> /tmp/.tmpWe47o9/main.rs:1:170\n  |\n1 | ...rd [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) }...\n  |        ^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror: aborting due to 12 previous errors; 11 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0599, E0605.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: has_key()"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 4,
          "line_number": 201,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// CSV-like processing (simplified)\nfun parse_csv_line(line) {\n    return line.split(\",\").map(|field| field.trim())\n}\n\nfun load_csv(filename) {\n    let lines = read_lines(filename)\n    let header = parse_csv_line(lines[0])\n    let data = []\n    \n    for line in lines[1..] {\n        let fields = parse_csv_line(line)\n        let record = {}\n        for i, field in fields.enumerate() {\n            record[header[i]] = field\n        }\n        data.push(record)\n    }\n    \n    return data\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 5,
          "line_number": 236,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: customer_analytics.ruchy\n// Analyzes customer purchase patterns\n\nprintln(\"=== Customer Analytics Tool ===\")\n\n// Sample customer data (in practice, load from file)\nlet customers = [\n    {\"name\": \"Alice\", \"email\": \"alice@email.com\", \"orders\": 5, \"total_spent\": 2500, \"signup_date\": \"2023-06-15\"},\n    {\"name\": \"Bob\", \"email\": \"bob@email.com\", \"orders\": 2, \"total_spent\": 150, \"signup_date\": \"2024-01-20\"},\n    {\"name\": \"Carol\", \"email\": \"carol@email.com\", \"orders\": 8, \"total_spent\": 4200, \"signup_date\": \"2023-03-10\"},\n    {\"name\": \"David\", \"email\": \"david@email.com\", \"orders\": 1, \"total_spent\": 75, \"signup_date\": \"2024-02-01\"}\n]\n\n// Calculate key metrics\nlet total_customers = customers.len()\nlet total_revenue = customers.map(|c| c.total_spent).sum()\nlet average_order_value = total_revenue / customers.map(|c| c.orders).sum()\nlet average_customer_value = total_revenue / total_customers\n\nprintln(\"Customer Base: \" + total_customers.to_s() + \" customers\")\nprintln(\"Total Revenue: $\" + total_revenue.to_s())\nprintln(\"Average Order Value: $\" + average_order_value.to_s())\nprintln(\"Average Customer Value: $\" + average_customer_value.to_s())\n\n// Segment customers\nlet vip_customers = customers.filter(|c| c.total_spent > 1000)\nlet new_customers = customers.filter(|c| c.signup_date.starts_with(\"2024\"))\nlet frequent_buyers = customers.filter(|c| c.orders > 5)\n\nprintln(f\"\\nCustomer Segments:\")\nprintln(\"VIP Customers (>$1000): \" + vip_customers.len().to_s())\nprintln(\"New Customers (2024): \" + new_customers.len().to_s())\nprintln(\"Frequent Buyers (>5 orders): \" + frequent_buyers.len().to_s())\n\n// Top customers by spending\nlet top_spenders = customers.sort_by(|c| -c.total_spent)[..3]\nprintln(f\"\\nTop Spenders:\")\nfor i, customer in top_spenders.enumerate() {\n    println(\"  \" + (i+1).to_s() + \". \" + customer.name + \": $\" + customer.total_spent.to_s() + \" (\" + customer.orders.to_s() + \" orders)\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 6,
          "line_number": 288,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: advanced_log_analyzer.ruchy\n// Comprehensive log file analysis\n\nprintln(\"=== Advanced Log Analyzer ===\")\n\n// Sample log entries (in practice, read from file)\nlet log_entries = [\n    \"2024-08-19 10:15:32 INFO User login: alice@email.com\",\n    \"2024-08-19 10:16:45 ERROR Database connection failed\", \n    \"2024-08-19 10:17:12 INFO User login: bob@email.com\",\n    \"2024-08-19 10:18:33 WARN Slow query detected: 2.5s\",\n    \"2024-08-19 10:19:44 ERROR 404 Not Found: /api/users/999\",\n    \"2024-08-19 10:20:15 INFO User logout: alice@email.com\"\n]\n\n// Parse log entries\nfun parse_log_entry(entry) {\n    let parts = entry.split(\" \")\n    return {\n        \"date\": parts[0],\n        \"time\": parts[1], \n        \"level\": parts[2],\n        \"message\": parts[3..].join(\" \")\n    }\n}\n\nlet parsed_logs = log_entries.map(parse_log_entry)\n\n// Analyze by level\nlet level_counts = {}\nfor log in parsed_logs {\n    let level = log.level\n    level_counts[level] = level_counts.get(level, 0) + 1\n}\n\nprintln(\"Log Level Summary:\")\nfor level, count in level_counts.items() {\n    let emoji = match level {\n        \"INFO\" => \"ℹ️\",\n        \"WARN\" => \"⚠️\", \n        \"ERROR\" => \"❌\",\n        _ => \"📝\"\n    }\n    println(\"  \" + emoji + \" \" + level + \": \" + count.to_s() + \" entries\")\n}\n\n// Find errors and warnings\nlet issues = parsed_logs.filter(|log| log.level == \"ERROR\" || log.level == \"WARN\")\nprintln(\"\\nIssues Found (\" + issues.len().to_s() + \"):\")\nfor issue in issues {\n    println(\"  \" + issue.time + \" \" + issue.level + \": \" + issue.message)\n}\n\n// Extract user activity\nlet user_actions = parsed_logs.filter(|log| log.message.contains(\"User\"))\nprintln(\"\\nUser Activity (\" + user_actions.len().to_s() + \" actions):\")\nfor action in user_actions {\n    println(\"  \" + action.time + \": \" + action.message)\n}\n\n// Time-based analysis\nlet hours = parsed_logs.map(|log| log.time.split(\":\")[0])\nlet hour_counts = {}\nfor hour in hours {\n    hour_counts[hour] = hour_counts.get(hour, 0) + 1\n}\n\nlet busiest_hour = hour_counts.max_by_value()\nprintln(\"\\nBusiest Hour: \" + busiest_hour.key + \":xx (\" + busiest_hour.value.to_s() + \" entries)\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 7,
          "line_number": 369,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: finance_processor.ruchy\n// Processes financial transactions and generates reports\n\nprintln(\"=== Financial Data Processor ===\")\n\n// Transaction data structure\nlet transactions = [\n    {\"date\": \"2024-01-15\", \"type\": \"income\", \"category\": \"salary\", \"amount\": 5000, \"description\": \"Monthly salary\"},\n    {\"date\": \"2024-01-16\", \"type\": \"expense\", \"category\": \"rent\", \"amount\": 1200, \"description\": \"Apartment rent\"},\n    {\"date\": \"2024-01-17\", \"type\": \"expense\", \"category\": \"groceries\", \"amount\": 85, \"description\": \"Weekly shopping\"},\n    {\"date\": \"2024-01-18\", \"type\": \"expense\", \"category\": \"utilities\", \"amount\": 150, \"description\": \"Electricity bill\"},\n    {\"date\": \"2024-01-20\", \"type\": \"income\", \"category\": \"freelance\", \"amount\": 800, \"description\": \"Web design project\"}\n]\n\n// Calculate totals\nlet total_income = transactions.filter(|t| t.type == \"income\").map(|t| t.amount).sum()\nlet total_expenses = transactions.filter(|t| t.type == \"expense\").map(|t| t.amount).sum()\nlet net_income = total_income - total_expenses\n\nprintln(f\"Financial Summary:\")\nprintln(\"Total Income: $\" + total_income.to_s())\nprintln(\"Total Expenses: $\" + total_expenses.to_s())\nprintln(\"Net Income: $\" + net_income.to_s())\nprintln(\"Savings Rate: \" + (net_income * 100 / total_income).to_s() + \"%\")\n\n// Expense breakdown by category\nlet expense_categories = {}\nfor transaction in transactions.filter(|t| t.type == \"expense\") {\n    let category = transaction.category\n    expense_categories[category] = expense_categories.get(category, 0) + transaction.amount\n}\n\nprintln(f\"\\nExpense Breakdown:\")\nfor category, amount in expense_categories.items() {\n    let percentage = (amount * 100) / total_expenses\n    println(\"  \" + category.capitalize() + \": $\" + amount.to_s() + \" (\" + percentage.to_s() + \"%)\")\n}\n\n// Budget analysis\nlet budget_limits = {\n    \"rent\": 1500,\n    \"groceries\": 400, \n    \"utilities\": 200,\n    \"entertainment\": 300\n}\n\nprintln(f\"\\nBudget Analysis:\")\nfor category, limit in budget_limits.items() {\n    let spent = expense_categories.get(category, 0)\n    let remaining = limit - spent\n    let status = if remaining >= 0 { \"✅ Under budget\" } else { \"❌ Over budget\" }\n    println(\"  \" + category.capitalize() + \": $\" + spent.to_s() + \"/$\" + limit.to_s() + \" - \" + status)\n}\n\n// Monthly trend (if we had multiple months of data)\nprintln(\"\\nTransaction History (\" + transactions.len().to_s() + \" transactions):\")\nfor transaction in transactions.sort_by(|t| t.date) {\n    let emoji = if transaction.type == \"income\" { \"💰\" } else { \"💸\" }\n    println(\"  \" + transaction.date + \" \" + emoji + \" $\" + transaction.amount.to_s() + \" - \" + transaction.description)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 8,
          "line_number": 443,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\n// Simple bar chart function\nfun draw_bar_chart(data, title) {\n    println(\"\\n\" + title)\n    println(\"=\" * title.len())\n    \n    let max_value = data.values().max()\n    let max_bar_width = 50\n    \n    for key, value in data.items() {\n        let bar_width = (value * max_bar_width) / max_value\n        let bar = \"█\" * bar_width.to_i()\n        println(key + \" │\" + bar + \" \" + value.to_s())\n    }\n}\n\n// Usage example\nlet monthly_sales = {\n    \"January\": 45000,\n    \"February\": 52000,\n    \"March\": 48000,\n    \"April\": 61000,\n    \"May\": 58000\n}\n\ndraw_bar_chart(monthly_sales, \"Monthly Sales Report\")",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpJhRLRv/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n\" , ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpJhRLRv/main.rs:1:268\n  |\n1 | ... values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . iter () . map (| (k , v) | (k . clone () , v . clone...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpJhRLRv/main.rs:1:358\n  |\n1 | ... { { { let bar_width = value * max_bar_width / max_value ; { let bar = \"█\" * bar_width . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") , bar) , \" \") , value . to_s ())) } } } } ...\n  |       ^^                                                                                                                                                                                                                                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{:?}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let bar_width = value * max_bar_width / max_value ; { let bar = \"█\" * bar_width . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") , bar) , \" \") , value . to_s ())) } } } } } } } } fn main () { let monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"January\" . to_string () , (45000i32) . to_string ()) ; map . insert (\"February\" . to_string () , (52000i32) . to_string ()) ; map . insert (\"March\" . to_string () , (48000i32) . to_string ()) ; map . insert (\"April\" . to_string () , (61000i32) . to_string ()) ; map . insert (\"May\" . to_string () , (58000i32) . to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n1 + use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{:?}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { let bar_width = value * max_bar_width / max_value ; { let bar = \"█\" * bar_width . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") , bar) , \" \") , value . to_s ())) } } } } } } } fn main () { let monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"January\" . to_string () , (45000i32) . to_string ()) ; map . insert (\"February\" . to_string () , (52000i32) . to_string ()) ; map . insert (\"March\" . to_string () , (48000i32) . to_string ()) ; map . insert (\"April\" . to_string () , (61000i32) . to_string ()) ; map . insert (\"May\" . to_string () , (58000i32) . to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpJhRLRv/main.rs:1:454\n  |\n1 | ...max_value ; { let bar = \"█\" * bar_width . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , for...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpJhRLRv/main.rs:1:1108\n  |\n1 | ...to_string () , (58000i32) . to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n  |                                                        ^ help: remove this semicolon\n\nerror[E0369]: cannot multiply `&str` by `usize`\n --> /tmp/.tmpJhRLRv/main.rs:1:172\n  |\n1 | ...rmat ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{:?}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let max_...\n  |                                                          --- ^ -------------- usize\n  |                                                          |\n  |                                                          &str\n\nerror[E0599]: no method named `values` found for struct `String` in the current scope\n --> /tmp/.tmpJhRLRv/main.rs:1:217\n  |\n1 | ...\"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . iter...\n  |                                                     ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n --> /tmp/.tmpJhRLRv/main.rs:1:298\n  |\n1 | ...bar_width = 50i32 ; ; for (key , value) in data . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let bar_width = valu...\n  |                                                      ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n  |\n1 - use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{:?}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . iter () . map (| (k , v) | (k . clone () , v . clone ())) { { { let bar_width = value * max_bar_width / max_value ; { let bar = \"█\" * bar_width . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") , bar) , \" \") , value . to_s ())) } } } } } } } } fn main () { let monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"January\" . to_string () , (45000i32) . to_string ()) ; map . insert (\"February\" . to_string () , (52000i32) . to_string ()) ; map . insert (\"March\" . to_string () , (48000i32) . to_string ()) ; map . insert (\"April\" . to_string () , (61000i32) . to_string ()) ; map . insert (\"May\" . to_string () , (58000i32) . to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n1 + use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{:?}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let max_bar_width = 50i32 ; ; for (key , value) in data . chars () . map (| (k , v) | (k . clone () , v . clone ())) { { { let bar_width = value * max_bar_width / max_value ; { let bar = \"█\" * bar_width . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") , bar) , \" \") , value . to_s ())) } } } } } } } } fn main () { let monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"January\" . to_string () , (45000i32) . to_string ()) ; map . insert (\"February\" . to_string () , (52000i32) . to_string ()) ; map . insert (\"March\" . to_string () , (48000i32) . to_string ()) ; map . insert (\"April\" . to_string () , (61000i32) . to_string ()) ; map . insert (\"May\" . to_string () , (58000i32) . to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n  |\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpJhRLRv/main.rs:1:420\n  |\n1 | ...= value * max_bar_width / max_value ; { let bar = \"█\" * bar_width . to_i () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}...\n  |                                                ^^^ doesn't have a size known at compile-time\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: all local variables must have a statically known size\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpJhRLRv/main.rs:1:566\n  |\n1 | ...! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") , bar) , \" \") , value . to_s ())) } } } } } } } } fn main () { let month...\n  |                             --                                     ^^^ doesn't have a size known at compile-time\n  |                             |\n  |                             required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpJhRLRv/main.rs:1:1126\n  |\n1 | ... to_string ()) ; map } ; ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n  |                               --------------  ^^^^^^^^^^^^^ expected `String`, found `HashMap<String, String>`\n  |                               |\n  |                               arguments to this function are incorrect\n  |\n  = note: expected struct `String`\n             found struct `HashMap<String, String>`\nnote: function defined here\n --> /tmp/.tmpJhRLRv/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n\" , ...\n  |                                        ^^^^^^^^^^^^^^  -------------\n\nerror: aborting due to 6 previous errors; 5 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: values()"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 9,
          "line_number": 497,
          "code": "let sales_data = load_csv(\"sales.csv\")\nlet total = sales_data.map(|row| row.amount.to_f()).sum()\nlet average = total / sales_data.len()\nprintln(\"Average sale: $\" + average.to_s())\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpU0dR8s/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let sales_data = load_csv (\"sales.csv\" . to_string ()) ; ; let total = sales_data . iter...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpU0dR8s/main.rs:1:107\n  |\n1 | ...ales_data = load_csv (\"sales.csv\" . to_string ()) ; ; let total = sales_data . iter () . map (| row | row . amount . to_f ()) . collec...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpU0dR8s/main.rs:1:221\n  |\n1 | ... . to_f ()) . collect :: < Vec < _ >> () . sum () ; ; let average = total / sales_data . len () ; ; println ! (\"{:?}\" , format ! (\"{}{...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpU0dR8s/main.rs:1:267\n  |\n1 | ... () ; ; let average = total / sales_data . len () ; ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Average sale: $\" , average . to_s ())) ; }\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `load_csv` in this scope\n --> /tmp/.tmpU0dR8s/main.rs:1:67\n  |\n1 | use std :: collections :: HashMap ; fn main () { let sales_data = load_csv (\"sales.csv\" . to_string ()) ; ; let total = sales_data . iter...\n  |                                                                   ^^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 10,
          "line_number": 593,
          "code": "// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// expense_tracker.ruchy - Track and analyze personal expenses\n\nlet EXPENSES_FILE = \"expenses.csv\"\n\nfun save_expense(date, category, amount, description) {\n    let entry = date + \",\" + category + \",\" + amount.to_s() + \",\" + description + \"\\n\"\n    append_file(EXPENSES_FILE, entry)\n}\n\nfun load_expenses() {\n    if !file_exists(EXPENSES_FILE) {\n        // Create header if file doesn't exist\n        write_file(EXPENSES_FILE, \"Date,Category,Amount,Description\\n\")\n        return []\n    }\n    \n    let lines = read_lines(EXPENSES_FILE)[1..]  // Skip header\n    let expenses = []\n    \n    for line in lines {\n        let parts = line.split(\",\")\n        expenses.push({\n            \"date\": parts[0],\n            \"category\": parts[1], \n            \"amount\": parts[2].to_f(),\n            \"description\": parts[3]\n        })\n    }\n    \n    return expenses\n}\n\nfun analyze_expenses(expenses) {\n    let total = expenses.map(|e| e.amount).sum()\n    let average = total / expenses.len()\n    \n    // Category breakdown\n    let categories = {}\n    for expense in expenses {\n        categories[expense.category] = categories.get(expense.category, 0) + expense.amount\n    }\n    \n    println(\"\\n💰 Expense Analysis (\" + expenses.len().to_s() + \" transactions)\")\n    println(\"Total Spent: $\" + total.to_s())\n    println(\"Average Transaction: $\" + average.to_s())\n    \n    println(f\"\\n📊 Spending by Category:\")\n    for category, amount in categories.items().sort_by(|item| -item.value) {\n        let percentage = (amount * 100) / total\n        println(\"  \" + category + \": $\" + amount.to_s() + \" (\" + percentage.to_s() + \"%)\")\n    }\n    \n    // Recent transactions\n    let recent = expenses.sort_by(|e| -e.date)[..5]  // Last 5\n    println(f\"\\n🕒 Recent Transactions:\")\n    for expense in recent {\n        println(\"  \" + expense.date + \" $\" + expense.amount.to_s() + \" \" + expense.category + \" \" + expense.description)\n    }\n}\n\nfun main_menu() {\n    println(\"\\n=== Personal Expense Tracker ===\")\n    println(\"1. Add expense\")\n    println(\"2. View analysis\") \n    println(\"3. Export data\")\n    println(\"4. Quit\")\n    \n    let choice = input(\"\\nChoose option: \")\n    \n    match choice {\n        \"1\" => {\n            let date = input(\"Date (YYYY-MM-DD): \")\n            let category = input(\"Category: \")\n            let amount = input(\"Amount: $\").to_f()\n            let description = input(\"Description: \")\n            \n            save_expense(date, category, amount, description)\n            println(\"✅ Expense added!\")\n        }\n        \"2\" => {\n            let expenses = load_expenses()\n            if expenses.is_empty() {\n                println(\"📝 No expenses recorded yet\")\n            } else {\n                analyze_expenses(expenses)\n            }\n        }\n        \"3\" => {\n            println(\"📁 Data exported to: \" + EXPENSES_FILE)\n            println(\"Open in spreadsheet application for advanced analysis\")\n        }\n        \"4\" => {\n            println(\"💸 Happy budgeting!\")\n            return false\n        }\n        _ => {\n            println(\"❌ Invalid choice\")\n        }\n    }\n    \n    return true\n}\n\n// Main program loop\nwhile main_menu() {\n    // Continue until user quits\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch01-02-hello-world": {
      "chapter": "ch01-02-hello-world",
      "total_examples": 8,
      "working_examples": 8,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 1,
          "line_number": 30,
          "code": "fun main() {\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 2,
          "line_number": 86,
          "code": "fun main() {\n    println(\"Hello\", \"World\", \"from\", \"Ruchy\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 3,
          "line_number": 106,
          "code": "fun main() {\n    let name = \"Alice\";\n    println(\"Hello,\", name);\n    \n    // String concatenation (interpolation coming in future versions)\n    println(\"Hello, \" + name + \"!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 4,
          "line_number": 131,
          "code": "fun main() {\n    println(\"The answer is\", 42);\n    println(\"Pi is approximately\", 3.14159);\n    println(\"Is Ruchy awesome?\", true);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 5,
          "line_number": 156,
          "code": "// ❌ This won't work - intentional error example\n// println(Hello, World!);\n//\n\n// Always use quotes for literal text.\n\nfun main() {\n    // ✅ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 6,
          "line_number": 176,
          "code": "// ❌ Quotes don't match - intentional error example\n// println(\"Hello, World!');\n//\n\n// Use either \"...\" or '...' but be consistent.\n\nfun main() {\n    // ✅ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 7,
          "line_number": 196,
          "code": "// ❌ Wrong capitalization - intentional error example\n// PrintLn(\"Hello, World!\");\n//\n\n\nfun main() {\n    // ✅ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 8,
          "line_number": 222,
          "code": "fun main() {\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch02-00-variables-types": {
      "chapter": "ch02-00-variables-types",
      "total_examples": 9,
      "working_examples": 7,
      "failing_examples": 2,
      "examples": [
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 1,
          "line_number": 30,
          "code": "fun main() {\n    let name = \"Alice\"\n    let age = 25\n    let is_learning = true\n\n    println(\"Hi\", name, \", you're\", age, \"years old!\")\n    println(\"Currently learning Ruchy:\", is_learning)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 2,
          "line_number": 86,
          "code": "fun main() {\n    // Text data\n    let first_name = \"John\"\n    let last_name = \"Doe\"\n    let full_name = first_name + \" \" + last_name\n\n    // Numeric data\n    let score = 95\n    let percentage = 95.5\n    let temperature = -10\n\n    // Boolean (true/false) data\n    let is_student = true\n    let has_graduated = false\n    let is_enrolled = !has_graduated\n\n    println(\"Student:\", full_name)\n    println(\"Score:\", score, \"(\", percentage, \"%)\")\n    println(\"Temperature:\", temperature, \"°C\")\n    println(\"Status: student=\", is_student, \", graduated=\", has_graduated)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 3,
          "line_number": 119,
          "code": "fun main() {\n    // Store user information\n    let username = \"programmer2024\"\n    let mut login_count = 1\n    let mut is_premium = false\n\n    // Use variables in calculations\n    let welcome_bonus = 100\n    let total_points = welcome_bonus + (login_count * 10)\n\n    // Update information (use mut for mutable variables)\n    login_count = login_count + 1\n    is_premium = total_points > 150\n\n    println(\"Welcome back,\", username, \"!\")\n    println(\"Logins:\", login_count, \", Points:\", total_points)\n    println(\"Premium status:\", is_premium)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 4,
          "line_number": 149,
          "code": "fun main() {\n    // Store multiple values\n    let favorite_languages = [\"Python\", \"Rust\", \"Ruchy\"]\n    let daily_temperatures = [22.5, 25.0, 23.8, 26.2]\n    let task_completed = [true, false, true, true]\n\n    // Access items by index (starting from 0)\n    println(\"First language:\", favorite_languages[0])\n    println(\"Today's temp:\", daily_temperatures[0], \"°C\")\n\n    // Get list length\n    println(\"I know\", favorite_languages.len(), \"languages\")\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 5,
          "line_number": 175,
          "code": "// ❌ This won't work\nfun main() {\n    user_name = \"Alice\"  \n}\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `user_name` in this scope\n --> /tmp/.tmptsYjb9/main.rs:1:52\n  |\n1 | use std :: collections :: HashMap ; fn main () { { user_name = \"Alice\" } }\n  |                                                    ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmptsYjb9/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { user_name = \"Alice\" } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmptsYjb9/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { user_name = \"Alice\" } }\n  |                                                  ^^                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { user_name = \"Alice\" } }\n1 + use std :: collections :: HashMap ; fn main () { user_name = \"Alice\" }\n  |\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 6,
          "line_number": 190,
          "code": "// ❌ This might not work as expected\nfun main() {\n    let age = \"25\"  // String, not number\n    let next_year = age + 1  // Can't add number to string\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpytDf3h/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let age = \"25\" . to_string () ; let next_year = age + 1i32 ; } } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpytDf3h/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let age = \"25\" . to_string () ; let next_year = age + 1i32 ; } } }\n  |                                                  ^^                                                                ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let age = \"25\" . to_string () ; let next_year = age + 1i32 ; } } }\n1 + use std :: collections :: HashMap ; fn main () { { let age = \"25\" . to_string () ; let next_year = age + 1i32 ; } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpytDf3h/main.rs:1:108\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let age = \"25\" . to_string () ; let next_year = age + 1i32 ; } } }\n  |                                                                                                            ^^^^ expected `&str`, found `i32`\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 7,
          "line_number": 207,
          "code": "// ❌ These are different variables\nfun main() {\n    let userName = \"Alice\"\n    let username = \"Bob\"\n    println(userName)  // Prints \"Alice\", not \"Bob\"\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 8,
          "line_number": 232,
          "code": "fun main() {\n    let name = \"Alice\"\n    let age = 25\n    println(\"Hi\", name, \", age\", age)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 9,
          "line_number": 301,
          "code": "fun main() {\n    // Personal profile\n    let name = \"Alex\"\n    let age = 28\n    let city = \"San Francisco\"\n    let hobby = \"rock climbing\"\n    let goal = \"master Ruchy in 30 days\"\n\n    // Data calculator  \n    let num1 = 15\n    let num2 = 25\n    let sum = num1 + num2\n    let difference = num1 - num2\n    let average = (num1 + num2) / 2\n\n    // Text manipulation\n    let first_name = \"Alex\"\n    let last_name = \"Johnson\"\n    let username = first_name + \"_\" + last_name\n    let email = username + \"@example.com\"\n\n    // Boolean logic\n    let is_adult = age >= 18\n    let lives_in_tech_city = city == \"San Francisco\"\n    let ready_for_job = is_adult && lives_in_tech_city\n\n    println(\"Profile:\", name, age, city)\n    println(\"Math:\", sum, difference, average)\n    println(\"Contact:\", username, email)\n    println(\"Status:\", is_adult, lives_in_tech_city, ready_for_job)\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch06-00-data-structures-tdd": {
      "chapter": "ch06-00-data-structures-tdd",
      "total_examples": 8,
      "working_examples": 8,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun main() {\n    let greeting = \"Hello\";\n    let name = \"World\";\n    println(greeting);\n    println(name);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 2,
          "line_number": 54,
          "code": "fun main() {\n    let first = \"Hello\";\n    let second = \"Beautiful\";\n    let third = \"World\";\n    println(first);\n    println(second);\n    println(third);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 3,
          "line_number": 79,
          "code": "fun main() {\n    let number = 42;\n    let text = \"Answer\";\n    println(text);\n    println(number);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 4,
          "line_number": 119,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nlet message = \"Hello World\";\nlet name = \"Alice\";\nlet greeting = \"Welcome\";",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 5,
          "line_number": 129,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nlet text = \"Count\";\nlet number = 100;\nlet flag = true;",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 6,
          "line_number": 153,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nlet first_name = \"John\";\nlet last_name = \"Doe\";\nlet title = \"Mr.\";",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 7,
          "line_number": 163,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nlet label = \"Temperature\";\nlet value = 72;\nlet unit = \"Fahrenheit\";",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 8,
          "line_number": 173,
          "code": "// Error: ✗ Compilation failed: Compilation failed:\nlet app_name = \"MyApp\";\nlet version = \"1.0\";\nlet debug = true;",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch03-00-functions": {
      "chapter": "ch03-00-functions",
      "total_examples": 12,
      "working_examples": 6,
      "failing_examples": 6,
      "examples": [
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 1,
          "line_number": 30,
          "code": "fun main() {\n    // Organize calculations\n    let name = \"Alice\"  \n    let a = 15\n    let b = 27\n\n    // Reusable greeting logic\n    let greeting = \"Hello, \" + name + \"! Welcome to Ruchy!\"\n\n    // Reusable calculation logic  \n    let sum = a + b\n    let result_message = a + \" + \" + b + \" = \" + sum\n\n    println(greeting)\n    println(result_message)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 2,
          "line_number": 69,
          "code": "fun main() {\n    // Store inputs\n    let input1 = 10\n    let input2 = 20\n\n    // Organize calculations  \n    let sum = input1 + input2\n    let product = input1 * input2\n    let average = sum / 2\n\n    // Organize output\n    let result = \"Sum: \" + sum + \", Product: \" + product + \", Average: \" + average\n    println(result)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 3,
          "line_number": 96,
          "code": "fun main() {\n    // Template: greeting with name\n    let user_name = \"Alice\"\n    let greeting_template = \"Hello, \" + user_name + \"! Welcome!\"\n\n    // Template: calculation display\n    let num1 = 15\n    let num2 = 27  \n    let operation = \"addition\"\n    let calc_result = num1 + num2\n    let calc_display = operation + \": \" + num1 + \" + \" + num2 + \" = \" + calc_result\n    \n    println(greeting_template)\n    println(calc_display)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 4,
          "line_number": 124,
          "code": "fun main() {\n    // Input section\n    let temperature_f = 68\n    let user_location = \"San Francisco\"\n\n    // Processing section  \n    let temperature_c = (temperature_f - 32) * 5 / 9\n    let is_comfortable = temperature_c > 18 && temperature_c < 25\n\n    // Output section\n    let weather_report = \"Weather in \" + user_location + \": \" + temperature_f + \"°F (\" + temperature_c + \"°C)\"\n    let comfort_message = if is_comfortable { \"Perfect weather!\" } else { \"Dress accordingly\" }\n\n    println(weather_report)\n    println(comfort_message)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 5,
          "line_number": 154,
          "code": "// Mathematical operations\nfun square(x) {\n    x * x\n}\n\nfun circle_area(radius) {\n    let pi = 3.14159\n    pi * square(radius)\n}\n\n// Text processing\nfun make_username(first_name, last_name) {\n    first_name + \"_\" + last_name\n}\n\nfun shout(message) {\n    message + \"!!!\"\n}\n\nfun main() {\n    // Use them together\n    let area = circle_area(5)\n    let username = make_username(\"Alice\", \"Johnson\") \n    let excited = shout(\"I love functions\")\n\n    println(\"Circle area:\", area)\n    println(\"Username:\", username)\n    println(excited)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpu4NilF/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpu4NilF/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f...\n  |                                                                  ^^     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , first_name , \"_\") , last_name) } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; ; let excited = shout (\"I love functions\" . to_string ()) ; ; println ! (\"{} {:?}\" , \"Circle area:\" , area) ; println ! (\"{} {:?}\" , \"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { x * x } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , first_name , \"_\") , last_name) } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; ; let excited = shout (\"I love functions\" . to_string ()) ; ; println ! (\"{} {:?}\" , \"Circle area:\" , area) ; println ! (\"{} {:?}\" , \"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpu4NilF/main.rs:1:117\n  |\n1 | ... } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , la...\n  |                                              ^^                                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , first_name , \"_\") , last_name) } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; ; let excited = shout (\"I love functions\" . to_string ()) ; ; println ! (\"{} {:?}\" , \"Circle area:\" , area) ; println ! (\"{} {:?}\" , \"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { let pi = 3.14159f64 ; pi * square (radius) } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , first_name , \"_\") , last_name) } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; ; let excited = shout (\"I love functions\" . to_string ()) ; ; println ! (\"{} {:?}\" , \"Circle area:\" , area) ; println ! (\"{} {:?}\" , \"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpu4NilF/main.rs:1:233\n  |\n1 | ...32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , first_name , \"_\") , last_name) } } fn shout (message : String) ...\n  |                                   ^^                                                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , first_name , \"_\") , last_name) } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; ; let excited = shout (\"I love functions\" . to_string ()) ; ; println ! (\"{} {:?}\" , \"Circle area:\" , area) ; println ! (\"{} {:?}\" , \"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { format ! (\"{}{}\" , format ! (\"{}{}\" , first_name , \"_\") , last_name) } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; ; let excited = shout (\"I love functions\" . to_string ()) ; ; println ! (\"{} {:?}\" , \"Circle area:\" , area) ; println ! (\"{} {:?}\" , \"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpu4NilF/main.rs:1:345\n  |\n1 | ...name) } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32...\n  |                                                   ^^                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , first_name , \"_\") , last_name) } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; ; let excited = shout (\"I love functions\" . to_string ()) ; ; println ! (\"{} {:?}\" , \"Circle area:\" , area) ; println ! (\"{} {:?}\" , \"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , first_name , \"_\") , last_name) } } fn shout (message : String) -> i32 { format ! (\"{}{}\" , message , \"!!!\") } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; ; let excited = shout (\"I love functions\" . to_string ()) ; ; println ! (\"{} {:?}\" , \"Circle area:\" , area) ; println ! (\"{} {:?}\" , \"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpu4NilF/main.rs:1:400\n  |\n1 | ... { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; ; let excited = shout (\"I love functions\" . to_string ()) ; ; println ! (\"{} {:?}\" , \"Circle area:\" , area) ; println ! (\"{} {:?}\" , \"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , first_name , \"_\") , last_name) } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; ; let excited = shout (\"I love functions\" . to_string ()) ; ; println ! (\"{} {:?}\" , \"Circle area:\" , area) ; println ! (\"{} {:?}\" , \"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , first_name , \"_\") , last_name) } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { let area = circle_area (5i32) ; { let username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; ; let excited = shout (\"I love functions\" . to_string ()) ; ; println ! (\"{} {:?}\" , \"Circle area:\" , area) ; println ! (\"{} {:?}\" , \"Username:\" , username) ; println ! (\"{:?}\" , excited) } } }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpu4NilF/main.rs:1:521\n  |\n1 | ...Alice\" . to_string () , \"Johnson\" . to_string ()) ; ; let excited = shout (\"I love functions\" . to_string ()) ; ; println ! (\"{} {:?}\"...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpu4NilF/main.rs:1:581\n  |\n1 | ...cited = shout (\"I love functions\" . to_string ()) ; ; println ! (\"{} {:?}\" , \"Circle area:\" , area) ; println ! (\"{} {:?}\" , \"Username...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0277]: cannot multiply `f64` by `i32`\n --> /tmp/.tmpu4NilF/main.rs:1:146\n  |\n1 | ...ius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 ...\n  |                                                     ^ no implementation for `f64 * i32`\n  |\n  = help: the trait `Mul<i32>` is not implemented for `f64`\n  = help: the following other types implement trait `Mul<Rhs>`:\n            `&f64` implements `Mul<f64>`\n            `&f64` implements `Mul`\n            `f64` implements `Mul<&f64>`\n            `f64` implements `Mul`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpu4NilF/main.rs:1:235\n  |\n1 | ...me : i32) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , first_name , \"_\") , last_name) } } fn shout (message : String) -> i32 { { f...\n  |                 ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`\n  |                 |\n  |                 expected `i32` because of return type\n  |\n  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpu4NilF/main.rs:1:347\n  |\n1 | ...n shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let u...\n  |                                  ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`\n  |                                  |\n  |                                  expected `i32` because of return type\n  |\n  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpu4NilF/main.rs:1:453\n  |\n1 | ...; { let username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; ; let excited = shout (\"I love functions\" . to_...\n  |                       ^^^^^^^^^^^^^  ----------------------   ------------------------ expected `i32`, found `String`\n  |                                      |\n  |                                      expected `i32`, found `String`\n  |\nnote: function defined here\n --> /tmp/.tmpu4NilF/main.rs:1:173\n  |\n1 | ....14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , format ! (\"...\n  |                                              ^^^^^^^^^^^^^  ----------------   ---------------\n\nerror: aborting due to 4 previous errors; 8 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 6,
          "line_number": 195,
          "code": "fun is_even(number) {\n    number % 2 == 0\n}\n\nfun grade_letter(score) {\n    if score >= 90 {\n        \"A\"\n    } else if score >= 80 {\n        \"B\"\n    } else if score >= 70 {\n        \"C\"\n    } else if score >= 60 {\n        \"D\"\n    } else {\n        \"F\"\n    }\n}\n\nfun describe_number(n) {\n    let even_odd = if is_even(n) { \"even\" } else { \"odd\" }\n    let size = if n > 100 { \"large\" } else { \"small\" }\n    n + \" is a \" + size + \" \" + even_odd + \" number\"\n}\n\nfun main() {\n    // Test your functions\n    println(describe_number(42))   // \"42 is a small even number\"\n    println(describe_number(150))  // \"150 is a large even number\"\n    println(grade_letter(85))      // \"B\"\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpr7ca4r/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpr7ca4r/main.rs:1:72\n  |\n1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...\n  |                                                                        ^^                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { number % 2i32 == 0i32 } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpr7ca4r/main.rs:1:142\n  |\n1 | ... { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } ...\n  |       ^^                                                                                                                                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpr7ca4r/main.rs:1:164\n  |\n1 | ...n grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { \"A\" } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpr7ca4r/main.rs:1:201\n  |\n1 | ...2 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { \"B\" } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpr7ca4r/main.rs:1:238\n  |\n1 | ...lse { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } }...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { \"C\" } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpr7ca4r/main.rs:1:275\n  |\n1 | ...lse { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i3...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { \"D\" } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpr7ca4r/main.rs:1:292\n  |\n1 | ... 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { \"F\" } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpr7ca4r/main.rs:1:350\n  |\n1 | ... { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpr7ca4r/main.rs:1:386\n  |\n1 | ...number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\"...\n  |                                                                  ^^      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { \"even\" } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpr7ca4r/main.rs:1:406\n  |\n1 | ...i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small...\n  |                                                                  ^^     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { \"odd\" } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpr7ca4r/main.rs:1:486\n  |\n1 | ...f n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , form...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpr7ca4r/main.rs:1:449\n  |\n1 | ...\"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}...\n  |                                                                 ^^       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { \"large\" } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpr7ca4r/main.rs:1:470\n  |\n1 | ...odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" ...\n  |                                                                 ^^       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { \"small\" } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpr7ca4r/main.rs:1:74\n  |\n1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...\n  |                                                                  ---     ^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `bool`\n  |                                                                  |\n  |                                                                  expected `i32` because of return type\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpr7ca4r/main.rs:1:156\n  |\n1 | ...er (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } }...\n  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                      |        |\n  |                                      |        expected `String`, found `i32`\n  |                                      expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpr7ca4r/main.rs:1:166\n  |\n1 | ...fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i3...\n  |                                        ---                           ^^^ expected `i32`, found `&str`\n  |                                        |\n  |                                        expected `i32` because of return type\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpr7ca4r/main.rs:1:193\n  |\n1 | ...re >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } }...\n  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                      |        |\n  |                                      |        expected `String`, found `i32`\n  |                                      expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpr7ca4r/main.rs:1:203\n  |\n1 | ...ore : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else ...\n  |                     --- expected `i32` because of return type                          ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpr7ca4r/main.rs:1:230\n  |\n1 | ...re >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn descri...\n  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                      |        |\n  |                                      |        expected `String`, found `i32`\n  |                                      expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpr7ca4r/main.rs:1:240\n  |\n1 | ...String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if s...\n  |               --- expected `i32` because of return type                                                               ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpr7ca4r/main.rs:1:267\n  |\n1 | ...re >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let ...\n  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                      |        |\n  |                                      |        expected `String`, found `i32`\n  |                                      expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpr7ca4r/main.rs:1:277\n  |\n1 | ...-> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } ...\n  |       --- expected `i32` because of return type                                                                                                    ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpr7ca4r/main.rs:1:294\n  |\n1 | ...-> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } ...\n  |       --- expected `i32` because of return type                                                                                                                     ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpr7ca4r/main.rs:1:372\n  |\n1 | ...umber (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" ...\n  |                                                   ^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpr7ca4r/main.rs:1:488\n  |\n1 | ...-> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") , size) , \" \") , even_odd) , \" number\") } ...\n  |       --- expected `i32` because of return type                                                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`\n  |\n  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpr7ca4r/main.rs:1:789\n  |\n1 | ...150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |                                   ------------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                   |             |\n  |                                   |             expected `String`, found `i32`\n  |                                   arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpr7ca4r/main.rs:1:103\n  |\n1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...\n  |                                                                                                       ^^^^^^^^^^^^  --------------\n\nerror: aborting due to 13 previous errors; 14 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 7,
          "line_number": 237,
          "code": "fun calculate_total(prices) {\n    let mut total = 0.0\n    let mut i = 0\n    while i < prices.len() {\n        total = total + prices[i]\n        i = i + 1\n    }\n    total\n}\n\nfun find_max(numbers) {\n    let mut max_val = numbers[0]\n    let mut i = 0\n    while i < numbers.len() {\n        if numbers[i] > max_val {\n            max_val = numbers[i]\n        }\n        i = i + 1\n    }\n    max_val\n}\n\nfun count_words(text) {\n    let words = text.split(\" \")\n    words.len()\n}\n\nfun main() {\n    // Real-world usage\n    let shopping_cart = [19.99, 5.50, 12.00, 8.75]\n    let test_scores = [85, 92, 78, 96, 88]\n    let essay = \"Functions make code reusable and testable\"\n\n    println(\"Total cost: $\", calculate_total(shopping_cart))\n    println(\"Highest score:\", find_max(test_scores))\n    println(\"Word count:\", count_words(essay))\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpX6TJTX/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpX6TJTX/main.rs:1:108\n  |\n1 | ...(prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as ...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpX6TJTX/main.rs:1:129\n  |\n1 | ...i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpX6TJTX/main.rs:1:314\n  |\n1 | ...i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > ma...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpX6TJTX/main.rs:1:335\n  |\n1 | ...al = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = n...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpX6TJTX/main.rs:1:404\n  |\n1 | ... . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words...\n  |                                                      ^^                              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = \"Functions make code reusable and testable\" . to_string () ; ; println ! (\"{} {:?}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {:?}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {:?}\" , \"Word count:\" , count_words (essay)) } } } }\n1 + use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { max_val = numbers [i as usize] } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = \"Functions make code reusable and testable\" . to_string () ; ; println ! (\"{} {:?}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {:?}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {:?}\" , \"Word count:\" , count_words (essay)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpX6TJTX/main.rs:1:514\n  |\n1 | ...n count_words (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = ...\n  |                                           ^^                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = \"Functions make code reusable and testable\" . to_string () ; ; println ! (\"{} {:?}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {:?}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {:?}\" , \"Word count:\" , count_words (essay)) } } } }\n1 + use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { let words = text . split (\" \") ; words . len () } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = \"Functions make code reusable and testable\" . to_string () ; ; println ! (\"{} {:?}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {:?}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {:?}\" , \"Word count:\" , count_words (essay)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpX6TJTX/main.rs:1:585\n  |\n1 | ... { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = \"Functions make code reusable and testable\" . to_string () ; ; println ! (\"{} {:?}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {:?}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {:?}\" , \"Word count:\" , count_words (essay)) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = \"Functions make code reusable and testable\" . to_string () ; ; println ! (\"{} {:?}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {:?}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {:?}\" , \"Word count:\" , count_words (essay)) } } } }\n1 + use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = \"Functions make code reusable and testable\" . to_string () ; ; println ! (\"{} {:?}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {:?}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {:?}\" , \"Word count:\" , count_words (essay)) } } }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpX6TJTX/main.rs:1:723\n  |\n1 | ...s = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = \"Functions make code reusable and testable\" . to_string () ; ; print...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpX6TJTX/main.rs:1:798\n  |\n1 | ...s make code reusable and testable\" . to_string () ; ; println ! (\"{} {:?}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; prin...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpX6TJTX/main.rs:1:141\n  |\n1 | ...tal = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } f...\n  |                                              -   ^^^^^^^^^^^^^^^ expected `i32`, found `usize`\n  |                                              |\n  |                                              expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len ().try_into().unwrap() { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = \"Functions make code reusable and testable\" . to_string () ; ; println ! (\"{} {:?}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {:?}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {:?}\" , \"Word count:\" , count_words (essay)) } } } }\n  |                                                                                                                                                            ++++++++++++++++++++\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmpX6TJTX/main.rs:1:185\n  |\n1 | ...rices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mu...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpX6TJTX/main.rs:1:218\n  |\n1 | ...-> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } ...\n  |       --- expected `i32` because of return type                                                                                                    ^^^^^ expected `i32`, found `f64`\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmpX6TJTX/main.rs:1:297\n  |\n1 | ...ng) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usiz...\n  |                                              ^^^^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpX6TJTX/main.rs:1:347\n  |\n1 | ... as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize...\n  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`\n  |                                              |\n  |                                              expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; ; let mut i = 0i32 ; ; while i < numbers . len ().try_into().unwrap() { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; ; let essay = \"Functions make code reusable and testable\" . to_string () ; ; println ! (\"{} {:?}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {:?}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {:?}\" , \"Word count:\" , count_words (essay)) } } } }\n  |                                                                                                                                                                                                                                                                                                                                                                           ++++++++++++++++++++\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmpX6TJTX/main.rs:1:380\n  |\n1 | ...while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val }...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmpX6TJTX/main.rs:1:425\n  |\n1 | ...as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { ...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0599]: no method named `len` found for struct `std::str::Split` in the current scope\n    --> /tmp/.tmpX6TJTX/main.rs:1:559\n     |\n1    | ... : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5...\n     |                                                                     ^^^\n     |\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:3877:5\n     |\n3877 | /     fn le<I>(self, other: I) -> bool\n3878 | |     where\n3879 | |         I: IntoIterator,\n3880 | |         Self::Item: PartialOrd<I::Item>,\n3881 | |         Self: Sized,\n     | |____________________^\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpX6TJTX/main.rs:1:858\n  |\n1 | ... ! (\"{} {:?}\" , \"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"{} {:?}\" , \"Highest score:\" , find_max (test_scores))...\n  |                                      ---------------  ^^^^^^^^^^^^^ expected `String`, found `Vec<f64>`\n  |                                      |\n  |                                      arguments to this function are incorrect\n  |\n  = note: expected struct `String`\n             found struct `Vec<f64>`\nnote: function defined here\n --> /tmp/.tmpX6TJTX/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; ; let mut i = 0i32 ; ; while i...\n  |                                        ^^^^^^^^^^^^^^^  ---------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpX6TJTX/main.rs:1:928\n  |\n1 | ...tln ! (\"{} {:?}\" , \"Highest score:\" , find_max (test_scores)) ; println ! (\"{} {:?}\" , \"Word count:\" , count_words (essay)) } } } }\n  |                                          --------  ^^^^^^^^^^^ expected `String`, found `Vec<i32>`\n  |                                          |\n  |                                          arguments to this function are incorrect\n  |\n  = note: expected struct `String`\n             found struct `Vec<i32>`\nnote: function defined here\n --> /tmp/.tmpX6TJTX/main.rs:1:231\n  |\n1 | ...rices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ...\n  |                                                         ^^^^^^^^  ----------------\n\nerror: aborting due to 10 previous errors; 10 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: len()"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 8,
          "line_number": 287,
          "code": "// ❌ This returns nothing (unit type)\nfun bad_add(a, b) {\n    a + b;\n    // The semicolon makes this a statement, returns ()\n}\n\n// ✅ This returns the sum\nfun good_add(a, b) {\n    a + b  // No semicolon - this is an expression\n}\n\nfun main() {\n    println(good_add(2, 3))\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 9,
          "line_number": 312,
          "code": "fun greet(name, age) {\n    \"Hi \" + name + \", you're \" + age + \" years old\"\n}\n\nfun main() {\n    // ❌ This won't work\n    let msg = greet(\"Alice\")  // Missing age parameter\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpAMEyiP/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpAMEyiP/main.rs:1:86\n  |\n1 | ... { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hi \" , name) , \", you're \") , age) , \" years old\") } } ...\n  |       ^^                                                                                                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hi \" , name) , \", you're \") , age) , \" years old\") } } fn main () { { let msg = greet (\"Alice\" . to_string ()) ; } }\n1 + use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hi \" , name) , \", you're \") , age) , \" years old\") } fn main () { { let msg = greet (\"Alice\" . to_string ()) ; } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpAMEyiP/main.rs:1:88\n  |\n1 | ...-> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hi \" , name) , \", you're \") , age) , \" years old\") } ...\n  |       ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`\n  |       |\n  |       expected `i32` because of return type\n  |\n  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n --> /tmp/.tmpAMEyiP/main.rs:1:245\n  |\n1 | ...\") } } fn main () { { let msg = greet (\"Alice\" . to_string ()) ; } }\n  |                                    ^^^^^------------------------- argument #2 of type `String` is missing\n  |\nnote: function defined here\n --> /tmp/.tmpAMEyiP/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{...\n  |                                        ^^^^^                  ------------\nhelp: provide the argument\n  |\n1 | use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hi \" , name) , \", you're \") , age) , \" years old\") } } fn main () { { let msg = greet(\"Alice\" . to_string (), /* String */) ; } }\n  |                                                                                                                                                                                                                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 10,
          "line_number": 332,
          "code": "// ❌ Parameters are read-only\nfun bad_function(x) {\n    x = x + 1  \n    x\n}\n\n// ✅ Create new variables inside functions\nfun good_function(x) {\n    let result = x + 1\n    result\n}\n\nfun main() {\n    println(good_function(5))\n}\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpvful02/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpvful02/main.rs:1:134\n  |\n1 | ...i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { { println ! (\"{:?}\" , good_funct...\n  |                                                    ^^                                  ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { { println ! (\"{:?}\" , good_function (5i32)) } }\n1 + use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { let result = x + 1i32 ; result } } fn main () { { println ! (\"{:?}\" , good_function (5i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpvful02/main.rs:1:188\n  |\n1 | ...sult = x + 1i32 ; result } } } fn main () { { println ! (\"{:?}\" , good_function (5i32)) } }\n  |                                                ^^                                         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { { println ! (\"{:?}\" , good_function (5i32)) } }\n1 + use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { println ! (\"{:?}\" , good_function (5i32)) }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpvful02/main.rs:1:85\n  |\n1 | use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { ...\n  |                                                                                     ^^^^ expected `&str`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpvful02/main.rs:1:92\n  |\n1 | use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { ...\n  |                                                                     ---                    ^ expected `i32`, found `String`\n  |                                                                     |\n  |                                                                     expected `i32` because of return type\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 11,
          "line_number": 364,
          "code": "fun add(a, b) {\n    a + b\n}\n\nfun main() {\n    let result = add(10, 20)\n    println(result)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 12,
          "line_number": 459,
          "code": "// Personal calculator\nfun celsius_to_fahrenheit(celsius) {\n    (celsius * 9 / 5) + 32\n}\n\nfun calculate_bmi(weight_kg, height_m) {\n    weight_kg / (height_m * height_m)\n}\n\nfun apply_discount(price, discount_percent) {\n    let discount = price * (discount_percent / 100)\n    price - discount\n}\n\n// Text tools\nfun word_count(text) {\n    let words = text.split(\" \")\n    words.len()\n}\n\nfun get_initials(full_name) {\n    let words = full_name.split(\" \")\n    let mut initials = \"\"\n    let mut i = 0\n    while i < words.len() {\n        let word = words[i]\n        initials = initials + word[0]\n        i = i + 1\n    }\n    initials\n}\n\n// Decision makers\nfun recommend_activity(energy_level, available_time) {\n    if energy_level > 7 && available_time > 60 {\n        \"Go for a run or hit the gym!\"\n    } else if energy_level > 5 && available_time > 30 {\n        \"Perfect time for a walk\"\n    } else {\n        \"Maybe just relax and read\"\n    }\n}\n\nfun main() {\n    // Test your functions!\n    println(celsius_to_fahrenheit(20))  // 68\n    println(calculate_bmi(70, 1.75))    // 22.86\n    println(get_initials(\"Alice Johnson\"))  // \"AJ\"\n    println(recommend_activity(8, 45))\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp1IcUiL/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bm...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1IcUiL/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bm...\n  |                                                                                       ^^                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { celsius * 9i32 / 5i32 + 32i32 } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1IcUiL/main.rs:1:184\n  |\n1 | ..._bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_perce...\n  |                                                     ^^                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { weight_kg / height_m * height_m } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1IcUiL/main.rs:1:288\n  |\n1 | ...ount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : Strin...\n  |                                 ^^                                                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { let discount = price * discount_percent / 100i32 ; price - discount } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1IcUiL/main.rs:1:405\n  |\n1 | ...fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) ...\n  |                                           ^^                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { let words = text . split (\" \") ; words . len () } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1IcUiL/main.rs:1:509\n  |\n1 | ... { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } ...\n  |       ^^                                                                                                                                                                                                                                                         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp1IcUiL/main.rs:1:592\n  |\n1 | ...it (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp1IcUiL/main.rs:1:613\n  |\n1 | ...initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = init...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1IcUiL/main.rs:1:642\n  |\n1 | ...ords . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } }...\n  |                    ^^                                                                                                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1IcUiL/main.rs:1:846\n  |\n1 | ... { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } ...\n  |       ^^                                                                                                                                                                                                                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1IcUiL/main.rs:1:899\n  |\n1 | ...f energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time...\n  |                                                      ^^                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { \"Go for a run or hit the gym!\" } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1IcUiL/main.rs:1:994\n  |\n1 | ... if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn ...\n  |                                                        ^^                         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { \"Perfect time for a walk\" } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1IcUiL/main.rs:1:1033\n  |\n1 | ...e > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_...\n  |                                                       ^^                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { \"Maybe just relax and read\" } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nerror[E0599]: no method named `len` found for struct `std::str::Split` in the current scope\n    --> /tmp/.tmp1IcUiL/main.rs:1:450\n     |\n1    | ... : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let wo...\n     |                                                                     ^^^\n     |\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:3877:5\n     |\n3877 | /     fn le<I>(self, other: I) -> bool\n3878 | |     where\n3879 | |         I: IntoIterator,\n3880 | |         Self::Item: PartialOrd<I::Item>,\n3881 | |         Self: Sized,\n     | |____________________^\n\nerror[E0599]: no method named `len` found for struct `std::str::Split` in the current scope\n    --> /tmp/.tmp1IcUiL/main.rs:1:633\n     |\n1    | ...s = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + ...\n     |                                                                     ^^^\n     |\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:3877:5\n     |\n3877 | /     fn le<I>(self, other: I) -> bool\n3878 | |     where\n3879 | |         I: IntoIterator,\n3880 | |         Self::Item: PartialOrd<I::Item>,\n3881 | |         Self: Sized,\n     | |____________________^\n\nerror[E0608]: cannot index into a value of type `std::str::Split<'_, &str>`\n --> /tmp/.tmp1IcUiL/main.rs:1:663\n  |\n1 | ...i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i3...\n  |                                                                 ^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp1IcUiL/main.rs:1:748\n  |\n1 | ...-> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } ...\n  |       --- expected `i32` because of return type                                                                                                                                                                                                            ^^^^^^^^ expected `i32`, found `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp1IcUiL/main.rs:1:866\n  |\n1 | ...e_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_l...\n  |                                   ------------   ^^^^- help: try using a conversion method: `.to_string()`\n  |                                   |              |\n  |                                   |              expected `String`, found `i32`\n  |                                   expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp1IcUiL/main.rs:1:891\n  |\n1 | ...{ { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available...\n  |                                  --------------   ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                  |                |\n  |                                  |                expected `String`, found `i32`\n  |                                  expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp1IcUiL/main.rs:1:901\n  |\n1 | ...ng) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 &...\n  |           --- expected `i32` because of return type                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp1IcUiL/main.rs:1:961\n  |\n1 | ...or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just re...\n  |                                   ------------   ^^^^- help: try using a conversion method: `.to_string()`\n  |                                   |              |\n  |                                   |              expected `String`, found `i32`\n  |                                   expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp1IcUiL/main.rs:1:986\n  |\n1 | ...e { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } ...\n  |                                  --------------   ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                  |                |\n  |                                  |                expected `String`, found `i32`\n  |                                  expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp1IcUiL/main.rs:1:996\n  |\n1 | ...-> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } ...\n  |       --- expected `i32` because of return type                                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp1IcUiL/main.rs:1:1035\n  |\n1 | ...-> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } ...\n  |       --- expected `i32` because of return type                                                                                                                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp1IcUiL/main.rs:1:1184\n  |\n1 | ...enheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string...\n  |                                          -------------          ^^^^^^^ expected `i32`, found `f64`\n  |                                          |\n  |                                          arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmp1IcUiL/main.rs:1:126\n  |\n1 | ...2 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m...\n  |                                               ^^^^^^^^^^^^^                    --------------\nhelp: change the type of the numeric literal from `f64` to `i32`\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1i32)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmp1IcUiL/main.rs:1:1285\n  |\n1 | ..._string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                       ^^^^^^^^^^^^^^^^^^  ----   ----- expected `String`, found `i32`\n  |                                                           |\n  |                                                           expected `String`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmp1IcUiL/main.rs:1:768\n  |\n1 | ...32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i3...\n  |                                     ^^^^^^^^^^^^^^^^^^  ---------------------   -----------------------\nhelp: try using a conversion method\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32.to_string() , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++\nhelp: try using a conversion method\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; ; let mut i = 0i32 ; ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32.to_string())) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++++++++++++\n\nerror: aborting due to 13 previous errors; 13 warnings emitted\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: len()"
        }
      ]
    },
    "ch01-02-hello-world-tdd": {
      "chapter": "ch01-02-hello-world-tdd",
      "total_examples": 6,
      "working_examples": 6,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun main() {\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 2,
          "line_number": 55,
          "code": "fun main() {\n    println(\"Hello,\");\n    println(\"World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 3,
          "line_number": 75,
          "code": "fun main() {\n    let greeting = \"Hello, World!\";\n    println(greeting);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 4,
          "line_number": 124,
          "code": "println(\"Your message here\");",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 5,
          "line_number": 132,
          "code": "let message = \"Your message\";\nprintln(message);",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 6,
          "line_number": 141,
          "code": "println(\"First line\");\nprintln(\"Second line\");",
          "passed": true,
          "status": "working"
        }
      ]
    }
  }
}