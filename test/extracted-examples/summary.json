{
  "timestamp": "2025-08-24T14:03:44.623Z",
  "ruchy_version": "ruchy 1.8.5",
  "chapters_processed": 37,
  "examples_found": 382,
  "examples_working": 44,
  "examples_failing": 338,
  "success_rate": 12,
  "chapters": {
    "ch02-00-variables-types-tdd": {
      "chapter": "ch02-00-variables-types-tdd",
      "total_examples": 8,
      "working_examples": 5,
      "failing_examples": 3,
      "examples": [
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let x = 42;\n    println(x);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 2,
          "line_number": 51,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let name = \"Ruchy\";\n    println(name);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 3,
          "line_number": 70,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let x = 10;\n    let y = 20;\n    let sum = x + y;\n    println(sum);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 4,
          "line_number": 91,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let pi = 3.14159;\n    let radius = 5.0;\n    let area = pi * radius * radius;\n    println(area);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 5,
          "line_number": 136,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let outer = 100;\n    // outer is accessible here\n    println(outer);\n}\n// outer is NOT accessible here",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 6,
          "line_number": 163,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet result = value1 + value2;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found `let` statement\n --> /tmp/.tmpjGjVkv/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...\n  |                                                               ^^^\n  |\n  = note: only supported directly in conditions of `if` and `while` expressions\n\nerror[E0425]: cannot find value `value1` in this scope\n --> /tmp/.tmpjGjVkv/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...\n  |                                                                                ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `value2` in this scope\n --> /tmp/.tmpjGjVkv/main.rs:1:89\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...\n  |                                                                                         ^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpjGjVkv/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 7,
          "line_number": 172,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet step1 = initial_value * factor;\nlet step2 = step1 + adjustment;\nlet final_result = step2 / divisor;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `}`\n --> /tmp/.tmpR2PdGR/main.rs:1:182\n  |\n1 | ...ustment ; let mut final_result = step2 / divisor } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < Strin...\n  |                                                     ^ expected one of 8 possible tokens\n\nerror[E0425]: cannot find value `initial_value` in this scope\n --> /tmp/.tmpR2PdGR/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut step1 = initial_value * factor ; let mut step2 = step1 + adjustme...\n  |                                                                                 ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `factor` in this scope\n --> /tmp/.tmpR2PdGR/main.rs:1:97\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut step1 = initial_value * factor ; let mut step2 = step1 + adjustme...\n  |                                                                                                 ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `adjustment` in this scope\n --> /tmp/.tmpR2PdGR/main.rs:1:130\n  |\n1 | ... initial_value * factor ; let mut step2 = step1 + adjustment ; let mut final_result = step2 / divisor } ; if let Some (s) = (& result ...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpR2PdGR/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut step1 = initial_value * factor ; let mut step2 = step1 + adjustme...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 8,
          "line_number": 183,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet PI = 3.14159;\nlet GRAVITY = 9.81;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpYHp8e4/main.rs:1:117\n  |\n1 | ...3.14159f64 ; let mut GRAVITY = 9.81f64 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpYHp8e4/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut PI = 3.14159f64 ; let mut GRAVITY = 9.81f64 } ; if let Some (s) =...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch10-00-performance-optimization": {
      "chapter": "ch10-00-performance-optimization",
      "total_examples": 11,
      "working_examples": 0,
      "failing_examples": 11,
      "examples": [
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 1,
          "line_number": 88,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// File: optimize_data_processing.ruchy\n// Before and after optimization\n\nuse std::perf;\nuse std::parallel;\n\n// Naive version - slow\nfun process_data_naive(data) {\n    let results = []\n    for item in data {\n        // Expensive computation\n        let processed = expensive_transform(item)\n        for existing in results {\n            if similar(processed, existing) {\n                processed.merge(existing)\n            }\n        }\n        results.push(processed)\n    }\n    return results\n}\n\n// Optimized version - fast\nfun process_data_optimized(data) {\n    // 1. Parallel processing\n    let results = parallel::map(data, |item| {\n        expensive_transform(item)\n    })\n    \n    // 2. Use hash map for lookups\n    let lookup = {}\n    for item in results {\n        let key = item.hash_key()\n        if lookup.has_key(key) {\n            lookup[key].merge(item)\n        } else {\n            lookup[key] = item\n        }\n    }\n    \n    return lookup.values()\n}\n\n// Benchmark both versions\nlet data = generate_test_data(10000)\n\nlet naive_time = perf::measure {\n    process_data_naive(data)\n}\n\nlet optimized_time = perf::measure {\n    process_data_optimized(data)\n}\n\nprintln(f\"Naive: {naive_time}ms\")\nprintln(f\"Optimized: {optimized_time}ms\")\nprintln(f\"Speedup: {naive_time / optimized_time:.1}x\")\n// Output: Speedup: 42.3x\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0432]: unresolved import `std::perf`\n --> /tmp/.tmpFQ3WAH/main.rs:1:967\n  |\n1 | ...eturn lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32)...\n  |                                                      ^^^^^^^^^^^ no `perf` in the root\n\nerror[E0432]: unresolved import `std::parallel`\n --> /tmp/.tmpFQ3WAH/main.rs:1:987\n  |\n1 | ... } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = ...\n  |                                                  ^^^^^^^^^^^^^^^ no `parallel` in the root\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpFQ3WAH/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpFQ3WAH/main.rs:1:207\n  |\n1 | ... { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpFQ3WAH/main.rs:1:257\n  |\n1 | ... { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ...\n  |       ^^                                                                                                                                                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpFQ3WAH/main.rs:1:334\n  |\n1 | ...; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed...\n  |                                  ^^                                                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { if similar (processed , existing) { { processed . merge (existing) } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpFQ3WAH/main.rs:1:372\n  |\n1 | ...in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; retur...\n  |                                                       ^^                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { processed . merge (existing) } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpFQ3WAH/main.rs:1:647\n  |\n1 | ... { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpFQ3WAH/main.rs:1:778\n  |\n1 | ... { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ...\n  |       ^^                                                                                                                                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpFQ3WAH/main.rs:1:841\n  |\n1 | ...= item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return l...\n  |                                                       ^^                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { lookup [key] . merge (item) } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpFQ3WAH/main.rs:1:882\n  |\n1 | ...s_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () ...\n  |                                                           ^^                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { lookup [key] = item } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpFQ3WAH/main.rs:1:981\n  |\n1 | ... . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut n...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpFQ3WAH/main.rs:1:1005\n  |\n1 | ...main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: meas...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0277]: `T` is not an iterator\n --> /tmp/.tmpFQ3WAH/main.rs:1:250\n  |\n1 | ...T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results...\n  |                                                         ^^^^ `T` is not an iterator\n  |\n  = note: required for `T` to implement `IntoIterator`\nhelp: consider further restricting type parameter `T` with trait `Iterator`\n  |\n1 | use std :: collections :: HashMap ; fn process_data_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (data : T) -> T { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {{naive_time / optimized_time:.1}}x\") ; }\n  |                                                                                                                                                                                           +++++++++++++++++++++\n\nerror[E0425]: cannot find function `expensive_transform` in this scope\n --> /tmp/.tmpFQ3WAH/main.rs:1:277\n  |\n1 | ...] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existi...\n  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `similar` in this scope\n --> /tmp/.tmpFQ3WAH/main.rs:1:339\n  |\n1 | ...ransform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results ....\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `parallel`\n --> /tmp/.tmpFQ3WAH/main.rs:1:665\n  |\n1 | ...(data : T) -> T { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for ite...\n  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `parallel`\n  |\n  = help: you might be missing a crate named `parallel`\n\nerror[E0425]: cannot find function `expensive_transform` in this scope\n --> /tmp/.tmpFQ3WAH/main.rs:1:700\n  |\n1 | ...results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key...\n  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `has_key` found for unit type `()` in the current scope\n --> /tmp/.tmpFQ3WAH/main.rs:1:825\n  |\n1 | ...s { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key] . merge (item) } } else { { lookup [key] = item } } ...\n  |                                                       ^^^^^^^ method not found in `()`\n\nerror[E0599]: no method named `values` found for unit type `()` in the current scope\n --> /tmp/.tmpFQ3WAH/main.rs:1:932\n  |\n1 | ... { lookup [key] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut ...\n  |                                                       ^^^^^^ method not found in `()`\n\nerror[E0425]: cannot find function `generate_test_data` in this scope\n --> /tmp/.tmpFQ3WAH/main.rs:1:1022\n  |\n1 | ...rf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_na...\n  |                                                  ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 10 previous errors; 11 warnings emitted\n\nSome errors have detailed explanations: E0277, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: has_key()"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 2,
          "line_number": 167,
          "code": "// Status: ❌ BROKEN\n\n// CPU profiling\nlet profiler = perf::CpuProfiler::new()\nprofiler.start()\n\n// Your code here\ncomplex_operation()\n\nprofiler.stop()\nlet report = profiler.report()\n\nprintln(\"=== CPU Profile ===\")\nfor func in report.top_functions(10) {\n    println(f\"{func.name}: {func.self_time}ms ({func.percent}%)\")\n}\n\n// Memory profiling\nlet mem_profiler = perf::MemoryProfiler::new()\nmem_profiler.start()\n\n// Your code here\nmemory_intensive_operation()\n\nmem_profiler.stop()\nlet mem_report = mem_profiler.report()\n\nprintln(\"\\n=== Memory Profile ===\")\nprintln(\"Peak memory: \" + format_size(mem_report.peak_usage))\nprintln(\"Allocations: \" + mem_report.allocation_count.to_s())\nprintln(\"Largest allocation: \" + format_size(mem_report.largest_allocation))\n\n// Flame graph generation\nprofiler.generate_flamegraph(\"profile.svg\")\nprintln(\"Flame graph saved to profile.svg\")",
          "passed": false,
          "status": "broken",
          "error": "\nthread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:\n\"perf::CpuProfiler\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 3,
          "line_number": 215,
          "code": "// Status: ❌ BROKEN\n\n// Micro-benchmarks\nuse std::bench;\n\nbench::suite(\"String Operations\", {\n    \"concatenation\" => || {\n        let s = \"\"\n        for i in range(1000) {\n            s += i.to_s()\n        }\n    },\n    \n    \"string builder\" => || {\n        let builder = StringBuilder::new()\n        for i in range(1000) {\n            builder.append(i.to_s())\n        }\n        builder.to_string()\n    },\n    \n    \"join\" => || {\n        range(1000).map(|i| i.to_s()).join(\"\")\n    }\n})\n\n// Results:\n// String Operations\n//   concatenation:  2.3ms ± 0.1ms\n//   string builder: 0.4ms ± 0.02ms  [FASTEST]\n//   join:          0.6ms ± 0.03ms\n\n// Custom benchmarks\nfun benchmark_algorithm(name, func, data) {\n    let times = []\n    \n    // Warmup\n    for i in range(5) {\n        func(data)\n    }\n    \n    // Measure\n    for i in range(100) {\n        let time = perf::measure {\n            func(data)\n        }\n        times.push(time)\n    }\n    \n    let avg = times.mean()\n    let std = times.std_dev()\n    println(f\"{name}: {avg:.2}ms ± {std:.2}ms\")\n}",
          "passed": false,
          "status": "broken",
          "error": "\nthread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:\n\"string builder\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 4,
          "line_number": 282,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Parallel map\nlet data = range(1, 1000000)\nlet results = parallel::map(data, |n| {\n    expensive_computation(n)\n})\n\n// Parallel reduce\nlet sum = parallel::reduce(data, 0, |acc, n| {\n    acc + n\n})\n\n// Thread pool\nlet pool = parallel::ThreadPool::new(num_cpus())\n\nfor task in tasks {\n    pool.execute(|| {\n        process_task(task)\n    })\n}\n\npool.wait()\n\n// Parallel pipeline\nparallel::pipeline()\n    .stage(|item| fetch_data(item))      // I/O bound\n    .stage(|data| parse_data(data))      // CPU bound\n    .stage(|parsed| transform(parsed))   // CPU bound\n    .stage(|result| save_result(result)) // I/O bound\n    .process(items)\n\n// Async concurrency\nlet futures = []\nfor url in urls {\n    futures.push(async {\n        http::get(url).await()\n    })\n}\n\nlet responses = async::wait_all(futures)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 5,
          "line_number": 336,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// File: algorithm_optimization.ruchy\n// Common optimization patterns\n\n// 1. Cache computed values\nlet fibonacci_cache = {}\nfun fibonacci_memo(n) {\n    if fibonacci_cache.has_key(n) {\n        return fibonacci_cache[n]\n    }\n    \n    let result = if n <= 1 {\n        n\n    } else {\n        fibonacci_memo(n - 1) + fibonacci_memo(n - 2)\n    }\n    \n    fibonacci_cache[n] = result\n    return result\n}\n\n// 2. Use better data structures\nfun find_duplicates_naive(items) {\n    let duplicates = []\n    for i in range(items.len()) {\n        for j in range(i + 1, items.len()) {\n            if items[i] == items[j] {\n                duplicates.push(items[i])\n            }\n        }\n    }\n    return duplicates  // O(n²)\n}\n\nfun find_duplicates_optimized(items) {\n    let seen = Set::new()\n    let duplicates = Set::new()\n    \n    for item in items {\n        if seen.contains(item) {\n            duplicates.add(item)\n        }\n        seen.add(item)\n    }\n    return duplicates.to_array()  // O(n)\n}\n\n// 3. Batch operations\nfun save_records_naive(records) {\n    for record in records {\n        database.insert(record)  // N database calls\n    }\n}\n\nfun save_records_optimized(records) {\n    database.insert_batch(records)  // 1 database call\n}\n\n// 4. Early termination\nfun find_first_match(items, predicate) {\n    for item in items {\n        if predicate(item) {\n            return item  // Stop as soon as found\n        }\n    }\n    return null\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `fibonacci_cache` in this scope\n --> /tmp/.tmpN6NQzQ/main.rs:1:205\n  |\n1 | ... :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n ...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `fibonacci_cache` in this scope\n --> /tmp/.tmpN6NQzQ/main.rs:1:246\n  |\n1 | ... { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `fibonacci_cache` in this scope\n --> /tmp/.tmpN6NQzQ/main.rs:1:381\n  |\n1 | ...(n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmpN6NQzQ/main.rs:1:651\n  |\n1 | ...) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmpN6NQzQ/main.rs:1:687\n  |\n1 | ...[] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . p...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpN6NQzQ/main.rs:1:1420\n  |\n1 | ...> (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Ad...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpN6NQzQ/main.rs:1:1634\n  |\n1 | ...d :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add <...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `null` in this scope\n --> /tmp/.tmpN6NQzQ/main.rs:1:1934\n  |\n1 | ...if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::ptr::null;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpN6NQzQ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpN6NQzQ/main.rs:1:237\n  |\n1 | ...(n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { ...\n  |                                                        ^^                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { return fibonacci_cache [n] } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpN6NQzQ/main.rs:1:302\n  |\n1 | ... return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32)...\n  |                                                                    ^^ ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { n } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpN6NQzQ/main.rs:1:317\n  |\n1 | ...esult = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; r...\n  |                                          ^^                                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpN6NQzQ/main.rs:1:608\n  |\n1 | ... { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } ...\n  |       ^^                                                                                                                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpN6NQzQ/main.rs:1:676\n  |\n1 | ...n ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; ret...\n  |            ^^                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpN6NQzQ/main.rs:1:723\n  |\n1 | ...ge (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } }...\n  |                                     ^^                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpN6NQzQ/main.rs:1:753\n  |\n1 | ..., items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_dupl...\n  |                                                      ^^                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { duplicates . push (items [i]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpN6NQzQ/main.rs:1:1003\n  |\n1 | ... { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } ...\n  |       ^^                                                                                                                                                                                                                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpN6NQzQ/main.rs:1:1123\n  |\n1 | ... ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_ar...\n  |                                                         ^^                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { duplicates . add (item) } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpN6NQzQ/main.rs:1:1392\n  |\n1 | ...Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : st...\n  |                                         ^^                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { for record in records { { database . insert (record) } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpN6NQzQ/main.rs:1:1418\n  |\n1 | ...ne > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops ::...\n  |                                                        ^^                          ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { database . insert (record) } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpN6NQzQ/main.rs:1:1632\n  |\n1 | ... :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < ...\n  |                                                    ^^                                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { database . insert_batch (records) } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpN6NQzQ/main.rs:1:1879\n  |\n1 | ... predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibo...\n  |                                                 ^^                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { if predicate (item) { { return item } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpN6NQzQ/main.rs:1:1903\n  |\n1 | ... : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cach...\n  |                                                               ^^           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { return item } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nerror[E0369]: binary operation `<=` cannot be applied to type `T`\n --> /tmp/.tmpN6NQzQ/main.rs:1:292\n  |\n1 | ... (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n...\n  |                                                                - ^^ ---- i32\n  |                                                                |\n  |                                                                T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |                                                                                                                                                                                       +++++++++++++++++++++++++++\n\nerror[E0369]: cannot subtract `i32` from `T`\n --> /tmp/.tmpN6NQzQ/main.rs:1:337\n  |\n1 | ...let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = resul...\n  |                                                                 - ^ ---- i32\n  |                                                                 |\n  |                                                                 T\n  |\nhelp: consider further restricting type parameter `T` with trait `Sub`\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<i32> > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |                                                                                                                                                                                       ++++++++++++++++++++\n\nerror[E0369]: cannot subtract `i32` from `T`\n --> /tmp/.tmpN6NQzQ/main.rs:1:365\n  |\n1 | ...{ n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn...\n  |                                                                 - ^ ---- i32\n  |                                                                 |\n  |                                                                 T\n  |\nhelp: consider further restricting type parameter `T` with trait `Sub`\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<i32, Output = T> > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |                                                                                                                                                                                       ++++++++++++++++++++++++++++++++\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmpN6NQzQ/main.rs:1:666\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                                                             ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++++++\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmpN6NQzQ/main.rs:1:713\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                                                                                                            ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++++++\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmpN6NQzQ/main.rs:1:734\n  |\n1 | ... ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; retu...\n  |                                                                     ^^^\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmpN6NQzQ/main.rs:1:747\n  |\n1 | ...j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates...\n  |                                                                     ^^^\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmpN6NQzQ/main.rs:1:780\n  |\n1 | ...n ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optim...\n  |                                                                     ^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `Set`\n --> /tmp/.tmpN6NQzQ/main.rs:1:1018\n  |\n1 | ... Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if see...\n  |                                                       ^^^ use of undeclared type `Set`\n\nerror[E0433]: failed to resolve: use of undeclared type `Set`\n --> /tmp/.tmpN6NQzQ/main.rs:1:1057\n  |\n1 | ... let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . ad...\n  |                                                       ^^^ use of undeclared type `Set`\n\nerror[E0277]: `T` is not an iterator\n --> /tmp/.tmpN6NQzQ/main.rs:1:1085\n  |\n1 | ...; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add ...\n  |                                                         ^^^^^ `T` is not an iterator\n  |\n  = note: required for `T` to implement `IntoIterator`\nhelp: consider further restricting type parameter `T` with trait `Iterator`\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      +++++++++++++++++++++\n\nerror[E0277]: `T` is not an iterator\n --> /tmp/.tmpN6NQzQ/main.rs:1:1408\n  |\n1 | ...ebug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std...\n  |                                                        ^^^^^^^ `T` is not an iterator\n  |\n  = note: required for `T` to implement `IntoIterator`\nhelp: consider further restricting type parameter `T` with trait `Iterator`\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpN6NQzQ/main.rs:1:1394\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } ...\n  |       -                                                                                                                                                -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |       |                                                                                                                                                |\n  |       expected this type parameter                                                                                                                     expected `T` because of return type\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: the caller chooses a type for `T` which can be different from `()`\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } /* `T` value */ } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++\n\nerror[E0277]: `T` is not an iterator\n --> /tmp/.tmpN6NQzQ/main.rs:1:1871\n  |\n1 | ...e > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main (...\n  |                                                         ^^^^^ `T` is not an iterator\n  |\n  = note: required for `T` to implement `IntoIterator`\nhelp: consider further restricting type parameter `T` with trait `Iterator`\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n] = result ; return result } } } } fn find_duplicates_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i] == items [j] { { duplicates . push (items [i]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (items : T) -> T { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { for record in records { { database . insert (record) } } } } fn save_records_optimized < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T) -> T { { database . insert_batch (records) } } fn find_first_match < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            +++++++++++++++++++++\n\nerror[E0618]: expected function, found `T`\n --> /tmp/.tmpN6NQzQ/main.rs:1:1884\n  |\n1 | ...e > (items : T , predicate : T) -> T { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main (...\n  |                     ---------                                        ^^^^^^^^^-------\n  |                     |                                                |\n  |                     `predicate` has type `T`                         call expression requires function\n\nwarning: unused variable: `fibonacci_cache`\n --> /tmp/.tmpN6NQzQ/main.rs:1:1964\n  |\n1 | ...n main () { let mut fibonacci_cache = () ; }\n  |                        ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_fibonacci_cache`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmpN6NQzQ/main.rs:1:1960\n  |\n1 | ...turn item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |                                                         ----^^^^^^^^^^^^^^^\n  |                                                         |\n  |                                                         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror: aborting due to 23 previous errors; 17 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0425, E0433, E0599, E0608, E0618.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: len()"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 6,
          "line_number": 417,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: memory_optimization.ruchy\n// Reduce memory usage\n\n// 1. Use generators for large datasets\nfun read_large_file_naive(path) {\n    return read_file(path).lines()  // Loads entire file\n}\n\nfun read_large_file_optimized(path) {\n    // Generator - yields lines one at a time\n    return generate {\n        let file = open(path)\n        while !file.eof() {\n            yield file.read_line()\n        }\n        file.close()\n    }\n}\n\n// 2. Object pooling\nlet connection_pool = Pool::new(\n    create: || Database::connect(),\n    reset: |conn| conn.clear()\n)\n\nfun handle_request(request) {\n    let conn = connection_pool.acquire()\n    let result = conn.query(request.sql)\n    connection_pool.release(conn)\n    return result\n}\n\n// 3. Weak references for caches\nlet cache = WeakMap::new()\n\nfun get_cached_data(key) {\n    if cache.has(key) {\n        return cache.get(key)\n    }\n    \n    let data = expensive_load(key)\n    cache.set(key, data)\n    return data\n}\n\n// 4. Compact data structures\nstruct CompactUser {\n    id: u32,        // 4 bytes instead of 8\n    flags: u8,      // Bit flags instead of booleans\n    name: String    // Single allocation\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 7,
          "line_number": 481,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: io_optimization.ruchy\n// Speed up I/O operations\n\n// 1. Buffered I/O\nfun process_file_naive(path) {\n    let file = open(path)\n    while !file.eof() {\n        let byte = file.read_byte()  // Syscall for each byte\n        process(byte)\n    }\n}\n\nfun process_file_optimized(path) {\n    let file = BufferedReader::new(open(path), 8192)\n    while !file.eof() {\n        let byte = file.read_byte()  // Reads from buffer\n        process(byte)\n    }\n}\n\n// 2. Async I/O\nasync fun fetch_all_naive(urls) {\n    let results = []\n    for url in urls {\n        let data = http::get(url).await()  // Sequential\n        results.push(data)\n    }\n    return results\n}\n\nasync fun fetch_all_optimized(urls) {\n    let futures = urls.map(|url| {\n        http::get(url)  // Concurrent\n    })\n    return async::wait_all(futures)\n}\n\n// 3. Memory-mapped files\nfun process_huge_file(path) {\n    let mmap = MemoryMap::open(path)\n    \n    // Process in parallel chunks\n    parallel::for_chunks(mmap, 1_000_000, |chunk| {\n        process_chunk(chunk)\n    })\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 8,
          "line_number": 542,
          "code": "// Status: ❌ BROKEN\n\n// File: query_optimizer.ruchy\n// Optimize database queries\n\nuse std::db;\nuse std::perf;\n\nlet database = db::connect(\"postgres://localhost/myapp\")\n\n// Enable query logging\ndatabase.log_queries(true)\n\n// Analyze slow queries\nfun analyze_query(sql) {\n    let plan = database.explain(sql)\n    println(\"Query: \" + sql)\n    println(\"Execution plan: \" + plan)\n    \n    // Find missing indexes\n    if plan.contains(\"Seq Scan\") {\n        println(\"⚠️  Sequential scan detected - consider adding index\")\n        \n        // Suggest index\n        let table = extract_table(sql)\n        let where_clause = extract_where(sql)\n        println(f\"Suggested: CREATE INDEX ON {table} ({where_clause.column})\")\n    }\n    \n    // Check for N+1 queries\n    let query_log = database.get_recent_queries(100)\n    let patterns = find_patterns(query_log)\n    \n    for pattern in patterns {\n        if pattern.count > 10 && pattern.similar {\n            println(\"⚠️  N+1 query pattern detected: \" + pattern.example)\n            println(\"Consider using JOIN or batch loading\")\n        }\n    }\n}\n\n// Optimize ORM queries\nfun get_users_with_posts_naive() {\n    let users = database.query(\"SELECT * FROM users\")\n    for user in users {\n        user.posts = database.query(\n            \"SELECT * FROM posts WHERE user_id = ?\", \n            [user.id]\n        )  // N+1 problem\n    }\n    return users\n}\n\nfun get_users_with_posts_optimized() {\n    // Single query with JOIN\n    return database.query(\"\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    \").group_by(|row| row.user_id)\n}\n\n// Benchmark improvements\nlet naive_time = perf::measure {\n    get_users_with_posts_naive()\n}\n\nlet optimized_time = perf::measure {\n    get_users_with_posts_optimized()\n}\n\nprintln(f\"Improvement: {naive_time / optimized_time:.1}x faster\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpc3iDIW/main.rs:1:478\n  |\n1 | ...\\u{fe0f}  Sequential scan detected - consider adding index\" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clau...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpc3iDIW/main.rs:1:480\n  |\n1 | ...n\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\" . to_string ()) ; { let table = extract_table (sql) ;...\n  |                       -------------------------------------------------------------   ^^^^^^^^^^^^ argument never used\n  |                       |\n  |                       formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpc3iDIW/main.rs:1:1011\n  |\n1 | ...ample)) ; println ! (\"Consider using JOIN or batch loading\" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpc3iDIW/main.rs:1:1013\n  |\n1 | ...tern . example)) ; println ! (\"Consider using JOIN or batch loading\" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () ...\n  |                                  --------------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                  |\n  |                                  formatting specifier missing\n\nerror[E0432]: unresolved import `std::db`\n --> /tmp/.tmpc3iDIW/main.rs:1:1539\n  |\n1 | ... []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\"...\n  |                                          ^^^^^^^--\n  |                                          |      |\n  |                                          |      help: a similar name exists in the module: `dbg`\n  |                                          no `db` in the root\n\nerror[E0432]: unresolved import `std::perf`\n --> /tmp/.tmpc3iDIW/main.rs:1:1557\n  |\n1 | ... unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_...\n  |                                                      ^^^^^^^^^^^ no `perf` in the root\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpc3iDIW/main.rs:1:216\n  |\n1 | ...:: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Query: \" , sql))...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpc3iDIW/main.rs:1:690\n  |\n1 | ...ere_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_lo...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpc3iDIW/main.rs:1:1094\n  |\n1 | ...fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = d...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpc3iDIW/main.rs:1:1176\n  |\n1 | ...M users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpc3iDIW/main.rs:1:1330\n  |\n1 | ... } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JO...\n  |                                                       ^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpc3iDIW/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: f...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpc3iDIW/main.rs:1:201\n  |\n1 | ... { { { let plan = database . explain (sql) ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\" . to_string ()) } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { let plan = database . explain (sql) ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\" . to_string ()) } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpc3iDIW/main.rs:1:804\n  |\n1 | ... { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\" . to_string ()) } } } } ...\n  |       ^^                                                                                                                                                                                                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\" . to_string ()) } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpc3iDIW/main.rs:1:1078\n  |\n1 | ... { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } ...\n  |       ^^                                                                                                                                                                                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpc3iDIW/main.rs:1:1159\n  |\n1 | ...r user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users }...\n  |                      ^^                                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpc3iDIW/main.rs:1:1321\n  |\n1 | ... { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } ...\n  |       ^^                                                                                                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n1 + use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpc3iDIW/main.rs:1:1551\n  |\n1 | ...(& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myap...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpc3iDIW/main.rs:1:1571\n  |\n1 | ... } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ;...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpc3iDIW/main.rs:1:480\n  |\n1 | ...quential scan detected - consider adding index\" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `extract_table` in this scope\n --> /tmp/.tmpc3iDIW/main.rs:1:510\n  |\n1 | ...r adding index\" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Sugge...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `extract_where` in this scope\n --> /tmp/.tmpc3iDIW/main.rs:1:557\n  |\n1 | ... extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `find_patterns` in this scope\n --> /tmp/.tmpc3iDIW/main.rs:1:750\n  |\n1 | ...et_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && ...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpc3iDIW/main.rs:1:1013\n  |\n1 | ...intln ! (\"Consider using JOIN or batch loading\" . to_string ()) } } } } } } } } fn get_users_with_posts_naive () { { { let users = dat...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpc3iDIW/main.rs:1:778\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\" . to_string ()) } } } } } ...\n  |       - expected this type parameter                                                                                                               - expected `T` because of return type                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: the caller chooses a type for `T` which can be different from `()`\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn analyze_query < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (sql : T) -> T { { { let plan = database . explain (sql) ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\" . to_string ()) ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\" . to_string ()) } } } } /* `T` value */ } } } } fn get_users_with_posts_naive () { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {{naive_time / optimized_time:.1}}x faster\") ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++\n\nerror: aborting due to 17 previous errors; 8 warnings emitted\n\nSome errors have detailed explanations: E0308, E0425, E0432.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "IMPORT_ERROR",
          "rootCause": "Missing dependency or import path issue"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 9,
          "line_number": 628,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: web_server_optimization.ruchy\n// High-performance web server\n\nuse std::net::http;\nuse std::cache;\n\nlet app = http::Server::new(\"0.0.0.0:8080\")\n\n// Response caching\nlet response_cache = cache::LRU::new(1000)\n\napp.use(|req, res, next| {\n    let cache_key = req.method + \":\" + req.path + \":\" + req.query_string\n    \n    if req.method == \"GET\" && response_cache.has(cache_key) {\n        let cached = response_cache.get(cache_key)\n        return res\n            .status(200)\n            .header(\"X-Cache\", \"HIT\")\n            .send(cached)\n    }\n    \n    // Capture response for caching\n    let original_send = res.send\n    res.send = |body| {\n        if req.method == \"GET\" && res.status == 200 {\n            response_cache.set(cache_key, body, ttl: 60)\n        }\n        original_send(body)\n    }\n    \n    next()\n})\n\n// Static file serving with ETags\napp.static(\"/static\", \"./public\", {\n    maxAge: 86400,  // 1 day\n    etag: true,\n    gzip: true\n})\n\n// Database connection pooling\nlet db_pool = ConnectionPool::new(\n    url: \"postgres://localhost/myapp\",\n    min: 5,\n    max: 20\n)\n\n// Async request handling\napp.get(\"/api/data\", async |req, res| {\n    let conn = db_pool.acquire().await()\n    let data = conn.query(\"SELECT * FROM data\").await()\n    db_pool.release(conn)\n    \n    res.json(data)\n})\n\n// Enable HTTP/2\napp.enable_http2()\n\n// Compression middleware\napp.use(compression({\n    level: 6,\n    threshold: 1024,  // Only compress > 1KB\n    types: [\"text/*\", \"application/json\", \"application/javascript\"]\n}))\n\nprintln(\"🚀 Optimized server running with:\")\nprintln(\"  • Response caching\")\nprintln(\"  • Connection pooling\")  \nprintln(\"  • HTTP/2 support\")\nprintln(\"  • Gzip compression\")\n\napp.listen()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 10,
          "line_number": 715,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: data_pipeline_optimization.ruchy\n// Optimize large-scale data processing\n\nuse std::parallel;\nuse std::stream;\n\nfun process_dataset(input_file, output_file) {\n    let start = perf::Timer::start()\n    \n    // Stream processing to avoid loading all data\n    let input = stream::FileStream::new(input_file)\n    let output = stream::FileWriter::new(output_file)\n    \n    input\n        // Parse in parallel\n        .parallel_map(|line| {\n            parse_record(line)\n        }, workers: num_cpus())\n        \n        // Filter early to reduce data\n        .filter(|record| {\n            record.is_valid() && record.value > threshold\n        })\n        \n        // Batch for efficient processing\n        .batch(1000)\n        \n        // Process batches in parallel\n        .parallel_map(|batch| {\n            let enriched = enrich_batch(batch)\n            let transformed = transform_batch(enriched)\n            return transformed\n        })\n        \n        // Flatten batches\n        .flatten()\n        \n        // Write with buffering\n        .for_each(|record| {\n            output.write_line(to_json(record))\n        })\n    \n    let duration = start.elapsed()\n    let records = input.count()\n    let throughput = records / duration.seconds()\n    \n    println(\"Processed \" + records.to_s() + \" records in \" + duration.to_s())\n    println(f\"Throughput: {throughput:.0} records/second\")\n}\n\n// Monitor performance\nlet monitor = perf::Monitor::new()\n\nmonitor.track(\"cpu_usage\", || system::cpu_usage())\nmonitor.track(\"memory_usage\", || system::memory_usage())\nmonitor.track(\"disk_io\", || system::disk_io_rate())\n\nprocess_dataset(\"input.jsonl\", \"output.jsonl\")\n\nmonitor.report()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 11,
          "line_number": 790,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// 1. Measure first\nperf::profile {\n    suspicious_function()\n}\n\n// 2. Optimize the right thing\n// Focus on the bottleneck, not random code\n\n// 3. Use the right algorithm\n// O(n) beats O(n²) even with overhead\n\n// 4. Batch operations\n// 1 operation on 1000 items > 1000 operations on 1 item\n\n// 5. Cache expensive computations\nlet cache = memoize(expensive_function)\n\n// 6. Parallelize independent work\nparallel::map(items, process)\n\n// 7. Use async for I/O\nasync::wait_all(io_operations)\n\n// 8. Profile in production\n// Dev performance ≠ Production performance",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch04-00-modules-tdd": {
      "chapter": "ch04-00-modules-tdd",
      "total_examples": 6,
      "working_examples": 1,
      "failing_examples": 5,
      "examples": [
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nmod math {\n    pub fun add(a: i32, b: i32) -> i32 {\n        a + b\n    }\n}\n\nfun main() {\n    let result = math::add(5, 3);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 2,
          "line_number": 57,
          "code": "// Status: ✅ WORKING\nmod utils {\n    pub fun greet() {\n        println(\"Hello from module!\");\n    }\n}\n\nfun main() {\n    utils::greet();\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmp6Oxhzh/main.rs:1:114\n  |\n1 | use std :: collections :: HashMap ; fn main () { mod utils { pub fn greet () { { println ! (\"Hello from module!\" . to_string ()) } } } ; ...\n  |                                                                                                                  ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmp6Oxhzh/main.rs:1:116\n  |\n1 | ...utils { pub fn greet () { { println ! (\"Hello from module!\" . to_string ()) } } } ; { utils :: greet () } }\n  |                                           --------------------   ^^^^^^^^^^^^ argument never used\n  |                                           |\n  |                                           formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp6Oxhzh/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { mod utils { pub fn greet () { { println ! (\"Hello from module!\" . to_string ()) } } } ; ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp6Oxhzh/main.rs:1:136\n  |\n1 | ...intln ! (\"Hello from module!\" . to_string ()) } } } ; { utils :: greet () } }\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp6Oxhzh/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn main () { mod utils { pub fn greet () { { println ! (\"Hello from module!\" . to_string ()) } } } ; ...\n  |                                                                                ^^                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { mod utils { pub fn greet () { { println ! (\"Hello from module!\" . to_string ()) } } } ; { utils :: greet () } }\n1 + use std :: collections :: HashMap ; fn main () { mod utils { pub fn greet () { println ! (\"Hello from module!\" . to_string ()) } } ; { utils :: greet () } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp6Oxhzh/main.rs:1:138\n  |\n1 | ...println ! (\"Hello from module!\" . to_string ()) } } } ; { utils :: greet () } }\n  |                                                            ^^                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { mod utils { pub fn greet () { { println ! (\"Hello from module!\" . to_string ()) } } } ; { utils :: greet () } }\n1 + use std :: collections :: HashMap ; fn main () { mod utils { pub fn greet () { { println ! (\"Hello from module!\" . to_string ()) } } } ; utils :: greet () }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmp6Oxhzh/main.rs:1:116\n  |\n1 | ...fn greet () { { println ! (\"Hello from module!\" . to_string ()) } } } ; { utils :: greet () } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 3,
          "line_number": 97,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nmod module_name {\n    pub fun public_function() {\n        // Accessible from outside\n    }\n    \n    fun private_function() {\n        // Only accessible within module\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found keyword `mod`\n --> /tmp/.tmpxys8Oi/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...\n  |                                                               ^^^ expected expression\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpxys8Oi/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 4,
          "line_number": 114,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfun main() {\n    module_name::public_function();  // Works\n    // module_name::private_function();  // Would fail - not public\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpFWVAeM/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpFWVAeM/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }\n  |                                                  ^^                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }\n1 + use std :: collections :: HashMap ; fn main () { module_name :: public_function () }\n  |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `module_name`\n --> /tmp/.tmpFWVAeM/main.rs:1:52\n  |\n1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }\n  |                                                    ^^^^^^^^^^^ use of unresolved module or unlinked crate `module_name`\n  |\n  = help: you might be missing a crate named `module_name`\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 5,
          "line_number": 142,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nmod math {\n    pub fun add(a: i32, b: i32) -> i32 { a + b }\n    pub fun subtract(a: i32, b: i32) -> i32 { a - b }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found keyword `mod`\n --> /tmp/.tmpzuCnhQ/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...\n  |                                                               ^^^ expected expression\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpzuCnhQ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 6,
          "line_number": 155,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nmod strings {\n    pub fun greet() { println(\"Hello!\"); }\n    pub fun farewell() { println(\"Goodbye!\"); }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found keyword `mod`\n --> /tmp/.tmp9R6fXX/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! (\"Hello!\" . to_string ()) } }...\n  |                                                               ^^^ expected expression\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp9R6fXX/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! (\"Hello!\" . to_string ()) } }...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch09-00-collections-tdd": {
      "chapter": "ch09-00-collections-tdd",
      "total_examples": 10,
      "working_examples": 1,
      "failing_examples": 9,
      "examples": [
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Counting to 5:\");\n    for i in 0..5 {\n        println(i);\n    }\n    println(\"Done counting\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmphrF05N/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Counting to 5:\" . to_string ()) ; for i in 0i32 .. 5i32 { { println ! (\"{}...\n  |                                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmphrF05N/main.rs:1:82\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Counting to 5:\" . to_string ()) ; for i in 0i32 .. 5i32 { { println ! (\"{}...\n  |                                                               ----------------   ^^^^^^^^^^^^ argument never used\n  |                                                               |\n  |                                                               formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmphrF05N/main.rs:1:178\n  |\n1 | ...2 { { println ! (\"{}\" , i) } } ; println ! (\"Done counting\" . to_string ()) } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmphrF05N/main.rs:1:180\n  |\n1 | ...{ { println ! (\"{}\" , i) } } ; println ! (\"Done counting\" . to_string ()) } }\n  |                                              ---------------   ^^^^^^^^^^^^ argument never used\n  |                                              |\n  |                                              formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmphrF05N/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Counting to 5:\" . to_string ()) ; for i in 0i32 .. 5i32 { { println ! (\"{}...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmphrF05N/main.rs:1:122\n  |\n1 | ...nting to 5:\" . to_string ()) ; for i in 0i32 .. 5i32 { { println ! (\"{}\" , i) } } ; println ! (\"Done counting\" . to_string ()) } }\n  |                                                           ^^                    ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { println ! (\"Counting to 5:\" . to_string ()) ; for i in 0i32 .. 5i32 { { println ! (\"{}\" , i) } } ; println ! (\"Done counting\" . to_string ()) } }\n1 + use std :: collections :: HashMap ; fn main () { { println ! (\"Counting to 5:\" . to_string ()) ; for i in 0i32 .. 5i32 { println ! (\"{}\" , i) } ; println ! (\"Done counting\" . to_string ()) } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmphrF05N/main.rs:1:82\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Counting to 5:\" . to_string ()) ; for i in 0i32 .. 5i32 { { println ! (\"{}...\n  |                                                                                  ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmphrF05N/main.rs:1:180\n  |\n1 | ...n ! (\"{}\" , i) } } ; println ! (\"Done counting\" . to_string ()) } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 2,
          "line_number": 60,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let mut sum = 0;\n    let mut i = 1;\n    while i <= 5 {\n        sum = sum + i;\n        i = i + 1;\n    }\n    println(\"Sum of 1-5:\");\n    println(sum);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmp6fZ7Y8/main.rs:1:172\n  |\n1 | ...sum = sum + i ; i = i + 1i32 } } ; println ! (\"Sum of 1-5:\" . to_string ()) ; println ! (\"{}\" , sum) } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmp6fZ7Y8/main.rs:1:174\n  |\n1 | ... = sum + i ; i = i + 1i32 } } ; println ! (\"Sum of 1-5:\" . to_string ()) ; println ! (\"{}\" , sum) } }\n  |                                               -------------   ^^^^^^^^^^^^ argument never used\n  |                                               |\n  |                                               formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp6fZ7Y8/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { let mut sum = 0i32 ; let mut i = 1i32 ; while i <= 5i32 { { sum = sum + i ; i = i + 1i...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmp6fZ7Y8/main.rs:1:174\n  |\n1 | ...i ; i = i + 1i32 } } ; println ! (\"Sum of 1-5:\" . to_string ()) ; println ! (\"{}\" , sum) } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 3,
          "line_number": 86,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Pattern:\");\n    for row in 0..3 {\n        for col in 0..3 {\n            if (row + col) % 2 == 0 {\n                print(\"*\");\n            } else {\n                print(\" \");\n            }\n        }\n        println(\"\");\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpP8akSq/main.rs:1:74\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Pattern:\" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .....\n  |                                                                          ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpP8akSq/main.rs:1:76\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Pattern:\" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .....\n  |                                                               ----------   ^^^^^^^^^^^^ argument never used\n  |                                                               |\n  |                                                               formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpP8akSq/main.rs:1:193\n  |\n1 | ...32 .. 3i32 { { if row + col % 2i32 == 0i32 { { print ! (\"*\" . to_string ()) } } else { { print ! (\" \" . to_string ()) } } } } ; printl...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpP8akSq/main.rs:1:195\n  |\n1 | ...32 { { if row + col % 2i32 == 0i32 { { print ! (\"*\" . to_string ()) } } else { { print ! (\" \" . to_string ()) } } } } ; println ! (\"\" ...\n  |                                                    ---   ^^^^^^^^^^^^ argument never used\n  |                                                    |\n  |                                                    formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpP8akSq/main.rs:1:235\n  |\n1 | ... { { print ! (\"*\" . to_string ()) } } else { { print ! (\" \" . to_string ()) } } } } ; println ! (\"\" . to_string ()) } } } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpP8akSq/main.rs:1:237\n  |\n1 | ...nt ! (\"*\" . to_string ()) } } else { { print ! (\" \" . to_string ()) } } } } ; println ! (\"\" . to_string ()) } } } }\n  |                                                    ---   ^^^^^^^^^^^^ argument never used\n  |                                                    |\n  |                                                    formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpP8akSq/main.rs:1:275\n  |\n1 | ...se { { print ! (\" \" . to_string ()) } } } } ; println ! (\"\" . to_string ()) } } } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpP8akSq/main.rs:1:277\n  |\n1 | ...int ! (\" \" . to_string ()) } } } } ; println ! (\"\" . to_string ()) } } } }\n  |                                                    --   ^^^^^^^^^^^^ argument never used\n  |                                                    |\n  |                                                    formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpP8akSq/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Pattern:\" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .....\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpP8akSq/main.rs:1:146\n  |\n1 | ...2 .. 3i32 { { if row + col % 2i32 == 0i32 { { print ! (\"*\" . to_string ()) } } else { { print ! (\" \" . to_string ()) } } } } ; println...\n  |                ^^                                                                                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { println ! (\"Pattern:\" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .. 3i32 { { if row + col % 2i32 == 0i32 { { print ! (\"*\" . to_string ()) } } else { { print ! (\" \" . to_string ()) } } } } ; println ! (\"\" . to_string ()) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { println ! (\"Pattern:\" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .. 3i32 { if row + col % 2i32 == 0i32 { { print ! (\"*\" . to_string ()) } } else { { print ! (\" \" . to_string ()) } } } ; println ! (\"\" . to_string ()) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpP8akSq/main.rs:1:178\n  |\n1 | ... in 0i32 .. 3i32 { { if row + col % 2i32 == 0i32 { { print ! (\"*\" . to_string ()) } } else { { print ! (\" \" . to_string ()) } } } } ; ...\n  |                                                       ^^                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { println ! (\"Pattern:\" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .. 3i32 { { if row + col % 2i32 == 0i32 { { print ! (\"*\" . to_string ()) } } else { { print ! (\" \" . to_string ()) } } } } ; println ! (\"\" . to_string ()) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { println ! (\"Pattern:\" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .. 3i32 { { if row + col % 2i32 == 0i32 { print ! (\"*\" . to_string ()) } else { { print ! (\" \" . to_string ()) } } } } ; println ! (\"\" . to_string ()) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpP8akSq/main.rs:1:220\n  |\n1 | ...= 0i32 { { print ! (\"*\" . to_string ()) } } else { { print ! (\" \" . to_string ()) } } } } ; println ! (\"\" . to_string ()) } } } }\n  |                                                       ^^                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { println ! (\"Pattern:\" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .. 3i32 { { if row + col % 2i32 == 0i32 { { print ! (\"*\" . to_string ()) } } else { { print ! (\" \" . to_string ()) } } } } ; println ! (\"\" . to_string ()) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { println ! (\"Pattern:\" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .. 3i32 { { if row + col % 2i32 == 0i32 { { print ! (\"*\" . to_string ()) } } else { print ! (\" \" . to_string ()) } } } ; println ! (\"\" . to_string ()) } } } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpP8akSq/main.rs:1:76\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Pattern:\" . to_string ()) ; for row in 0i32 .. 3i32 { { for col in 0i32 .....\n  |                                                                            ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpP8akSq/main.rs:1:195\n  |\n1 | ... { if row + col % 2i32 == 0i32 { { print ! (\"*\" . to_string ()) } } else { { print ! (\" \" . to_string ()) } } } } ; println ! (\"\" . to...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpP8akSq/main.rs:1:237\n  |\n1 | ... (\"*\" . to_string ()) } } else { { print ! (\" \" . to_string ()) } } } } ; println ! (\"\" . to_string ()) } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpP8akSq/main.rs:1:277\n  |\n1 | ... ! (\" \" . to_string ()) } } } } ; println ! (\"\" . to_string ()) } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 12 previous errors; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 4,
          "line_number": 134,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfor variable in start..end {\n    // Process each value\n    println(variable);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `start` in this scope\n --> /tmp/.tmpbqnroG/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{}\" , variable) } } ; if let S...\n  |                                                                               ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `end` in this scope\n --> /tmp/.tmpbqnroG/main.rs:1:88\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{}\" , variable) } } ; if let S...\n  |                                                                                        ^^^ not found in this scope\n  |\nhelp: you might have meant to write `.` instead of `..`\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{}\" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start.end { { println ! (\"{}\" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpbqnroG/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{}\" , variable) } } ; if let S...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpbqnroG/main.rs:1:94\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{}\" , variable) } } ; if let S...\n  |                                                                                              ^^                           ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{}\" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { println ! (\"{}\" , variable) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 5,
          "line_number": 146,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet mut accumulator = initial_value;\nlet mut counter = start;\nwhile counter <= end {\n    accumulator = update(accumulator, counter);\n    counter = counter + 1;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `initial_value` in this scope\n --> /tmp/.tmpuEBIHI/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut accumulator = initial_value ; let mut counter = start ; while cou...\n  |                                                                                       ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `start` in this scope\n --> /tmp/.tmpuEBIHI/main.rs:1:121\n  |\n1 | ...mut accumulator = initial_value ; let mut counter = start ; while counter <= end { { accumulator = update (accumulator , counter) ; co...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `end` in this scope\n --> /tmp/.tmpuEBIHI/main.rs:1:146\n  |\n1 | ...l_value ; let mut counter = start ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 }...\n  |                                                         ^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpuEBIHI/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut accumulator = initial_value ; let mut counter = start ; while cou...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `update` in this scope\n --> /tmp/.tmpuEBIHI/main.rs:1:168\n  |\n1 | ...er = start ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 } } } ; if let Some (s) ...\n  |                                                        ^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 6,
          "line_number": 160,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfor outer in 0..height {\n    for inner in 0..width {\n        // Process (outer, inner) coordinate\n        process(outer, inner);\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `height` in this scope\n --> /tmp/.tmpfg4XYs/main.rs:1:84\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...\n  |                                                                                    ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `width` in this scope\n --> /tmp/.tmpfg4XYs/main.rs:1:116\n  |\n1 | ...or outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn s...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpfg4XYs/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpfg4XYs/main.rs:1:93\n  |\n1 | ...ult = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as ...\n  |                                        ^^                                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { for inner in 0i32 .. width { { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpfg4XYs/main.rs:1:124\n  |\n1 | ...r in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: a...\n  |                                                         ^^                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `process` in this scope\n --> /tmp/.tmpfg4XYs/main.rs:1:126\n  |\n1 | ... 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 7,
          "line_number": 188,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfor i in 1..10 {\n    let result = process(i);\n    println(result);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpFB7CEJ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! (\"{}\" , r...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpFB7CEJ/main.rs:1:88\n  |\n1 | ...et result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! (\"{}\" , result) } } } ; if let Some (s) = (& result as &...\n  |                                         ^^                                                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! (\"{}\" , result) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { let result = process (i) ; println ! (\"{}\" , result) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `process` in this scope\n --> /tmp/.tmpFB7CEJ/main.rs:1:105\n  |\n1 | ...result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! (\"{}\" , result) } } } ; if let Some (s) = (& result as & dy...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 8,
          "line_number": 200,
          "code": "// Status: ✅ WORKING\nlet mut total = 0;\nfor value in 1..100 {\n    total = total + value;\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 9,
          "line_number": 211,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfor row in 0..height {\n    for col in 0..width {\n        let value = calculate(row, col);\n        display(value);\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `height` in this scope\n --> /tmp/.tmpNmkVN2/main.rs:1:82\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...\n  |                                                                                  ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `width` in this scope\n --> /tmp/.tmpNmkVN2/main.rs:1:112\n  |\n1 | ... = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpNmkVN2/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpNmkVN2/main.rs:1:91\n  |\n1 | ... in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) ...\n  |                         ^^                                                                                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpNmkVN2/main.rs:1:120\n  |\n1 | ...eight { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result a...\n  |                                         ^^                                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `calculate` in this scope\n --> /tmp/.tmpNmkVN2/main.rs:1:136\n  |\n1 | ...ht { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as &...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `display` in this scope\n --> /tmp/.tmpNmkVN2/main.rs:1:160\n  |\n1 | ..... width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any)...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 10,
          "line_number": 225,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet mut count = 0;\nfor i in 1..100 {\n    if condition(i) {\n        count = count + 1;\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpBHto0t/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { c...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpBHto0t/main.rs:1:114\n  |\n1 | ... count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn...\n  |                                              ^^                                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { if condition (i) { { count = count + 1i32 } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpBHto0t/main.rs:1:135\n  |\n1 | ... 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: ...\n  |                                                           ^^                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { count = count + 1i32 } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `condition` in this scope\n --> /tmp/.tmpBHto0t/main.rs:1:119\n  |\n1 | ...mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch19-00-real-world-projects": {
      "chapter": "ch19-00-real-world-projects",
      "total_examples": 4,
      "working_examples": 0,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch19-00-real-world-projects.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// taskmaster.ruchy - Complete task management system\nuse std::cli::{App, Arg, SubCommand};\nuse std::fs;\nuse std::chrono::{DateTime, Local};\n\n#[derive(Serialize, Deserialize, Clone)]\nstruct Task {\n    id: String,\n    title: String,\n    description: Option<String>,\n    status: TaskStatus,\n    priority: Priority,\n    due_date: Option<DateTime<Local>>,\n    tags: Vec<String>,\n    created_at: DateTime<Local>,\n    completed_at: Option<DateTime<Local>>,\n}\n\n#[derive(Serialize, Deserialize, Clone)]\nenum TaskStatus {\n    Todo,\n    InProgress,\n    Done,\n    Archived\n}\n\n#[derive(Serialize, Deserialize, Clone)]\nenum Priority {\n    Low,\n    Medium,\n    High,\n    Critical\n}\n\nstruct TaskStore {\n    path: PathBuf,\n    tasks: Vec<Task>,\n}\n\nimpl TaskStore {\n    fun load(path: PathBuf) -> Result<Self> {\n        let tasks = if path.exists() {\n            let content = fs::read_to_string(&path)?;\n            serde_json::from_str(&content)?\n        } else {\n            Vec::new()\n        };\n        \n        Ok(TaskStore { path, tasks })\n    }\n    \n    fun save(&self) -> Result<()> {\n        let json = serde_json::to_string_pretty(&self.tasks)?;\n        fs::write(&self.path, json)?;\n        Ok(())\n    }\n    \n    fun add(&mut self, task: Task) -> Result<()> {\n        self.tasks.push(task);\n        self.save()\n    }\n    \n    fun find(&self, id: &str) -> Option<&Task> {\n        self.tasks.iter().find(|t| t.id == id)\n    }\n    \n    fun update<F>(&mut self, id: &str, updater: F) -> Result<()>\n    where F: FnOnce(&mut Task)\n    {\n        if let Some(task) = self.tasks.iter_mut().find(|t| t.id == id) {\n            updater(task);\n            self.save()?;\n        }\n        Ok(())\n    }\n    \n    fun list(&self, filter: Option<TaskFilter>) -> Vec<&Task> {\n        self.tasks.iter()\n            .filter(|t| {\n                if let Some(ref f) = filter {\n                    f.matches(t)\n                } else {\n                    true\n                }\n            })\n            .collect()\n    }\n}\n\nstruct TaskFilter {\n    status: Option<TaskStatus>,\n    priority: Option<Priority>,\n    tags: Vec<String>,\n    search: Option<String>,\n}\n\nimpl TaskFilter {\n    fun matches(&self, task: &Task) -> bool {\n        if let Some(ref status) = self.status {\n            if task.status != *status {\n                return false;\n            }\n        }\n        \n        if let Some(ref priority) = self.priority {\n            if task.priority != *priority {\n                return false;\n            }\n        }\n        \n        if !self.tags.is_empty() {\n            if !self.tags.iter().any(|tag| task.tags.contains(tag)) {\n                return false;\n            }\n        }\n        \n        if let Some(ref search) = self.search {\n            let search_lower = search.to_lowercase();\n            if !task.title.to_lowercase().contains(&search_lower) &&\n               !task.description.as_ref()\n                   .map(|d| d.to_lowercase().contains(&search_lower))\n                   .unwrap_or(false) {\n                return false;\n            }\n        }\n        \n        true\n    }\n}\n\nfun main() -> Result<()> {\n    let app = App::new(\"taskmaster\")\n        .version(\"1.0.0\")\n        .author(\"Your Name\")\n        .about(\"Powerful task management from the command line\")\n        .subcommand(\n            SubCommand::with_name(\"add\")\n                .about(\"Add a new task\")\n                .arg(Arg::with_name(\"title\").required(true))\n                .arg(Arg::with_name(\"description\").short(\"d\").takes_value(true))\n                .arg(Arg::with_name(\"priority\").short(\"p\").takes_value(true))\n                .arg(Arg::with_name(\"due\").long(\"due\").takes_value(true))\n                .arg(Arg::with_name(\"tags\").short(\"t\").multiple(true))\n        )\n        .subcommand(\n            SubCommand::with_name(\"list\")\n                .about(\"List tasks\")\n                .arg(Arg::with_name(\"status\").short(\"s\").takes_value(true))\n                .arg(Arg::with_name(\"priority\").short(\"p\").takes_value(true))\n                .arg(Arg::with_name(\"tags\").short(\"t\").multiple(true))\n        )\n        .subcommand(\n            SubCommand::with_name(\"done\")\n                .about(\"Mark task as done\")\n                .arg(Arg::with_name(\"id\").required(true))\n        )\n        .get_matches();\n    \n    let store_path = dirs::home_dir()\n        .unwrap()\n        .join(\".taskmaster\")\n        .join(\"tasks.json\");\n    \n    let mut store = TaskStore::load(store_path)?;\n    \n    match app.subcommand() {\n        (\"add\", Some(matches)) => {\n            let task = Task {\n                id: generate_id(),\n                title: matches.value_of(\"title\").unwrap().to_string(),\n                description: matches.value_of(\"description\").map(String::from),\n                status: TaskStatus::Todo,\n                priority: matches.value_of(\"priority\")\n                    .and_then(|p| p.parse().ok())\n                    .unwrap_or(Priority::Medium),\n                due_date: matches.value_of(\"due\")\n                    .and_then(|d| parse_date(d).ok()),\n                tags: matches.values_of(\"tags\")\n                    .map(|tags| tags.map(String::from).collect())\n                    .unwrap_or_default(),\n                created_at: Local::now(),\n                completed_at: None,\n            };\n            \n            store.add(task)?;\n            println!(\"✅ Task added successfully!\");\n        }\n        \n        (\"list\", Some(matches)) => {\n            let filter = TaskFilter {\n                status: matches.value_of(\"status\").and_then(|s| s.parse().ok()),\n                priority: matches.value_of(\"priority\").and_then(|p| p.parse().ok()),\n                tags: matches.values_of(\"tags\")\n                    .map(|tags| tags.map(String::from).collect())\n                    .unwrap_or_default(),\n                search: None,\n            };\n            \n            let tasks = store.list(Some(filter));\n            \n            for task in tasks {\n                let status_emoji = match task.status {\n                    TaskStatus::Todo => \"⬜\",\n                    TaskStatus::InProgress => \"🔄\",\n                    TaskStatus::Done => \"✅\",\n                    TaskStatus::Archived => \"📦\",\n                };\n                \n                let priority_marker = match task.priority {\n                    Priority::Critical => \"🔴\",\n                    Priority::High => \"🟠\",\n                    Priority::Medium => \"🟡\",\n                    Priority::Low => \"🟢\",\n                };\n                \n                println!(\"{} {} {} {}\", \n                    status_emoji, \n                    priority_marker,\n                    task.id[..8].to_string(),\n                    task.title\n                );\n                \n                if let Some(ref desc) = task.description {\n                    println!(\"    {}\", desc);\n                }\n                \n                if !task.tags.is_empty() {\n                    println!(\"    Tags: {}\", task.tags.join(\", \"));\n                }\n            }\n        }\n        \n        (\"done\", Some(matches)) => {\n            let id = matches.value_of(\"id\").unwrap();\n            store.update(id, |task| {\n                task.status = TaskStatus::Done;\n                task.completed_at = Some(Local::now());\n            })?;\n            println!(\"✅ Task marked as done!\");\n        }\n        \n        _ => {\n            println!(\"Use --help for usage information\");\n        }\n    }\n    \n    Ok(())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch19-00-real-world-projects.md",
          "example_number": 2,
          "line_number": 293,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// api_server.ruchy - Complete web service\nuse warp::{Filter, Reply, Rejection};\nuse sqlx::{PgPool, FromRow};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize, FromRow)]\nstruct User {\n    id: i32,\n    username: String,\n    email: String,\n    created_at: chrono::DateTime<chrono::Utc>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct CreateUser {\n    username: String,\n    email: String,\n    password: String,\n}\n\n#[derive(Clone)]\nstruct AppState {\n    db: PgPool,\n    jwt_secret: String,\n}\n\nasync fun create_user(\n    user: CreateUser,\n    state: AppState,\n) -> Result<impl Reply, Rejection> {\n    let hashed_password = hash_password(&user.password)?;\n    \n    let result = sqlx::query_as!(\n        User,\n        r#\"\n        INSERT INTO users (username, email, password_hash)\n        VALUES ($1, $2, $3)\n        RETURNING id, username, email, created_at\n        \"#,\n        user.username,\n        user.email,\n        hashed_password\n    )\n    .fetch_one(&state.db)\n    .await\n    .map_err(|e| reject::custom(DatabaseError(e)))?;\n    \n    Ok(warp::reply::json(&result))\n}\n\nasync fun get_user(\n    id: i32,\n    state: AppState,\n) -> Result<impl Reply, Rejection> {\n    let user = sqlx::query_as!(\n        User,\n        \"SELECT id, username, email, created_at FROM users WHERE id = $1\",\n        id\n    )\n    .fetch_one(&state.db)\n    .await\n    .map_err(|e| reject::custom(DatabaseError(e)))?;\n    \n    Ok(warp::reply::json(&user))\n}\n\nasync fun list_users(\n    state: AppState,\n) -> Result<impl Reply, Rejection> {\n    let users = sqlx::query_as!(\n        User,\n        \"SELECT id, username, email, created_at FROM users ORDER BY created_at DESC\"\n    )\n    .fetch_all(&state.db)\n    .await\n    .map_err(|e| reject::custom(DatabaseError(e)))?;\n    \n    Ok(warp::reply::json(&users))\n}\n\nfun with_state(\n    state: AppState,\n) -> impl Filter<Extract = (AppState,), Error = Infallible> + Clone {\n    warp::any().map(move || state.clone())\n}\n\nfun routes(state: AppState) -> impl Filter<Extract = impl Reply> + Clone {\n    let users_create = warp::path(\"users\")\n        .and(warp::post())\n        .and(warp::body::json())\n        .and(with_state(state.clone()))\n        .and_then(create_user);\n    \n    let users_get = warp::path!(\"users\" / i32)\n        .and(warp::get())\n        .and(with_state(state.clone()))\n        .and_then(get_user);\n    \n    let users_list = warp::path(\"users\")\n        .and(warp::get())\n        .and(with_state(state.clone()))\n        .and_then(list_users);\n    \n    let health = warp::path(\"health\")\n        .and(warp::get())\n        .map(|| \"OK\");\n    \n    users_create\n        .or(users_get)\n        .or(users_list)\n        .or(health)\n        .with(warp::cors().allow_any_origin())\n        .with(warp::log(\"api\"))\n        .recover(handle_rejection)\n}\n\nasync fun handle_rejection(err: Rejection) -> Result<impl Reply, Infallible> {\n    let code;\n    let message;\n    \n    if err.is_not_found() {\n        code = StatusCode::NOT_FOUND;\n        message = \"Not Found\";\n    } else if let Some(DatabaseError(_)) = err.find() {\n        code = StatusCode::INTERNAL_SERVER_ERROR;\n        message = \"Database Error\";\n    } else {\n        code = StatusCode::INTERNAL_SERVER_ERROR;\n        message = \"Internal Server Error\";\n    }\n    \n    let json = warp::reply::json(&ErrorResponse {\n        message: message.to_string(),\n    });\n    \n    Ok(warp::reply::with_status(json, code))\n}\n\n#[tokio::main]\nasync fun main() -> Result<()> {\n    env_logger::init();\n    \n    let database_url = env::var(\"DATABASE_URL\")\n        .expect(\"DATABASE_URL must be set\");\n    \n    let pool = PgPool::connect(&database_url).await?;\n    \n    // Run migrations\n    sqlx::migrate!(\"./migrations\").run(&pool).await?;\n    \n    let state = AppState {\n        db: pool,\n        jwt_secret: env::var(\"JWT_SECRET\")\n            .expect(\"JWT_SECRET must be set\"),\n    };\n    \n    let routes = routes(state);\n    \n    println!(\"🚀 Server running on http://localhost:3030\");\n    \n    warp::serve(routes)\n        .run(([0, 0, 0, 0], 3030))\n        .await;\n    \n    Ok(())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch19-00-real-world-projects.md",
          "example_number": 3,
          "line_number": 474,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// sysmon.ruchy - System monitoring dashboard\nuse sysinfo::{System, SystemExt, ProcessExt, CpuExt};\nuse tui::{Terminal, Frame, backend::CrosstermBackend};\nuse crossterm::event::{self, Event, KeyCode};\n\nstruct App {\n    system: System,\n    cpu_history: Vec<f32>,\n    memory_history: Vec<f32>,\n    selected_process: Option<usize>,\n    processes: Vec<ProcessInfo>,\n}\n\n#[derive(Clone)]\nstruct ProcessInfo {\n    pid: u32,\n    name: String,\n    cpu_usage: f32,\n    memory: u64,\n    status: String,\n}\n\nimpl App {\n    fun new() -> Self {\n        let mut system = System::new_all();\n        system.refresh_all();\n        \n        App {\n            system,\n            cpu_history: Vec::with_capacity(60),\n            memory_history: Vec::with_capacity(60),\n            selected_process: None,\n            processes: Vec::new(),\n        }\n    }\n    \n    fun update(&mut self) {\n        self.system.refresh_all();\n        \n        // Update CPU history\n        let cpu_usage = self.system.global_cpu_info().cpu_usage();\n        self.cpu_history.push(cpu_usage);\n        if self.cpu_history.len() > 60 {\n            self.cpu_history.remove(0);\n        }\n        \n        // Update memory history\n        let used_memory = self.system.used_memory();\n        let total_memory = self.system.total_memory();\n        let memory_usage = (used_memory as f32 / total_memory as f32) * 100.0;\n        self.memory_history.push(memory_usage);\n        if self.memory_history.len() > 60 {\n            self.memory_history.remove(0);\n        }\n        \n        // Update process list\n        self.processes = self.system.processes()\n            .iter()\n            .map(|(pid, process)| ProcessInfo {\n                pid: pid.as_u32(),\n                name: process.name().to_string(),\n                cpu_usage: process.cpu_usage(),\n                memory: process.memory(),\n                status: format!(\"{:?}\", process.status()),\n            })\n            .collect();\n        \n        // Sort by CPU usage\n        self.processes.sort_by(|a, b| \n            b.cpu_usage.partial_cmp(&a.cpu_usage).unwrap()\n        );\n    }\n    \n    fun draw(&self, frame: &mut Frame<impl Backend>) {\n        let chunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Length(3),\n                Constraint::Percentage(30),\n                Constraint::Percentage(30),\n                Constraint::Percentage(40),\n            ])\n            .split(frame.size());\n        \n        // Header\n        let header = Paragraph::new(\"System Monitor - Press 'q' to quit\")\n            .style(Style::default().fg(Color::Cyan))\n            .block(Block::default().borders(Borders::ALL));\n        frame.render_widget(header, chunks[0]);\n        \n        // CPU Chart\n        let cpu_data: Vec<(f64, f64)> = self.cpu_history\n            .iter()\n            .enumerate()\n            .map(|(i, &val)| (i as f64, val as f64))\n            .collect();\n        \n        let cpu_chart = Chart::new(vec![\n            Dataset::default()\n                .name(\"CPU\")\n                .marker(symbols::Marker::Dot)\n                .style(Style::default().fg(Color::Yellow))\n                .data(&cpu_data),\n        ])\n        .block(Block::default().title(\"CPU Usage\").borders(Borders::ALL))\n        .x_axis(Axis::default()\n            .bounds([0.0, 60.0])\n            .labels(vec![\"60s\", \"30s\", \"Now\"]))\n        .y_axis(Axis::default()\n            .bounds([0.0, 100.0])\n            .labels(vec![\"0%\", \"50%\", \"100%\"]));\n        \n        frame.render_widget(cpu_chart, chunks[1]);\n        \n        // Memory Chart\n        let memory_data: Vec<(f64, f64)> = self.memory_history\n            .iter()\n            .enumerate()\n            .map(|(i, &val)| (i as f64, val as f64))\n            .collect();\n        \n        let memory_chart = Chart::new(vec![\n            Dataset::default()\n                .name(\"Memory\")\n                .marker(symbols::Marker::Dot)\n                .style(Style::default().fg(Color::Blue))\n                .data(&memory_data),\n        ])\n        .block(Block::default().title(\"Memory Usage\").borders(Borders::ALL))\n        .x_axis(Axis::default()\n            .bounds([0.0, 60.0])\n            .labels(vec![\"60s\", \"30s\", \"Now\"]))\n        .y_axis(Axis::default()\n            .bounds([0.0, 100.0])\n            .labels(vec![\"0%\", \"50%\", \"100%\"]));\n        \n        frame.render_widget(memory_chart, chunks[2]);\n        \n        // Process List\n        let processes: Vec<ListItem> = self.processes\n            .iter()\n            .take(10)\n            .map(|p| {\n                let content = format!(\"{:5} {:20} {:6.1}% {:8}\",\n                    p.pid,\n                    p.name,\n                    p.cpu_usage,\n                    format_bytes(p.memory)\n                );\n                ListItem::new(content)\n            })\n            .collect();\n        \n        let process_list = List::new(processes)\n            .block(Block::default()\n                .title(\"Top Processes (PID | Name | CPU | Memory)\")\n                .borders(Borders::ALL))\n            .highlight_style(Style::default().bg(Color::DarkGray));\n        \n        frame.render_widget(process_list, chunks[3]);\n    }\n}\n\n#[tokio::main]\nasync fun main() -> Result<()> {\n    // Setup terminal\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backend = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backend)?;\n    \n    let mut app = App::new();\n    let mut last_update = Instant::now();\n    \n    loop {\n        // Update data every second\n        if last_update.elapsed() >= Duration::from_secs(1) {\n            app.update();\n            last_update = Instant::now();\n        }\n        \n        // Draw UI\n        terminal.draw(|f| app.draw(f))?;\n        \n        // Handle events\n        if event::poll(Duration::from_millis(100))? {\n            if let Event::Key(key) = event::read()? {\n                match key.code {\n                    KeyCode::Char('q') => break,\n                    KeyCode::Up => {\n                        if let Some(selected) = &mut app.selected_process {\n                            if *selected > 0 {\n                                *selected -= 1;\n                            }\n                        }\n                    }\n                    KeyCode::Down => {\n                        if let Some(selected) = &mut app.selected_process {\n                            if *selected < app.processes.len() - 1 {\n                                *selected += 1;\n                            }\n                        } else {\n                            app.selected_process = Some(0);\n                        }\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n    \n    // Restore terminal\n    disable_raw_mode()?;\n    execute!(terminal.backend_mut(), LeaveAlternateScreen)?;\n    terminal.show_cursor()?;\n    \n    Ok(())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch19-00-real-world-projects.md",
          "example_number": 4,
          "line_number": 742,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// 1. Project structure\nmy-project/\n├── src/\n│   ├── main.rs\n│   ├── lib.rs\n│   ├── models/\n│   ├── handlers/\n│   └── utils/\n├── tests/\n├── benches/\n├── docs/\n├── Cargo.toml\n├── README.md\n└── .github/\n    └── workflows/\n\n// 2. Error handling\ntype Result<T> = std::result::Result<T, Error>;\n\n#[derive(Debug, thiserror::Error)]\nenum Error {\n    #[error(\"Database error: {0}\")]\n    Database(#[from] sqlx::Error),\n    \n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n    \n    #[error(\"Invalid input: {0}\")]\n    InvalidInput(String),\n}\n\n// 3. Configuration\n#[derive(Debug, Deserialize)]\nstruct Config {\n    server: ServerConfig,\n    database: DatabaseConfig,\n    #[serde(default)]\n    features: Features,\n}\n\nimpl Config {\n    fun load() -> Result<Self> {\n        // Try multiple sources\n        let config = config::Config::builder()\n            .add_source(config::File::with_name(\"config\"))\n            .add_source(config::Environment::with_prefix(\"APP\"))\n            .build()?;\n        \n        Ok(config.try_deserialize()?)\n    }\n}\n\n// 4. Logging\nfun init_logging() {\n    tracing_subscriber::fmt()\n        .with_env_filter(EnvFilter::from_default_env())\n        .with_target(false)\n        .with_thread_ids(true)\n        .with_file(true)\n        .with_line_number(true)\n        .init();\n}\n\n// 5. Testing\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fun test_functionality() {\n        // Arrange\n        let input = prepare_test_data();\n        \n        // Act\n        let result = function_under_test(input);\n        \n        // Assert\n        assert_eq!(result, expected);\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch21-00-professional-tooling-tdd": {
      "chapter": "ch21-00-professional-tooling-tdd",
      "total_examples": 1,
      "working_examples": 1,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch21-00-professional-tooling-tdd.md",
          "example_number": 1,
          "line_number": 23,
          "code": "// Status: ✅ WORKING\n// test/tooling/simple_test.ruchy - ✓ VERIFIED WORKING\nfun add(a: i32, b: i32) -> i32 {\n    a + b\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "conclusion": {
      "chapter": "conclusion",
      "total_examples": 2,
      "working_examples": 1,
      "failing_examples": 1,
      "examples": [
        {
          "file": "src/conclusion.md",
          "example_number": 1,
          "line_number": 205,
          "code": "// Status: ✅ WORKING\nfun calculate(x: i32, y: i32) -> i32 {\n    return x + y;\n}\n\nfun main() {\n    let result = calculate(10, 20);\n    println(result);  // Output: 30\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/conclusion.md",
          "example_number": 2,
          "line_number": 220,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\n// Arrays - NOT YET\nlet arr = [1, 2, 3];\n\n// User Input - NOT YET  \nlet name = input(\"Enter name: \");\n\n// File I/O - NOT YET\nlet contents = fs::read_to_string(\"file.txt\");\n\n// Closures - NOT YET\nlet add_one = |x| x + 1;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpusQQ53/main.rs:1:266\n  |\n1 | ...()) ; let mut add_one = | x | x + 1i32 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n --> /tmp/.tmpusQQ53/main.rs:1:182\n  |\n1 | ...e: \" . to_string ()) ; let mut contents = fs :: read_to_string (\"file.txt\" . to_string ()) ; let mut add_one = | x | x + 1i32 } ; if l...\n  |                                              ^^ use of unresolved module or unlinked crate `fs`\n  |\n  = help: you might be missing a crate named `fs`\nhelp: consider importing this module\n  |\n1 + use std::fs;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpusQQ53/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut arr = vec ! [1i32 , 2i32 , 3i32] ; let mut name = input (\"Enter n...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpusQQ53/main.rs:1:123\n  |\n1 | ...t arr = vec ! [1i32 , 2i32 , 3i32] ; let mut name = input (\"Enter name: \" . to_string ()) ; let mut contents = fs :: read_to_string (\"...\n  |                                                        ^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch11-00-advanced-patterns": {
      "chapter": "ch11-00-advanced-patterns",
      "total_examples": 12,
      "working_examples": 0,
      "failing_examples": 12,
      "examples": [
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: event_system.ruchy\n// Event-driven architecture with multiple patterns\n\nuse std::patterns;\n\n// Observer pattern for events\nclass EventBus {\n    let subscribers = {}\n    \n    fun on(event, handler) {\n        if !subscribers.has_key(event) {\n            subscribers[event] = []\n        }\n        subscribers[event].push(handler)\n        \n        // Return unsubscribe function (closure pattern)\n        return || {\n            subscribers[event] = subscribers[event].filter(|h| h != handler)\n        }\n    }\n    \n    fun emit(event, data) {\n        if subscribers.has_key(event) {\n            for handler in subscribers[event] {\n                spawn { handler(data) }  // Async pattern\n            }\n        }\n    }\n}\n\n// Singleton pattern for global event bus\nlet events = EventBus::singleton()\n\n// Decorator pattern for logging\nfun with_logging(handler) {\n    return |data| {\n        println(\"[\" + current_datetime() + \"] Event triggered: \" + data)\n        let result = handler(data)\n        println(\"[\" + current_datetime() + \"] Event completed\")\n        return result\n    }\n}\n\n// Usage combining patterns\nlet unsubscribe = events.on(\"user.login\", with_logging(|user| {\n    println(\"User \" + user.name + \" logged in\")\n    update_last_login(user)\n}))\n\nevents.emit(\"user.login\", {name: \"Alice\", id: 123})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 2,
          "line_number": 99,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Fluent interface for configuration\nclass ServerBuilder {\n    let config = {\n        port: 8080,\n        host: \"localhost\",\n        threads: 4,\n        timeout: 30000,\n        middleware: [],\n        routes: {}\n    }\n    \n    fun port(p) {\n        config.port = p\n        return self  // Enable chaining\n    }\n    \n    fun host(h) {\n        config.host = h\n        return self\n    }\n    \n    fun threads(t) {\n        config.threads = t\n        return self\n    }\n    \n    fun use(middleware) {\n        config.middleware.push(middleware)\n        return self\n    }\n    \n    fun route(path, handler) {\n        config.routes[path] = handler\n        return self\n    }\n    \n    fun build() {\n        validate_config()\n        return Server::new(config)\n    }\n}\n\n// Clean, readable configuration\nlet server = ServerBuilder::new()\n    .port(3000)\n    .host(\"0.0.0.0\")\n    .threads(8)\n    .use(cors())\n    .use(auth())\n    .use(logging())\n    .route(\"/\", home_handler)\n    .route(\"/api\", api_handler)\n    .build()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 3,
          "line_number": 167,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Different compression strategies\nclass CompressionContext {\n    let strategy\n    \n    fun set_strategy(s) {\n        strategy = s\n    }\n    \n    fun compress(data) {\n        return strategy.compress(data)\n    }\n}\n\nclass GzipStrategy {\n    fun compress(data) {\n        return gzip::compress(data, level: 6)\n    }\n}\n\nclass BrotliStrategy {\n    fun compress(data) {\n        return brotli::compress(data, quality: 4)\n    }\n}\n\nclass NoCompressionStrategy {\n    fun compress(data) {\n        return data\n    }\n}\n\n// Choose strategy based on context\nlet compressor = CompressionContext::new()\n\nif file_size > mb(10) {\n    compressor.set_strategy(BrotliStrategy::new())  // Better for large files\n} else if client_supports_gzip {\n    compressor.set_strategy(GzipStrategy::new())\n} else {\n    compressor.set_strategy(NoCompressionStrategy::new())\n}\n\nlet compressed = compressor.compress(file_data)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 4,
          "line_number": 225,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Middleware chain for request processing\nclass MiddlewareChain {\n    let middlewares = []\n    \n    fun use(middleware) {\n        middlewares.push(middleware)\n    }\n    \n    fun execute(request, response) {\n        let index = 0\n        \n        fun next() {\n            if index < middlewares.len() {\n                let middleware = middlewares[index]\n                index += 1\n                middleware(request, response, next)\n            }\n        }\n        \n        next()\n    }\n}\n\n// Define middleware\nfun auth_middleware(req, res, next) {\n    let token = req.header(\"Authorization\")\n    if !token {\n        return res.status(401).json({error: \"Unauthorized\"})\n    }\n    \n    req.user = validate_token(token)\n    next()\n}\n\nfun rate_limit_middleware(req, res, next) {\n    let key = req.ip\n    if rate_limiter.exceeded(key) {\n        return res.status(429).json({error: \"Too many requests\"})\n    }\n    \n    rate_limiter.increment(key)\n    next()\n}\n\nfun cache_middleware(req, res, next) {\n    let cache_key = req.url\n    if cache.has(cache_key) {\n        return res.send(cache.get(cache_key))\n    }\n    \n    // Intercept response to cache it\n    let original_send = res.send\n    res.send = |data| {\n        cache.set(cache_key, data)\n        original_send(data)\n    }\n    \n    next()\n}\n\n// Build the chain\nlet chain = MiddlewareChain::new()\nchain.use(rate_limit_middleware)\nchain.use(auth_middleware)\nchain.use(cache_middleware)\nchain.use(route_handler)\n\nchain.execute(request, response)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 5,
          "line_number": 310,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Function composition\nfun compose(...functions) {\n    return |x| {\n        let result = x\n        for f in functions.reverse() {\n            result = f(result)\n        }\n        return result\n    }\n}\n\n// Pipeline operator\nfun pipeline(value, ...functions) {\n    let result = value\n    for f in functions {\n        result = f(result)\n    }\n    return result\n}\n\n// Example: Data transformation pipeline\nlet process_data = compose(\n    validate,\n    normalize,\n    enrich,\n    transform,\n    format\n)\n\nlet result = process_data(raw_data)\n\n// Or using pipeline\nlet result = pipeline(\n    raw_data,\n    validate,\n    normalize,\n    enrich,\n    transform,\n    format\n)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 6,
          "line_number": 365,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Result monad for error handling\nclass Result {\n    let value\n    let error\n    \n    static fun ok(val) {\n        return Result{value: val, error: null}\n    }\n    \n    static fun err(e) {\n        return Result{value: null, error: e}\n    }\n    \n    fun is_ok() {\n        return error == null\n    }\n    \n    fun map(f) {\n        if is_ok() {\n            return Result::ok(f(value))\n        }\n        return self\n    }\n    \n    fun flat_map(f) {\n        if is_ok() {\n            return f(value)\n        }\n        return self\n    }\n    \n    fun unwrap_or(default) {\n        if is_ok() {\n            return value\n        }\n        return default\n    }\n}\n\n// Chain operations safely\nfun process_user(id) {\n    return fetch_user(id)\n        .map(|user| validate_user(user))\n        .flat_map(|user| enrich_user_data(user))\n        .map(|user| format_user(user))\n        .unwrap_or({error: \"Processing failed\"})\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 7,
          "line_number": 427,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Lazy sequences\nclass LazySeq {\n    let generator\n    let cache = []\n    let index = 0\n    \n    fun next() {\n        if index >= cache.len() {\n            let value = generator()\n            if value != null {\n                cache.push(value)\n            }\n        }\n        \n        if index < cache.len() {\n            let value = cache[index]\n            index += 1\n            return value\n        }\n        \n        return null\n    }\n    \n    fun take(n) {\n        let result = []\n        for i in range(n) {\n            let value = next()\n            if value == null {\n                break\n            }\n            result.push(value)\n        }\n        return result\n    }\n    \n    fun map(f) {\n        return LazySeq::new(|| {\n            let value = next()\n            if value != null {\n                return f(value)\n            }\n            return null\n        })\n    }\n    \n    fun filter(predicate) {\n        return LazySeq::new(|| {\n            loop {\n                let value = next()\n                if value == null {\n                    return null\n                }\n                if predicate(value) {\n                    return value\n                }\n            }\n        })\n    }\n}\n\n// Infinite sequence\nlet fibonacci = LazySeq::new(|| {\n    static let a = 0\n    static let b = 1\n    let next = a\n    a = b\n    b = next + b\n    return next\n})\n\n// Only computes what's needed\nlet first_10_even = fibonacci\n    .filter(|n| n % 2 == 0)\n    .take(10)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 8,
          "line_number": 518,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Generic repository interface\nclass Repository {\n    fun find(id)\n    fun find_all()\n    fun find_where(conditions)\n    fun save(entity)\n    fun delete(id)\n}\n\n// Concrete implementation\nclass UserRepository < Repository {\n    let db\n    \n    fun find(id) {\n        let row = db.query_one(\"SELECT * FROM users WHERE id = ?\", [id])\n        return row ? User::from_row(row) : null\n    }\n    \n    fun find_where(conditions) {\n        let query = QueryBuilder::new(\"users\")\n            .where(conditions)\n            .build()\n        \n        return db.query(query).map(|row| User::from_row(row))\n    }\n    \n    fun save(user) {\n        if user.id {\n            db.execute(\"UPDATE users SET ... WHERE id = ?\", user.to_row())\n        } else {\n            user.id = db.execute(\"INSERT INTO users ... VALUES ...\", user.to_row())\n        }\n        return user\n    }\n}\n\n// Use repository in service layer\nclass UserService {\n    let repository\n    \n    fun get_active_users() {\n        return repository.find_where({active: true})\n    }\n    \n    fun create_user(data) {\n        let user = User::new(data)\n        user.validate()\n        return repository.save(user)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 9,
          "line_number": 583,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Event sourcing system\nclass EventStore {\n    let events = []\n    let snapshots = {}\n    let projections = {}\n    \n    fun append(event) {\n        event.id = generate_id()\n        event.timestamp = current_time()\n        event.version = events.len() + 1\n        \n        events.push(event)\n        update_projections(event)\n        \n        // Create snapshot every 100 events\n        if events.len() % 100 == 0 {\n            create_snapshot()\n        }\n    }\n    \n    fun replay(from_version = 0) {\n        let state = snapshots.get_latest_before(from_version) || {}\n        \n        for event in events.filter(|e| e.version > from_version) {\n            state = apply_event(state, event)\n        }\n        \n        return state\n    }\n    \n    fun get_projection(name) {\n        return projections[name]\n    }\n}\n\n// Domain events\nclass OrderPlaced {\n    let order_id\n    let customer_id\n    let items\n    let total\n}\n\nclass PaymentReceived {\n    let order_id\n    let amount\n    let method\n}\n\n// Event handlers update projections\nfun handle_order_placed(event) {\n    projections.orders[event.order_id] = {\n        status: \"pending\",\n        customer: event.customer_id,\n        total: event.total\n    }\n    \n    projections.customer_orders[event.customer_id].push(event.order_id)\n}\n\n// Rebuild state from events\nlet current_state = event_store.replay()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 10,
          "line_number": 660,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Command side - writes\nclass CommandBus {\n    let handlers = {}\n    \n    fun register(command_type, handler) {\n        handlers[command_type] = handler\n    }\n    \n    fun dispatch(command) {\n        let handler = handlers[command.type]\n        if !handler {\n            throw \"No handler for command: \" + command.type\n        }\n        \n        return handler(command)\n    }\n}\n\n// Query side - reads\nclass QueryBus {\n    let handlers = {}\n    \n    fun register(query_type, handler) {\n        handlers[query_type] = handler\n    }\n    \n    fun query(query) {\n        let handler = handlers[query.type]\n        if !handler {\n            throw \"No handler for query: \" + query.type\n        }\n        \n        return handler(query)\n    }\n}\n\n// Commands modify state\ncommand_bus.register(\"CreateOrder\", |cmd| {\n    let order = Order::new(cmd.data)\n    order.validate()\n    event_store.append(OrderPlaced::new(order))\n    return order.id\n})\n\n// Queries read projections\nquery_bus.register(\"GetOrdersByCustomer\", |query| {\n    return read_model.get_customer_orders(query.customer_id)\n})\n\n// Usage\nlet order_id = command_bus.dispatch({\n    type: \"CreateOrder\",\n    data: {customer: 123, items: [...]}\n})\n\nlet orders = query_bus.query({\n    type: \"GetOrdersByCustomer\",\n    customer_id: 123\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 11,
          "line_number": 736,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Actor system\nclass Actor {\n    let mailbox = Queue::new()\n    let running = true\n    \n    fun receive(message) {\n        mailbox.push(message)\n    }\n    \n    fun start() {\n        spawn {\n            while running {\n                let message = mailbox.pop()\n                if message {\n                    handle_message(message)\n                }\n                sleep(1)\n            }\n        }\n    }\n    \n    fun handle_message(message) {\n        // Override in subclass\n    }\n}\n\n// Concrete actor\nclass WorkerActor < Actor {\n    let state = {}\n    \n    fun handle_message(message) {\n        match message.type {\n            \"process\" => {\n                let result = process_work(message.data)\n                message.reply_to.receive({\n                    type: \"result\",\n                    data: result\n                })\n            }\n            \"get_state\" => {\n                message.reply_to.receive({\n                    type: \"state\",\n                    data: state\n                })\n            }\n            \"shutdown\" => {\n                running = false\n            }\n        }\n    }\n}\n\n// Actor system\nlet system = ActorSystem::new()\nlet worker = system.spawn(WorkerActor)\n\nworker.send({\n    type: \"process\",\n    data: work_item,\n    reply_to: self\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 12,
          "line_number": 812,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nclass CircuitBreaker {\n    let failure_threshold = 5\n    let timeout = 30000\n    let failure_count = 0\n    let last_failure_time = 0\n    let state = \"closed\"  // closed, open, half_open\n    \n    fun call(operation) {\n        if state == \"open\" {\n            if current_time() - last_failure_time > timeout {\n                state = \"half_open\"\n            } else {\n                throw \"Circuit breaker is open\"\n            }\n        }\n        \n        try {\n            let result = operation()\n            \n            if state == \"half_open\" {\n                state = \"closed\"\n                failure_count = 0\n            }\n            \n            return result\n        } catch error {\n            failure_count += 1\n            last_failure_time = current_time()\n            \n            if failure_count >= failure_threshold {\n                state = \"open\"\n                println(\"Circuit breaker opened after \" + failure_count.to_s() + \" failures\")\n            }\n            \n            throw error\n        }\n    }\n}\n\n// Use circuit breaker for external service\nlet api_breaker = CircuitBreaker::new()\n\nfun call_external_api(data) {\n    return api_breaker.call(|| {\n        http::post(\"https://api.external.com/endpoint\")\n            .json(data)\n            .timeout(5000)\n            .send()\n    })\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "appendix-b-syntax-reference": {
      "chapter": "appendix-b-syntax-reference",
      "total_examples": 35,
      "working_examples": 1,
      "failing_examples": 34,
      "examples": [
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 1,
          "line_number": 23,
          "code": "// Status: ✅ WORKING\n\n// Single line comment\n\n/* \n   Multi-line comment\n   Can span multiple lines\n*/\n\n/// Documentation comment for the following item\nfun documented_function() {}\n\n//! Inner documentation comment for containing item",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 2,
          "line_number": 47,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Valid identifiers\nvariable_name\ncamelCase\nPascalCase\n_private\n_internal\nsnake_case_123\nτ  // Unicode allowed\n\n// Keywords (reserved)\nlet mut fn if else match while for loop break continue\nreturn true false null struct enum trait impl use mod\nasync await type where const static pub super self",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 3,
          "line_number": 74,
          "code": "// Status: ❌ BROKEN\n\n// Integers\n42          // Decimal\n0xFF        // Hexadecimal  \n0o77        // Octal\n0b1010      // Binary\n1_000_000   // With separators\n\n// Floating point\n3.14\n2.0\n1e6         // Scientific notation\n1.5e-10\n\n// Type suffixes\n42i32       // 32-bit integer\n3.14f64     // 64-bit float\n100u8       // Unsigned 8-bit\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `xFF` in this scope\n --> /tmp/.tmpUJM9ct/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...\n  |                                                                                ^^^ not found in this scope\n\nerror[E0425]: cannot find value `o77` in this scope\n --> /tmp/.tmpUJM9ct/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...\n  |                                                                                             ^^^ not found in this scope\n\nerror[E0425]: cannot find value `b1010` in this scope\n --> /tmp/.tmpUJM9ct/main.rs:1:106\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...\n  |                                                                                                          ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `_000_000` in this scope\n --> /tmp/.tmpUJM9ct/main.rs:1:121\n  |\n1 | ... ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; ...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `e6` in this scope\n --> /tmp/.tmpUJM9ct/main.rs:1:156\n  |\n1 | ...2 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Som...\n  |                                                          ^^ not found in this scope\n\nerror[E0423]: expected value, found builtin type `i32`\n --> /tmp/.tmpUJM9ct/main.rs:1:188\n  |\n1 | ... ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Some (s) = (& result as & dyn ...\n  |                                                               ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `f64`\n --> /tmp/.tmpUJM9ct/main.rs:1:204\n  |\n1 | ...4 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Some (s) = (& result as & dyn std :: any :: An...\n  |                                                               ^^^ not a value\n\nerror[E0423]: expected value, found builtin type `u8`\n --> /tmp/.tmpUJM9ct/main.rs:1:219\n  |\n1 | ...; 0.00000000015f64 ; 42i32 ; i32 ; 3.14f64 ; f64 ; 100i32 ; u8 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_...\n  |                                                                ^^ not a value\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpUJM9ct/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 8 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 4,
          "line_number": 105,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// String literals\n\"hello world\"\n\"unicode: αβγ\"\n\"escapes: \\n \\t \\r \\\\ \\\" \\'\"\n\n// Raw strings (no escapes)\nr\"raw string with \\n literal backslashes\"\nr#\"can contain \"quotes\" with # delimiters\"#\nr##\"even more \"# nested # delimiters\"##\n\n// Multi-line strings\n\"line one\\\nline two\"\n\n// Format strings\n\"Hello, \" + name + \"!\"\n\"Result: \" + value.to_s()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 5,
          "line_number": 134,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n'a'         // ASCII character\n'\\n'        // Escape sequence\n'\\x41'      // Hex escape\n'\\u{1F600}' // Unicode escape",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 6,
          "line_number": 152,
          "code": "// Status: ❌ BROKEN\n\n// Boolean\nlet flag: bool = true\n\n// Integers\nlet small: i8 = -128           // 8-bit signed\nlet byte: u8 = 255             // 8-bit unsigned  \nlet short: i16 = -32768        // 16-bit signed\nlet word: u16 = 65535          // 16-bit unsigned\nlet int: i32 = -2147483648     // 32-bit signed\nlet uint: u32 = 4294967295     // 32-bit unsigned\nlet long: i64 = -9223372036854775808  // 64-bit signed\nlet ulong: u64 = 18446744073709551615 // 64-bit unsigned\nlet size: isize = -1           // Pointer-sized signed\nlet usize: usize = 1           // Pointer-sized unsigned\n\n// Floating point\nlet single: f32 = 3.14         // 32-bit float\nlet double: f64 = 2.718281828  // 64-bit float\n\n// Character\nlet ch: char = 'A'             // Unicode scalar value\n\n// String\nlet text: str = \"hello\"        // String slice\nlet owned: String = \"world\"    // Owned string\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found `let` statement\n --> /tmp/.tmpYolxRE/main.rs:1:275\n  |\n1 | ...147483648i64 ; let mut uint = 4294967295i64 ; let mut long = - ! let mut ulong = ! let mut size = - 1i32 ; let mut usize = 1i32 ; let ...\n  |                                                                     ^^^\n  |\n  = note: only supported directly in conditions of `if` and `while` expressions\n\nerror: expected expression, found `let` statement\n --> /tmp/.tmpYolxRE/main.rs:1:293\n  |\n1 | ... mut uint = 4294967295i64 ; let mut long = - ! let mut ulong = ! let mut size = - 1i32 ; let mut usize = 1i32 ; let mut single = 3.14f...\n  |                                                                     ^^^\n  |\n  = note: only supported directly in conditions of `if` and `while` expressions\n\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpYolxRE/main.rs:1:469\n  |\n1 | ...xt = \"hello\" ; let mut owned = \"world\" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpYolxRE/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut flag = true ; let mut small = - 128i32 ; let mut byte = 255i32 ; ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 7,
          "line_number": 191,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Arrays (fixed size)\nlet arr: [i32; 5] = [1, 2, 3, 4, 5]\nlet zeros: [i32; 100] = [0; 100]\n\n// Slices (dynamic size)\nlet slice: &[i32] = &arr[1..3]\n\n// Tuples\nlet tuple: (i32, str, bool) = (42, \"hello\", true)\nlet unit: () = ()  // Unit type\n\n// Vectors (dynamic arrays)\nlet vec: Vec<i32> = vec![1, 2, 3, 4, 5]\n\n// Hash maps\nlet map: HashMap<String, i32> = HashMap::new()\n\n// Options\nlet maybe: Option<i32> = Some(42)\nlet nothing: Option<i32> = None\n\n// Results  \nlet ok: Result<i32, String> = Ok(42)\nlet err: Result<i32, String> = Err(\"error message\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 8,
          "line_number": 229,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Immutable by default\nlet x = 42\nlet name = \"Alice\"\n\n// Explicit type annotation\nlet count: i32 = 100\nlet score: f64 = 95.5\n\n// Mutable variables\nlet mut counter = 0\ncounter += 1\n\n// Pattern destructuring\nlet (x, y) = (10, 20)\nlet [first, second, ..] = [1, 2, 3, 4, 5]\n\n// Shadowing\nlet x = 42\nlet x = \"now a string\"  // Shadows previous x",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 9,
          "line_number": 260,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Compile-time constants\nconst MAX_SIZE: usize = 1024\nconst PI: f64 = 3.14159265359\n\n// Static variables\nstatic GLOBAL_COUNTER: AtomicUsize = AtomicUsize::new(0)\nstatic mut GLOBAL_STATE: i32 = 0  // Unsafe to mutate",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 10,
          "line_number": 281,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// If expressions\nlet result = if condition {\n    \"true branch\"\n} else {\n    \"false branch\"\n}\n\n// Multiple conditions\nif x > 0 {\n    \"positive\"\n} else if x < 0 {\n    \"negative\"  \n} else {\n    \"zero\"\n}\n\n// Let-else pattern\nlet Some(value) = optional else {\n    return Err(\"No value\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 11,
          "line_number": 313,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\n// Match expressions\nmatch value {\n    0 => \"zero\",\n    1 | 2 => \"one or two\",\n    3..=10 => \"three through ten\",\n    n if n > 100 => \"big number\",\n    _ => \"something else\"\n}\n\n// Destructuring patterns\nmatch point {\n    Point { x: 0, y: 0 } => \"origin\",\n    Point { x, y: 0 } => \"on x-axis at \" + x.to_s() + \",\",\n    Point { x: 0, y } => \"on y-axis at \" + y.to_s() + \",\",\n    Point { x, y } => \"point at (\" + x.to_s() + \", \" + y.to_s() + \")\"\n}\n\n// Guards\nmatch number {\n    n if n < 0 => \"negative\",\n    n if n > 0 => \"positive\", \n    _ => \"zero\"\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `value` in this scope\n --> /tmp/.tmprqJ21a/main.rs:1:71\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { match value { 0i32 => \"zero\" , 1i32 | 2i32 => \"one or two\" , 3i32 ..= 10i...\n  |                                                                       ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `point` in this scope\n --> /tmp/.tmprqJ21a/main.rs:1:234\n  |\n1 | ...=> \"big number\" , _ => \"something else\" , } ; match point { Point { x : 0i32 , y : 0i32 } => \"origin\" , Point { x , y : 0i32 } => form...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmprqJ21a/main.rs:1:242\n  |\n1 | ...number\" , _ => \"something else\" , } ; match point { Point { x : 0i32 , y : 0i32 } => \"origin\" , Point { x , y : 0i32 } => format ! (\"{...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmprqJ21a/main.rs:1:286\n  |\n1 | ...point { Point { x : 0i32 , y : 0i32 } => \"origin\" , Point { x , y : 0i32 } => format ! (\"{}{}\" , format ! (\"{}{}\" , \"on x-axis at \" , ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmprqJ21a/main.rs:1:390\n  |\n1 | ...! (\"{}{}\" , \"on x-axis at \" , x . to_s ()) , \",\") , Point { x : 0i32 , y } => format ! (\"{}{}\" , format ! (\"{}{}\" , \"on y-axis at \" , ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmprqJ21a/main.rs:1:494\n  |\n1 | ...! (\"{}{}\" , \"on y-axis at \" , y . to_s ()) , \",\") , Point { x , y } => format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"point...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `number` in this scope\n --> /tmp/.tmprqJ21a/main.rs:1:639\n  |\n1 | .... to_s ()) , \", \") + y . to_s () , \")\") , } ; match number { n if n < 0i32 => \"negative\" , n if n > 0i32 => \"positive\" , _ => \"zero\" ,...\n  |                                                        ^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmprqJ21a/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { match value { 0i32 => \"zero\" , 1i32 | 2i32 => \"one or two\" , 3i32 ..= 10i...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: `match` arms have incompatible types\n --> /tmp/.tmprqJ21a/main.rs:1:312\n  |\n1 | ... ; match point { Point { x : 0i32 , y : 0i32 } => \"origin\" , Point { x , y : 0i32 } => format ! (\"{}{}\" , format ! (\"{}{}\" , \"on x-axis at \" , x . to_s ()) , \",\") , ...\n  |       -----------                                    --------                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`\n  |       |                                              |\n  |       |                                              this is found to be of type `&str`\n  |       `match` arms have incompatible types\n  |\n  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 8 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0422, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 12,
          "line_number": 348,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Infinite loop\nloop {\n    // Code here\n    if condition {\n        break\n    }\n}\n\n// While loop\nwhile condition {\n    // Code here\n}\n\n// For loop with iterators\nfor item in collection {\n    // Process item\n}\n\n// For loop with range\nfor i in 0..10 {\n    println(\"Count: \" + i.to_s())\n}\n\n// For loop with enumerate\nfor (index, item) in collection.enumerate() {\n    println(index.to_s() + \": \" + item)\n}\n\n// Loop labels and break/continue\n'outer: loop {\n    loop {\n        if condition {\n            break 'outer  // Break outer loop\n        }\n        if other_condition {\n            continue 'outer  // Continue outer loop\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 13,
          "line_number": 403,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Basic function\nfun greet(name: String) -> String {\n    return \"Hello, \" + name + \"!\"\n}\n\n// Implicit return (no semicolon)\nfun add(a: i32, b: i32) -> i32 {\n    a + b  // Last expression is returned\n}\n\n// Unit return type (no return value)\nfun print_message(msg: String) {\n    println(msg)\n}\n\n// Multiple parameters\nfun calculate(x: f64, y: f64, operation: char) -> f64 {\n    match operation {\n        '+' => x + y,\n        '-' => x - y,\n        '*' => x * y,\n        '/' => x / y,\n        _ => panic(\"Invalid operation\")\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 14,
          "line_number": 440,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// By value (move)\nfun take_ownership(s: String) {\n    // s is moved here\n}\n\n// By reference (borrow)\nfun borrow_value(s: &String) -> usize {\n    s.len()  // s is borrowed\n}\n\n// Mutable reference\nfun modify_value(s: &mut String) {\n    s.push_str(\" modified\")\n}\n\n// Default parameters\nfun connect(host: String, port: u16 = 8080, timeout: u64 = 5000) {\n    // Implementation\n}\n\n// Variable arguments\nfun sum(numbers: &[i32]) -> i32 {\n    numbers.iter().sum()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 15,
          "line_number": 476,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Closure syntax\nlet add = |a, b| a + b\nlet result = add(5, 3)\n\n// Explicit types\nlet multiply: fn(i32, i32) -> i32 = |a, b| a * b\n\n// Capturing environment\nlet x = 10\nlet add_x = |y| x + y  // Captures x\nlet result = add_x(5)  // 15\n\n// Move capture\nlet name = String::from(\"Alice\")\nlet greeter = move |greeting| {\n    greeting + \", \" + name + \"!\"  // name is moved into closure\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 16,
          "line_number": 505,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Function as parameter\nfun apply_operation(x: i32, y: i32, op: fn(i32, i32) -> i32) -> i32 {\n    op(x, y)\n}\n\n// Function returning function\nfun make_adder(n: i32) -> impl Fn(i32) -> i32 {\n    move |x| x + n\n}\n\n// Generic function\nfun map_over<T, U, F>(items: Vec<T>, f: F) -> Vec<U>\nwhere F: Fn(T) -> U\n{\n    items.into_iter().map(f).collect()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 17,
          "line_number": 535,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Basic struct\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n// Tuple struct\nstruct Color(u8, u8, u8)\n\n// Unit struct\nstruct Marker\n\n// Generic struct\nstruct Container<T> {\n    value: T,\n}\n\n// Struct with lifetime\nstruct Excerpt<'a> {\n    text: &'a str,\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 18,
          "line_number": 568,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Creating instances\nlet origin = Point { x: 0.0, y: 0.0 }\nlet red = Color(255, 0, 0)\n\n// Field access\nlet x_coord = origin.x\n\n// Struct update syntax\nlet point2 = Point { x: 1.0, ..origin }\n\n// Destructuring\nlet Point { x, y } = origin\nlet Color(r, g, b) = red",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 19,
          "line_number": 593,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Basic enum\nenum Direction {\n    North,\n    South,\n    East,\n    West,\n}\n\n// Enum with data\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\n// Generic enum\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 20,
          "line_number": 626,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nimpl Point {\n    // Associated function (constructor)\n    fun new(x: f64, y: f64) -> Point {\n        Point { x, y }\n    }\n    \n    // Method (takes &self)\n    fun distance_from_origin(&self) -> f64 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n    \n    // Mutable method (takes &mut self)\n    fun translate(&mut self, dx: f64, dy: f64) {\n        self.x += dx\n        self.y += dy\n    }\n    \n    // Consuming method (takes self)\n    fun into_tuple(self) -> (f64, f64) {\n        (self.x, self.y)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 21,
          "line_number": 662,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Basic trait\ntrait Draw {\n    fun draw(&self)\n}\n\n// Trait with default implementation\ntrait Summary {\n    fun summarize_author(&self) -> String\n    \n    fun summarize(&self) -> String {\n        \"(Read more from \" + self.summarize_author() + \"...)\"\n    }\n}\n\n// Trait with associated types\ntrait Iterator {\n    type Item\n    \n    fun next(&mut self) -> Option<Self::Item>\n}\n\n// Trait with generic parameters\ntrait From<T> {\n    fun from(value: T) -> Self\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 22,
          "line_number": 699,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nimpl Draw for Point {\n    fun draw(&self) {\n        println(\"Drawing point at (\" + self.x.to_s() + \", \" + self.y.to_s() + \")\")\n    }\n}\n\n// Conditional implementation\nimpl<T: Display> ToString for T {\n    fun to_string(&self) -> String {\n        // Implementation\n    }\n}\n\n// Blanket implementation\nimpl<T: Clone> Clone for Box<T> {\n    fun clone(&self) -> Box<T> {\n        // Implementation  \n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 23,
          "line_number": 732,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun largest<T: PartialOrd>(list: &[T]) -> &T {\n    let mut largest = &list[0]\n    for item in list {\n        if item > largest {\n            largest = item\n        }\n    }\n    largest\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 24,
          "line_number": 753,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Point<T> {\n    fun new(x: T, y: T) -> Point<T> {\n        Point { x, y }\n    }\n}\n\nimpl Point<f64> {\n    fun distance_from_origin(&self) -> f64 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 25,
          "line_number": 781,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Single bound\nfun print_it<T: Display>(item: T) {\n    println(\"{}\", item)\n}\n\n// Multiple bounds\nfun compare_and_print<T: Display + PartialOrd>(a: T, b: T) {\n    if a > b {\n        println(\"a is greater\")\n    } else {\n        println(\"b is greater or equal\")\n    }\n}\n\n// Where clause\nfun some_function<T, U>(t: T, u: U) -> i32\nwhere\n    T: Display + Clone,\n    U: Clone + Debug,\n{\n    // Implementation\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 26,
          "line_number": 817,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Inline module\nmod network {\n    fun connect() {\n        // Implementation\n    }\n    \n    pub fun public_function() {\n        // Can be called from outside module\n    }\n}\n\n// File-based modules\nmod utils;  // Looks for utils.rs or utils/mod.rs\n\n// Nested modules\nmod graphics {\n    pub mod shapes {\n        pub fun draw_circle() {}\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 27,
          "line_number": 849,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\npub fun public_function() {}           // Public\nfun private_function() {}              // Private to module\n\npub struct PublicStruct {\n    pub public_field: i32,            // Public field\n    private_field: i32,               // Private field\n}\n\npub(crate) fun crate_visible() {}      // Visible within crate\npub(super) fun parent_visible() {}     // Visible to parent module\npub(in crate::utils) fun limited() {} // Visible within specific path",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 28,
          "line_number": 872,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nuse std::collections::HashMap         // Single import\nuse std::fs::{File, OpenOptions}      // Multiple imports\nuse std::io::*                        // Glob import\nuse std::collections::HashMap as Map  // Alias\n\n// Re-exports\npub use internal::public_api\n\n// Conditional compilation\n#[cfg(unix)]\nuse unix_specific::module\n\n#[cfg(windows)]  \nuse windows_specific::module",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 29,
          "line_number": 900,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Result type\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\n// Option type\nenum Option<T> {\n    Some(T),\n    None,\n}\n\n// Using ? operator\nfun read_file(path: &str) -> Result<String, std::io::Error> {\n    let content = std::fs::read_to_string(path)?\n    Ok(content.to_uppercase())\n}\n\n// Combining with match\nmatch result {\n    Ok(value) => println(\"Success: {}\", value),\n    Err(error) => eprintln(\"Error: {}\", error),\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 30,
          "line_number": 935,
          "code": "// Status: ❌ BROKEN\n\n// Unconditional panic\npanic!(\"Something went wrong!\")\n\n// Conditional panic\nassert!(condition, \"Condition must be true\")\nassert_eq!(left, right, \"Values must be equal\")\n\n// Debug assertions (only in debug builds)\ndebug_assert!(expensive_check())\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 31,
          "line_number": 960,
          "code": "// Status: ❌ BROKEN\n\n// Function-like macros\nprintln!(\"Hello, {}!\", name)\nvec![1, 2, 3, 4, 5]\nformat!(\"Value: {}\", x)\n\n// Attribute-like macros\n#[derive(Debug, Clone)]\nstruct MyStruct {}\n\n#[cfg(test)]\nmod tests {}\n\n// Derive macros\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\nstruct Point { x: i32, y: i32 }\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 32,
          "line_number": 989,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Declarative macro\nmacro_rules! say_hello {\n    () => {\n        println!(\"Hello!\")\n    };\n    ($name:expr) => {\n        println!(\"Hello, {}!\", $name)\n    };\n}\n\n// Usage\nsay_hello!()\nsay_hello!(\"World\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 33,
          "line_number": 1016,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Conditional compilation\n#[cfg(target_os = \"linux\")]\nfun linux_only() {}\n\n#[cfg(feature = \"network\")]\nmod networking {}\n\n// Testing\n#[test]\nfun test_function() {}\n\n#[ignore]\n#[test]\nfun expensive_test() {}\n\n// Documentation\n#[doc = \"This is a documented function\"]\nfun documented() {}\n\n// Deprecation\n#[deprecated(note = \"Use new_function instead\")]\nfun old_function() {}\n\n// Allow/deny lints\n#[allow(dead_code)]\nfun unused_function() {}\n\n#[deny(missing_docs)]\nmod well_documented {}\n\n// Inline hints\n#[inline]\nfun small_function() {}\n\n#[inline(always)]\nfun always_inline() {}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 34,
          "line_number": 1066,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Async function\nasync fun fetch_data(url: &str) -> Result<String, reqwest::Error> {\n    let response = reqwest::get(url).await?\n    let text = response.text().await?\n    Ok(text)\n}\n\n// Async blocks\nlet future = async {\n    let result = some_async_operation().await\n    process_result(result)\n}\n\n// Async closures\nlet async_closure = async |x| {\n    expensive_async_operation(x).await\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 35,
          "line_number": 1095,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nuse futures::{Future, Stream}\n\n// Implementing Future\nimpl Future for MyFuture {\n    type Output = i32\n    \n    fun poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        // Implementation\n    }\n}\n\n// Working with streams\nlet stream = async_stream::stream! {\n    for i in 0..10 {\n        yield i\n        tokio::time::sleep(Duration::from_millis(100)).await\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch10-00-input-output-tdd": {
      "chapter": "ch10-00-input-output-tdd",
      "total_examples": 10,
      "working_examples": 0,
      "failing_examples": 10,
      "examples": [
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"=== Output Demo ===\");\n    println(\"Number: \");\n    println(42);\n    println(\"Boolean: \");\n    println(true);\n    println(\"=== End Demo ===\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmp75gbMg/main.rs:1:85\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"=== Output Demo ===\" . to_string ()) ; println ! (\"Number: \" . to_string (...\n  |                                                                                     ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmp75gbMg/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"=== Output Demo ===\" . to_string ()) ; println ! (\"Number: \" . to_string (...\n  |                                                               ---------------------   ^^^^^^^^^^^^ argument never used\n  |                                                               |\n  |                                                               formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmp75gbMg/main.rs:1:125\n  |\n1 | ...== Output Demo ===\" . to_string ()) ; println ! (\"Number: \" . to_string ()) ; println ! (\"{}\" , 42i32) ; println ! (\"Boolean: \" . to_s...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmp75gbMg/main.rs:1:127\n  |\n1 | ...tput Demo ===\" . to_string ()) ; println ! (\"Number: \" . to_string ()) ; println ! (\"{}\" , 42i32) ; println ! (\"Boolean: \" . to_string...\n  |                                                ----------   ^^^^^^^^^^^^ argument never used\n  |                                                |\n  |                                                formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmp75gbMg/main.rs:1:193\n  |\n1 | ...ing ()) ; println ! (\"{}\" , 42i32) ; println ! (\"Boolean: \" . to_string ()) ; println ! (\"{}\" , true) ; println ! (\"=== End Demo ===\" ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmp75gbMg/main.rs:1:195\n  |\n1 | ...()) ; println ! (\"{}\" , 42i32) ; println ! (\"Boolean: \" . to_string ()) ; println ! (\"{}\" , true) ; println ! (\"=== End Demo ===\" . to...\n  |                                                -----------   ^^^^^^^^^^^^ argument never used\n  |                                                |\n  |                                                formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmp75gbMg/main.rs:1:267\n  |\n1 | ...) ; println ! (\"{}\" , true) ; println ! (\"=== End Demo ===\" . to_string ()) } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmp75gbMg/main.rs:1:269\n  |\n1 | ... ; println ! (\"{}\" , true) ; println ! (\"=== End Demo ===\" . to_string ()) } }\n  |                                            ------------------   ^^^^^^^^^^^^ argument never used\n  |                                            |\n  |                                            formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp75gbMg/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"=== Output Demo ===\" . to_string ()) ; println ! (\"Number: \" . to_string (...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmp75gbMg/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"=== Output Demo ===\" . to_string ()) ; println ! (\"Number: \" . to_string (...\n  |                                                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmp75gbMg/main.rs:1:127\n  |\n1 | ...mo ===\" . to_string ()) ; println ! (\"Number: \" . to_string ()) ; println ! (\"{}\" , 42i32) ; println ! (\"Boolean: \" . to_string ()) ; ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmp75gbMg/main.rs:1:195\n  |\n1 | ...intln ! (\"{}\" , 42i32) ; println ! (\"Boolean: \" . to_string ()) ; println ! (\"{}\" , true) ; println ! (\"=== End Demo ===\" . to_string ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmp75gbMg/main.rs:1:269\n  |\n1 | ...! (\"{}\" , true) ; println ! (\"=== End Demo ===\" . to_string ()) } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 12 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 2,
          "line_number": 60,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let name = \"Alice\";\n    let age = 30;\n    let height = 5.6;\n    \n    println(\"=== User Profile ===\");\n    println(\"Name:\");\n    println(name);\n    println(\"Age:\");\n    println(age);\n    println(\"Height:\");\n    println(height);\n    println(\"================\");\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpDOHD9Z/main.rs:1:159\n  |\n1 | ...let mut height = 5.6f64 ; println ! (\"=== User Profile ===\" . to_string ()) ; println ! (\"Name:\" . to_string ()) ; println ! (\"{}\" , n...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpDOHD9Z/main.rs:1:161\n  |\n1 | ... let mut height = 5.6f64 ; println ! (\"=== User Profile ===\" . to_string ()) ; println ! (\"Name:\" . to_string ()) ; println ! (\"{}\" , ...\n  |                                          ----------------------   ^^^^^^^^^^^^ argument never used\n  |                                          |\n  |                                          formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpDOHD9Z/main.rs:1:196\n  |\n1 | ...\"=== User Profile ===\" . to_string ()) ; println ! (\"Name:\" . to_string ()) ; println ! (\"{}\" , name) ; println ! (\"Age:\" . to_string ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpDOHD9Z/main.rs:1:198\n  |\n1 | ...ser Profile ===\" . to_string ()) ; println ! (\"Name:\" . to_string ()) ; println ! (\"{}\" , name) ; println ! (\"Age:\" . to_string ()) ; ...\n  |                                                  -------   ^^^^^^^^^^^^ argument never used\n  |                                                  |\n  |                                                  formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpDOHD9Z/main.rs:1:258\n  |\n1 | ...to_string ()) ; println ! (\"{}\" , name) ; println ! (\"Age:\" . to_string ()) ; println ! (\"{}\" , age) ; println ! (\"Height:\" . to_strin...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpDOHD9Z/main.rs:1:260\n  |\n1 | ...ng ()) ; println ! (\"{}\" , name) ; println ! (\"Age:\" . to_string ()) ; println ! (\"{}\" , age) ; println ! (\"Height:\" . to_string ()) ;...\n  |                                                  ------   ^^^^^^^^^^^^ argument never used\n  |                                                  |\n  |                                                  formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpDOHD9Z/main.rs:1:322\n  |\n1 | ..._string ()) ; println ! (\"{}\" , age) ; println ! (\"Height:\" . to_string ()) ; println ! (\"{}\" , height) ; println ! (\"================...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpDOHD9Z/main.rs:1:324\n  |\n1 | ...ng ()) ; println ! (\"{}\" , age) ; println ! (\"Height:\" . to_string ()) ; println ! (\"{}\" , height) ; println ! (\"================\" . t...\n  |                                                 ---------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpDOHD9Z/main.rs:1:398\n  |\n1 | ...; println ! (\"{}\" , height) ; println ! (\"================\" . to_string ()) } } } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpDOHD9Z/main.rs:1:400\n  |\n1 | ... println ! (\"{}\" , height) ; println ! (\"================\" . to_string ()) } } } }\n  |                                            ------------------   ^^^^^^^^^^^^ argument never used\n  |                                            |\n  |                                            formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpDOHD9Z/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" ; { let mut age = 30i32 ; let mut height = 5.6f64 ; println ! (\"=...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpDOHD9Z/main.rs:1:50\n  |\n1 | ... { { { let name = \"Alice\" ; { let mut age = 30i32 ; let mut height = 5.6f64 ; println ! (\"=== User Profile ===\" . to_string ()) ; println ! (\"Name:\" . to_string ()) ; println ! (\"{}\" , name) ; println ! (\"Age:\" . to_string ()) ; println ! (\"{}\" , age) ; println ! (\"Height:\" . to_string ()) ; println ! (\"{}\" , height) ; println ! (\"================\" . to_string ()) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" ; { let mut age = 30i32 ; let mut height = 5.6f64 ; println ! (\"=== User Profile ===\" . to_string ()) ; println ! (\"Name:\" . to_string ()) ; println ! (\"{}\" , name) ; println ! (\"Age:\" . to_string ()) ; println ! (\"{}\" , age) ; println ! (\"Height:\" . to_string ()) ; println ! (\"{}\" , height) ; println ! (\"================\" . to_string ()) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let name = \"Alice\" ; { let mut age = 30i32 ; let mut height = 5.6f64 ; println ! (\"=== User Profile ===\" . to_string ()) ; println ! (\"Name:\" . to_string ()) ; println ! (\"{}\" , name) ; println ! (\"Age:\" . to_string ()) ; println ! (\"{}\" , age) ; println ! (\"Height:\" . to_string ()) ; println ! (\"{}\" , height) ; println ! (\"================\" . to_string ()) } } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpDOHD9Z/main.rs:1:161\n  |\n1 | ...ht = 5.6f64 ; println ! (\"=== User Profile ===\" . to_string ()) ; println ! (\"Name:\" . to_string ()) ; println ! (\"{}\" , name) ; print...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpDOHD9Z/main.rs:1:198\n  |\n1 | ...ofile ===\" . to_string ()) ; println ! (\"Name:\" . to_string ()) ; println ! (\"{}\" , name) ; println ! (\"Age:\" . to_string ()) ; printl...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpDOHD9Z/main.rs:1:260\n  |\n1 | ...) ; println ! (\"{}\" , name) ; println ! (\"Age:\" . to_string ()) ; println ! (\"{}\" , age) ; println ! (\"Height:\" . to_string ()) ; prin...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpDOHD9Z/main.rs:1:324\n  |\n1 | ...; println ! (\"{}\" , age) ; println ! (\"Height:\" . to_string ()) ; println ! (\"{}\" , height) ; println ! (\"================\" . to_strin...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpDOHD9Z/main.rs:1:400\n  |\n1 | ...(\"{}\" , height) ; println ! (\"================\" . to_string ()) } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 15 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 3,
          "line_number": 96,
          "code": "// Status: ✅ WORKING\nfun display_menu() {\n    println(\"=== Main Menu ===\");\n    println(\"1. View Profile\");\n    println(\"2. Settings\");\n    println(\"3. Exit\");\n    println(\"=================\");\n}\n\nfun main() {\n    display_menu();\n    println(\"Menu displayed successfully\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpsRcBvc/main.rs:1:91\n  |\n1 | use std :: collections :: HashMap ; fn display_menu () { { println ! (\"=== Main Menu ===\" . to_string ()) ; println ! (\"1. View Profile\" ...\n  |                                                                                           ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpsRcBvc/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn display_menu () { { println ! (\"=== Main Menu ===\" . to_string ()) ; println ! (\"1. View Profile\" ...\n  |                                                                       -------------------   ^^^^^^^^^^^^ argument never used\n  |                                                                       |\n  |                                                                       formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpsRcBvc/main.rs:1:138\n  |\n1 | ...in Menu ===\" . to_string ()) ; println ! (\"1. View Profile\" . to_string ()) ; println ! (\"2. Settings\" . to_string ()) ; println ! (\"3...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpsRcBvc/main.rs:1:140\n  |\n1 | ...n Menu ===\" . to_string ()) ; println ! (\"1. View Profile\" . to_string ()) ; println ! (\"2. Settings\" . to_string ()) ; println ! (\"3....\n  |                                             -----------------   ^^^^^^^^^^^^ argument never used\n  |                                             |\n  |                                             formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpsRcBvc/main.rs:1:181\n  |\n1 | ...1. View Profile\" . to_string ()) ; println ! (\"2. Settings\" . to_string ()) ; println ! (\"3. Exit\" . to_string ()) ; println ! (\"=====...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpsRcBvc/main.rs:1:183\n  |\n1 | ...View Profile\" . to_string ()) ; println ! (\"2. Settings\" . to_string ()) ; println ! (\"3. Exit\" . to_string ()) ; println ! (\"========...\n  |                                               -------------   ^^^^^^^^^^^^ argument never used\n  |                                               |\n  |                                               formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpsRcBvc/main.rs:1:220\n  |\n1 | ...tln ! (\"2. Settings\" . to_string ()) ; println ! (\"3. Exit\" . to_string ()) ; println ! (\"=================\" . to_string ()) } } fn ma...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpsRcBvc/main.rs:1:222\n  |\n1 | ... (\"2. Settings\" . to_string ()) ; println ! (\"3. Exit\" . to_string ()) ; println ! (\"=================\" . to_string ()) } } fn main ()...\n  |                                                 ---------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpsRcBvc/main.rs:1:269\n  |\n1 | ...(\"3. Exit\" . to_string ()) ; println ! (\"=================\" . to_string ()) } } fn main () { { display_menu () ; println ! (\"Menu disp...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpsRcBvc/main.rs:1:271\n  |\n1 | ...(\"3. Exit\" . to_string ()) ; println ! (\"=================\" . to_string ()) } } fn main () { { display_menu () ; println ! (\"Menu disp...\n  |                                            -------------------   ^^^^^^^^^^^^ argument never used\n  |                                            |\n  |                                            formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpsRcBvc/main.rs:1:363\n  |\n1 | ... display_menu () ; println ! (\"Menu displayed successfully\" . to_string ()) } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpsRcBvc/main.rs:1:365\n  |\n1 | ...) { { display_menu () ; println ! (\"Menu displayed successfully\" . to_string ()) } }\n  |                                       -----------------------------   ^^^^^^^^^^^^ argument never used\n  |                                       |\n  |                                       formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpsRcBvc/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn display_menu () { { println ! (\"=== Main Menu ===\" . to_string ()) ; println ! (\"1. View Profile\" ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpsRcBvc/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn display_menu () { { println ! (\"=== Main Menu ===\" . to_string ()) ; println ! (\"1. View Profile\" ...\n  |                                                                                             ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpsRcBvc/main.rs:1:140\n  |\n1 | ... . to_string ()) ; println ! (\"1. View Profile\" . to_string ()) ; println ! (\"2. Settings\" . to_string ()) ; println ! (\"3. Exit\" . to...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpsRcBvc/main.rs:1:183\n  |\n1 | ...ile\" . to_string ()) ; println ! (\"2. Settings\" . to_string ()) ; println ! (\"3. Exit\" . to_string ()) ; println ! (\"=================...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpsRcBvc/main.rs:1:222\n  |\n1 | ...ettings\" . to_string ()) ; println ! (\"3. Exit\" . to_string ()) ; println ! (\"=================\" . to_string ()) } } fn main () { { di...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpsRcBvc/main.rs:1:271\n  |\n1 | ... to_string ()) ; println ! (\"=================\" . to_string ()) } } fn main () { { display_menu () ; println ! (\"Menu displayed succes...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpsRcBvc/main.rs:1:365\n  |\n1 | ...u () ; println ! (\"Menu displayed successfully\" . to_string ()) } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 18 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 4,
          "line_number": 147,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nprintln(\"text message\");\nprintln(variable);\nprintln(42);\nprintln(true);",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmp9JE0uX/main.rs:1:91\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"text message\" . to_string ()) ; println ! (\"{}\" , variable) ;...\n  |                                                                                           ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmp9JE0uX/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"text message\" . to_string ()) ; println ! (\"{}\" , variable) ;...\n  |                                                                            --------------   ^^^^^^^^^^^^ argument never used\n  |                                                                            |\n  |                                                                            formatting specifier missing\n\nerror[E0425]: cannot find value `variable` in this scope\n --> /tmp/.tmp9JE0uX/main.rs:1:127\n  |\n1 | ...\"text message\" . to_string ()) ; println ! (\"{}\" , variable) ; println ! (\"{}\" , 42i32) ; println ! (\"{}\" , true) } ; if let Some (s) ...\n  |                                                       ^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp9JE0uX/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"text message\" . to_string ()) ; println ! (\"{}\" , variable) ;...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmp9JE0uX/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"text message\" . to_string ()) ; println ! (\"{}\" , variable) ;...\n  |                                                                                             ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 5,
          "line_number": 159,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet data = value;\nprintln(\"Label:\");\nprintln(data);",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpM1sfqJ/main.rs:1:108\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut data = value ; println ! (\"Label:\" . to_string ()) ; println ! (\"...\n  |                                                                                                            ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpM1sfqJ/main.rs:1:110\n  |\n1 | ...result = { let mut data = value ; println ! (\"Label:\" . to_string ()) ; println ! (\"{}\" , data) } ; if let Some (s) = (& result as & d...\n  |                                                 --------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror[E0425]: cannot find value `value` in this scope\n --> /tmp/.tmpM1sfqJ/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut data = value ; println ! (\"Label:\" . to_string ()) ; println ! (\"...\n  |                                                                                ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpM1sfqJ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut data = value ; println ! (\"Label:\" . to_string ()) ; println ! (\"...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpM1sfqJ/main.rs:1:110\n  |\n1 | ... = { let mut data = value ; println ! (\"Label:\" . to_string ()) ; println ! (\"{}\" , data) } ; if let Some (s) = (& result as & dyn std...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 6,
          "line_number": 170,
          "code": "// Status: ✅ WORKING\nfun display_options() {\n    println(\"=== Menu ===\");\n    println(\"1. Option One\");\n    println(\"2. Option Two\");\n    println(\"============\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmptMSVr7/main.rs:1:89\n  |\n1 | use std :: collections :: HashMap ; fn display_options () { { println ! (\"=== Menu ===\" . to_string ()) ; println ! (\"1. Option One\" . to...\n  |                                                                                         ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmptMSVr7/main.rs:1:91\n  |\n1 | use std :: collections :: HashMap ; fn display_options () { { println ! (\"=== Menu ===\" . to_string ()) ; println ! (\"1. Option One\" . to...\n  |                                                                          --------------   ^^^^^^^^^^^^ argument never used\n  |                                                                          |\n  |                                                                          formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmptMSVr7/main.rs:1:134\n  |\n1 | ...\"=== Menu ===\" . to_string ()) ; println ! (\"1. Option One\" . to_string ()) ; println ! (\"2. Option Two\" . to_string ()) ; println ! (...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmptMSVr7/main.rs:1:136\n  |\n1 | ...== Menu ===\" . to_string ()) ; println ! (\"1. Option One\" . to_string ()) ; println ! (\"2. Option Two\" . to_string ()) ; println ! (\"=...\n  |                                              ---------------   ^^^^^^^^^^^^ argument never used\n  |                                              |\n  |                                              formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmptMSVr7/main.rs:1:179\n  |\n1 | ...1. Option One\" . to_string ()) ; println ! (\"2. Option Two\" . to_string ()) ; println ! (\"============\" . to_string ()) } } fn main ()...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmptMSVr7/main.rs:1:181\n  |\n1 | ... Option One\" . to_string ()) ; println ! (\"2. Option Two\" . to_string ()) ; println ! (\"============\" . to_string ()) } } fn main () { }\n  |                                              ---------------   ^^^^^^^^^^^^ argument never used\n  |                                              |\n  |                                              formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmptMSVr7/main.rs:1:223\n  |\n1 | ...\"2. Option Two\" . to_string ()) ; println ! (\"============\" . to_string ()) } } fn main () { }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmptMSVr7/main.rs:1:225\n  |\n1 | ... Option Two\" . to_string ()) ; println ! (\"============\" . to_string ()) } } fn main () { }\n  |                                              --------------   ^^^^^^^^^^^^ argument never used\n  |                                              |\n  |                                              formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmptMSVr7/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn display_options () { { println ! (\"=== Menu ===\" . to_string ()) ; println ! (\"1. Option One\" . to...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmptMSVr7/main.rs:1:91\n  |\n1 | use std :: collections :: HashMap ; fn display_options () { { println ! (\"=== Menu ===\" . to_string ()) ; println ! (\"1. Option One\" . to...\n  |                                                                                           ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmptMSVr7/main.rs:1:136\n  |\n1 | ...=\" . to_string ()) ; println ! (\"1. Option One\" . to_string ()) ; println ! (\"2. Option Two\" . to_string ()) ; println ! (\"===========...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmptMSVr7/main.rs:1:181\n  |\n1 | ...e\" . to_string ()) ; println ! (\"2. Option Two\" . to_string ()) ; println ! (\"============\" . to_string ()) } } fn main () { }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmptMSVr7/main.rs:1:225\n  |\n1 | ...wo\" . to_string ()) ; println ! (\"============\" . to_string ()) } } fn main () { }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 12 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 7,
          "line_number": 197,
          "code": "// Status: ✅ WORKING\nlet value = 100;\nprintln(\"Result:\");\nprintln(value);",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpiVP56x/main.rs:1:111\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut value = 100i32 ; println ! (\"Result:\" . to_string ()) ; println !...\n  |                                                                                                               ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpiVP56x/main.rs:1:113\n  |\n1 | ...sult = { let mut value = 100i32 ; println ! (\"Result:\" . to_string ()) ; println ! (\"{}\" , value) } ; if let Some (s) = (& result as &...\n  |                                                 ---------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpiVP56x/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut value = 100i32 ; println ! (\"Result:\" . to_string ()) ; println !...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpiVP56x/main.rs:1:113\n  |\n1 | ...{ let mut value = 100i32 ; println ! (\"Result:\" . to_string ()) ; println ! (\"{}\" , value) } ; if let Some (s) = (& result as & dyn st...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 8,
          "line_number": 207,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun display_report(title: &str, data: i32) {\n    println(\"=== Report ===\");\n    println(title);\n    println(data);\n    println(\"==============\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 9,
          "line_number": 221,
          "code": "// Status: ✅ WORKING\nprintln(\"Processing...\");\n// ... do work ...\nprintln(\"Complete!\");",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmptwVrEc/main.rs:1:92\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"Processing...\" . to_string ()) ; println ! (\"Complete!\" . to_...\n  |                                                                                            ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmptwVrEc/main.rs:1:94\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"Processing...\" . to_string ()) ; println ! (\"Complete!\" . to_...\n  |                                                                            ---------------   ^^^^^^^^^^^^ argument never used\n  |                                                                            |\n  |                                                                            formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmptwVrEc/main.rs:1:133\n  |\n1 | ...! (\"Processing...\" . to_string ()) ; println ! (\"Complete!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmptwVrEc/main.rs:1:135\n  |\n1 | ...Processing...\" . to_string ()) ; println ! (\"Complete!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...\n  |                                                -----------   ^^^^^^^^^^^^ argument never used\n  |                                                |\n  |                                                formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmptwVrEc/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"Processing...\" . to_string ()) ; println ! (\"Complete!\" . to_...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmptwVrEc/main.rs:1:94\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"Processing...\" . to_string ()) ; println ! (\"Complete!\" . to_...\n  |                                                                                              ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmptwVrEc/main.rs:1:135\n  |\n1 | ...ng...\" . to_string ()) ; println ! (\"Complete!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 10,
          "line_number": 231,
          "code": "// Status: ✅ WORKING\nfun show_options() {\n    println(\"Choose an option:\");\n    println(\"1. Start\");\n    println(\"2. Stop\");\n    println(\"3. Help\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpRZ4hVH/main.rs:1:91\n  |\n1 | use std :: collections :: HashMap ; fn show_options () { { println ! (\"Choose an option:\" . to_string ()) ; println ! (\"1. Start\" . to_st...\n  |                                                                                           ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpRZ4hVH/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn show_options () { { println ! (\"Choose an option:\" . to_string ()) ; println ! (\"1. Start\" . to_st...\n  |                                                                       -------------------   ^^^^^^^^^^^^ argument never used\n  |                                                                       |\n  |                                                                       formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpRZ4hVH/main.rs:1:131\n  |\n1 | ...\"Choose an option:\" . to_string ()) ; println ! (\"1. Start\" . to_string ()) ; println ! (\"2. Stop\" . to_string ()) ; println ! (\"3. He...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpRZ4hVH/main.rs:1:133\n  |\n1 | ...se an option:\" . to_string ()) ; println ! (\"1. Start\" . to_string ()) ; println ! (\"2. Stop\" . to_string ()) ; println ! (\"3. Help\" ....\n  |                                                ----------   ^^^^^^^^^^^^ argument never used\n  |                                                |\n  |                                                formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpRZ4hVH/main.rs:1:170\n  |\n1 | ...rintln ! (\"1. Start\" . to_string ()) ; println ! (\"2. Stop\" . to_string ()) ; println ! (\"3. Help\" . to_string ()) } } fn main () { }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpRZ4hVH/main.rs:1:172\n  |\n1 | ...n ! (\"1. Start\" . to_string ()) ; println ! (\"2. Stop\" . to_string ()) ; println ! (\"3. Help\" . to_string ()) } } fn main () { }\n  |                                                 ---------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpRZ4hVH/main.rs:1:209\n  |\n1 | ...println ! (\"2. Stop\" . to_string ()) ; println ! (\"3. Help\" . to_string ()) } } fn main () { }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpRZ4hVH/main.rs:1:211\n  |\n1 | ...ln ! (\"2. Stop\" . to_string ()) ; println ! (\"3. Help\" . to_string ()) } } fn main () { }\n  |                                                 ---------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpRZ4hVH/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn show_options () { { println ! (\"Choose an option:\" . to_string ()) ; println ! (\"1. Start\" . to_st...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpRZ4hVH/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn show_options () { { println ! (\"Choose an option:\" . to_string ()) ; println ! (\"1. Start\" . to_st...\n  |                                                                                             ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpRZ4hVH/main.rs:1:133\n  |\n1 | ...ption:\" . to_string ()) ; println ! (\"1. Start\" . to_string ()) ; println ! (\"2. Stop\" . to_string ()) ; println ! (\"3. Help\" . to_str...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpRZ4hVH/main.rs:1:172\n  |\n1 | .... Start\" . to_string ()) ; println ! (\"2. Stop\" . to_string ()) ; println ! (\"3. Help\" . to_string ()) } } fn main () { }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpRZ4hVH/main.rs:1:211\n  |\n1 | ...2. Stop\" . to_string ()) ; println ! (\"3. Help\" . to_string ()) } } fn main () { }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 12 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch18-00-deployment-devops": {
      "chapter": "ch18-00-deployment-devops",
      "total_examples": 8,
      "working_examples": 0,
      "failing_examples": 8,
      "examples": [
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n\n// deploy.ruchy - One-command deployment\nuse std::deploy;\n\nlet config = DeployConfig {\n    app: \"my-app\",\n    environment: env::var(\"DEPLOY_ENV\"),  // staging/production\n    strategy: BlueGreen,\n    health_check: \"/health\",\n    rollback_on_failure: true\n}\n\n// Build and test\ndeploy::build()\n    .test()\n    .security_scan()\n    .create_artifact()\n\n// Deploy with zero downtime\nlet deployment = deploy::start(config)\n    .provision_infrastructure()\n    .deploy_new_version()\n    .run_smoke_tests()\n    .switch_traffic()\n    .verify_metrics()\n\nif deployment.is_healthy() {\n    deployment.commit()\n    println(\"✅ Deployment successful!\")\n} else {\n    deployment.rollback()\n    println(\"⚠️  Rolled back to previous version\")\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpFHjjC0/main.rs:1:637\n  |\n1 | ...loyment . commit () ; println ! (\"✅ Deployment successful!\" . to_string ()) } } else { { deployment . rollback () ; println ! (\"⚠\\u{fe0...\n  |                                                                 ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpFHjjC0/main.rs:1:639\n  |\n1 | ...deployment . commit () ; println ! (\"✅ Deployment successful!\" . to_string ()) } } else { { deployment . rollback () ; println ! (\"⚠\\u{...\n  |                                        ---------------------------   ^^^^^^^^^^^^ argument never used\n  |                                        |\n  |                                        formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpFHjjC0/main.rs:1:749\n  |\n1 | ...) ; println ! (\"⚠\\u{fe0f}  Rolled back to previous version\" . to_string ()) } } } ; if let Some (s) = (& result as & dyn std :: any ::...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpFHjjC0/main.rs:1:751\n  |\n1 | .... rollback () ; println ! (\"⚠\\u{fe0f}  Rolled back to previous version\" . to_string ()) } } } ; if let Some (s) = (& result as & dyn s...\n  |                               --------------------------------------------   ^^^^^^^^^^^^ argument never used\n  |                               |\n  |                               formatting specifier missing\n\nerror[E0432]: unresolved import `std::deploy`\n --> /tmp/.tmpFHjjC0/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let mut config = DeployConfig { app : \"my-app\" . to...\n  |                                                                     ^^^^^^^^^^^^^ no `deploy` in the root\n\nerror[E0422]: cannot find struct, variant or union type `DeployConfig` in this scope\n --> /tmp/.tmpFHjjC0/main.rs:1:104\n  |\n1 | ...esult = { use std :: deploy ; ; let mut config = DeployConfig { app : \"my-app\" . to_string () , environment : env :: var (\"DEPLOY_ENV\"...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `env`\n --> /tmp/.tmpFHjjC0/main.rs:1:165\n  |\n1 | ... \"my-app\" . to_string () , environment : env :: var (\"DEPLOY_ENV\" . to_string ()) , strategy : BlueGreen , health_check : \"/health\" . ...\n  |                                             ^^^ use of unresolved module or unlinked crate `env`\n  |\n  = help: you might be missing a crate named `env`\nhelp: consider importing this module\n  |\n1 + use std::env;\n  |\n\nerror[E0425]: cannot find value `BlueGreen` in this scope\n --> /tmp/.tmpFHjjC0/main.rs:1:219\n  |\n1 | ...:: var (\"DEPLOY_ENV\" . to_string ()) , strategy : BlueGreen , health_check : \"/health\" . to_string () , rollback_on_failure : true , }...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpFHjjC0/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let mut config = DeployConfig { app : \"my-app\" . to...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpFHjjC0/main.rs:1:85\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let mut config = DeployConfig { app : \"my-app\" . to...\n  |                                                                                     ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpFHjjC0/main.rs:1:639\n  |\n1 | ...mmit () ; println ! (\"✅ Deployment successful!\" . to_string ()) } } else { { deployment . rollback () ; println ! (\"⚠\\u{fe0f}  Rolled b...\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpFHjjC0/main.rs:1:751\n  |\n1 | ...! (\"⚠\\u{fe0f}  Rolled back to previous version\" . to_string ()) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . down...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 10 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\n\n",
          "errorCategory": "IMPORT_ERROR",
          "rootCause": "Missing dependency or import path issue"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 2,
          "line_number": 281,
          "code": "// Status: ❌ BROKEN\n\n// blue_green.ruchy\nfun deploy_blue_green(new_version: String) {\n    // Current production is \"blue\"\n    let blue = Environment::current()\n    \n    // Provision identical \"green\" environment\n    let green = Environment::provision(new_version)\n    \n    // Deploy to green\n    green.deploy()\n    green.run_health_checks()\n    green.run_smoke_tests()\n    \n    // Verify green is healthy\n    if !green.is_healthy() {\n        green.destroy()\n        panic!(\"Green environment unhealthy\")\n    }\n    \n    // Switch traffic to green\n    LoadBalancer::switch_to(green)\n    \n    // Monitor for issues\n    sleep(Duration::from_mins(5))\n    \n    if green.error_rate() > 0.01 {\n        // Rollback\n        LoadBalancer::switch_to(blue)\n        green.destroy()\n        panic!(\"High error rate, rolled back\")\n    }\n    \n    // Success - green is now production\n    blue.destroy()\n    println!(\"✅ Deployed version {}\", new_version)\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 3,
          "line_number": 334,
          "code": "// Status: ❌ BROKEN\n\n// canary.ruchy\nfun deploy_canary(new_version: String) {\n    let deployment = CanaryDeployment::new(new_version)\n    \n    // Start with 5% traffic\n    deployment.set_traffic_percentage(5)\n    deployment.deploy()\n    \n    // Monitor metrics\n    let baseline = Metrics::baseline()\n    \n    // Gradually increase traffic\n    for percentage in [5, 10, 25, 50, 100] {\n        deployment.set_traffic_percentage(percentage)\n        \n        sleep(Duration::from_mins(10))\n        \n        let current = Metrics::current()\n        if current.error_rate > baseline.error_rate * 1.1 {\n            deployment.rollback()\n            panic!(\"Error rate increased by >10%\")\n        }\n        \n        if current.p99_latency > baseline.p99_latency * 1.2 {\n            deployment.rollback()\n            panic!(\"Latency increased by >20%\")\n        }\n        \n        println!(\"✅ Canary at {}% - metrics healthy\", percentage)\n    }\n    \n    deployment.finalize()\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 4,
          "line_number": 384,
          "code": "// Status: ❌ BROKEN\n\n// feature_flags.ruchy\nuse feature_flags::{Client, Flag};\n\nlet flags = Client::new(\"api_key\")\n\n// Define feature flag\nlet new_algorithm = Flag::new(\"new-algorithm\")\n    .default(false)\n    .rollout_percentage(10)  // 10% of users\n    .targeting_rules([\n        Rule::new(\"beta_users\", true),\n        Rule::new(\"internal_users\", true)\n    ])\n\n// Use in code\nif flags.is_enabled(new_algorithm, user) {\n    use_new_algorithm()\n} else {\n    use_old_algorithm()\n}\n\n// Gradual rollout\nfor percentage in [10, 25, 50, 75, 100] {\n    flags.set_rollout(new_algorithm, percentage)\n    monitor_metrics()\n    \n    if metrics_degraded() {\n        flags.disable(new_algorithm)\n        break\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0432]: unresolved import `feature_flags`\n --> /tmp/.tmpAbVA7O/main.rs:1:69\n  |\n1 | ...n main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new (\"api_key\" . to_string ()) ; let m...\n  |                                   ^^^^^^^^^^^^^ use of unresolved module or unlinked crate `feature_flags`\n  |\nhelp: you might be missing a crate named `feature_flags`, add it to your project and import it in your code\n  |\n1 + extern crate feature_flags;\n  |\n\nerror[E0425]: cannot find value `user` in this scope\n --> /tmp/.tmpAbVA7O/main.rs:1:456\n  |\n1 | ...) , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percen...\n  |                                                         ^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpAbVA7O/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpAbVA7O/main.rs:1:106\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ...\n  |                                                                                                          ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpAbVA7O/main.rs:1:464\n  |\n1 | ...ue)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage i...\n  |                                                           ^^                    ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new (\"api_key\" . to_string ()) ; let mut new_algorithm = Flag :: new (\"new-algorithm\" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new (\"beta_users\" . to_string () , true) , Rule :: new (\"internal_users\" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new (\"api_key\" . to_string ()) ; let mut new_algorithm = Flag :: new (\"new-algorithm\" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new (\"beta_users\" . to_string () , true) , Rule :: new (\"internal_users\" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { use_new_algorithm () } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpAbVA7O/main.rs:1:498\n  |\n1 | ..._algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 7...\n  |                                                           ^^                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new (\"api_key\" . to_string ()) ; let mut new_algorithm = Flag :: new (\"new-algorithm\" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new (\"beta_users\" . to_string () , true) , Rule :: new (\"internal_users\" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new (\"api_key\" . to_string ()) ; let mut new_algorithm = Flag :: new (\"new-algorithm\" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new (\"beta_users\" . to_string () , true) , Rule :: new (\"internal_users\" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { use_old_algorithm () } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Rule`\n --> /tmp/.tmpAbVA7O/main.rs:1:309\n  |\n1 | ...lout_percentage (10i32) . targeting_rules (vec ! [Rule :: new (\"beta_users\" . to_string () , true) , Rule :: new (\"internal_users\" . t...\n  |                                                      ^^^^ use of undeclared type `Rule`\n\nerror[E0433]: failed to resolve: use of undeclared type `Rule`\n --> /tmp/.tmpAbVA7O/main.rs:1:360\n  |\n1 | ...ule :: new (\"beta_users\" . to_string () , true) , Rule :: new (\"internal_users\" . to_string () , true)]) ; if flags . is_enabled (new_...\n  |                                                      ^^^^ use of undeclared type `Rule`\n\nerror[E0425]: cannot find function `use_new_algorithm` in this scope\n --> /tmp/.tmpAbVA7O/main.rs:1:466\n  |\n1 | ...ew_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 ,...\n  |                             ^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `new_algorithm`\n\nerror[E0425]: cannot find function `use_old_algorithm` in this scope\n --> /tmp/.tmpAbVA7O/main.rs:1:500\n  |\n1 | ..., user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `monitor_metrics` in this scope\n --> /tmp/.tmpAbVA7O/main.rs:1:647\n  |\n1 | ...s . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `metrics_degraded` in this scope\n --> /tmp/.tmpAbVA7O/main.rs:1:671\n  |\n1 | ...orithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 8 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "IMPORT_ERROR",
          "rootCause": "Missing dependency or import path issue"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 5,
          "line_number": 491,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// metrics.ruchy\nuse metrics::{counter, gauge, histogram};\n\n// Application metrics\ncounter!(\"requests_total\", 1, \"endpoint\" => \"/api/users\")\nhistogram!(\"request_duration_seconds\", duration.as_secs_f64())\ngauge!(\"active_connections\", connections.len() as f64)\n\n// Prometheus endpoint\n#[get(\"/metrics\")]\nasync fun metrics_endpoint() -> String {\n    prometheus::gather()\n}\n\n// Grafana dashboard configuration\nlet dashboard = json!({\n    \"title\": \"Application Metrics\",\n    \"panels\": [\n        {\n            \"title\": \"Request Rate\",\n            \"targets\": [{\n                \"expr\": \"rate(requests_total[5m])\"\n            }]\n        },\n        {\n            \"title\": \"Error Rate\",\n            \"targets\": [{\n                \"expr\": \"rate(requests_total{status=~'5..'}[5m])\"\n            }]\n        },\n        {\n            \"title\": \"P99 Latency\",\n            \"targets\": [{\n                \"expr\": \"histogram_quantile(0.99, request_duration_seconds)\"\n            }]\n        }\n    ]\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 6,
          "line_number": 542,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// logging.ruchy\nuse tracing::{info, warn, error, debug, span, Level};\n\n// Structured logging\n#[instrument]\nasync fun process_request(req: Request) -> Result<Response, Error> {\n    let span = span!(Level::INFO, \"request\", \n        method = %req.method(),\n        path = %req.path(),\n        request_id = %generate_id()\n    );\n    \n    let _enter = span.enter();\n    \n    info!(\"Processing request\");\n    \n    let result = match handle_request(req).await {\n        Ok(response) => {\n            info!(status = response.status(), \"Request successful\");\n            Ok(response)\n        }\n        Err(e) => {\n            error!(error = ?e, \"Request failed\");\n            Err(e)\n        }\n    };\n    \n    result\n}\n\n// Log aggregation config\nlet config = json!({\n    \"sinks\": {\n        \"elasticsearch\": {\n            \"type\": \"elasticsearch\",\n            \"endpoints\": [\"http://elasticsearch:9200\"],\n            \"index\": \"logs-%Y.%m.%d\"\n        },\n        \"s3\": {\n            \"type\": \"aws_s3\",\n            \"bucket\": \"my-app-logs\",\n            \"compression\": \"gzip\"\n        }\n    }\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 7,
          "line_number": 600,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// tracing.ruchy\nuse opentelemetry::{global, sdk, trace::Tracer};\n\n// Initialize tracing\nlet tracer = global::tracer(\"my-app\")\n\n// Trace requests\n#[instrument(skip(db))]\nasync fun handle_request(req: Request, db: &Database) -> Result<Response> {\n    let span = tracer.start(\"handle_request\")\n    \n    // Trace database query\n    let user = db.with_span(\"fetch_user\", |db| {\n        db.query_one(\"SELECT * FROM users WHERE id = $1\", &[req.user_id()])\n    }).await?\n    \n    // Trace external API call\n    let data = http_client.with_span(\"fetch_external_data\", |client| {\n        client.get(\"https://api.example.com/data\").send()\n    }).await?\n    \n    span.end()\n    \n    Ok(Response::new(data))\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 8,
          "line_number": 694,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to transpile to Rust\n// secrets.ruchy\nuse vault::Client;\n\n// Vault integration\nlet vault = Client::new(\"https://vault.example.com\")\n    .auth_kubernetes()  // Use K8s service account\n\n// Fetch secrets\nlet db_password = vault.read(\"secret/database/password\").await?\nlet api_key = vault.read(\"secret/external/api_key\").await?\n\n// Rotate secrets\nvault.rotate(\"secret/database/password\").await?\n\n// Environment injection\nenv::set_var(\"DATABASE_URL\", \n    format!(\"postgres://user:{}@host/db\", db_password))",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch01-03-interpreter-scripting": {
      "chapter": "ch01-03-interpreter-scripting",
      "total_examples": 15,
      "working_examples": 2,
      "failing_examples": 13,
      "examples": [
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 1,
          "line_number": 28,
          "code": "// Status: ❌ BROKEN\nruchy -e \"2 + 2\"\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `ruchy` in this scope\n --> /tmp/.tmpGxBqwH/main.rs:1:65\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"2 + 2\" } ; if let Some (s) = (& result as & dyn std :: any :...\n  |                                                                 ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `e` in this scope\n --> /tmp/.tmpGxBqwH/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"2 + 2\" } ; if let Some (s) = (& result as & dyn std :: any :...\n  |                                                                         ^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpGxBqwH/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"2 + 2\" } ; if let Some (s) = (& result as & dyn std :: any :...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 2,
          "line_number": 42,
          "code": "// Status: ❌ BROKEN\nruchy -e \"let name = \\\"World\\\"; \\\"Hello \\\" + name + \\\"!\\\"\"\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `ruchy` in this scope\n --> /tmp/.tmpYwRSUa/main.rs:1:65\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let name = \\\"World\\\"; \\\"Hello \\\" + name + \\\"!\\\"\" } ; if let ...\n  |                                                                 ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `e` in this scope\n --> /tmp/.tmpYwRSUa/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let name = \\\"World\\\"; \\\"Hello \\\" + name + \\\"!\\\"\" } ; if let ...\n  |                                                                         ^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpYwRSUa/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let name = \\\"World\\\"; \\\"Hello \\\" + name + \\\"!\\\"\" } ; if let ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 3,
          "line_number": 56,
          "code": "// Status: ❌ BROKEN\nruchy -e \"let nums = [1, 2, 3]; nums[1]\"\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `ruchy` in this scope\n --> /tmp/.tmpEjvJrU/main.rs:1:65\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let nums = [1, 2, 3]; nums[1]\" } ; if let Some (s) = (& resu...\n  |                                                                 ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `e` in this scope\n --> /tmp/.tmpEjvJrU/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let nums = [1, 2, 3]; nums[1]\" } ; if let Some (s) = (& resu...\n  |                                                                         ^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpEjvJrU/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let nums = [1, 2, 3]; nums[1]\" } ; if let Some (s) = (& resu...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 4,
          "line_number": 88,
          "code": "// Status: ❌ BROKEN\nfun main() {\n    // Integer values\n    let small_int = 42\n    let result = small_int * 2\n\n    // Floating point numbers  \n    let pi = 3.14159\n    let area = pi * 5.0 * 5.0\n\n    // String operations\n    let greeting = \"Hello\"\n    let name = \"Ruchy\"\n\n    // Arrays with indexing\n    let data = [1, 2, 3, 4, 5]\n    println(data[2])\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpzf5zcD/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let small_int = 42i32 ; { let mut result = small_int * 2i32 ; let mut pi = 3.14159f6...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpzf5zcD/main.rs:1:50\n  |\n1 | ... { { { let small_int = 42i32 ; { let mut result = small_int * 2i32 ; let mut pi = 3.14159f64 ; let mut area = pi * 5f64 * 5f64 ; let mut greeting = \"Hello\" ; let mut name = \"Ruchy\" ; let mut data = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32] ; println ! (\"{}\" , data [2i32]) } } } }\n  |       ^^                                                                                                                                                                                                                                                                              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let small_int = 42i32 ; { let mut result = small_int * 2i32 ; let mut pi = 3.14159f64 ; let mut area = pi * 5f64 * 5f64 ; let mut greeting = \"Hello\" ; let mut name = \"Ruchy\" ; let mut data = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32] ; println ! (\"{}\" , data [2i32]) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let small_int = 42i32 ; { let mut result = small_int * 2i32 ; let mut pi = 3.14159f64 ; let mut area = pi * 5f64 * 5f64 ; let mut greeting = \"Hello\" ; let mut name = \"Ruchy\" ; let mut data = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32] ; println ! (\"{}\" , data [2i32]) } } }\n  |\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n --> /tmp/.tmpzf5zcD/main.rs:1:312\n  |\n1 | ...32 , 5i32] ; println ! (\"{}\" , data [2i32]) } } } }\n  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<i32>` to implement `Index<i32>`\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 5,
          "line_number": 137,
          "code": "// Status: ❌ BROKEN\n// calculator.ruchy - Basic calculator functionality\n\nfun add(a, b) {\n    a + b\n}\n\nfun subtract(a, b) {\n    a - b\n}\n\nfun multiply(a, b) {\n    a * b\n}\n\nfun divide(a, b) {\n    if b == 0 {\n        println(\"Error: Division by zero\")\n        0\n    } else {\n        a / b\n    }\n}\n\nfun main() {\n    // Test our calculator\n    let x = 10\n    let y = 3\n\n    println(\"Addition:\")\n    println(add(x, y))\n    println(\"Subtraction:\")\n    println(subtract(x, y))\n    println(\"Multiplication:\")\n    println(multiply(x, y))\n    println(\"Division:\")\n    println(divide(x, y))\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpazRDS3/main.rs:1:782\n  |\n1 | ...T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x =...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpazRDS3/main.rs:1:784\n  |\n1 | ...-> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let ...\n  |                                         -------------------------   ^^^^^^^^^^^^ argument never used\n  |                                         |\n  |                                         formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpazRDS3/main.rs:1:909\n  |\n1 | ...let x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpazRDS3/main.rs:1:911\n  |\n1 | ...x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" ....\n  |                                                -----------   ^^^^^^^^^^^^ argument never used\n  |                                                |\n  |                                                formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpazRDS3/main.rs:1:986\n  |\n1 | ... println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multip...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpazRDS3/main.rs:1:988\n  |\n1 | ...intln ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplic...\n  |                                              --------------   ^^^^^^^^^^^^ argument never used\n  |                                              |\n  |                                              formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpazRDS3/main.rs:1:1071\n  |\n1 | ... ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Divisi...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpazRDS3/main.rs:1:1073\n  |\n1 | ...! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Divisio...\n  |                                             -----------------   ^^^^^^^^^^^^ argument never used\n  |                                             |\n  |                                             formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpazRDS3/main.rs:1:1150\n  |\n1 | ...rintln ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpazRDS3/main.rs:1:1152\n  |\n1 | ...ln ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n  |                                                -----------   ^^^^^^^^^^^^ argument never used\n  |                                                |\n  |                                                formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpazRDS3/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Disp...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpazRDS3/main.rs:1:197\n  |\n1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ...\n  |                                                                  ^^     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a + b } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpazRDS3/main.rs:1:374\n  |\n1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ...\n  |                                                                  ^^     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a - b } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpazRDS3/main.rs:1:551\n  |\n1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: op...\n  |                                                                  ^^     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a * b } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpazRDS3/main.rs:1:726\n  |\n1 | ... b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { ...\n  |                   ^^                                                                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpazRDS3/main.rs:1:816\n  |\n1 | ... (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; pr...\n  |                                                                  ^^     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { a / b } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpazRDS3/main.rs:1:845\n  |\n1 | ... { { { let x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { let x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } }\n  |\n\nerror[E0369]: cannot subtract `T` from `T`\n --> /tmp/.tmpazRDS3/main.rs:1:378\n  |\n1 | ...splay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: o...\n  |                                                                   - ^ - T\n  |                                                                   |\n  |                                                                   T\n  |\nhelp: consider further restricting type parameter `T` with trait `Sub`\n  |\n1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<Output = T> > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n  |                                                                                                                                                                                                                                                                                                                                                             +++++++++++++++++++++++++++\n\nerror[E0369]: binary operation `==` cannot be applied to type `T`\n --> /tmp/.tmpazRDS3/main.rs:1:733\n  |\n1 | ...+ std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 ...\n  |                                                                - ^^ ---- i32\n  |                                                                |\n  |                                                                T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialEq`\n  |\n1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialEq<i32> > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++++++++++++++++\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpazRDS3/main.rs:1:784\n  |\n1 | ...= 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { l...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpazRDS3/main.rs:1:800\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } ...\n  |       - expected this type parameter                                                                                                                     - expected `T` because of return type                                         ^^^^ expected type parameter `T`, found `i32`\n  |\n  = note: expected type parameter `T`\n                       found type `i32`\n  = note: the caller chooses a type for `T` which can be different from `i32`\n\nerror[E0369]: cannot divide `T` by `T`\n --> /tmp/.tmpazRDS3/main.rs:1:820\n  |\n1 | ...(\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; pri...\n  |                                                                   - ^ - T\n  |                                                                   |\n  |                                                                   T\n  |\nhelp: consider further restricting type parameter `T` with trait `Div`\n  |\n1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn subtract < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a - b } } fn multiply < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a * b } } fn divide < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div<Output = T> > (a : T , b : T) -> T { { if b == 0i32 { { println ! (\"Error: Division by zero\" . to_string ()) ; 0i32 } } else { { a / b } } } } fn main () { { { let x = 10i32 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             +++++++++++++++++++++++++++\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpazRDS3/main.rs:1:911\n  |\n1 | ...2 ; { let mut y = 3i32 ; println ! (\"Addition:\" . to_string ()) ; println ! (\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_stri...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpazRDS3/main.rs:1:988\n  |\n1 | ...\"{}\" , add (x , y)) ; println ! (\"Subtraction:\" . to_string ()) ; println ! (\"{}\" , subtract (x , y)) ; println ! (\"Multiplication:\" ....\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpazRDS3/main.rs:1:1073\n  |\n1 | ...ubtract (x , y)) ; println ! (\"Multiplication:\" . to_string ()) ; println ! (\"{}\" , multiply (x , y)) ; println ! (\"Division:\" . to_st...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpazRDS3/main.rs:1:1152\n  |\n1 | ...}\" , multiply (x , y)) ; println ! (\"Division:\" . to_string ()) ; println ! (\"{}\" , divide (x , y)) } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 19 previous errors; 7 warnings emitted\n\nSome errors have detailed explanations: E0308, E0369, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 6,
          "line_number": 192,
          "code": "// Status: ❌ BROKEN\n// data_processing.ruchy - Array manipulation examples\n\nfun main() {\n    let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    // Access elements\n    println(\"First:\")\n    println(numbers[0])\n    println(\"Last:\")\n    println(numbers[9])\n\n    // Simple iteration (manual)\n    let mut sum = 0\n    let mut i = 0\n    while i < 10 {\n        sum = sum + numbers[i]\n        i = i + 1\n    }\n    println(\"Sum:\")\n    println(sum)\n\n    // Calculate average\n    let average = sum / 10\n    println(\"Average:\")\n    println(average)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpwuaEEK/main.rs:1:169\n  |\n1 | ... 6i32 , 7i32 , 8i32 , 9i32 , 10i32] ; { println ! (\"First:\" . to_string ()) ; println ! (\"{}\" , numbers [0i32]) ; println ! (\"Last:\" ....\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpwuaEEK/main.rs:1:171\n  |\n1 | ..., 7i32 , 8i32 , 9i32 , 10i32] ; { println ! (\"First:\" . to_string ()) ; println ! (\"{}\" , numbers [0i32]) ; println ! (\"Last:\" . to_st...\n  |                                                 --------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpwuaEEK/main.rs:1:242\n  |\n1 | ...)) ; println ! (\"{}\" , numbers [0i32]) ; println ! (\"Last:\" . to_string ()) ; println ! (\"{}\" , numbers [9i32]) ; let mut sum = 0i32 ;...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpwuaEEK/main.rs:1:244\n  |\n1 | ...rintln ! (\"{}\" , numbers [0i32]) ; println ! (\"Last:\" . to_string ()) ; println ! (\"{}\" , numbers [9i32]) ; let mut sum = 0i32 ; let m...\n  |                                                  -------   ^^^^^^^^^^^^ argument never used\n  |                                                  |\n  |                                                  formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpwuaEEK/main.rs:1:419\n  |\n1 | ... = sum + numbers [i] ; i = i + 1i32 } } ; println ! (\"Sum:\" . to_string ()) ; println ! (\"{}\" , sum) ; let mut average = sum / 10i32 ;...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpwuaEEK/main.rs:1:421\n  |\n1 | ...+ numbers [i] ; i = i + 1i32 } } ; println ! (\"Sum:\" . to_string ()) ; println ! (\"{}\" , sum) ; let mut average = sum / 10i32 ; printl...\n  |                                                  ------   ^^^^^^^^^^^^ argument never used\n  |                                                  |\n  |                                                  formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpwuaEEK/main.rs:1:516\n  |\n1 | ...um) ; let mut average = sum / 10i32 ; println ! (\"Average:\" . to_string ()) ; println ! (\"{}\" , average) } } } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpwuaEEK/main.rs:1:518\n  |\n1 | ... let mut average = sum / 10i32 ; println ! (\"Average:\" . to_string ()) ; println ! (\"{}\" , average) } } } }\n  |                                                ----------   ^^^^^^^^^^^^ argument never used\n  |                                                |\n  |                                                formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpwuaEEK/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let numbers = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32 , 6i32 , 7i32 , 8i32 , 9i32 , ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpwuaEEK/main.rs:1:50\n  |\n1 | ... { { { let numbers = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32 , 6i32 , 7i32 , 8i32 , 9i32 , 10i32] ; { println ! (\"First:\" . to_string ()) ; println ! (\"{}\" , numbers [0i32]) ; println ! (\"Last:\" . to_string ()) ; println ! (\"{}\" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i = 0i32 ; while i < 10i32 { { sum = sum + numbers [i] ; i = i + 1i32 } } ; println ! (\"Sum:\" . to_string ()) ; println ! (\"{}\" , sum) ; let mut average = sum / 10i32 ; println ! (\"Average:\" . to_string ()) ; println ! (\"{}\" , average) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let numbers = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32 , 6i32 , 7i32 , 8i32 , 9i32 , 10i32] ; { println ! (\"First:\" . to_string ()) ; println ! (\"{}\" , numbers [0i32]) ; println ! (\"Last:\" . to_string ()) ; println ! (\"{}\" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i = 0i32 ; while i < 10i32 { { sum = sum + numbers [i] ; i = i + 1i32 } } ; println ! (\"Sum:\" . to_string ()) ; println ! (\"{}\" , sum) ; let mut average = sum / 10i32 ; println ! (\"Average:\" . to_string ()) ; println ! (\"{}\" , average) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let numbers = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32 , 6i32 , 7i32 , 8i32 , 9i32 , 10i32] ; { println ! (\"First:\" . to_string ()) ; println ! (\"{}\" , numbers [0i32]) ; println ! (\"Last:\" . to_string ()) ; println ! (\"{}\" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i = 0i32 ; while i < 10i32 { { sum = sum + numbers [i] ; i = i + 1i32 } } ; println ! (\"Sum:\" . to_string ()) ; println ! (\"{}\" , sum) ; let mut average = sum / 10i32 ; println ! (\"Average:\" . to_string ()) ; println ! (\"{}\" , average) } } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpwuaEEK/main.rs:1:171\n  |\n1 | ... , 8i32 , 9i32 , 10i32] ; { println ! (\"First:\" . to_string ()) ; println ! (\"{}\" , numbers [0i32]) ; println ! (\"Last:\" . to_string (...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n --> /tmp/.tmpwuaEEK/main.rs:1:214\n  |\n1 | ...ing ()) ; println ! (\"{}\" , numbers [0i32]) ; println ! (\"Last:\" . to_string ()) ; println ! (\"{}\" , numbers [9i32]) ; let mut sum = 0...\n  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<i32>` to implement `Index<i32>`\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpwuaEEK/main.rs:1:244\n  |\n1 | ... ! (\"{}\" , numbers [0i32]) ; println ! (\"Last:\" . to_string ()) ; println ! (\"{}\" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i =...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n --> /tmp/.tmpwuaEEK/main.rs:1:287\n  |\n1 | ...ing ()) ; println ! (\"{}\" , numbers [9i32]) ; let mut sum = 0i32 ; let mut i = 0i32 ; while i < 10i32 { { sum = sum + numbers [i] ; i ...\n  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<i32>` to implement `Index<i32>`\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n --> /tmp/.tmpwuaEEK/main.rs:1:377\n  |\n1 | ...ile i < 10i32 { { sum = sum + numbers [i] ; i = i + 1i32 } } ; println ! (\"Sum:\" . to_string ()) ; println ! (\"{}\" , sum) ; let mut av...\n  |                                           ^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<i32>` to implement `Index<i32>`\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpwuaEEK/main.rs:1:421\n  |\n1 | ...bers [i] ; i = i + 1i32 } } ; println ! (\"Sum:\" . to_string ()) ; println ! (\"{}\" , sum) ; let mut average = sum / 10i32 ; println ! (...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpwuaEEK/main.rs:1:518\n  |\n1 | ...t average = sum / 10i32 ; println ! (\"Average:\" . to_string ()) ; println ! (\"{}\" , average) } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 15 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 7,
          "line_number": 233,
          "code": "// Status: ❌ BROKEN\n// scoping.ruchy - Variable scope examples\n\nlet global_var = \"I'm global\"\n\nfun demonstrate_scope() {\n    let local_var = \"I'm local\"\n    println(global_var)  // Can access global\n    println(local_var)   // Can access local\n    \n    // Nested function\n    fun nested() {\n        println(global_var)  // Can access global\n        println(local_var)   // Can access parent local\n        let nested_var = \"I'm nested\"\n        println(nested_var)\n    }\n    \n    nested()\n}\n\nfun main() {\n    demonstrate_scope()\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0434]: can't capture dynamic environment in a fn item\n --> /tmp/.tmp4kFrLu/main.rs:1:229\n  |\n1 | ...sted () { { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; { let nested_var = \"I'm nested\" ; println ! (\"{}\" , nested_...\n  |                                                                  ^^^^^^^^^\n  |\n  = help: use the `|| { ... }` closure form instead\n\nerror[E0425]: cannot find value `global_var` in this scope\n --> /tmp/.tmp4kFrLu/main.rs:1:117\n  |\n1 | ... local\" ; { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; fn nested () { { println ! (\"{}\" , global_var) ; println ! ...\n  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`\n\nerror[E0425]: cannot find value `global_var` in this scope\n --> /tmp/.tmp4kFrLu/main.rs:1:197\n  |\n1 | ...sted () { { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; { let nested_var = \"I'm nested\" ; println ! (\"{}\" , nested_...\n  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp4kFrLu/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn demonstrate_scope () { { { let local_var = \"I'm local\" ; { println ! (\"{}\" , global_var) ; println...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4kFrLu/main.rs:1:63\n  |\n1 | ... { { { let local_var = \"I'm local\" ; { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; fn nested () { { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; { let nested_var = \"I'm nested\" ; println ! (\"{}\" , nested_var) } } } ; nested () } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                      ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn demonstrate_scope () { { { let local_var = \"I'm local\" ; { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; fn nested () { { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; { let nested_var = \"I'm nested\" ; println ! (\"{}\" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = \"I'm global\" ; { demonstrate_scope () } }\n1 + use std :: collections :: HashMap ; fn demonstrate_scope () { { let local_var = \"I'm local\" ; { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; fn nested () { { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; { let nested_var = \"I'm nested\" ; println ! (\"{}\" , nested_var) } } } ; nested () } } } fn main () { let mut global_var = \"I'm global\" ; { demonstrate_scope () } }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp4kFrLu/main.rs:1:312\n  |\n1 | ... \"I'm nested\" ; println ! (\"{}\" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = \"I'm global\" ; { demonstrate...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4kFrLu/main.rs:1:381\n  |\n1 | ...} } } fn main () { let mut global_var = \"I'm global\" ; { demonstrate_scope () } }\n  |                                                           ^^                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn demonstrate_scope () { { { let local_var = \"I'm local\" ; { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; fn nested () { { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; { let nested_var = \"I'm nested\" ; println ! (\"{}\" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = \"I'm global\" ; { demonstrate_scope () } }\n1 + use std :: collections :: HashMap ; fn demonstrate_scope () { { { let local_var = \"I'm local\" ; { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; fn nested () { { println ! (\"{}\" , global_var) ; println ! (\"{}\" , local_var) ; { let nested_var = \"I'm nested\" ; println ! (\"{}\" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = \"I'm global\" ; demonstrate_scope () }\n  |\n\nwarning: unused variable: `global_var`\n --> /tmp/.tmp4kFrLu/main.rs:1:353\n  |\n1 | ...} } fn main () { let mut global_var = \"I'm global\" ; { demonstrate_scope () } }\n  |                             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_global_var`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmp4kFrLu/main.rs:1:349\n  |\n1 | ...sted_var) } } } ; nested () } } } } fn main () { let mut global_var = \"I'm global\" ; { demonstrate_scope () } }\n  |                                                         ----^^^^^^^^^^\n  |                                                         |\n  |                                                         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror: aborting due to 3 previous errors; 6 warnings emitted\n\nSome errors have detailed explanations: E0425, E0434.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 8,
          "line_number": 273,
          "code": "// Status: ❌ BROKEN\nfun main() {\n    let arr = [1, 2, 3]\n\n    // Unsafe - may cause error if index is out of bounds\n    // println(arr[5])\n\n    // Better approach\n    if 5 < arr.len() {\n        println(arr[5])\n    } else {\n        println(\"Index out of bounds\")\n    }\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmp6XLWTe/main.rs:1:196\n  |\n1 | ..., arr [5i32]) } } else { { println ! (\"Index out of bounds\" . to_string ()) } } } } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmp6XLWTe/main.rs:1:198\n  |\n1 | ... , arr [5i32]) } } else { { println ! (\"Index out of bounds\" . to_string ()) } } } } }\n  |                                           ---------------------   ^^^^^^^^^^^^ argument never used\n  |                                           |\n  |                                           formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp6XLWTe/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp6XLWTe/main.rs:1:50\n  |\n1 | ... { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\" . to_string ()) } } } } }\n  |       ^^                                                                                                                                                                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\" . to_string ()) } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\" . to_string ()) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp6XLWTe/main.rs:1:118\n  |\n1 | ...! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\" . to_s...\n  |                                                      ^^                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\" . to_string ()) } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { println ! (\"{}\" , arr [5i32]) } else { { println ! (\"Index out of bounds\" . to_string ()) } } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp6XLWTe/main.rs:1:161\n  |\n1 | ...println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\" . to_string ()) } } } } }\n  |                                             ^^                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\" . to_string ()) } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , arr [5i32]) } } else { println ! (\"Index out of bounds\" . to_string ()) } } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp6XLWTe/main.rs:1:103\n  |\n1 | ...let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of ...\n  |                                              ----   ^^^^^^^^^^^^ expected `i32`, found `usize`\n  |                                              |\n  |                                              expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len ().try_into().unwrap() { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\" . to_string ()) } } } } }\n  |                                                                                                                   ++++++++++++++++++++\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n --> /tmp/.tmp6XLWTe/main.rs:1:143\n  |\n1 | ... . len () { { println ! (\"{}\" , arr [5i32]) } } else { { println ! (\"Index out of bounds\" . to_string ()) } } } } }\n  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<i32>` to implement `Index<i32>`\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmp6XLWTe/main.rs:1:198\n  |\n1 | ...) } } else { { println ! (\"Index out of bounds\" . to_string ()) } } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 5 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 9,
          "line_number": 301,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let x = 5\n    // x = 10  // Error! x is immutable\n\n    // Use mut for mutable variables\n    let mut y = 5\n    y = 10  // OK\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 10,
          "line_number": 323,
          "code": "// Status: ❌ BROKEN\nfun get_double(x) {\n    x * 2  // This is returned (no semicolon)\n}\n\nfun process_and_print(x) {\n    let doubled = x * 2\n    println(\"Doubled:\")\n    println(doubled)\n    // No explicit return - returns unit type ()\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmperMK6N/main.rs:1:430\n  |\n1 | ...-> T { { { let doubled = x * 2i32 ; { println ! (\"Doubled:\" . to_string ()) ; println ! (\"{}\" , doubled) } } } } fn main () { }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmperMK6N/main.rs:1:432\n  |\n1 | ...{ { { let doubled = x * 2i32 ; { println ! (\"Doubled:\" . to_string ()) ; println ! (\"{}\" , doubled) } } } } fn main () { }\n  |                                                ----------   ^^^^^^^^^^^^ argument never used\n  |                                                |\n  |                                                formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmperMK6N/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmperMK6N/main.rs:1:196\n  |\n1 | ...mt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T ...\n  |                                                                 ^^        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! (\"Doubled:\" . to_string ()) ; println ! (\"{}\" , doubled) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { x * 2i32 } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! (\"Doubled:\" . to_string ()) ; println ! (\"{}\" , doubled) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmperMK6N/main.rs:1:377\n  |\n1 | ...(x : T) -> T { { { let doubled = x * 2i32 ; { println ! (\"Doubled:\" . to_string ()) ; println ! (\"{}\" , doubled) } } } } fn main () { }\n  |                   ^^                                                                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! (\"Doubled:\" . to_string ()) ; println ! (\"{}\" , doubled) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn get_double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } } fn process_and_print < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { let doubled = x * 2i32 ; { println ! (\"Doubled:\" . to_string ()) ; println ! (\"{}\" , doubled) } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmperMK6N/main.rs:1:202\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * 2i32 } ...\n  |       -                                                                                                                                                -   ^^^^ expected type parameter `T`, found `i32`\n  |       |                                                                                                                                                |\n  |       expected this type parameter                                                                                                                     expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                       found type `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmperMK6N/main.rs:1:399\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; ...\n  |       -                                                                                                                                                                -   ^^^^ expected type parameter `T`, found `i32`\n  |       |                                                                                                                                                                |\n  |       expected this type parameter                                                                                                                                     expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                       found type `i32`\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmperMK6N/main.rs:1:432\n  |\n1 | ...et doubled = x * 2i32 ; { println ! (\"Doubled:\" . to_string ()) ; println ! (\"{}\" , doubled) } } } } fn main () { }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmperMK6N/main.rs:1:448\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let doubled = x * 2i32 ; { println ! (\"Doubled:\" . to_string ()) ; println ! (\"{}\" , doubled) } ...\n  |       - expected this type parameter                                                                                                                                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 6 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 11,
          "line_number": 390,
          "code": "// Status: ✅ WORKING\n// Good: Clear, functional style\nfun calculate_tax(income, rate) {\n    income * rate\n}\n\n// Avoid: Complex nested logic (for now)",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 12,
          "line_number": 407,
          "code": "// Status: ❌ BROKEN\n// Good\nlet user_count = 42\nlet total_price = calculate_price(items)\n\n// Avoid\nlet x = 42\nlet y = calc(z)\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpxm8gp4/main.rs:1:183\n  |\n1 | ...t mut x = 42i32 ; let mut y = calc (z) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]: cannot find value `items` in this scope\n --> /tmp/.tmpxm8gp4/main.rs:1:133\n  |\n1 | ...nt = 42i32 ; let mut total_price = calculate_price (items) ; let mut x = 42i32 ; let mut y = calc (z) } ; if let Some (s) = (& result ...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpxm8gp4/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut user_count = 42i32 ; let mut total_price = calculate_price (items...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `calculate_price` in this scope\n --> /tmp/.tmpxm8gp4/main.rs:1:116\n  |\n1 | ...mut user_count = 42i32 ; let mut total_price = calculate_price (items) ; let mut x = 42i32 ; let mut y = calc (z) } ; if let Some (s) ...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 13,
          "line_number": 428,
          "code": "// Status: ❌ BROKEN\nfun main() {\n    let grades = [95, 87, 92, 78, 89]\n    let first_grade = grades[0]\n    let last_grade = grades[4]\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmp6SBayT/main.rs:1:190\n  |\n1 | ...] ; let mut last_grade = grades [4i32] } } } }\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp6SBayT/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade =...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp6SBayT/main.rs:1:50\n  |\n1 | ... { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade = grades [0i32] ; let mut last_grade = grades [4i32] } } } }\n  |       ^^                                                                                                                                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade = grades [0i32] ; let mut last_grade = grades [4i32] } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade = grades [0i32] ; let mut last_grade = grades [4i32] } } }\n  |\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n --> /tmp/.tmp6SBayT/main.rs:1:147\n  |\n1 | ...2] ; { let mut first_grade = grades [0i32] ; let mut last_grade = grades [4i32] } } } }\n  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<i32>` to implement `Index<i32>`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 14,
          "line_number": 447,
          "code": "// Status: ❌ BROKEN\n// Add functions\nfun double(n) { n * 2 }\n\nfun main() {\n    // Start simple\n    let x = 5\n\n    // Combine\n    let result = double(x)\n    println(result)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpzslMim/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: D...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpzslMim/main.rs:1:192\n  |\n1 | ...mt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { { let x = 5i32 ; { let mut result = double ...\n  |                                                                 ^^        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { { let x = 5i32 ; { let mut result = double (x) ; println ! (\"{}\" , result) } } } }\n1 + use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { n * 2i32 } fn main () { { { let x = 5i32 ; { let mut result = double (x) ; println ! (\"{}\" , result) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpzslMim/main.rs:1:220\n  |\n1 | ...n * 2i32 } } fn main () { { { let x = 5i32 ; { let mut result = double (x) ; println ! (\"{}\" , result) } } } }\n  |                              ^^                                                                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { { let x = 5i32 ; { let mut result = double (x) ; println ! (\"{}\" , result) } } } }\n1 + use std :: collections :: HashMap ; fn double < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } } fn main () { { let x = 5i32 ; { let mut result = double (x) ; println ! (\"{}\" , result) } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpzslMim/main.rs:1:198\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { n * 2i32 } ...\n  |       -                                                                                                                                                -   ^^^^ expected type parameter `T`, found `i32`\n  |       |                                                                                                                                                |\n  |       expected this type parameter                                                                                                                     expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                       found type `i32`\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmpzslMim/main.rs:1:245\n  |\n1 | ...{ n * 2i32 } } fn main () { { { let x = 5i32 ; { let mut result = double (x) ; println ! (\"{}\" , result) } } } }\n  |                                                         ----^^^^^^\n  |                                                         |\n  |                                                         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror: aborting due to 1 previous error; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 15,
          "line_number": 473,
          "code": "// Status: ✅ WORKING\n// test_calculator.ruchy\nfun add(a, b) { a + b }\n\nfun main() {\n    // Test cases\n    let test1 = add(2, 3) == 5\n    let test2 = add(0, 0) == 0\n    let test3 = add(-1, 1) == 0\n\n    if test1 && test2 && test3 {\n        println(\"All tests passed!\")\n    } else {\n        println(\"Some tests failed\")\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpvnszJa/main.rs:1:420\n  |\n1 | ... test1 && test2 && test3 { { println ! (\"All tests passed!\" . to_string ()) } } else { { println ! (\"Some tests failed\" . to_string ()...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpvnszJa/main.rs:1:422\n  |\n1 | ... test1 && test2 && test3 { { println ! (\"All tests passed!\" . to_string ()) } } else { { println ! (\"Some tests failed\" . to_string ()...\n  |                                            -------------------   ^^^^^^^^^^^^ argument never used\n  |                                            |\n  |                                            formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpvnszJa/main.rs:1:480\n  |\n1 | .... to_string ()) } } else { { println ! (\"Some tests failed\" . to_string ()) } } } } } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpvnszJa/main.rs:1:482\n  |\n1 | .... to_string ()) } } else { { println ! (\"Some tests failed\" . to_string ()) } } } } } }\n  |                                            -------------------   ^^^^^^^^^^^^ argument never used\n  |                                            |\n  |                                            formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpvnszJa/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Disp...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpvnszJa/main.rs:1:197\n  |\n1 | ...isplay + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn main () { { { let test1 = add (2i32 , 3i32) == 5i32 ; { l...\n  |                                                                  ^^     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn main () { { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { { println ! (\"All tests passed!\" . to_string ()) } } else { { println ! (\"Some tests failed\" . to_string ()) } } } } } }\n1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { a + b } fn main () { { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { { println ! (\"All tests passed!\" . to_string ()) } } else { { println ! (\"Some tests failed\" . to_string ()) } } } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpvnszJa/main.rs:1:222\n  |\n1 | ... { { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { { println ! (\"All tests passed!\" . to_string ()) } } else { { println ! (\"Some tests failed\" . to_string ()) } } } } } }\n  |       ^^                                                                                                                                                                                                                                                                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn main () { { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { { println ! (\"All tests passed!\" . to_string ()) } } else { { println ! (\"Some tests failed\" . to_string ()) } } } } } }\n1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn main () { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { { println ! (\"All tests passed!\" . to_string ()) } } else { { println ! (\"Some tests failed\" . to_string ()) } } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpvnszJa/main.rs:1:387\n  |\n1 | ...2) == 0i32 ; if test1 && test2 && test3 { { println ! (\"All tests passed!\" . to_string ()) } } else { { println ! (\"Some tests failed\"...\n  |                                              ^^                                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn main () { { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { { println ! (\"All tests passed!\" . to_string ()) } } else { { println ! (\"Some tests failed\" . to_string ()) } } } } } }\n1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn main () { { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { println ! (\"All tests passed!\" . to_string ()) } else { { println ! (\"Some tests failed\" . to_string ()) } } } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpvnszJa/main.rs:1:447\n  |\n1 | ...tests passed!\" . to_string ()) } } else { { println ! (\"Some tests failed\" . to_string ()) } } } } } }\n  |                                              ^^                                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn main () { { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { { println ! (\"All tests passed!\" . to_string ()) } } else { { println ! (\"Some tests failed\" . to_string ()) } } } } } }\n1 + use std :: collections :: HashMap ; fn add < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (a : T , b : T) -> T { { a + b } } fn main () { { { let test1 = add (2i32 , 3i32) == 5i32 ; { let mut test2 = add (0i32 , 0i32) == 0i32 ; let mut test3 = add (- 1i32 , 1i32) == 0i32 ; if test1 && test2 && test3 { { println ! (\"All tests passed!\" . to_string ()) } } else { println ! (\"Some tests failed\" . to_string ()) } } } } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpvnszJa/main.rs:1:422\n  |\n1 | ...st2 && test3 { { println ! (\"All tests passed!\" . to_string ()) } } else { { println ! (\"Some tests failed\" . to_string ()) } } } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpvnszJa/main.rs:1:482\n  |\n1 | ...()) } } else { { println ! (\"Some tests failed\" . to_string ()) } } } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors; 5 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch17-00-documentation": {
      "chapter": "ch17-00-documentation",
      "total_examples": 10,
      "working_examples": 0,
      "failing_examples": 10,
      "examples": [
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n/// A high-performance cache with automatic eviction.\n/// \n/// # Examples\n/// \n/// ```\n/// let cache = Cache::new(100)  // Max 100 items\n/// cache.insert(\"key\", \"value\")\n/// assert_eq!(cache.get(\"key\"), Some(\"value\"))\n/// ```\n/// \n/// # Performance\n/// \n/// - Insert: O(1) amortized\n/// - Get: O(1)\n/// - Memory: O(n) where n is cache size\n/// \n/// # Thread Safety\n/// \n/// This cache is thread-safe using internal locking.\n/// For better performance with multiple threads, consider\n/// using `ShardedCache` instead.\npub struct Cache<K, V> {\n    /// Maximum number of items before eviction starts\n    capacity: usize\n    \n    /// Current items in cache\n    items: HashMap<K, V>\n    \n    /// Access order for LRU eviction\n    order: LinkedList<K>\n}\n\nimpl<K, V> Cache<K, V> {\n    /// Creates a new cache with the specified capacity.\n    /// \n    /// # Arguments\n    /// \n    /// * `capacity` - Maximum items to store before eviction\n    /// \n    /// # Panics\n    /// \n    /// Panics if capacity is 0.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// let cache = Cache::new(1000)\n    /// ```\n    pub fn new(capacity: usize) -> Self {\n        assert!(capacity > 0, \"Capacity must be positive\")\n        // Implementation\n    }\n    \n    /// Inserts a key-value pair, evicting LRU item if at capacity.\n    /// \n    /// Returns the evicted value if any.\n    /// \n    /// # Complexity\n    /// \n    /// O(1) amortized time complexity.\n    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n        // Implementation with inline comments for complex parts\n        \n        // Update access order for LRU\n        self.update_access_order(&key)\n        \n        // Check capacity and evict if necessary\n        if self.items.len() >= self.capacity {\n            // Evict least recently used\n            let lru = self.order.pop_front()\n            // ...\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 2,
          "line_number": 123,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n/// Single line summary of what this does.\n/// \n/// More detailed explanation that provides context,\n/// use cases, and important information.\n/// \n/// # Arguments\n/// \n/// * `param1` - Description of first parameter\n/// * `param2` - Description of second parameter\n/// \n/// # Returns\n/// \n/// Description of return value and what it represents.\n/// \n/// # Errors\n/// \n/// * `ErrorType1` - When this error occurs\n/// * `ErrorType2` - When that error occurs\n/// \n/// # Examples\n/// \n/// ```\n/// let result = function(arg1, arg2)?\n/// assert_eq!(result, expected)\n/// ```\n/// \n/// # Safety\n/// \n/// This function is safe to call from multiple threads.\n/// \n/// # Performance\n/// \n/// Time: O(n log n)\n/// Space: O(n)\npub fn documented_function(param1: Type1, param2: Type2) -> Result<Return, Error> {\n    // Implementation\n}\n\n// Module-level documentation\n//! # Module Name\n//! \n//! This module provides functionality for...\n//! \n//! ## Overview\n//! \n//! Explain the module's purpose and main components.\n//! \n//! ## Usage\n//! \n//! ```\n//! use mylib::module\n//! \n//! let thing = module::Thing::new()\n//! thing.do_stuff()\n//! ```\n\n// Inner documentation\nimpl Struct {\n    fn method(&self) {\n        //! This method does...\n        \n        // Regular comment for implementation details\n        let temp = calculate_something()\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 3,
          "line_number": 203,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n/// Calculates the factorial of a number.\n/// \n/// # Examples\n/// \n/// ```\n/// assert_eq!(factorial(0), 1)\n/// assert_eq!(factorial(5), 120)\n/// assert_eq!(factorial(10), 3628800)\n/// ```\n/// \n/// ```should_panic\n/// factorial(-1)  // Panics on negative input\n/// ```\n/// \n/// ```no_run\n/// // Example that shouldn't be executed during tests\n/// let huge = factorial(1000000)\n/// ```\n/// \n/// ```ignore\n/// // Example that's temporarily broken\n/// let result = factorial(non_existent_var)\n/// ```\npub fn factorial(n: i32) -> i32 {\n    assert!(n >= 0, \"Factorial undefined for negative numbers\")\n    if n <= 1 { 1 } else { n * factorial(n - 1) }\n}\n\n// Run doc tests\n$ ruchy test --doc\n   Doc-tests mylib\nrunning 4 doc tests\ntest src/lib.rs - factorial (line 5) ... ok\ntest src/lib.rs - factorial (line 9) ... ok\ntest src/lib.rs - factorial (line 13) ... ok\ntest src/lib.rs - factorial (line 17) ... ignored\n\ntest result: ok. 3 passed; 0 failed; 1 ignored",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 4,
          "line_number": 256,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n/// Configuration for the application.\n/// \n/// This struct holds all configuration values needed to run\n/// the application. It can be loaded from files, environment\n/// variables, or command-line arguments.\n/// \n/// # Example Configuration File\n/// \n/// ```toml\n/// [server]\n/// host = \"localhost\"\n/// port = 8080\n/// \n/// [database]\n/// url = \"postgres://localhost/myapp\"\n/// pool_size = 20\n/// ```\n#[derive(Deserialize, Serialize, Debug)]\npub struct Config {\n    /// Server configuration\n    pub server: ServerConfig,\n    \n    /// Database configuration  \n    pub database: DatabaseConfig,\n    \n    /// Optional cache configuration\n    pub cache: Option<CacheConfig>,\n}\n\n/// Server configuration options.\n#[derive(Deserialize, Serialize, Debug)]\npub struct ServerConfig {\n    /// Host to bind to (default: \"127.0.0.1\")\n    #[serde(default = \"default_host\")]\n    pub host: String,\n    \n    /// Port to listen on (default: 8080)\n    #[serde(default = \"default_port\")]\n    pub port: u16,\n    \n    /// Number of worker threads (default: CPU cores)\n    #[serde(default = \"num_cpus\")]\n    pub workers: usize,\n}\n\n// Generate HTML documentation\n$ ruchy doc --open\nDocumenting mylib v0.1.0\n    Finished documentation\n    Opening docs/mylib/index.html",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 5,
          "line_number": 321,
          "code": "// Status: ❌ BROKEN\n\n//! # System Architecture\n//! \n//! ## Overview\n//! \n//! This application follows a layered architecture:\n//! \n//! ```text\n//! ┌─────────────────────────────────┐\n//! │          HTTP Layer             │\n//! │  (Handlers, Middleware, Routes) │\n//! └─────────────┬───────────────────┘\n//!               │\n//! ┌─────────────▼───────────────────┐\n//! │        Service Layer            │\n//! │   (Business Logic, Validation)  │\n//! └─────────────┬───────────────────┘\n//!               │\n//! ┌─────────────▼───────────────────┐\n//! │      Repository Layer           │\n//! │    (Database Access, Caching)   │\n//! └─────────────┬───────────────────┘\n//!               │\n//! ┌─────────────▼───────────────────┐\n//! │         Data Layer              │\n//! │    (PostgreSQL, Redis, S3)      │\n//! └─────────────────────────────────┘\n//! ```\n//! \n//! ## Data Flow\n//! \n//! 1. Request enters through HTTP handler\n//! 2. Handler validates input and calls service\n//! 3. Service applies business logic\n//! 4. Repository handles data persistence\n//! 5. Response flows back through layers\n//! \n//! ## Key Design Decisions\n//! \n//! ### Why Layered Architecture?\n//! \n//! - **Separation of Concerns**: Each layer has a single responsibility\n//! - **Testability**: Layers can be tested independently with mocks\n//! - **Flexibility**: Easy to swap implementations (e.g., database)\n//! \n//! ### Why Event Sourcing?\n//! \n//! - **Audit Trail**: Complete history of all changes\n//! - **Time Travel**: Can reconstruct state at any point\n//! - **Event Replay**: Easy to fix bugs in event processing\n\n/// Module containing HTTP handlers\npub mod handlers {\n    //! HTTP request handlers.\n    //! \n    //! Each handler is responsible for:\n    //! - Request validation\n    //! - Calling appropriate service\n    //! - Response formatting\n}\n\n/// Module containing business logic\npub mod services {\n    //! Business logic layer.\n    //! \n    //! Services contain all business rules and orchestrate\n    //! operations across multiple repositories.\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected item, found `{`\n --> /tmp/.tmp6BMecg/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...\n  |                                                                                ^ expected item\n  |\n  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>\n\nerror: expected item, found `{`\n --> /tmp/.tmp6BMecg/main.rs:1:103\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...\n  |                                                                                                       ^ expected item\n  |\n  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>\n\nerror: expected item, found `}`\n --> /tmp/.tmp6BMecg/main.rs:1:109\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...\n  |                                                                                                             ^ expected item\n  |\n  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>\n\nerror: aborting due to 3 previous errors\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 6,
          "line_number": 521,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n/// # Examples Section\n/// \n/// ## Basic Usage\n/// \n/// The simplest way to use this library:\n/// \n/// ```\n/// use mylib::Thing;\n/// \n/// let thing = Thing::default();\n/// thing.process()?;\n/// ```\n/// \n/// ## Advanced Usage\n/// \n/// For more control, configure manually:\n/// \n/// ```\n/// use mylib::{Thing, Config};\n/// \n/// let config = Config::builder()\n///     .timeout(5000)\n///     .retries(3)\n///     .build()?;\n/// \n/// let thing = Thing::with_config(config);\n/// ```\n/// \n/// ## Error Handling\n/// \n/// All operations return `Result`:\n/// \n/// ```\n/// match thing.risky_operation() {\n///     Ok(value) => println!(\"Success: {}\", value),\n///     Err(e) => eprintln!(\"Error: {}\", e),\n/// }\n/// ```\n/// \n/// ## Complete Example\n/// \n/// Here's a full working program:\n/// \n/// ```no_run\n/// use mylib::{Thing, Config, Error};\n/// \n/// fn main() -> Result<(), Error> {\n///     let config = Config::from_env()?;\n///     let thing = Thing::with_config(config);\n///     \n///     for item in thing.process_all()? {\n///         println!(\"Processed: {:?}\", item);\n///     }\n///     \n///     Ok(())\n/// }\n/// ```",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 7,
          "line_number": 593,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Generate interactive documentation site\n$ ruchy doc --format html --output docs/\n\n// With search, examples, and playground\n$ ruchy doc --features search,playground,examples\n\n// Serve documentation locally\n$ ruchy doc --serve --port 8080\nServing documentation at http://localhost:8080",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 8,
          "line_number": 615,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n/// Interactive API endpoint documentation\n/// \n/// <playground>\n/// {\n///   \"endpoint\": \"/api/users\",\n///   \"method\": \"POST\",\n///   \"body\": {\n///     \"name\": \"Alice\",\n///     \"email\": \"alice@example.com\"\n///   }\n/// }\n/// </playground>\n#[post(\"/api/users\")]\npub async fun create_user(user: Json<User>) -> Result<Json<User>, Error> {\n    // Implementation\n}\n\n// Generates interactive API tester in docs",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 9,
          "line_number": 648,
          "code": "// Status: ❌ BROKEN\n\n// Generate documentation from code\n#[doc_gen]\nimpl ConfigBuilder {\n    // Automatically documents builder pattern\n}\n\n// Generate diagrams from code\n#[diagram(sequence)]\nasync fun request_flow() {\n    client.send_request()\n    server.validate()\n    server.process()\n    server.respond()\n}\n\n// Generates:\n// Client -> Server: send_request()\n// Server -> Server: validate()\n// Server -> Server: process()\n// Server -> Client: respond()\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0670]: `async fn` is not permitted in Rust 2015\n --> /tmp/.tmp3wlN1H/main.rs:1:37\n  |\n1 | use std :: collections :: HashMap ; async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; ...\n  |                                     ^^^^^ to use `async fn`, switch to Rust 2018 or later\n  |\n  = help: pass `--edition 2024` to `rustc`\n  = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n\nerror[E0425]: cannot find value `client` in this scope\n --> /tmp/.tmp3wlN1H/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; ...\n  |                                                                  ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `server` in this scope\n --> /tmp/.tmp3wlN1H/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; ...\n  |                                                                                             ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `server` in this scope\n --> /tmp/.tmp3wlN1H/main.rs:1:116\n  |\n1 | ...{ client . send_request () ; server . validate () ; server . process () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `server` in this scope\n --> /tmp/.tmp3wlN1H/main.rs:1:138\n  |\n1 | ...t () ; server . validate () ; server . process () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `ConfigBuilder` in this scope\n --> /tmp/.tmp3wlN1H/main.rs:1:180\n  |\n1 | ... () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp3wlN1H/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; async fn request_flow () { { client . send_request () ; server . validate () ; server . process () ; ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp3wlN1H/main.rs:1:198\n  |\n1 | ... respond () } } fn main () { impl ConfigBuilder { } ; }\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror: aborting due to 6 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425, E0670.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 10,
          "line_number": 683,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Check documentation quality\n$ ruchy doc-lint\nChecking documentation...\n\n⚠️  Missing documentation: src/internal.rs:15 `fun process()`\n⚠️  Broken link: src/lib.rs:42 `[Config](../config.html)`\n⚠️  Outdated example: src/api.rs:88 (code changed)\n❌  Missing examples: src/client.rs `struct Client`\n\nDocumentation score: 87/100\n\n// Enforce in CI\n$ ruchy doc-lint --min-score 90",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch06-00-file-operations": {
      "chapter": "ch06-00-file-operations",
      "total_examples": 10,
      "working_examples": 0,
      "failing_examples": 10,
      "examples": [
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\n// File: desktop_organizer.ruchy\n// Organizes files by type into folders\n\nprintln(\"=== Desktop Organizer ===\")\n\n// Define organization rules\nlet file_categories = {\n    \"Documents\": [\".pdf\", \".doc\", \".docx\", \".txt\"],\n    \"Images\": [\".jpg\", \".jpeg\", \".png\", \".gif\", \".svg\"],\n    \"Videos\": [\".mp4\", \".avi\", \".mov\", \".mkv\"],\n    \"Code\": [\".py\", \".js\", \".rs\", \".ruchy\", \".cpp\"],\n    \"Data\": [\".csv\", \".json\", \".xml\", \".xlsx\"]\n}\n\nlet source_dir = \"~/Desktop\"\nlet files = list_files(source_dir)\n\nprintln(\"Found \" + files.len().to_s() + \" files to organize\")\n\n// Organize files\nfor file in files {\n    let extension = get_extension(file).lower()\n    \n    for category, extensions in file_categories.items() {\n        if extensions.contains(extension) {\n            let target_dir = join_path(source_dir, category)\n            \n            // Create category folder if needed\n            if !dir_exists(target_dir) {\n                create_dir(target_dir)\n                println(\"Created folder: \" + category)\n            }\n            \n            // Move file to appropriate folder\n            let source = join_path(source_dir, file)\n            let destination = join_path(target_dir, file)\n            \n            move_file(source, destination)\n            println(\"  Moved \" + file + \" -> \" + category + \"/\")\n            break\n        }\n    }\n}\n\nprintln(\"✅ Desktop organized!\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmpX3pZzi/main.rs:1:148\n  |\n1 | ... = { Documents : vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"] , Images : vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"] , Videos : vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"] , Code : vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"] , Data : vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"] , } ; ...\n  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\" . to_string ()) ; let mut file_categories = { SomeStruct { Documents : vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"] , Images : vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"] , Videos : vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"] , Code : vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"] , Data : vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"] , } } ; let mut source_dir = \"~/Desktop\" ; let mut files = list_files (source_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Found \" , files . len () . to_s ()) , \" files to organize\")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } } } } } } ; println ! (\"✅ Desktop organized!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |                                                                                                                                                    ++++++++++++                                                                                                                                                                                                                                                                                                  +\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpX3pZzi/main.rs:1:104\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\" . to_string ()) ; let mut file_cat...\n  |                                                                                                        ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpX3pZzi/main.rs:1:106\n  |\n1 | ...main () { let result = { println ! (\"=== Desktop Organizer ===\" . to_string ()) ; let mut file_categories = { Documents : vec ! [\".pdf...\n  |                                        ---------------------------   ^^^^^^^^^^^^ argument never used\n  |                                        |\n  |                                        formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpX3pZzi/main.rs:1:1327\n  |\n1 | ...break } } } } } } } } } ; println ! (\"✅ Desktop organized!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any)...\n  |                                                                 ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpX3pZzi/main.rs:1:1329\n  |\n1 | ... break } } } } } } } } } ; println ! (\"✅ Desktop organized!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any...\n  |                                          -----------------------   ^^^^^^^^^^^^ argument never used\n  |                                          |\n  |                                          formatting specifier missing\n\nerror[E0425]: cannot find function `create_dir` in this scope\n --> /tmp/.tmpX3pZzi/main.rs:1:903\n  |\n1 | ... , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Created folder: \" , ...\n  |                                                      ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::create_dir;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpX3pZzi/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\" . to_string ()) ; let mut file_cat...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpX3pZzi/main.rs:1:656\n  |\n1 | ... { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\" . to_string ()) ; let mut file_categories = { Documents : vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"] , Images : vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"] , Videos : vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"] , Code : vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"] , Data : vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"] , } ; let mut source_dir = \"~/Desktop\" ; let mut files = list_files (source_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Found \" , files . len () . to_s ()) , \" files to organize\")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } } } } } } ; println ! (\"✅ Desktop organized!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\" . to_string ()) ; let mut file_categories = { Documents : vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"] , Images : vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"] , Videos : vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"] , Code : vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"] , Data : vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"] , } ; let mut source_dir = \"~/Desktop\" ; let mut files = list_files (source_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Found \" , files . len () . to_s ()) , \" files to organize\")) ; for file in files { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } } } } } ; println ! (\"✅ Desktop organized!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpX3pZzi/main.rs:1:770\n  |\n1 | ... { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\" . to_string ()) ; let mut file_categories = { Documents : vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"] , Images : vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"] , Videos : vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"] , Code : vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"] , Data : vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"] , } ; let mut source_dir = \"~/Desktop\" ; let mut files = list_files (source_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Found \" , files . len () . to_s ()) , \" files to organize\")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } } } } } } ; println ! (\"✅ Desktop organized!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\" . to_string ()) ; let mut file_categories = { Documents : vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"] , Images : vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"] , Videos : vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"] , Code : vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"] , Data : vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"] , } ; let mut source_dir = \"~/Desktop\" ; let mut files = list_files (source_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Found \" , files . len () . to_s ()) , \" files to organize\")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } } } } } ; println ! (\"✅ Desktop organized!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpX3pZzi/main.rs:1:811\n  |\n1 | ... { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\" . to_string ()) ; let mut file_categories = { Documents : vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"] , Images : vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"] , Videos : vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"] , Code : vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"] , Data : vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"] , } ; let mut source_dir = \"~/Desktop\" ; let mut files = list_files (source_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Found \" , files . len () . to_s ()) , \" files to organize\")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } } } } } } ; println ! (\"✅ Desktop organized!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\" . to_string ()) ; let mut file_categories = { Documents : vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"] , Images : vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"] , Videos : vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"] , Code : vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"] , Data : vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"] , } ; let mut source_dir = \"~/Desktop\" ; let mut files = list_files (source_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Found \" , files . len () . to_s ()) , \" files to organize\")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . items () { { if extensions . contains (extension) { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } } } } } ; println ! (\"✅ Desktop organized!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpX3pZzi/main.rs:1:106\n  |\n1 | ...sult = { println ! (\"=== Desktop Organizer ===\" . to_string ()) ; let mut file_categories = { Documents : vec ! [\".pdf\" , \".doc\" , \".d...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `list_files` in this scope\n --> /tmp/.tmpX3pZzi/main.rs:1:490\n  |\n1 | ...et mut source_dir = \"~/Desktop\" ; let mut files = list_files (source_dir) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"F...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `get_extension` in this scope\n --> /tmp/.tmpX3pZzi/main.rs:1:676\n  |\n1 | ...ze\")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . ite...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpX3pZzi/main.rs:1:832\n  |\n1 | ...ons . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (t...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `dir_exists` in this scope\n --> /tmp/.tmpX3pZzi/main.rs:1:875\n  |\n1 | ..._dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{}\" , format ! (\"{...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpX3pZzi/main.rs:1:1021\n  |\n1 | ...ted folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpX3pZzi/main.rs:1:1075\n  |\n1 | ..._path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" ,...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `move_file` in this scope\n --> /tmp/.tmpX3pZzi/main.rs:1:1107\n  |\n1 | ...mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpX3pZzi/main.rs:1:1329\n  |\n1 | ...} } } } } } ; println ! (\"✅ Desktop organized!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_...\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 15 previous errors; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 2,
          "line_number": 93,
          "code": "// Status: ❌ BROKEN\n\n// Current directory operations\nlet current_dir = get_current_dir()\nset_current_dir(\"/home/user/projects\")\n\n// Path operations\nlet full_path = absolute_path(\"data.txt\")\nlet parent = parent_dir(full_path)\nlet filename = file_name(full_path)\nlet extension = file_extension(full_path)\n\n// Path joining and normalization\nlet project_path = join_path(home_dir(), \"projects\", \"my_app\")\nlet clean_path = normalize_path(\".././data//file.txt\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpGbSh92/main.rs:1:541\n  |\n1 | ...(\".././data//file.txt\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]: cannot find function `set_current_dir` in this scope\n --> /tmp/.tmpGbSh92/main.rs:1:108\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir (\"/home/user/p...\n  |                                                                                                            ^^^^^^^^^^^^^^^\n  |\nhelp: a local variable with a similar name exists\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir (\"/home/user/projects\" . to_string ()) ; let mut full_path = absolute_path (\"data.txt\" . to_string ()) ; let mut parent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut project_path = join_path (home_dir () , \"projects\" . to_string () , \"my_app\" . to_string ()) ; let mut clean_path = normalize_path (\".././data//file.txt\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; current_dir (\"/home/user/projects\" . to_string ()) ; let mut full_path = absolute_path (\"data.txt\" . to_string ()) ; let mut parent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut project_path = join_path (home_dir () , \"projects\" . to_string () , \"my_app\" . to_string ()) ; let mut clean_path = normalize_path (\".././data//file.txt\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\nhelp: consider importing this function\n  |\n1 + use std::env::set_current_dir;\n  |\n\nerror[E0425]: cannot find function `home_dir` in this scope\n --> /tmp/.tmpGbSh92/main.rs:1:397\n  |\n1 | ...on (full_path) ; let mut project_path = join_path (home_dir () , \"projects\" . to_string () , \"my_app\" . to_string ()) ; let mut clean_...\n  |                                                       ^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::env::home_dir;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpGbSh92/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir (\"/home/user/p...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `get_current_dir` in this scope\n --> /tmp/.tmpGbSh92/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir (\"/home/user/p...\n  |                                                                                       ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `absolute_path` in this scope\n --> /tmp/.tmpGbSh92/main.rs:1:185\n  |\n1 | ...projects\" . to_string ()) ; let mut full_path = absolute_path (\"data.txt\" . to_string ()) ; let mut parent = parent_dir (full_path) ; ...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `parent_dir` in this scope\n --> /tmp/.tmpGbSh92/main.rs:1:246\n  |\n1 | ...tring ()) ; let mut parent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (f...\n  |                                 ^^^^^^^^^^ help: a local variable with a similar name exists: `current_dir`\n\nerror[E0425]: cannot find function `file_name` in this scope\n --> /tmp/.tmpGbSh92/main.rs:1:290\n  |\n1 | ...ent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut pro...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_extension` in this scope\n --> /tmp/.tmpGbSh92/main.rs:1:334\n  |\n1 | ...e = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut project_path = join_path (home_dir () , \"projects...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpGbSh92/main.rs:1:386\n  |\n1 | ...le_extension (full_path) ; let mut project_path = join_path (home_dir () , \"projects\" . to_string () , \"my_app\" . to_string ()) ; let ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 9 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 3,
          "line_number": 122,
          "code": "// Status: ❌ BROKEN\n\n// Check file properties\nlet exists = file_exists(\"config.json\")\nlet size = file_size(\"data.csv\")  // In bytes\nlet modified = file_modified_time(\"log.txt\")\nlet is_read_only = is_readonly(\"system.conf\")\n\n// File type checking\nlet is_file = is_file(path)\nlet is_dir = is_directory(path)\nlet is_symlink = is_symbolic_link(path)\n\n// Permissions (Unix-like systems)\nlet can_read = is_readable(path)\nlet can_write = is_writable(path)\nlet can_execute = is_executable(path)\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpXBv1G7/main.rs:1:562\n  |\n1 | ...mut can_execute = is_executable (path) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0423]: expected value, found built-in attribute `path`\n --> /tmp/.tmpXBv1G7/main.rs:1:344\n  |\n1 | ...\"system.conf\" . to_string ()) ; let mut is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_symb...\n  |                                                               ^^^^ not a value\n\nerror[E0423]: expected value, found built-in attribute `path`\n --> /tmp/.tmpXBv1G7/main.rs:1:383\n  |\n1 | ... is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read = i...\n  |                                                               ^^^^ not a value\n\nerror[E0423]: expected value, found built-in attribute `path`\n --> /tmp/.tmpXBv1G7/main.rs:1:430\n  |\n1 | ..._directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = is_writ...\n  |                                                               ^^^^ not a value\n\nerror[E0423]: expected value, found built-in attribute `path`\n --> /tmp/.tmpXBv1G7/main.rs:1:470\n  |\n1 | ... is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = is_e...\n  |                                                               ^^^^ not a value\n\nerror[E0423]: expected value, found built-in attribute `path`\n --> /tmp/.tmpXBv1G7/main.rs:1:511\n  |\n1 | ...ad = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = is_executable (path) } ; if let Some (s) = (&...\n  |                                                               ^^^^ not a value\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpXBv1G7/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut exists = file_exists (\"config.json\" . to_string ()) ; let mut siz...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpXBv1G7/main.rs:1:82\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut exists = file_exists (\"config.json\" . to_string ()) ; let mut siz...\n  |                                                                                  ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_size` in this scope\n --> /tmp/.tmpXBv1G7/main.rs:1:142\n  |\n1 | ...s (\"config.json\" . to_string ()) ; let mut size = file_size (\"data.csv\" . to_string ()) ; let mut modified = file_modified_time (\"log....\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_modified_time` in this scope\n --> /tmp/.tmpXBv1G7/main.rs:1:201\n  |\n1 | ...ata.csv\" . to_string ()) ; let mut modified = file_modified_time (\"log.txt\" . to_string ()) ; let mut is_read_only = is_readonly (\"sys...\n  |                                                  ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_readonly` in this scope\n --> /tmp/.tmpXBv1G7/main.rs:1:272\n  |\n1 | ...og.txt\" . to_string ()) ; let mut is_read_only = is_readonly (\"system.conf\" . to_string ()) ; let mut is_file = is_file (path) ; let m...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_file` in this scope\n --> /tmp/.tmpXBv1G7/main.rs:1:335\n  |\n1 | ...(\"system.conf\" . to_string ()) ; let mut is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_sym...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_directory` in this scope\n --> /tmp/.tmpXBv1G7/main.rs:1:369\n  |\n1 | ... mut is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_symbolic_link` in this scope\n --> /tmp/.tmpXBv1G7/main.rs:1:412\n  |\n1 | ...r = is_directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = i...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_readable` in this scope\n --> /tmp/.tmpXBv1G7/main.rs:1:457\n  |\n1 | ...k = is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = i...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_writable` in this scope\n --> /tmp/.tmpXBv1G7/main.rs:1:498\n  |\n1 | ..._read = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = is_executable (path) } ; if let Some (s) =...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 15 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 4,
          "line_number": 153,
          "code": "// Status: ❌ BROKEN\n\n// Create and remove directories\ncreate_dir(\"new_folder\")\ncreate_dir_all(\"path/to/nested/folder\")  // Creates parent dirs\nremove_dir(\"empty_folder\")\nremove_dir_all(\"folder_with_contents\")  // Recursive delete\n\n// List directory contents\nlet all_items = list_dir(\".\")\nlet files_only = list_files(\".\")\nlet dirs_only = list_directories(\".\")\n\n// Recursive directory walking\nfun walk_directory(dir) {\n    let items = list_dir(dir)\n    for item in items {\n        let path = join_path(dir, item)\n        if is_directory(path) {\n            walk_directory(path)  // Recurse into subdirectory\n        } else {\n            process_file(path)\n        }\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `create_dir` in this scope\n --> /tmp/.tmpnrhmRB/main.rs:1:406\n  |\n1 | ... process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" ....\n  |                                                      ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::create_dir;\n  |\n\nerror[E0425]: cannot find function `create_dir_all` in this scope\n --> /tmp/.tmpnrhmRB/main.rs:1:449\n  |\n1 | ...() { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" ....\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::create_dir_all;\n  |\n\nerror[E0425]: cannot find function `remove_dir` in this scope\n --> /tmp/.tmpnrhmRB/main.rs:1:507\n  |\n1 | ...ir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" ...\n  |                                                      ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_dir;\n  |\n\nerror[E0425]: cannot find function `remove_dir_all` in this scope\n --> /tmp/.tmpnrhmRB/main.rs:1:552\n  |\n1 | ... ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir ...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_dir_all;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpnrhmRB/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpnrhmRB/main.rs:1:202\n  |\n1 | ... { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } ...\n  |       ^^                                                                                                                                                                                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n1 + use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpnrhmRB/main.rs:1:255\n  |\n1 | ... { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } ...\n  |       ^^                                                                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n1 + use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpnrhmRB/main.rs:1:320\n  |\n1 | ...h = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main...\n  |                                                          ^^                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n1 + use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { walk_directory (path) } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpnrhmRB/main.rs:1:355\n  |\n1 | ..._directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . t...\n  |                                                           ^^                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n1 + use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { process_file (path) } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n  |\n\nerror[E0425]: cannot find function `list_dir` in this scope\n --> /tmp/.tmpnrhmRB/main.rs:1:218\n  |\n1 | ...: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpnrhmRB/main.rs:1:270\n  |\n1 | ...st_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else {...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_directory` in this scope\n --> /tmp/.tmpnrhmRB/main.rs:1:298\n  |\n1 | ...ems { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } ...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: cannot add `()` to `()`\n --> /tmp/.tmpnrhmRB/main.rs:1:338\n  |\n1 | ... , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (...\n  |                                          --------------  ^^^^ no implementation for `() + ()`\n  |                                          |\n  |                                          required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `()`\nnote: required by a bound in `walk_directory`\n --> /tmp/.tmpnrhmRB/main.rs:1:61\n  |\n1 | ...ap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt ...\n  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `walk_directory`\n\nerror[E0277]: cannot multiply `()` by `()`\n --> /tmp/.tmpnrhmRB/main.rs:1:338\n  |\n1 | ... , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (...\n  |                                          --------------  ^^^^ no implementation for `() * ()`\n  |                                          |\n  |                                          required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `()`\nnote: required by a bound in `walk_directory`\n --> /tmp/.tmpnrhmRB/main.rs:1:96\n  |\n1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T {...\n  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `walk_directory`\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpnrhmRB/main.rs:1:338\n  |\n1 | ... if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folde...\n  |                                --------------  ^^^^ the trait `std::fmt::Display` is not implemented for `()`\n  |                                |\n  |                                required by a bound introduced by this call\n  |\nnote: required by a bound in `walk_directory`\n --> /tmp/.tmpnrhmRB/main.rs:1:131\n  |\n1 | ...std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (di...\n  |                                       ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `walk_directory`\n\nerror[E0425]: cannot find function `process_file` in this scope\n --> /tmp/.tmpnrhmRB/main.rs:1:357\n  |\n1 | ...ry (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . to_string...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpnrhmRB/main.rs:1:235\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } ...\n  |       -                                                                                                                                            -                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |       |                                                                                                                                            |\n  |       expected this type parameter                                                                                                                 expected `T` because of return type\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: the caller chooses a type for `T` which can be different from `()`\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn walk_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } /* `T` value */ } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                   +++++++++++++++\n\nerror[E0425]: cannot find function `list_dir` in this scope\n --> /tmp/.tmpnrhmRB/main.rs:1:629\n  |\n1 | ...th_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `list_files` in this scope\n --> /tmp/.tmpnrhmRB/main.rs:1:682\n  |\n1 | ...t_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_str...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `list_directories` in this scope\n --> /tmp/.tmpnrhmRB/main.rs:1:736\n  |\n1 | ...les (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 15 previous errors; 5 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 5,
          "line_number": 193,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: smart_backup.ruchy\n// Creates timestamped backups of important files\n\nprintln(\"=== Smart Backup System ===\")\n\nlet backup_config = {\n    \"documents\": [\"~/Documents\", \"*.doc\", \"*.pdf\", \"*.txt\"],\n    \"code\": [\"~/Projects\", \"*.py\", \"*.js\", \"*.rs\"],\n    \"config\": [\"~/.config\", \"*.conf\", \"*.json\", \"*.yaml\"]\n}\n\nlet backup_root = \"~/Backups\"\nlet timestamp = current_datetime().format(\"%Y%m%d_%H%M%S\")\nlet backup_dir = join_path(backup_root, \"backup_\" + timestamp)\n\ncreate_dir_all(backup_dir)\nprintln(\"Creating backup at: \" + backup_dir)\n\nlet total_files = 0\nlet total_size = 0\n\nfor category, config in backup_config.items() {\n    let source_dir = expand_home(config[0])\n    let patterns = config[1..]\n    \n    let category_dir = join_path(backup_dir, category)\n    create_dir(category_dir)\n    \n    println(\"\\n📁 Backing up \" + category + \"...\")\n    \n    for pattern in patterns {\n        let files = glob(join_path(source_dir, pattern))\n        \n        for file in files {\n            let size = file_size(file)\n            let relative_path = relative_to(file, source_dir)\n            let backup_path = join_path(category_dir, relative_path)\n            \n            // Create parent directories\n            let parent = parent_dir(backup_path)\n            if !dir_exists(parent) {\n                create_dir_all(parent)\n            }\n            \n            // Copy file to backup\n            copy_file(file, backup_path)\n            total_files += 1\n            total_size += size\n            \n            println(\"  ✓ \" + relative_path + \" (\" + format_size(size) + \")\")\n        }\n    }\n}\n\nprintln(\"\\n✅ Backup complete!\")\nprintln(\"Files backed up: \" + total_files.to_s())\nprintln(\"Total size: \" + format_size(total_size))\nprintln(\"Location: \" + backup_dir)\n\n// Create backup summary\nlet summary = \"Backup Summary\\n==============\\nDate: \" + timestamp + \"\\nFiles: \" + total_files.to_s() + \"\\nSize: \" + format_size(total_size) + \"\\nCategories: \" + backup_config.keys().join(\", \") + \"\\n\"\n\nwrite_file(join_path(backup_dir, \"summary.txt\"), summary)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 6,
          "line_number": 269,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// File: find_duplicates.ruchy\n// Finds duplicate files based on content hash\n\nprintln(\"=== Duplicate File Finder ===\")\n\nlet search_dir = input(\"Enter directory to search: \")\nlet min_size = input(\"Minimum file size (bytes, 0 for all): \").to_i()\n\nprintln(\"\\nScanning \" + search_dir + \"...\")\n\n// Build file hash map\nlet file_hashes = {}\nlet duplicates = []\n\nfun hash_file(path) {\n    let content = read_bytes(path)\n    return sha256(content)\n}\n\nfun scan_directory(dir) {\n    let items = list_dir(dir)\n    \n    for item in items {\n        let path = join_path(dir, item)\n        \n        if is_directory(path) {\n            scan_directory(path)  // Recurse\n        } else if is_file(path) {\n            let size = file_size(path)\n            \n            if size >= min_size {\n                let hash = hash_file(path)\n                \n                if file_hashes.has_key(hash) {\n                    // Found duplicate\n                    duplicates.push({\n                        \"original\": file_hashes[hash],\n                        \"duplicate\": path,\n                        \"size\": size,\n                        \"hash\": hash\n                    })\n                } else {\n                    file_hashes[hash] = path\n                }\n            }\n        }\n    }\n}\n\nscan_directory(search_dir)\n\nif duplicates.is_empty() {\n    println(\"\\n✅ No duplicate files found!\")\n} else {\n    println(\"\\n⚠️  Found \" + duplicates.len().to_s() + \" duplicate files:\")\n    \n    let total_wasted = 0\n    \n    for dup in duplicates {\n        println(\"\\nOriginal: \" + dup.original)\n        println(\"Duplicate: \" + dup.duplicate)\n        println(\"Size: \" + format_size(dup.size))\n        total_wasted += dup.size\n    }\n    \n    println(\"\\nTotal space wasted: \" + format_size(total_wasted))\n    \n    let action = input(\"\\nDelete duplicates? (y/n): \")\n    if action.lower() == \"y\" {\n        for dup in duplicates {\n            remove_file(dup.duplicate)\n            println(\"Deleted: \" + dup.duplicate)\n        }\n        println(\"\\n✅ Freed \" + format_size(total_wasted) + \" of space!\")\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmp4ewgLG/main.rs:1:749\n  |\n1 | ...h) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes...\n  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ SomeStruct { original : file_hashes [hash] , duplicate : path , size : size , hash : hash , } }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++                                                                                    +\n\nerror: expected `,`, found `.`\n --> /tmp/.tmp4ewgLG/main.rs:1:958\n  |\n1 | ...} } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmp4ewgLG/main.rs:1:960\n  |\n1 | ...} } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to se...\n  |                                      -------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                      |\n  |                                      formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmp4ewgLG/main.rs:1:1407\n  |\n1 | ... is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! ...\n  |                                                                 ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmp4ewgLG/main.rs:1:1409\n  |\n1 | ...ates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , for...\n  |                                      --------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                      |\n  |                                      formatting specifier missing\n\nerror[E0425]: cannot find value `min_size` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:649\n  |\n1 | ...th) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { du...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `file_hashes` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:697\n  |\n1 | ... min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] ,...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `duplicates` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:730\n  |\n1 | ...file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size ...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `file_hashes` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:846\n  |\n1 | ...th , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `remove_file` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:2111\n  |\n1 | ... . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , du...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_file;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp4ewgLG/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4ewgLG/main.rs:1:198\n  |\n1 | ...Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: o...\n  |                                      ^^                                                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { let content = read_bytes (path) ; return sha256 (content) } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4ewgLG/main.rs:1:431\n  |\n1 | ... { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4ewgLG/main.rs:1:484\n  |\n1 | ... { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4ewgLG/main.rs:1:549\n  |\n1 | ...h = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size ...\n  |                                                          ^^                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { scan_directory (path) } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4ewgLG/main.rs:1:604\n  |\n1 | ... { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4ewgLG/main.rs:1:660\n  |\n1 | ... { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } ...\n  |       ^^                                                                                                                                                                                                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4ewgLG/main.rs:1:728\n  |\n1 | ..._key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { fi...\n  |                  ^^                                                                                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4ewgLG/main.rs:1:844\n  |\n1 | ... : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (...\n  |                                                        ^^                         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { file_hashes [hash] = path } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4ewgLG/main.rs:1:1362\n  |\n1 | ...ir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ...\n  |                                        ^^                                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nerror[E0425]: cannot find function `read_bytes` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:216\n  |\n1 | ...bug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `sha256` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:243\n  |\n1 | ...-> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + ...\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `list_dir` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:447\n  |\n1 | ...: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:499\n  |\n1 | ...st_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else {...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_directory` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:527\n  |\n1 | ...ems { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let ...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: cannot add `()` to `()`\n --> /tmp/.tmp4ewgLG/main.rs:1:567\n  |\n1 | ... , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >...\n  |                                          --------------  ^^^^ no implementation for `() + ()`\n  |                                          |\n  |                                          required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `()`\nnote: required by a bound in `scan_directory`\n --> /tmp/.tmp4ewgLG/main.rs:1:290\n  |\n1 | ... } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt ...\n  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `scan_directory`\n\nerror[E0277]: cannot multiply `()` by `()`\n --> /tmp/.tmp4ewgLG/main.rs:1:567\n  |\n1 | ... , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >...\n  |                                          --------------  ^^^^ no implementation for `() * ()`\n  |                                          |\n  |                                          required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `()`\nnote: required by a bound in `scan_directory`\n --> /tmp/.tmp4ewgLG/main.rs:1:325\n  |\n1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T {...\n  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `scan_directory`\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmp4ewgLG/main.rs:1:567\n  |\n1 | ... if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size...\n  |                                --------------  ^^^^ the trait `std::fmt::Display` is not implemented for `()`\n  |                                |\n  |                                required by a bound introduced by this call\n  |\nnote: required by a bound in `scan_directory`\n --> /tmp/.tmp4ewgLG/main.rs:1:360\n  |\n1 | ...std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (di...\n  |                                       ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `scan_directory`\n\nerror[E0425]: cannot find function `is_file` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:587\n  |\n1 | ...ory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let ha...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_size` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:619\n  |\n1 | ...th) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_h...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp4ewgLG/main.rs:1:464\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } } ...\n  |       -                                                                                                                                            -                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |       |                                                                                                                                            |\n  |       expected this type parameter                                                                                                                 expected `T` because of return type\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: the caller chooses a type for `T` which can be different from `()`\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn hash_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (dir : T) -> T { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ original : file_hashes [hash] , duplicate : path , size : size , hash : hash , }) } } else { { file_hashes [hash] = path } } } } } } } } } } } } /* `T` value */ } } } fn main () { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +++++++++++++++\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:960\n  |\n1 | ...() { println ! (\"=== Duplicate File Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_strin...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:997\n  |\n1 | ... Finder ===\" . to_string ()) ; let mut search_dir = input (\"Enter directory to search: \" . to_string ()) ; let mut min_size = input (\"...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:1071\n  |\n1 | ...y to search: \" . to_string ()) ; let mut min_size = input (\"Minimum file size (bytes, 0 for all): \" . to_string ()) . to_i () ; printl...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:1409\n  |\n1 | ... { { println ! (\"\\n✅ No duplicate files found!\" . to_string ()) } } else { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\...\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_s` found for type `usize` in the current scope\n --> /tmp/.tmp4ewgLG/main.rs:1:1538\n  |\n1 | ...}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplica...\n  |                                                       ^^^^ method not found in `usize`\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:1823\n  |\n1 | ... println ! (\"{}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{}\" , forma...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:1949\n  |\n1 | ... , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \"...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:1997\n  |\n1 | ...\" , format_size (total_wasted))) ; let mut action = input (\"\\nDelete duplicates? (y/n): \" . to_string ()) ; if action . lower () == \"y...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmp4ewgLG/main.rs:1:2289\n  |\n1 | ...at ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |                                                      ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 30 previous errors; 10 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 7,
          "line_number": 360,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// File: log_rotator.ruchy\n// Manages log files with size-based rotation\n\nprintln(\"=== Log Rotation System ===\")\n\nlet log_config = {\n    \"max_size\": 10 * 1024 * 1024,  // 10MB\n    \"max_backups\": 5,\n    \"compress\": true\n}\n\nlet log_dir = \"/var/log/myapp\"\nlet log_files = glob(join_path(log_dir, \"*.log\"))\n\nfor log_file in log_files {\n    let size = file_size(log_file)\n    \n    if size > log_config.max_size {\n        println(\"Rotating \" + log_file + \" (\" + format_size(size) + \")...\")\n        \n        // Shift existing backups\n        for i in range(log_config.max_backups - 1, 0, -1) {\n            let old_backup = log_file + \".\" + i.to_s()\n            let new_backup = log_file + \".\" + (i + 1).to_s()\n            \n            if file_exists(old_backup) {\n                if i == log_config.max_backups - 1 {\n                    // Delete oldest backup\n                    remove_file(old_backup)\n                } else {\n                    // Rename to next number\n                    rename_file(old_backup, new_backup)\n                }\n            }\n        }\n        \n        // Move current log to .1\n        let backup_path = log_file + \".1\"\n        rename_file(log_file, backup_path)\n        \n        // Compress if configured\n        if log_config.compress {\n            compress_file(backup_path, backup_path + \".gz\")\n            remove_file(backup_path)\n            println(\"  Compressed to \" + backup_path + \".gz\")\n        }\n        \n        // Create new empty log file\n        write_file(log_file, \"\")\n        println(\"  Created new \" + log_file)\n    }\n}\n\nprintln(\"\\n✅ Log rotation complete!\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmpQYDeWZ/main.rs:1:145\n  |\n1 | ...)) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = \"/var/...\n  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\" . to_string ()) ; let mut log_config = { SomeStruct { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } } ; let mut log_dir = \"/var/log/myapp\" ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |                                                                                                                                                 ++++++++++++                                                                                   +\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpQYDeWZ/main.rs:1:106\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\" . to_string ()) ; let mut log_co...\n  |                                                                                                          ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpQYDeWZ/main.rs:1:108\n  |\n1 | ...ain () { let result = { println ! (\"=== Log Rotation System ===\" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 *...\n  |                                       -----------------------------   ^^^^^^^^^^^^ argument never used\n  |                                       |\n  |                                       formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpQYDeWZ/main.rs:1:1474\n  |\n1 | ...e)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any)...\n  |                                                                 ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpQYDeWZ/main.rs:1:1476\n  |\n1 | ..._file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: ...\n  |                                       -----------------------------   ^^^^^^^^^^^^ argument never used\n  |                                       |\n  |                                       formatting specifier missing\n\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmpQYDeWZ/main.rs:1:592\n  |\n1 | ... , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = for...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nerror[E0425]: cannot find function `remove_file` in this scope\n --> /tmp/.tmpQYDeWZ/main.rs:1:879\n  |\n1 | ... { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } }...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_file;\n  |\n\nerror[E0425]: cannot find function `remove_file` in this scope\n --> /tmp/.tmpQYDeWZ/main.rs:1:1173\n  |\n1 | ...ath , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_file;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpQYDeWZ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\" . to_string ()) ; let mut log_co...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpQYDeWZ/main.rs:1:368\n  |\n1 | ... { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = \"/var/log/myapp\" ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = \"/var/log/myapp\" ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } ; println ! (\"\\n✅ Log rotation complete!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpQYDeWZ/main.rs:1:650\n  |\n1 | ... { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                          ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = \"/var/log/myapp\" ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = \"/var/log/myapp\" ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpQYDeWZ/main.rs:1:833\n  |\n1 | ... { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } }...\n  |       ^^                                                                                                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = \"/var/log/myapp\" ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = \"/var/log/myapp\" ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpQYDeWZ/main.rs:1:877\n  |\n1 | ...ackup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } }...\n  |                                                         ^^                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = \"/var/log/myapp\" ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = \"/var/log/myapp\" ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { remove_file (old_backup) } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpQYDeWZ/main.rs:1:915\n  |\n1 | ... 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (...\n  |                                                  ^^                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = \"/var/log/myapp\" ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_backups : 5i32 , compress : true , } ; let mut log_dir = \"/var/log/myapp\" ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpQYDeWZ/main.rs:1:108\n  |\n1 | ...lt = { println ! (\"=== Log Rotation System ===\" . to_string ()) ; let mut log_config = { max_size : 10i32 * 1024i32 * 1024i32 , max_ba...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpQYDeWZ/main.rs:1:292\n  |\n1 | ...ir = \"/var/log/myapp\" ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `glob` in this scope\n --> /tmp/.tmpQYDeWZ/main.rs:1:286\n  |\n1 | ...mut log_dir = \"/var/log/myapp\" ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files {...\n  |                                                         ^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_size` in this scope\n --> /tmp/.tmpQYDeWZ/main.rs:1:383\n  |\n1 | ...())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{}\" , format ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpQYDeWZ/main.rs:1:551\n  |\n1 | ...at ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i3...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpQYDeWZ/main.rs:1:793\n  |\n1 | ...p = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpQYDeWZ/main.rs:1:806\n  |\n1 | ...}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `rename_file` in this scope\n --> /tmp/.tmpQYDeWZ/main.rs:1:917\n  |\n1 | ...- 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `rename_file` in this scope\n --> /tmp/.tmpQYDeWZ/main.rs:1:1033\n  |\n1 | ...p_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (ba...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `compress_file` in this scope\n --> /tmp/.tmpQYDeWZ/main.rs:1:1101\n  |\n1 | ...e , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (b...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpQYDeWZ/main.rs:1:1307\n  |\n1 | ...\"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"  ...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpQYDeWZ/main.rs:1:1476\n  |\n1 | ...} } } ; println ! (\"\\n✅ Log rotation complete!\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_...\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 20 previous errors; 6 warnings emitted\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 8,
          "line_number": 429,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: config_manager.ruchy\n// Manages application configuration files\n\nprintln(\"=== Configuration Manager ===\")\n\nlet config_dir = \"~/.config/myapp\"\nlet config_file = join_path(config_dir, \"config.json\")\n\n// Ensure config directory exists\nif !dir_exists(config_dir) {\n    create_dir_all(config_dir)\n    println(\"Created config directory: \" + config_dir)\n}\n\n// Load or create default configuration\nlet config = if file_exists(config_file) {\n    parse_json(read_file(config_file))\n} else {\n    // Default configuration\n    {\n        \"version\": \"1.0\",\n        \"theme\": \"dark\",\n        \"auto_save\": true,\n        \"backup_interval\": 3600,\n        \"recent_files\": [],\n        \"window\": {\n            \"width\": 1200,\n            \"height\": 800,\n            \"maximized\": false\n        }\n    }\n}\n\nfun save_config() {\n    let json = to_json_pretty(config)\n    write_file(config_file, json)\n    println(\"✅ Configuration saved\")\n}\n\nfun update_setting(key, value) {\n    config[key] = value\n    save_config()\n}\n\nfun add_recent_file(path) {\n    if !config.recent_files.contains(path) {\n        config.recent_files.insert(0, path)\n        // Keep only last 10 files\n        if config.recent_files.len() > 10 {\n            config.recent_files = config.recent_files[..10]\n        }\n        save_config()\n    }\n}\n\n// Interactive configuration editor\nloop {\n    println(\"\\n=== Current Configuration ===\")\n    for key, value in config.items() {\n        println(key + \": \" + value.to_s())\n    }\n    \n    println(\"\\nOptions:\")\n    println(\"1. Change theme\")\n    println(\"2. Toggle auto-save\")\n    println(\"3. Set backup interval\")\n    println(\"4. Clear recent files\")\n    println(\"5. Reset to defaults\")\n    println(\"6. Exit\")\n    \n    let choice = input(\"\\nChoice: \")\n    \n    match choice {\n        \"1\" => {\n            let theme = input(\"Theme (light/dark): \")\n            update_setting(\"theme\", theme)\n        }\n        \"2\" => {\n            config.auto_save = !config.auto_save\n            save_config()\n        }\n        \"3\" => {\n            let interval = input(\"Backup interval (seconds): \").to_i()\n            update_setting(\"backup_interval\", interval)\n        }\n        \"4\" => {\n            config.recent_files = []\n            save_config()\n        }\n        \"5\" => {\n            // Reset to defaults\n            remove_file(config_file)\n            println(\"Configuration reset!\")\n            break\n        }\n        \"6\" => break\n        _ => println(\"Invalid choice\")\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 9,
          "line_number": 543,
          "code": "// Status: ❌ BROKEN\n\nfun safe_file_operation(path) {\n    // Check permissions first\n    if !file_exists(path) {\n        println(\"Error: File not found: \" + path)\n        return false\n    }\n    \n    if !is_readable(path) {\n        println(\"Error: No read permission for: \" + path)\n        return false\n    }\n    \n    // Try operation with error handling\n    try {\n        let content = read_file(path)\n        process_content(content)\n        return true\n    } catch error {\n        println(\"Error processing file: \" + error.to_s())\n        \n        // Log error for debugging\n        let error_log = \"errors.log\"\n        let timestamp = current_datetime()\n        append_file(error_log, timestamp.to_s() + \": \" + path + \" - \" + error.to_s() + \"\\n\")\n        \n        return false\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0423]: expected value, found macro `try`\n --> /tmp/.tmpXUtjdM/main.rs:1:460\n  |\n1 | ...: No read permission for: \" , path)) ; return false } } ; r#try ; { { let content = read_file (path) ; { process_content (content) ; r...\n  |                                                              ^^^^^ not a value\n\nerror[E0425]: cannot find value `catch` in this scope\n --> /tmp/.tmpXUtjdM/main.rs:1:555\n  |\n1 | ...; { process_content (content) ; return true } } } ; catch ; error ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Error processing file: \" ,...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpXUtjdM/main.rs:1:563\n  |\n1 | ...ess_content (content) ; return true } } } ; catch ; error ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Error processing file: \" , error ....\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpXUtjdM/main.rs:1:638\n  |\n1 | ...}\" , format ! (\"{}{}\" , \"Error processing file: \" , error . to_s ())) ; { let error_log = \"errors.log\" ; { let mut timestamp = current...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpXUtjdM/main.rs:1:863\n  |\n1 | ...{}\" , timestamp . to_s () , \": \") + path , \" - \") + error . to_s () , \"\\n\")) ; return false } } } } } fn main () { }\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpXUtjdM/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn safe_file_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + st...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpXUtjdM/main.rs:1:215\n  |\n1 | ... fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! (\"{}\" , format ! (\"{}{}\" , \"Error: File not found: \"...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXUtjdM/main.rs:1:319\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! (\"{}\" , format ! (\"{}{}\" , \"Error: File not found: \" , path)) ; return false } ...\n  |       - expected this type parameter                                                                                                                - expected `T` because of return type                                                                              ^^^^^ expected type parameter `T`, found `bool`\n  |\n  = note: expected type parameter `T`\n                       found type `bool`\n  = note: the caller chooses a type for `T` which can be different from `bool`\n\nerror[E0425]: cannot find function `is_readable` in this scope\n --> /tmp/.tmpXUtjdM/main.rs:1:336\n  |\n1 | ... not found: \" , path)) ; return false } } ; if ! is_readable (path) { { println ! (\"{}\" , format ! (\"{}{}\" , \"Error: No read permissio...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpXUtjdM/main.rs:1:486\n  |\n1 | ...)) ; return false } } ; r#try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ;...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `process_content` in this scope\n --> /tmp/.tmpXUtjdM/main.rs:1:507\n  |\n1 | ...r#try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! (\"{}\" , for...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unreachable statement\n --> /tmp/.tmpXUtjdM/main.rs:1:555\n  |\n1 | ...th) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Error processing file:...\n  |                                        -----------         ^^^^^^^ unreachable statement\n  |                                        |\n  |                                        any code following this expression is unreachable\n  |\n  = note: `#[warn(unreachable_code)]` on by default\n\nerror[E0425]: cannot find function `current_datetime` in this scope\n --> /tmp/.tmpXUtjdM/main.rs:1:713\n  |\n1 | ...ror_log = \"errors.log\" ; { let mut timestamp = current_datetime () ; append_file (error_log , format ! (\"{}{}\" , format ! (\"{}{}\" , fo...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXUtjdM/main.rs:1:847\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (path : T) -> T { { if ! file_exists (path) { { println ! (\"{}\" , format ! (\"{}{}\" , \"Error: File not found: \" , path)) ; return false } } ; if ! is_readable (path) { { println ! (\"{}\" , format ! (\"{}{}\" , \"Error: No read permission for: \" , path)) ; return false } } ; r#try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! (\"{}\" , format ! (\"{}{}\" , \"Error processing file: \" , error . to_s ())) ; { let error_log = \"errors.log\" ; { let mut timestamp = current_datetime () ; append_file (error_log , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , timestamp . to_s () , \": \") + path , ...\n  |       - found this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^^^ expected `&str`, found type parameter `T`\n  |\n  = note:   expected reference `&str`\n          found type parameter `T`\n\nerror[E0425]: cannot find function `append_file` in this scope\n --> /tmp/.tmpXUtjdM/main.rs:1:735\n  |\n1 | ...g\" ; { let mut timestamp = current_datetime () ; append_file (error_log , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , tim...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 13 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0308, E0423, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 10,
          "line_number": 592,
          "code": "// Status: ❌ BROKEN\n\nlet files = list_files(\"data\")\nfor file in files {\n    let size = file_size(file)\n    if size > 1000000 {\n        move_file(file, \"large_files/\" + file)\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpHjQFl0/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files (\"data\" . to_string ()) ; for file in files { ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpHjQFl0/main.rs:1:138\n  |\n1 | ... { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! (\"{}{}\" , \"large_files/\" , file)) } } } } } }...\n  |       ^^                                                                                                                           ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files (\"data\" . to_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! (\"{}{}\" , \"large_files/\" , file)) } } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files (\"data\" . to_string ()) ; for file in files { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! (\"{}{}\" , \"large_files/\" , file)) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpHjQFl0/main.rs:1:195\n  |\n1 | ...ze (file) ; if size > 1000000i32 { { move_file (file , format ! (\"{}{}\" , \"large_files/\" , file)) } } } } } } ; if let Some (s) = (& r...\n  |                                       ^^                                                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files (\"data\" . to_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! (\"{}{}\" , \"large_files/\" , file)) } } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files (\"data\" . to_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { move_file (file , format ! (\"{}{}\" , \"large_files/\" , file)) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `list_files` in this scope\n --> /tmp/.tmpHjQFl0/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files (\"data\" . to_string ()) ; for file in files { ...\n  |                                                                                 ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_size` in this scope\n --> /tmp/.tmpHjQFl0/main.rs:1:153\n  |\n1 | ...o_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! (\"{}{}\" , \"la...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `move_file` in this scope\n --> /tmp/.tmpHjQFl0/main.rs:1:197\n  |\n1 | ...ize = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! (\"{}{}\" , \"large_files/\" , file)) } } } } } } ; if let So...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch20-00-tooling": {
      "chapter": "ch20-00-tooling",
      "total_examples": 6,
      "working_examples": 0,
      "failing_examples": 6,
      "examples": [
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 1,
          "line_number": 150,
          "code": "// Status: ❌ BROKEN\n// bad_code.ruchy - Multiple issues for demonstration\nfun calculate_something(x: int) {\n    let unused_var = 42;\n    let y = x + 1;\n    return y;\n}\n\nfun main() {\n    let result=calculate_something(10);\n    println(result);\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpfZeJRj/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } }...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpfZeJRj/main.rs:1:72\n  |\n1 | ... calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = ...\n  |                                     ^^                                                                ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{}\" , result) } } }\n1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{}\" , result) } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpfZeJRj/main.rs:1:156\n  |\n1 | ...eturn y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{}\" , result) } } }\n  |                                 ^^                                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{}\" , result) } } }\n1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { let result = calculate_something (10i32) ; println ! (\"{}\" , result) } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpfZeJRj/main.rs:1:119\n  |\n1 | ...) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ;...\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot add `i32` to `i64`\n --> /tmp/.tmpfZeJRj/main.rs:1:117\n  |\n1 | ...) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ;...\n  |                                                     ^ no implementation for `i64 + i32`\n  |\n  = help: the trait `Add<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Add<Rhs>`:\n            `&i64` implements `Add<i64>`\n            `&i64` implements `Add`\n            `i64` implements `Add<&i64>`\n            `i64` implements `Add`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpfZeJRj/main.rs:1:133\n  |\n1 | ...e_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate...\n  |                         - help: try adding a return type: `-> i64`                      ^ expected `()`, found `i64`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpfZeJRj/main.rs:1:194\n  |\n1 | ... } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{}\" , result) } } }\n  |                                         -------------------  ^^^^^ expected `i64`, found `i32`\n  |                                         |\n  |                                         arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpfZeJRj/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } }...\n  |                                        ^^^^^^^^^^^^^^^^^^^  -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{}\" , result) } } }\n1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i64) ; println ! (\"{}\" , result) } } }\n  |\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpfZeJRj/main.rs:1:221\n  |\n1 | ...te_something (10i32) ; println ! (\"{}\" , result) } } }\n  |                                       --    ^^^^^^ `()` cannot be formatted with the default formatter\n  |                                       |\n  |                                       required by this formatting parameter\n  |\n  = help: the trait `std::fmt::Display` is not implemented for `()`\n  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 5 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 2,
          "line_number": 231,
          "code": "// Status: ❌ BROKEN\n// Before formatting (messy)\nfun fibonacci(n:int)->int{if n<=1{n}else{fibonacci(n-1)+fibonacci(n-2)}}\n\n// After running: ruchy fmt fibonacci.ruchy\nfun fibonacci(n: int) -> int {\n    if n <= 1 {\n        n\n    } else {\n        fibonacci(n - 1) + fibonacci(n - 2)\n    }\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0428]: the name `fibonacci` is defined multiple times\n --> /tmp/.tmpEs4H5h/main.rs:1:155\n  |\n1 | ... ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { ...\n  |       ----------------------------- previous definition of the value `fibonacci` here                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `fibonacci` redefined here\n  |\n  = note: `fibonacci` must be defined only once in the value namespace of this module\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpEs4H5h/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEs4H5h/main.rs:1:69\n  |\n1 | ...nacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) ...\n  |                             ^^                                                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEs4H5h/main.rs:1:86\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...\n  |                                                                                      ^^ ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEs4H5h/main.rs:1:101\n  |\n1 | ...) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if ...\n  |                                               ^^                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEs4H5h/main.rs:1:187\n  |\n1 | ...nacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                             ^^                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEs4H5h/main.rs:1:204\n  |\n1 | ... 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } f...\n  |                                                                    ^^ ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEs4H5h/main.rs:1:219\n  |\n1 | ...) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                                               ^^                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpEs4H5h/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...\n  |                                                                          -    ^^^^ expected `i64`, found `i32`\n  |                                                                          |\n  |                                                                          expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpEs4H5h/main.rs:1:118\n  |\n1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32...\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmpEs4H5h/main.rs:1:116\n  |\n1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32...\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpEs4H5h/main.rs:1:141\n  |\n1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fib...\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmpEs4H5h/main.rs:1:139\n  |\n1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fib...\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpEs4H5h/main.rs:1:197\n  |\n1 | ...2) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn ma...\n  |                                                    -    ^^^^ expected `i64`, found `i32`\n  |                                                    |\n  |                                                    expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpEs4H5h/main.rs:1:236\n  |\n1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmpEs4H5h/main.rs:1:234\n  |\n1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpEs4H5h/main.rs:1:259\n  |\n1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmpEs4H5h/main.rs:1:257\n  |\n1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror: aborting due to 11 previous errors; 7 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0428.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 3,
          "line_number": 276,
          "code": "// Status: ❌ BROKEN\n// math_utils.ruchy\nfun add(a: int, b: int) -> int {\n    a + b\n}\n\nfun multiply(a: int, b: int) -> int {\n    a * b\n}\n\n// Tests can be in the same file or separate test files\nfun test_add() {\n    assert_eq(add(2, 3), 5);\n    assert_eq(add(-1, 1), 0);\n    assert_eq(add(0, 0), 0);\n}\n\nfun test_multiply() {\n    assert_eq(multiply(2, 3), 6);\n    assert_eq(multiply(-1, 5), -5);\n    assert_eq(multiply(0, 100), 0);\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpPeCf55/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpPeCf55/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                                                         ^^     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { a + b } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpPeCf55/main.rs:1:126\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                                                                                                              ^^     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { a * b } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpPeCf55/main.rs:1:168\n  |\n1 | ... { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32...\n  |                                                 ^^^  ----   ---- expected `i64`, found `i32`\n  |                                                      |\n  |                                                      expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpPeCf55/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                        ^^^  -------   -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i64 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i64) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found macro `assert_eq`\n --> /tmp/.tmpPeCf55/main.rs:1:157\n  |\n1 | ...i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ;...\n  |                                                           ^^^^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq! (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                      +\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpPeCf55/main.rs:1:207\n  |\n1 | ..._eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply ()...\n  |                                                ^^^  ------   ---- expected `i64`, found `i32`\n  |                                                     |\n  |                                                     expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpPeCf55/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                        ^^^  -------   -------\nhelp: you can convert an `i32` to an `i64`\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add ((- 1i32).into() , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                                    +      ++++++++\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i64) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found macro `assert_eq`\n --> /tmp/.tmpPeCf55/main.rs:1:196\n  |\n1 | ...test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) }...\n  |                                                           ^^^^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq! (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                             +\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpPeCf55/main.rs:1:248\n  |\n1 | ...eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) ,...\n  |                                                 ^^^  ----   ---- expected `i64`, found `i32`\n  |                                                      |\n  |                                                      expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpPeCf55/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                        ^^^  -------   -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i64 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i64) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found macro `assert_eq`\n --> /tmp/.tmpPeCf55/main.rs:1:237\n  |\n1 | ...32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (mul...\n  |                                                           ^^^^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                                                                      +\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpPeCf55/main.rs:1:313\n  |\n1 | ...2) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (...\n  |                                              ^^^^^^^^  ----   ---- expected `i64`, found `i32`\n  |                                                        |\n  |                                                        expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpPeCf55/main.rs:1:88\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                                                                        ^^^^^^^^  -------   -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i64 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i64) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found macro `assert_eq`\n --> /tmp/.tmpPeCf55/main.rs:1:302\n  |\n1 | ...(add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32)...\n  |                                                           ^^^^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq! (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                       +\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpPeCf55/main.rs:1:357\n  |\n1 | ...tiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main ...\n  |                                             ^^^^^^^^  ------   ---- expected `i64`, found `i32`\n  |                                                       |\n  |                                                       expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpPeCf55/main.rs:1:88\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                                                                        ^^^^^^^^  -------   -------\nhelp: you can convert an `i32` to an `i64`\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply ((- 1i32).into() , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                               +      ++++++++\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i64) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found macro `assert_eq`\n --> /tmp/.tmpPeCf55/main.rs:1:346\n  |\n1 | ...ply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100...\n  |                                                           ^^^^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                   +\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpPeCf55/main.rs:1:405\n  |\n1 | ...y (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                             ^^^^^^^^  ----   ------ expected `i64`, found `i32`\n  |                                                       |\n  |                                                       expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpPeCf55/main.rs:1:88\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                                                                        ^^^^^^^^  -------   -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i64 , 100i32) , 0i32) } } fn main () { }\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i64) , 0i32) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found macro `assert_eq`\n --> /tmp/.tmpPeCf55/main.rs:1:394\n  |\n1 | ...i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                           ^^^^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () { { assert_eq (add (2i32 , 3i32) , 5i32) ; assert_eq (add (- 1i32 , 1i32) , 0i32) ; assert_eq (add (0i32 , 0i32) , 0i32) } } fn test_multiply () { { assert_eq (multiply (2i32 , 3i32) , 6i32) ; assert_eq (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                   +\n\nerror: aborting due to 12 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 4,
          "line_number": 351,
          "code": "// Status: ❌ BROKEN\n// property_test.ruchy\nfun reverse_string(s: string) -> string {\n    // Implementation details...\n    s  // Placeholder\n}\n\nfun property_test_reverse_twice_is_identity() {\n    // Property: reverse(reverse(s)) == s\n    property_test(|s: string| {\n        assert_eq(reverse_string(reverse_string(s)), s);\n    });\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmptWMKMM/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmptWMKMM/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { ...\n  |                                                                                ^^ ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { s } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmptWMKMM/main.rs:1:136\n  |\n1 | ...se_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }\n  |                              ^^                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } fn main () { }\n  |\n\nerror[E0423]: expected function, found macro `assert_eq`\n --> /tmp/.tmptWMKMM/main.rs:1:161\n  |\n1 | ...everse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn main () { }\n  |                                                           ^^^^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }\n  |                                                                                                                                                                          +\n\nerror[E0425]: cannot find function `property_test` in this scope\n --> /tmp/.tmptWMKMM/main.rs:1:138\n  |\n1 | ... property_test_reverse_twice_is_identity () { { property_test (| s | { assert_eq (reverse_string (reverse_string (s)) , s) }) } } fn m...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 5,
          "line_number": 440,
          "code": "// Status: ❌ BROKEN\n// documented_code.ruchy\n\n/// Calculates the factorial of a positive integer\n/// \n/// # Examples\n/// ```ruchy\n/// let result = factorial(5);\n/// assert_eq(result, 120);\n/// ```\n///\n/// # Panics\n/// Panics if n is negative\nfun factorial(n: int) -> int {\n    if n < 0 {\n        panic(\"Factorial not defined for negative numbers\");\n    }\n    \n    if n == 0 || n == 1 {\n        1\n    } else {\n        n * factorial(n - 1)\n    }\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp7vtXcR/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative number...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7vtXcR/main.rs:1:85\n  |\n1 | ...i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\" . to_string ()) } } ; if n == 0i32 || n == 1i32 ...\n  |                                  ^^                                                                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { panic ! (\"Factorial not defined for negative numbers\" . to_string ()) } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7vtXcR/main.rs:1:191\n  |\n1 | ...ive numbers\" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |                                                                   ^^    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\" . to_string ()) } } ; if n == 0i32 || n == 1i32 { 1i32 } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7vtXcR/main.rs:1:209\n  |\n1 | ... } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |                                                         ^^                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { n * factorial (n - 1i32) } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7vtXcR/main.rs:1:78\n  |\n1 | use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative number...\n  |                                                                          -   ^^^^ expected `i64`, found `i32`\n  |                                                                          |\n  |                                                                          expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i64 { { panic ! (\"Factorial not defined for negative numbers\" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7vtXcR/main.rs:1:171\n  |\n1 | ... for negative numbers\" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main ...\n  |                                                    -    ^^^^ expected `i64`, found `i32`\n  |                                                    |\n  |                                                    expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\" . to_string ()) } } ; if n == 0i64 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7vtXcR/main.rs:1:184\n  |\n1 | ... numbers\" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |                                                    -    ^^^^ expected `i64`, found `i32`\n  |                                                    |\n  |                                                    expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\" . to_string ()) } } ; if n == 0i32 || n == 1i64 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7vtXcR/main.rs:1:193\n  |\n1 | ...-> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } ...\n  |       --- expected `i64` because of return type                                                                                         ^^^^ expected `i64`, found `i32`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\" . to_string ()) } } ; if n == 0i32 || n == 1i32 { { 1i64 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7vtXcR/main.rs:1:230\n  |\n1 | ...n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmp7vtXcR/main.rs:1:228\n  |\n1 | ...n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror: aborting due to 6 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 6,
          "line_number": 494,
          "code": "// Status: ❌ BROKEN\n// bench_test.ruchy\nfun fibonacci_recursive(n: int) -> int {\n    if n <= 1 { n } else { fibonacci_recursive(n-1) + fibonacci_recursive(n-2) }\n}\n\nfun fibonacci_iterative(n: int) -> int {\n    let mut a = 0;\n    let mut b = 1;\n    for i in range(n) {\n        let temp = a + b;\n        a = b;\n        b = temp;\n    }\n    a\n}\n\n// Benchmark functions\nfun bench_recursive_fib() {\n    bench(\"fibonacci_recursive_20\", || fibonacci_recursive(20));\n}\n\nfun bench_iterative_fib() {\n    bench(\"fibonacci_iterative_20\", || fibonacci_iterative(20));\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmpTDeiMK/main.rs:1:276\n  |\n1 | ... { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_rec...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpTDeiMK/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTDeiMK/main.rs:1:79\n  |\n1 | ... i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_...\n  |                   ^^                                                                                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTDeiMK/main.rs:1:96\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...\n  |                                                                                                ^^ ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTDeiMK/main.rs:1:111\n  |\n1 | ... { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n :...\n  |                                     ^^                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTDeiMK/main.rs:1:288\n  |\n1 | ... ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { ben...\n  |                                               ^^                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { let temp = a + b ; { a = b ; b = temp } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTDeiMK/main.rs:1:374\n  |\n1 | ...bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib...\n  |                             ^^                                                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTDeiMK/main.rs:1:489\n  |\n1 | ...bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |                             ^^                                                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpTDeiMK/main.rs:1:89\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...\n  |                                                                                    -    ^^^^ expected `i64`, found `i32`\n  |                                                                                    |\n  |                                                                                    expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpTDeiMK/main.rs:1:138\n  |\n1 | ...= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> ...\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmpTDeiMK/main.rs:1:136\n  |\n1 | ...= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> ...\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpTDeiMK/main.rs:1:171\n  |\n1 | ...ci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mu...\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmpTDeiMK/main.rs:1:169\n  |\n1 | ...ci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mu...\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpTDeiMK/main.rs:1:340\n  |\n1 | ...) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn b...\n  |         --- expected `i64` because of return type                                                                              ^ expected `i64`, found `i32`\n  |\nhelp: you can convert an `i32` to an `i64`\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a.into() } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                     +++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpTDeiMK/main.rs:1:449\n  |\n1 | ...ci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . ...\n  |                                         -------------------  ^^^^^ expected `i64`, found `i32`\n  |                                         |\n  |                                         arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpTDeiMK/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...\n  |                                        ^^^^^^^^^^^^^^^^^^^  -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i64)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found attribute macro `bench`\n --> /tmp/.tmpTDeiMK/main.rs:1:376\n  |\n1 | ...; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i3...\n  |                                                             ^^^^^ not a function\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpTDeiMK/main.rs:1:564\n  |\n1 | ...ci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |                                         -------------------  ^^^^^ expected `i64`, found `i32`\n  |                                         |\n  |                                         arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpTDeiMK/main.rs:1:188\n  |\n1 | ...- 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for...\n  |                                                        ^^^^^^^^^^^^^^^^^^^  -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i64)) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found attribute macro `bench`\n --> /tmp/.tmpTDeiMK/main.rs:1:491\n  |\n1 | ...cci_recursive (20i32)) } } fn bench_iterative_fib () { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i3...\n  |                                                             ^^^^^ not a function\n\nerror: aborting due to 11 previous errors; 7 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch07-00-building-applications": {
      "chapter": "ch07-00-building-applications",
      "total_examples": 9,
      "working_examples": 0,
      "failing_examples": 9,
      "examples": [
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: note_keeper.ruchy\n// A complete note-taking application\n\nlet APP_NAME = \"NoteKeeper\"\nlet VERSION = \"1.0.0\"\nlet NOTES_DIR = expand_home(\"~/.notes\")\nlet NOTES_INDEX = join_path(NOTES_DIR, \"index.json\")\n\n// Initialize application\nfun init_app() {\n    if !dir_exists(NOTES_DIR) {\n        create_dir_all(NOTES_DIR)\n        println(\"Created notes directory: \" + NOTES_DIR)\n    }\n    \n    if !file_exists(NOTES_INDEX) {\n        let initial_index = {\n            \"version\": VERSION,\n            \"notes\": [],\n            \"tags\": [],\n            \"last_modified\": current_datetime()\n        }\n        save_index(initial_index)\n    }\n}\n\nfun load_index() {\n    let content = read_file(NOTES_INDEX)\n    return parse_json(content)\n}\n\nfun save_index(index) {\n    index.last_modified = current_datetime()\n    let json = to_json_pretty(index)\n    write_file(NOTES_INDEX, json)\n}\n\nfun create_note() {\n    println(\"\\n📝 Create New Note\")\n    let title = input(\"Title: \")\n    let content = input_multiline(\"Content (end with empty line):\\n\")\n    let tags = input(\"Tags (comma-separated): \").split(\",\").map(|t| t.trim())\n    \n    let note_id = generate_id()\n    let note_file = join_path(NOTES_DIR, note_id + \".md\")\n    \n    let note = {\n        \"id\": note_id,\n        \"title\": title,\n        \"created\": current_datetime(),\n        \"modified\": current_datetime(),\n        \"tags\": tags,\n        \"file\": note_file\n    }\n    \n    // Save note content\n    let markdown = \"# \" + title + \"\\n\\nCreated: \" + note.created + \"\\nTags: \" + tags.join(\", \") + \"\\n\\n---\\n\\n\" + content\n    \n    write_file(note_file, markdown)\n    \n    // Update index\n    let index = load_index()\n    index.notes.push(note)\n    index.tags = index.tags.union(tags)\n    save_index(index)\n    \n    println(\"✅ Note created: \" + title)\n}\n\nfun list_notes(filter_tag = null) {\n    let index = load_index()\n    let notes = index.notes\n    \n    if filter_tag {\n        notes = notes.filter(|n| n.tags.contains(filter_tag))\n        println(f\"\\n📋 Notes tagged '{filter_tag}':\")\n    } else {\n        println(f\"\\n📋 All Notes ({notes.len()} total):\")\n    }\n    \n    if notes.is_empty() {\n        println(\"  No notes found\")\n        return\n    }\n    \n    for i, note in notes.enumerate() {\n        let age = time_ago(note.created)\n        println((i+1).to_s() + \". \" + note.title)\n        println(\"     Tags: \" + note.tags.join(\", \") + \" | Created: \" + age)\n    }\n}\n\nfun search_notes(query) {\n    let index = load_index()\n    let results = []\n    \n    for note in index.notes {\n        // Search in title\n        if note.title.lower().contains(query.lower()) {\n            results.push(note)\n            continue\n        }\n        \n        // Search in content\n        let content = read_file(note.file)\n        if content.lower().contains(query.lower()) {\n            results.push(note)\n        }\n    }\n    \n    println(f\"\\n🔍 Search results for '{query}': {results.len()} matches\")\n    \n    for note in results {\n        println(\"  • \" + note.title)\n        \n        // Show context\n        let content = read_file(note.file)\n        let lines = content.lines()\n        for line in lines {\n            if line.lower().contains(query.lower()) {\n                println(f\"    ...{line.trim()}...\")\n                break\n            }\n        }\n    }\n}\n\nfun view_note(index_num) {\n    let index = load_index()\n    \n    if index_num < 1 || index_num > index.notes.len() {\n        println(\"❌ Invalid note number\")\n        return\n    }\n    \n    let note = index.notes[index_num - 1]\n    let content = read_file(note.file)\n    \n    println(\"\\n\" + \"=\"*50)\n    println(content)\n    println(\"=\"*50)\n}\n\nfun export_notes(format) {\n    let index = load_index()\n    let export_file = \"notes_export_\" + current_date() + \".\" + format\n    \n    match format {\n        \"json\" => {\n            let data = {\n                \"exported\": current_datetime(),\n                \"notes\": []\n            }\n            \n            for note in index.notes {\n                let content = read_file(note.file)\n                data.notes.push({\n                    \"title\": note.title,\n                    \"content\": content,\n                    \"tags\": note.tags,\n                    \"created\": note.created\n                })\n            }\n            \n            write_file(export_file, to_json_pretty(data))\n        }\n        \"markdown\" => {\n            let markdown = f\"# My Notes\nExported: {current_datetime()}\n\n\"\n            for note in index.notes {\n                let content = read_file(note.file)\n                markdown += f\"\n\n---\n\n{content}\n\"\n            }\n            \n            write_file(export_file, markdown)\n        }\n        _ => {\n            println(\"❌ Unsupported format: \" + format)\n            return\n        }\n    }\n    \n    println(\"✅ Exported \" + index.notes.len().to_s() + \" notes to \" + export_file)\n}\n\nfun show_menu() {\n    println(f\"\\n=== {APP_NAME} v{VERSION} ===\")\n    println(\"1. Create note\")\n    println(\"2. List all notes\")\n    println(\"3. Search notes\")\n    println(\"4. View note\")\n    println(\"5. List by tag\")\n    println(\"6. Export notes\")\n    println(\"7. Statistics\")\n    println(\"8. Quit\")\n}\n\nfun show_statistics() {\n    let index = load_index()\n    let total_notes = index.notes.len()\n    let total_tags = index.tags.len()\n    \n    // Calculate word count\n    let total_words = 0\n    for note in index.notes {\n        let content = read_file(note.file)\n        total_words += content.split_whitespace().len()\n    }\n    \n    // Find most used tags\n    let tag_counts = {}\n    for note in index.notes {\n        for tag in note.tags {\n            tag_counts[tag] = tag_counts.get(tag, 0) + 1\n        }\n    }\n    \n    println(f\"\\n📊 NoteKeeper Statistics\")\n    println(\"Total notes: \" + total_notes.to_s())\n    println(\"Total words: \" + total_words.to_s())\n    println(\"Average words per note: \" + (total_words / max(total_notes, 1)).to_s())\n    println(\"Unique tags: \" + total_tags.to_s())\n    \n    if !tag_counts.is_empty() {\n        println(\"\\nTop tags:\")\n        let sorted_tags = tag_counts.items().sort_by(|item| -item.value)\n        for tag, count in sorted_tags[..min(5, sorted_tags.len())] {\n            println(f\"  • {tag}: {count} notes\")\n        }\n    }\n}\n\n// Main application loop\nfun main() {\n    init_app()\n    \n    println(f\"Welcome to {APP_NAME}!\")\n    println(\"Your personal note-taking assistant\")\n    \n    loop {\n        show_menu()\n        let choice = input(\"\\nChoice: \")\n        \n        match choice {\n            \"1\" => create_note()\n            \"2\" => list_notes()\n            \"3\" => {\n                let query = input(\"Search for: \")\n                search_notes(query)\n            }\n            \"4\" => {\n                list_notes()\n                let num = input(\"\\nNote number to view: \").to_i()\n                view_note(num)\n            }\n            \"5\" => {\n                let index = load_index()\n                println(\"\\nAvailable tags:\")\n                for tag in index.tags {\n                    println(\"  • \" + tag)\n                }\n                let tag = input(\"\\nFilter by tag: \")\n                list_notes(tag)\n            }\n            \"6\" => {\n                let format = input(\"Export format (json/markdown): \")\n                export_notes(format)\n            }\n            \"7\" => show_statistics()\n            \"8\" => {\n                println(\"👋 Thanks for using NoteKeeper!\")\n                break\n            }\n            _ => println(\"❌ Invalid choice\")\n        }\n    }\n}\n\n// Run the application\nmain()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 2,
          "line_number": 336,
          "code": "// Status: ❌ BROKEN\n\n// Application structure\nlet APP = {\n    \"name\": \"MyApp\",\n    \"version\": \"1.0.0\",\n    \"config_dir\": \"~/.config/myapp\",\n    \"data_dir\": \"~/.local/share/myapp\",\n    \"cache_dir\": \"~/.cache/myapp\"\n}\n\n// Separate concerns into modules\n// models.ruchy - Data structures\nlet User = {\n    \"id\": null,\n    \"name\": \"\",\n    \"email\": \"\",\n    \"created\": null\n}\n\n// services.ruchy - Business logic\nfun create_user(name, email) {\n    let user = User.copy()\n    user.id = generate_uuid()\n    user.name = name\n    user.email = email\n    user.created = current_datetime()\n    return user\n}\n\n// ui.ruchy - User interface\nfun display_user(user) {\n    println(f\"User: {user.name} ({user.email})\")\n    println(\"Member since: \" + user.created)\n}\n\n// main.ruchy - Application entry point\nfun main() {\n    init_app()\n    load_config()\n    run_event_loop()\n    cleanup()\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmpirQFgi/main.rs:1:709\n  |\n1 | ... = { name : \"MyApp\" , version : \"1.0.0\" , config_dir : \"~/.config/myapp\" , data_dir : \"~/.local/share/myapp\" , cache_dir : \"~/.cache/myapp\" , } ; ...\n  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Member since: \" , user . created)) } } fn main () { let mut APP = { SomeStruct { name : \"MyApp\" , version : \"1.0.0\" , config_dir : \"~/.config/myapp\" , data_dir : \"~/.local/share/myapp\" , cache_dir : \"~/.cache/myapp\" , } } ; let mut User = { id : null , name : \"\" , email : \"\" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++++++++++++                                                                                                                                              +\n\nerror: struct literal body without path\n --> /tmp/.tmpirQFgi/main.rs:1:867\n  |\n1 | ...\"~/.cache/myapp\" , } ; let mut User = { id : null , name : \"\" , email : \"\" , created : null , } ; { init_app () ; load_config () ; run...\n  |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Member since: \" , user . created)) } } fn main () { let mut APP = { name : \"MyApp\" , version : \"1.0.0\" , config_dir : \"~/.config/myapp\" , data_dir : \"~/.local/share/myapp\" , cache_dir : \"~/.cache/myapp\" , } ; let mut User = { SomeStruct { id : null , name : \"\" , email : \"\" , created : null , } } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ++++++++++++                                                           +\n\nerror[E0425]: cannot find value `User` in this scope\n --> /tmp/.tmpirQFgi/main.rs:1:227\n  |\n1 | ...Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . ema...\n  |                                                         ^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpirQFgi/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpirQFgi/main.rs:1:212\n  |\n1 | ... { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } ...\n  |       ^^                                                                                                                                                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Member since: \" , user . created)) } } fn main () { let mut APP = { name : \"MyApp\" , version : \"1.0.0\" , config_dir : \"~/.config/myapp\" , data_dir : \"~/.local/share/myapp\" , cache_dir : \"~/.cache/myapp\" , } ; let mut User = { id : null , name : \"\" , email : \"\" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n1 + use std :: collections :: HashMap ; fn create_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , email : T) -> T { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } fn display_user < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Member since: \" , user . created)) } } fn main () { let mut APP = { name : \"MyApp\" , version : \"1.0.0\" , config_dir : \"~/.config/myapp\" , data_dir : \"~/.local/share/myapp\" , cache_dir : \"~/.cache/myapp\" , } ; let mut User = { id : null , name : \"\" , email : \"\" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |\n\nerror[E0425]: cannot find function `generate_uuid` in this scope\n --> /tmp/.tmpirQFgi/main.rs:1:258\n  |\n1 | ...{ { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = curren...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `current_datetime` in this scope\n --> /tmp/.tmpirQFgi/main.rs:1:338\n  |\n1 | ...name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user < T : std :: ops :: Add < Out...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0609]: no field `name` on type `T`\n --> /tmp/.tmpirQFgi/main.rs:1:582\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! (\"User: {} ({})\" , user . name , ...\n  |       - type parameter 'T' declared here                                                                                                                                                      ^^^^ unknown field\n\nerror[E0609]: no field `email` on type `T`\n --> /tmp/.tmpirQFgi/main.rs:1:596\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! (\"User: {} ({})\" , user . name , user . email) ;...\n  |       - type parameter 'T' declared here                                                                                                                                                                    ^^^^^ unknown field\n\nerror[E0609]: no field `created` on type `T`\n --> /tmp/.tmpirQFgi/main.rs:1:668\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Member since: \" , user . created)) ...\n  |       - type parameter 'T' declared here                                                                                                                                                                                                                                            ^^^^^^^ unknown field\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpirQFgi/main.rs:1:605\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (user : T) -> T { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Member since: \" , user . created)) } ...\n  |       - expected this type parameter                                                                                                                                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `init_app` in this scope\n --> /tmp/.tmpirQFgi/main.rs:1:929\n  |\n1 | ... , name : \"\" , email : \"\" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `load_config` in this scope\n --> /tmp/.tmpirQFgi/main.rs:1:943\n  |\n1 | ...mail : \"\" , created : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `run_event_loop` in this scope\n --> /tmp/.tmpirQFgi/main.rs:1:960\n  |\n1 | ...d : null , } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `cleanup` in this scope\n --> /tmp/.tmpirQFgi/main.rs:1:980\n  |\n1 | ...init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 13 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0308, E0425, E0609.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 3,
          "line_number": 394,
          "code": "// Status: ❌ BROKEN\n\n// Global application state\nlet STATE = {\n    \"users\": [],\n    \"current_user\": null,\n    \"settings\": {},\n    \"cache\": {},\n    \"dirty\": false\n}\n\nfun update_state(key, value) {\n    STATE[key] = value\n    STATE.dirty = true\n    trigger_save()\n}\n\nfun save_state() {\n    if STATE.dirty {\n        let state_file = join_path(APP.data_dir, \"state.json\")\n        write_file(state_file, to_json(STATE))\n        STATE.dirty = false\n    }\n}\n\nfun load_state() {\n    let state_file = join_path(APP.data_dir, \"state.json\")\n    if file_exists(state_file) {\n        STATE = parse_json(read_file(state_file))\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmpPfkhdI/main.rs:1:693\n  |\n1 | ... () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { SomeStruct { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++++++++++++                                                                                           +\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpPfkhdI/main.rs:1:214\n  |\n1 | ...t :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpPfkhdI/main.rs:1:236\n  |\n1 | ...key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty {...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpPfkhdI/main.rs:1:303\n  |\n1 | ... true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP` in this scope\n --> /tmp/.tmpPfkhdI/main.rs:1:351\n  |\n1 | ...{ if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_jso...\n  |                                                         ^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpPfkhdI/main.rs:1:435\n  |\n1 | ...to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpPfkhdI/main.rs:1:445\n  |\n1 | ...()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_pat...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP` in this scope\n --> /tmp/.tmpPfkhdI/main.rs:1:530\n  |\n1 | ...} fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { S...\n  |                                                         ^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpPfkhdI/main.rs:1:610\n  |\n1 | ...\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE =...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpPfkhdI/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fm...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpPfkhdI/main.rs:1:298\n  |\n1 | ... { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } ...\n  |       ^^                                                                                                                                                                              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n1 + use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpPfkhdI/main.rs:1:319\n  |\n1 | ... { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } ...\n  |       ^^                                                                                                                                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n1 + use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpPfkhdI/main.rs:1:498\n  |\n1 | ... { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } ...\n  |       ^^                                                                                                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n1 + use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpPfkhdI/main.rs:1:608\n  |\n1 | ...string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { user...\n  |                                               ^^                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n1 + use std :: collections :: HashMap ; fn update_state < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (key : T , value : T) -> T { { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { STATE = parse_json (read_file (state_file)) } } } } fn main () { let mut STATE = { users : vec ! [] , current_user : null , settings : () , cache : () , dirty : false , } ; }\n  |\n\nerror[E0425]: cannot find function `trigger_save` in this scope\n --> /tmp/.tmpPfkhdI/main.rs:1:259\n  |\n1 | ...{ { STATE [key] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () { { if STATE . dirty { { { let state_file = join...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpPfkhdI/main.rs:1:340\n  |\n1 | ...te () { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_json` in this scope\n --> /tmp/.tmpPfkhdI/main.rs:1:426\n  |\n1 | ...json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let sta...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpPfkhdI/main.rs:1:401\n  |\n1 | ...ate.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () { { { let...\n  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `state_file`\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpPfkhdI/main.rs:1:519\n  |\n1 | ...} } } } } fn load_state () { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_fil...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpPfkhdI/main.rs:1:581\n  |\n1 | ...P . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpPfkhdI/main.rs:1:630\n  |\n1 | ... file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users : vec ! [] , ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `parse_json` in this scope\n --> /tmp/.tmpPfkhdI/main.rs:1:618\n  |\n1 | ...ing ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { users :...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 17 previous errors; 5 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 4,
          "line_number": 440,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\nfun safe_operation(operation_fn, fallback_value) {\n    try {\n        return operation_fn()\n    } catch error {\n        log_error(error)\n        return fallback_value\n    }\n}\n\nfun with_retry(operation_fn, max_attempts = 3) {\n    for attempt in range(max_attempts) {\n        try {\n            return operation_fn()\n        } catch error {\n            if attempt == max_attempts - 1 {\n                println(\"❌ Failed after \" + max_attempts.to_s() + \" attempts: \" + error.to_s())\n                throw error\n            }\n            \n            let wait_time = 2 ** attempt  // Exponential backoff\n            println(f\"⚠️  Attempt {attempt + 1} failed, retrying in {wait_time}s...\")\n            sleep(wait_time * 1000)\n        }\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0423]: expected value, found macro `try`\n --> /tmp/.tmpwPQpHo/main.rs:1:234\n  |\n1 | ... Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; r...\n  |                                                              ^^^^^ not a value\n\nerror[E0425]: cannot find value `catch` in this scope\n --> /tmp/.tmpwPQpHo/main.rs:1:271\n  |\n1 | ... : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpwPQpHo/main.rs:1:279\n  |\n1 | ... T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpwPQpHo/main.rs:1:300\n  |\n1 | ...rn operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Outpu...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmpwPQpHo/main.rs:1:543\n  |\n1 | ..._fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nerror[E0423]: expected value, found macro `try`\n --> /tmp/.tmpwPQpHo/main.rs:1:568\n  |\n1 | ...pts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_att...\n  |                                                              ^^^^^ not a value\n\nerror[E0425]: cannot find value `catch` in this scope\n --> /tmp/.tmpwPQpHo/main.rs:1:605\n  |\n1 | ..._attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , format !...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpwPQpHo/main.rs:1:613\n  |\n1 | ...s) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , format ! (\"{}{}\"...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpwPQpHo/main.rs:1:780\n  |\n1 | ...fter \" , max_attempts . to_s ()) , \" attempts: \") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpwPQpHo/main.rs:1:808\n  |\n1 | ... ()) , \" attempts: \") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Att...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `sleep` in this scope\n --> /tmp/.tmpwPQpHo/main.rs:1:958\n  |\n1 | ...retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::sleep;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpwPQpHo/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpwPQpHo/main.rs:1:526\n  |\n1 | ... { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Failed after \" , max_attempts . to_s ()) , \" attempts: \") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } f...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Failed after \" , max_attempts . to_s ()) , \" attempts: \") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Failed after \" , max_attempts . to_s ()) , \" attempts: \") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } fn main () { }\n  |\n\nerror[E0618]: expected function, found `T`\n --> /tmp/.tmpwPQpHo/main.rs:1:251\n  |\n1 | ... Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; r...\n  |              ------------                                                     ^^^^^^^^^^^^---\n  |              |                                                                |\n  |              `operation_fn` has type `T`                                      call expression requires function\n\nwarning: unreachable statement\n --> /tmp/.tmpwPQpHo/main.rs:1:271\n  |\n1 | ..._value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_re...\n  |                                   ----------------------     ^^^^^^^ unreachable statement\n  |                                   |\n  |                                   any code following this expression is unreachable\n  |\n  = note: `#[warn(unreachable_code)]` on by default\n\nerror[E0425]: cannot find function `log_error` in this scope\n --> /tmp/.tmpwPQpHo/main.rs:1:289\n  |\n1 | ... ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Ad...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0618]: expected function, found `T`\n --> /tmp/.tmpwPQpHo/main.rs:1:585\n  |\n1 | ...one > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catc...\n  |           ------------                                                                                           ^^^^^^^^^^^^---\n  |           |                                                                                                      |\n  |           `operation_fn` has type `T`                                                                            call expression requires function\n\nwarning: unreachable statement\n --> /tmp/.tmpwPQpHo/main.rs:1:605\n  |\n1 | ...e (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , fo...\n  |                                   ----------------------     ^^^^^^^ unreachable statement\n  |                                   |\n  |                                   any code following this expression is unreachable\n\nerror[E0369]: cannot subtract `i32` from `T`\n --> /tmp/.tmpwPQpHo/main.rs:1:650\n  |\n1 | ...rn operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , ...\n  |                                                           ------------ ^ ---- i32\n  |                                                           |\n  |                                                           T\n  |\nhelp: consider further restricting type parameter `T` with trait `Sub`\n  |\n1 | use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Sub<i32> > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Failed after \" , max_attempts . to_s ()) , \" attempts: \") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ++++++++++++++++++++\n\nerror[E0599]: no method named `to_s` found for type parameter `T` in the current scope\n --> /tmp/.tmpwPQpHo/main.rs:1:752\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Failed after \" , max_attempts . to_s ())...\n  |       - method `to_s` not found for this type parameter                                                                                                                                                                                                                                                                                                                                                               ^^^^ method not found in `T`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpwPQpHo/main.rs:1:938\n  |\n1 | ...Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }\n  |                                                       ^^^^ expected `u32`, found `i32`\n\nerror[E0277]: cannot add `i32` to `u32`\n --> /tmp/.tmpwPQpHo/main.rs:1:936\n  |\n1 | ...Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }\n  |                                                     ^ no implementation for `u32 + i32`\n  |\n  = help: the trait `Add<i32>` is not implemented for `u32`\n  = help: the following other types implement trait `Add<Rhs>`:\n            `&u32` implements `Add<u32>`\n            `&u32` implements `Add`\n            `u32` implements `Add<&u32>`\n            `u32` implements `Add`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpwPQpHo/main.rs:1:528\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Failed after \" , max_attempts . to_s ()) , \" attempts: \") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } }...\n  |       -                                                                                                                                                                        -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |       |                                                                                                                                                                        |\n  |       expected this type parameter                                                                                                                                             expected `T` because of return type\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: the caller chooses a type for `T` which can be different from `()`\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn safe_operation < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , fallback_value : T) -> T { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (operation_fn : T , max_attempts : T) -> T { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Failed after \" , max_attempts . to_s ()) , \" attempts: \") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } /* `T` value */ } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     +++++++++++++++\n\nerror: aborting due to 19 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0423, E0425, E0599, E0618.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 5,
          "line_number": 482,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n// Error: ✗ Compilation failed: Compilation failed:\n// Simple password manager with encryption\nlet MASTER_KEY = null\nlet PASSWORDS_FILE = \"~/.passwords.enc\"\n\nfun encrypt(text, key) {\n    // Simple XOR encryption (use real encryption in production!)\n    let encrypted = []\n    for i, char in text.chars().enumerate() {\n        let key_char = key[i % key.len()]\n        encrypted.push(char.code() ^ key_char.code())\n    }\n    return base64_encode(encrypted)\n}\n\nfun decrypt(encrypted, key) {\n    let bytes = base64_decode(encrypted)\n    let decrypted = []\n    for i, byte in bytes.enumerate() {\n        let key_char = key[i % key.len()]\n        decrypted.push(char_from_code(byte ^ key_char.code()))\n    }\n    return decrypted.join(\"\")\n}\n\nfun add_password(site, username, password) {\n    let passwords = load_passwords()\n    passwords[site] = {\n        \"username\": username,\n        \"password\": encrypt(password, MASTER_KEY),\n        \"created\": current_datetime()\n    }\n    save_passwords(passwords)\n}\n\nfun get_password(site) {\n    let passwords = load_passwords()\n    if passwords.has_key(site) {\n        let entry = passwords[site]\n        let password = decrypt(entry.password, MASTER_KEY)\n        copy_to_clipboard(password)\n        println(\"✅ Password copied to clipboard!\")\n        \n        // Clear clipboard after 30 seconds\n        spawn_after(30000, || clear_clipboard())\n    } else {\n        println(\"❌ No password found for \" + site)\n    }\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmpCXSCym/main.rs:1:1136\n  |\n1 | ...swords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_password...\n  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { SomeStruct { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ++++++++++++                                                                                                        +\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpCXSCym/main.rs:1:1686\n  |\n1 | ...d (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } el...\n  |                                                                 ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpCXSCym/main.rs:1:1688\n  |\n1 | ...lipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } }...\n  |                                     ----------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                     |\n  |                                     formatting specifier missing\n\nerror[E0425]: cannot find value `MASTER_KEY` in this scope\n --> /tmp/.tmpCXSCym/main.rs:1:1596\n  |\n1 | ... { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboa...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `null` in this scope\n --> /tmp/.tmpCXSCym/main.rs:1:1885\n  |\n1 | ..., site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::ptr::null;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpCXSCym/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpCXSCym/main.rs:1:206\n  |\n1 | ... { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } ...\n  |       ^^                                                                                                                                                                                                                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpCXSCym/main.rs:1:290\n  |\n1 | ... enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base...\n  |                    ^^                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpCXSCym/main.rs:1:612\n  |\n1 | ... { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpCXSCym/main.rs:1:730\n  |\n1 | ...merate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return d...\n  |                ^^                                                                                                         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpCXSCym/main.rs:1:1075\n  |\n1 | ... { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } ...\n  |       ^^                                                                                                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpCXSCym/main.rs:1:1440\n  |\n1 | ... { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpCXSCym/main.rs:1:1512\n  |\n1 | ... { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } e...\n  |       ^^                                                                                                                                                                                                                                                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpCXSCym/main.rs:1:1766\n  |\n1 | ...clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut ...\n  |                                 ^^                                                                         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n1 + use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |\n\nerror[E0599]: no method named `chars` found for type parameter `T` in the current scope\n --> /tmp/.tmpCXSCym/main.rs:1:264\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars ()...\n  |       - method `chars` not found for this type parameter                                                                                                                                                                    ^^^^^ method not found in `T`\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmpCXSCym/main.rs:1:324\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                  ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |                                                                                                                                                                                +++++++++++++++++++\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmpCXSCym/main.rs:1:313\n  |\n1 | ...n text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) ...\n  |                                                              ^^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function `base64_encode` in this scope\n --> /tmp/.tmpCXSCym/main.rs:1:404\n  |\n1 | ... . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + ...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `base64_decode` in this scope\n --> /tmp/.tmpCXSCym/main.rs:1:628\n  |\n1 | ...encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes ....\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmpCXSCym/main.rs:1:764\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                                                         ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn encrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T , key : T) -> T { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len ()] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (encrypted : T , key : T) -> T { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 +++++++++++++++++++\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmpCXSCym/main.rs:1:753\n  |\n1 | ... , byte) in bytes . enumerate () { { { let key_char = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . cod...\n  |                                                              ^^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function `char_from_code` in this scope\n --> /tmp/.tmpCXSCym/main.rs:1:792\n  |\n1 | ...ar = key [i % key . len ()] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } }...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `load_passwords` in this scope\n --> /tmp/.tmpCXSCym/main.rs:1:1095\n  |\n1 | ... : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (p...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `save_passwords` in this scope\n --> /tmp/.tmpCXSCym/main.rs:1:1241\n  |\n1 | ...STER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = ...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `load_passwords` in this scope\n --> /tmp/.tmpCXSCym/main.rs:1:1460\n  |\n1 | ... } fn add_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T , username : T , password : T) -> T { { { let passwords = load_passwords () ; { passwords [site] = { username : username , password : encrypt (password , MASTER_KEY) , created : current_datetime () , } ; save_passwords (passwords) } } } } fn get_password < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords ()...\n  |       ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- similarly named function `add_password` defined here                                                                                                                                                                                                                                                                                                                                               ^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_password`\n\nerror[E0425]: cannot find function `copy_to_clipboard` in this scope\n --> /tmp/.tmpCXSCym/main.rs:1:1610\n  |\n1 | ...d = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string (...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpCXSCym/main.rs:1:1688\n  |\n1 | ... ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { print...\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `clear_clipboard` in this scope\n --> /tmp/.tmpCXSCym/main.rs:1:1731\n  |\n1 | ...\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `spawn_after` in this scope\n --> /tmp/.tmpCXSCym/main.rs:1:1704\n  |\n1 | ...Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , form...\n  |                                                      ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpCXSCym/main.rs:1:1768\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (site : T) -> T { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\" . to_string ()) ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } ...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 21 previous errors; 9 warnings emitted\n\nSome errors have detailed explanations: E0308, E0425, E0599, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: chars()"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 6,
          "line_number": 543,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n// Error: ✗ Compilation failed: Compilation failed:\n// Personal finance tracker\nlet TRANSACTIONS_FILE = \"~/.budget/transactions.csv\"\nlet CATEGORIES = [\"Food\", \"Transport\", \"Bills\", \"Entertainment\", \"Other\"]\n\nfun add_transaction(amount, category, description) {\n    let transaction = {\n        \"date\": current_date(),\n        \"amount\": amount,\n        \"category\": category,\n        \"description\": description\n    }\n    \n    append_csv(TRANSACTIONS_FILE, transaction)\n    \n    // Check budget alerts\n    let monthly_spent = get_monthly_total(category)\n    let budget_limit = get_budget_limit(category)\n    \n    if monthly_spent > budget_limit {\n        send_notification(f\"⚠️ Over budget for {category}!\")\n        println(\"Warning: \" + category + \" spending at $\" + monthly_spent.to_s() + \"/$\" + budget_limit.to_s())\n    }\n}\n\nfun generate_report(month) {\n    let transactions = load_transactions(month)\n    let by_category = group_by(transactions, \"category\")\n    \n    println(\"\\n📊 Budget Report for \" + month)\n    println(\"=\"*40)\n    \n    let total = 0\n    for category, items in by_category.items() {\n        let category_total = items.map(|t| t.amount).sum()\n        total += category_total\n        \n        let bar = \"█\" * (category_total / 50).to_i()\n        println(category + \" $\" + category_total.to_s() + \" \" + bar)\n    }\n    \n    println(\"=\"*40)\n    println(\"Total:          $\" + total.to_s())\n    \n    // Save report\n    let report_file = f\"budget_report_{month}.pdf\"\n    generate_pdf(report_file, report_data)\n    println(\"\\n📄 Report saved to \" + report_file)\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmpFNMSNl/main.rs:1:261\n  |\n1 | ... let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TR...\n  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { SomeStruct { date : current_date () , amount : amount , category : category , description : description , } } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n  |                                                                                                                                                                                                                                                                     ++++++++++++                                                                                                  +\n\nerror[E0425]: cannot find value `TRANSACTIONS_FILE` in this scope\n --> /tmp/.tmpFNMSNl/main.rs:1:374\n  |\n1 | ...description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `report_data` in this scope\n --> /tmp/.tmpFNMSNl/main.rs:1:1817\n  |\n1 | ...t_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_fi...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpFNMSNl/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std ::...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpFNMSNl/main.rs:1:239\n  |\n1 | ... { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n1 + use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpFNMSNl/main.rs:1:988\n  |\n1 | ... { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n1 + use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } fn main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpFNMSNl/main.rs:1:1298\n  |\n1 | ... { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n1 + use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n  |\n\nerror[E0425]: cannot find function `append_csv` in this scope\n --> /tmp/.tmpFNMSNl/main.rs:1:362\n  |\n1 | ...ry : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_t...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `get_monthly_total` in this scope\n --> /tmp/.tmpFNMSNl/main.rs:1:433\n  |\n1 | ...FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if m...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `get_budget_limit` in this scope\n --> /tmp/.tmpFNMSNl/main.rs:1:487\n  |\n1 | ...thly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (fo...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `send_notification` in this scope\n --> /tmp/.tmpFNMSNl/main.rs:1:553\n  |\n1 | ...tegory) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpFNMSNl/main.rs:1:629\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } ...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `load_transactions` in this scope\n --> /tmp/.tmpFNMSNl/main.rs:1:1011\n  |\n1 | ... ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (m...\n  |       ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- similarly named function `add_transaction` defined here                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^^^^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_transaction`\n\nerror[E0425]: cannot find function `group_by` in this scope\n --> /tmp/.tmpFNMSNl/main.rs:1:1063\n  |\n1 | ...oad_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{}\" , format ! (\"...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot multiply `&str` by `i32`\n --> /tmp/.tmpFNMSNl/main.rs:1:1213\n  |\n1 | ...\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category ...\n  |                                                                --- ^ ----- i32\n  |                                                                |\n  |                                                                &str\n\nerror[E0599]: no method named `to_i` found for type `i32` in the current scope\n --> /tmp/.tmpFNMSNl/main.rs:1:1477\n  |\n1 | ...otal ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\")...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpFNMSNl/main.rs:1:1436\n  |\n1 | ... sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , form...\n  |                                              ^^^^^^^ doesn't have a size known at compile-time\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: all local variables must have a statically known size\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpFNMSNl/main.rs:1:1596\n  |\n1 | ...tegory , \" $\") + category_total . to_s () , \" \") + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , format ! (\"{}{}\" ...\n  |                                                       ^^^ expected `&str`, found `str`\n  |\nhelp: consider borrowing here\n  |\n1 | use std :: collections :: HashMap ; fn add_transaction < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (amount : T , category : T , description : T) -> T { { { let transaction = { date : current_date () , amount : amount , category : category , description : description , } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } } fn generate_report < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + &bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             +\n\nerror[E0369]: cannot multiply `&str` by `i32`\n --> /tmp/.tmpFNMSNl/main.rs:1:1633\n  |\n1 | ..._total . to_s () , \" \") + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total:          $\" , t...\n  |                                                               --- ^ ----- i32\n  |                                                               |\n  |                                                               &str\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpFNMSNl/main.rs:1:1711\n  |\n1 | ... , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; gene...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0425]: cannot find function `generate_pdf` in this scope\n --> /tmp/.tmpFNMSNl/main.rs:1:1789\n  |\n1 | ...le = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📄 R...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpFNMSNl/main.rs:1:1832\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (month : T) -> T { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . items () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } } ; println ! (\"{}\" , \"=\" * 40i32) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } ...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unused variable: `TRANSACTIONS_FILE`\n --> /tmp/.tmpFNMSNl/main.rs:1:1937\n  |\n1 | ...main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Ent...\n  |                      ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_TRANSACTIONS_FILE`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `CATEGORIES`\n --> /tmp/.tmpFNMSNl/main.rs:1:1996\n  |\n1 | ...nsactions.csv\" ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n  |                             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_CATEGORIES`\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmpFNMSNl/main.rs:1:1933\n  |\n1 | ... saved to \" , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let mut CATEGORIES = vec !...\n  |                                                         ----^^^^^^^^^^^^^^^^^\n  |                                                         |\n  |                                                         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmpFNMSNl/main.rs:1:1992\n  |\n1 | ...ANSACTIONS_FILE = \"~/.budget/transactions.csv\" ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other...\n  |                                                         ----^^^^^^^^^^\n  |                                                         |\n  |                                                         help: remove this `mut`\n\nerror: aborting due to 18 previous errors; 8 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_i()"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 7,
          "line_number": 604,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Development project scaffolding tool\nlet TEMPLATES = {\n    \"python\": {\n        \"files\": [\"main.py\", \"requirements.txt\", \"README.md\", \".gitignore\"],\n        \"folders\": [\"src\", \"tests\", \"docs\"]\n    },\n    \"javascript\": {\n        \"files\": [\"index.js\", \"package.json\", \"README.md\", \".gitignore\"],\n        \"folders\": [\"src\", \"test\", \"public\"]\n    },\n    \"ruchy\": {\n        \"files\": [\"main.ruchy\", \"Cargo.toml\", \"README.md\", \".gitignore\"],\n        \"folders\": [\"src\", \"tests\", \"docs\"]\n    }\n}\n\nfun create_project(name, language) {\n    let project_dir = name\n    \n    if dir_exists(project_dir) {\n        println(f\"❌ Directory {project_dir} already exists\")\n        return\n    }\n    \n    create_dir(project_dir)\n    println(\"📁 Created project: \" + name)\n    \n    let template = TEMPLATES[language]\n    \n    // Create folder structure\n    for folder in template.folders {\n        create_dir(join_path(project_dir, folder))\n        println(f\"  📂 {folder}/\")\n    }\n    \n    // Create files from templates\n    for file in template.files {\n        let template_content = get_template_content(language, file)\n        let content = template_content\n            .replace(\"{{PROJECT_NAME}}\", name)\n            .replace(\"{{DATE}}\", current_date())\n            .replace(\"{{AUTHOR}}\", get_git_user())\n        \n        write_file(join_path(project_dir, file), content)\n        println(\"  📄 \" + file)\n    }\n    \n    // Initialize git\n    run_command(\"git init\", project_dir)\n    run_command(\"git add .\", project_dir)\n    run_command('git commit -m \"Initial commit\"', project_dir)\n    \n    println(f\"\\n✅ Project {name} created successfully!\")\n    println(f\"Next steps:\")\n    println(\"  cd \" + project_dir)\n    println(\"  \" + get_run_command(language))\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 8,
          "line_number": 676,
          "code": "// Status: ❌ BROKEN\n\n// test_app.ruchy - Application test suite\n\nfun test_user_creation() {\n    let user = create_user(\"Alice\", \"alice@example.com\")\n    \n    assert(user.name == \"Alice\", \"Name should be set\")\n    assert(user.email == \"alice@example.com\", \"Email should be set\")\n    assert(user.id != null, \"ID should be generated\")\n    \n    println(\"✅ test_user_creation passed\")\n}\n\nfun test_data_persistence() {\n    let test_data = {\"test\": \"value\"}\n    let test_file = \"test_data.json\"\n    \n    // Save data\n    save_json(test_file, test_data)\n    assert(file_exists(test_file), \"File should be created\")\n    \n    // Load data\n    let loaded = load_json(test_file)\n    assert(loaded.test == \"value\", \"Data should persist\")\n    \n    // Cleanup\n    remove_file(test_file)\n    \n    println(\"✅ test_data_persistence passed\")\n}\n\nfun run_all_tests() {\n    println(\"🧪 Running application tests...\")\n    \n    test_user_creation()\n    test_data_persistence()\n    test_error_handling()\n    test_performance()\n    \n    println(\"\\n✅ All tests passed!\")\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmpg19VvQ/main.rs:1:501\n  |\n1 | ... } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let mut test_file = \"test_data.json\" ; save_json (te...\n  |                                                             ^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert (user . name == \"Alice\" , \"Name should be set\" . to_string ()) ; assert (user . email == \"alice@example.com\" , \"Email should be set\" . to_string ()) ; assert (user . id != null , \"ID should be generated\" . to_string ()) ; println ! (\"✅ test_user_creation passed\" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { SomeStruct { test : \"value\" , } } ; { let mut test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\" . to_string ()) ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\" . to_string ()) } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\" . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\" . to_string ()) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ++++++++++++                      +\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpg19VvQ/main.rs:1:427\n  |\n1 | ... . to_string ()) ; println ! (\"✅ test_user_creation passed\" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = {...\n  |                                                                 ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpg19VvQ/main.rs:1:429\n  |\n1 | ...ated\" . to_string ()) ; println ! (\"✅ test_user_creation passed\" . to_string ()) } } } } fn test_data_persistence () { { { let test_dat...\n  |                                       ------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                       |\n  |                                       formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpg19VvQ/main.rs:1:864\n  |\n1 | ...e (test_file) ; println ! (\"✅ test_data_persistence passed\" . to_string ()) } } } } fn run_all_tests () { { println ! (\"🧪 Running applic...\n  |                                                                 ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpg19VvQ/main.rs:1:866\n  |\n1 | ...ve_file (test_file) ; println ! (\"✅ test_data_persistence passed\" . to_string ()) } } } } fn run_all_tests () { { println ! (\"🧪 Running ...\n  |                                     ---------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                     |\n  |                                     formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpg19VvQ/main.rs:1:956\n  |\n1 | ...ll_tests () { { println ! (\"🧪 Running application tests...\" . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_e...\n  |                                                                 ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpg19VvQ/main.rs:1:958\n  |\n1 | ... run_all_tests () { { println ! (\"🧪 Running application tests...\" . to_string ()) ; test_user_creation () ; test_data_persistence () ; ...\n  |                                     ---------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                     |\n  |                                     formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpg19VvQ/main.rs:1:1107\n  |\n1 | ... ; test_performance () ; println ! (\"\\n✅ All tests passed!\" . to_string ()) } } fn main () { }\n  |                                                                 ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpg19VvQ/main.rs:1:1109\n  |\n1 | ...() ; test_performance () ; println ! (\"\\n✅ All tests passed!\" . to_string ()) } } fn main () { }\n  |                                          ------------------------   ^^^^^^^^^^^^ argument never used\n  |                                          |\n  |                                          formatting specifier missing\n\nerror[E0425]: cannot find value `null` in this scope\n --> /tmp/.tmpg19VvQ/main.rs:1:336\n  |\n1 | ...hould be set\" . to_string ()) ; assert (user . id != null , \"ID should be generated\" . to_string ()) ; println ! (\"✅ test_user_creation...\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::ptr::null;\n  |\n\nerror[E0425]: cannot find function `remove_file` in this scope\n --> /tmp/.tmpg19VvQ/main.rs:1:794\n  |\n1 | ...value\" , \"Data should persist\" . to_string ()) ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\" . to_string ()) ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_file;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpg19VvQ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" ....\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpg19VvQ/main.rs:1:64\n  |\n1 | ... { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert (user . name == \"Alice\" , \"Name should be set\" . to_string ()) ; assert (user . email == \"alice@example.com\" , \"Email should be set\" . to_string ()) ; assert (user . id != null , \"ID should be generated\" . to_string ()) ; println ! (\"✅ test_user_creation passed\" . to_string ()) } } } } f...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert (user . name == \"Alice\" , \"Name should be set\" . to_string ()) ; assert (user . email == \"alice@example.com\" , \"Email should be set\" . to_string ()) ; assert (user . id != null , \"ID should be generated\" . to_string ()) ; println ! (\"✅ test_user_creation passed\" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let mut test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\" . to_string ()) ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\" . to_string ()) } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\" . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\" . to_string ()) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test_user_creation () { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert (user . name == \"Alice\" , \"Name should be set\" . to_string ()) ; assert (user . email == \"alice@example.com\" , \"Email should be set\" . to_string ()) ; assert (user . id != null , \"ID should be generated\" . to_string ()) ; println ! (\"✅ test_user_creation passed\" . to_string ()) } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let mut test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\" . to_string ()) ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\" . to_string ()) } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\" . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\" . to_string ()) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpg19VvQ/main.rs:1:481\n  |\n1 | ... { { { let test_data = { test : \"value\" , } ; { let mut test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\" . to_string ()) ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\" . to_string ()) } } } } f...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert (user . name == \"Alice\" , \"Name should be set\" . to_string ()) ; assert (user . email == \"alice@example.com\" , \"Email should be set\" . to_string ()) ; assert (user . id != null , \"ID should be generated\" . to_string ()) ; println ! (\"✅ test_user_creation passed\" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let mut test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\" . to_string ()) ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\" . to_string ()) } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\" . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\" . to_string ()) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert (user . name == \"Alice\" , \"Name should be set\" . to_string ()) ; assert (user . email == \"alice@example.com\" , \"Email should be set\" . to_string ()) ; assert (user . id != null , \"ID should be generated\" . to_string ()) ; println ! (\"✅ test_user_creation passed\" . to_string ()) } } } } fn test_data_persistence () { { let test_data = { test : \"value\" , } ; { let mut test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\" . to_string ()) ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\" . to_string ()) } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\" . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\" . to_string ()) } } fn main () { }\n  |\n\nerror[E0425]: cannot find function `create_user` in this scope\n --> /tmp/.tmpg19VvQ/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" ....\n  |                                                                               ^^^^^^^^^^^ not found in this scope\n\nerror[E0423]: expected function, found macro `assert`\n --> /tmp/.tmpg19VvQ/main.rs:1:157\n  |\n1 | ... to_string () , \"alice@example.com\" . to_string ()) ; { assert (user . name == \"Alice\" , \"Name should be set\" . to_string ()) ; assert...\n  |                                                            ^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert! (user . name == \"Alice\" , \"Name should be set\" . to_string ()) ; assert (user . email == \"alice@example.com\" , \"Email should be set\" . to_string ()) ; assert (user . id != null , \"ID should be generated\" . to_string ()) ; println ! (\"✅ test_user_creation passed\" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let mut test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\" . to_string ()) ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\" . to_string ()) } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\" . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\" . to_string ()) } } fn main () { }\n  |                                                                                                                                                                   +\n\nerror[E0423]: expected function, found macro `assert`\n --> /tmp/.tmpg19VvQ/main.rs:1:229\n  |\n1 | ...ame == \"Alice\" , \"Name should be set\" . to_string ()) ; assert (user . email == \"alice@example.com\" , \"Email should be set\" . to_strin...\n  |                                                            ^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert (user . name == \"Alice\" , \"Name should be set\" . to_string ()) ; assert! (user . email == \"alice@example.com\" , \"Email should be set\" . to_string ()) ; assert (user . id != null , \"ID should be generated\" . to_string ()) ; println ! (\"✅ test_user_creation passed\" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let mut test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\" . to_string ()) ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\" . to_string ()) } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\" . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\" . to_string ()) } } fn main () { }\n  |                                                                                                                                                                                                                                           +\n\nerror[E0423]: expected function, found macro `assert`\n --> /tmp/.tmpg19VvQ/main.rs:1:315\n  |\n1 | ...@example.com\" , \"Email should be set\" . to_string ()) ; assert (user . id != null , \"ID should be generated\" . to_string ()) ; println...\n  |                                                            ^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert (user . name == \"Alice\" , \"Name should be set\" . to_string ()) ; assert (user . email == \"alice@example.com\" , \"Email should be set\" . to_string ()) ; assert! (user . id != null , \"ID should be generated\" . to_string ()) ; println ! (\"✅ test_user_creation passed\" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let mut test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\" . to_string ()) ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\" . to_string ()) } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\" . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\" . to_string ()) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                 +\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpg19VvQ/main.rs:1:429\n  |\n1 | ... ()) ; println ! (\"✅ test_user_creation passed\" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { test : \"val...\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `save_json` in this scope\n --> /tmp/.tmpg19VvQ/main.rs:1:565\n  |\n1 | ...e\" , } ; { let mut test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should b...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpg19VvQ/main.rs:1:609\n  |\n1 | ...n\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\" . to_string ()) ; let mut loaded =...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0423]: expected function, found macro `assert`\n --> /tmp/.tmpg19VvQ/main.rs:1:601\n  |\n1 | ... \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\" . to_string ()) ; l...\n  |                                                            ^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert (user . name == \"Alice\" , \"Name should be set\" . to_string ()) ; assert (user . email == \"alice@example.com\" , \"Email should be set\" . to_string ()) ; assert (user . id != null , \"ID should be generated\" . to_string ()) ; println ! (\"✅ test_user_creation passed\" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let mut test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert! (file_exists (test_file) , \"File should be created\" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\" . to_string ()) ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\" . to_string ()) } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\" . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\" . to_string ()) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +\n\nerror[E0425]: cannot find function `load_json` in this scope\n --> /tmp/.tmpg19VvQ/main.rs:1:695\n  |\n1 | ...ld be created\" . to_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\" . t...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0423]: expected function, found macro `assert`\n --> /tmp/.tmpg19VvQ/main.rs:1:719\n  |\n1 | ...o_string ()) ; let mut loaded = load_json (test_file) ; assert (loaded . test == \"value\" , \"Data should persist\" . to_string ()) ; rem...\n  |                                                            ^^^^^^ not a function\n  |\nhelp: use `!` to invoke the macro\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert (user . name == \"Alice\" , \"Name should be set\" . to_string ()) ; assert (user . email == \"alice@example.com\" , \"Email should be set\" . to_string ()) ; assert (user . id != null , \"ID should be generated\" . to_string ()) ; println ! (\"✅ test_user_creation passed\" . to_string ()) } } } } fn test_data_persistence () { { { let test_data = { test : \"value\" , } ; { let mut test_file = \"test_data.json\" ; save_json (test_file , test_data) ; assert (file_exists (test_file) , \"File should be created\" . to_string ()) ; let mut loaded = load_json (test_file) ; assert! (loaded . test == \"value\" , \"Data should persist\" . to_string ()) ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\" . to_string ()) } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\" . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\" . to_string ()) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      +\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpg19VvQ/main.rs:1:866\n  |\n1 | ...) ; println ! (\"✅ test_data_persistence passed\" . to_string ()) } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests....\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpg19VvQ/main.rs:1:958\n  |\n1 | ...{ { println ! (\"🧪 Running application tests...\" . to_string ()) ; test_user_creation () ; test_data_persistence () ; test_error_handlin...\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `test_error_handling` in this scope\n --> /tmp/.tmpg19VvQ/main.rs:1:1025\n  |\n1 | ...ser_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\" . to_str...\n  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `test_performance` in this scope\n --> /tmp/.tmpg19VvQ/main.rs:1:1050\n  |\n1 | ...data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\" . to_string ()) } } fn main () ...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpg19VvQ/main.rs:1:1109\n  |\n1 | ...ormance () ; println ! (\"\\n✅ All tests passed!\" . to_string ()) } } fn main () { }\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 26 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 9,
          "line_number": 733,
          "code": "// Status: ❌ BROKEN\n\n// build.ruchy - Build and package script\n\nfun build_release() {\n    println(\"🔨 Building release version...\")\n    \n    // Run tests first\n    run_tests()\n    \n    // Create release directory\n    let release_dir = \"release_\" + VERSION\n    create_dir_all(release_dir)\n    \n    // Copy application files\n    copy_file(\"main.ruchy\", join_path(release_dir, APP_NAME))\n    copy_dir(\"resources\", join_path(release_dir, \"resources\"))\n    \n    // Generate documentation\n    generate_docs(join_path(release_dir, \"docs\"))\n    \n    // Create installer script\n    let installer = f\"#!/bin/bash\necho 'Installing {APP_NAME} v{VERSION}'\nmkdir -p ~/.local/bin\ncp {APP_NAME} ~/.local/bin/\nchmod +x ~/.local/bin/{APP_NAME}\necho 'Installation complete! Run {APP_NAME} to start.'\n\"\n    write_file(join_path(release_dir, \"install.sh\"), installer)\n    \n    // Package as archive\n    create_archive(f\"{APP_NAME}-{VERSION}.tar.gz\", release_dir)\n    \n    println(f\"✅ Release built: {APP_NAME}-{VERSION}.tar.gz\")\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpts47tq/main.rs:1:104\n  |\n1 | use std :: collections :: HashMap ; fn build_release () { { println ! (\"🔨 Building release version...\" . to_string ()) ; run_tests () ; { ...\n  |                                                                                                         ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpts47tq/main.rs:1:106\n  |\n1 | ...n build_release () { { println ! (\"🔨 Building release version...\" . to_string ()) ; run_tests () ; { let release_dir = format ! (\"{}{}\"...\n  |                                      --------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                      |\n  |                                      formatting specifier missing\n\nerror[E0425]: cannot find value `VERSION` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:189\n  |\n1 | ... let release_dir = format ! (\"{}{}\" , \"release_\" , VERSION) ; { create_dir_all (release_dir) ; copy_file (\"main.ruchy\" . to_string () ...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `create_dir_all` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:202\n  |\n1 | ... = format ! (\"{}{}\" , \"release_\" , VERSION) ; { create_dir_all (release_dir) ; copy_file (\"main.ruchy\" . to_string () , join_path (rel...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::create_dir_all;\n  |\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:299\n  |\n1 | ...n.ruchy\" . to_string () , join_path (release_dir , APP_NAME)) ; copy_dir (\"resources\" . to_string () , join_path (release_dir , \"resou...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:665\n  |\n1 | ...cho 'Installation complete! Run {} to start.'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (relea...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `VERSION` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:676\n  |\n1 | ...lation complete! Run {} to start.'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"i...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:686\n  |\n1 | ...plete! Run {} to start.'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"install.sh\"...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:697\n  |\n1 | ...{} to start.'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"install.sh\" . to_strin...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:708\n  |\n1 | ....'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"install.sh\" . to_string ()) , ins...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:844\n  |\n1 | ...ller) ; create_archive (format ! (\"{}-{}.tar.gz\" , APP_NAME , VERSION) , release_dir) ; println ! (\"✅ Release built: {}-{}.tar.gz\" , AP...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `VERSION` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:855\n  |\n1 | ...ate_archive (format ! (\"{}-{}.tar.gz\" , APP_NAME , VERSION) , release_dir) ; println ! (\"✅ Release built: {}-{}.tar.gz\" , APP_NAME , VE...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:926\n  |\n1 | ...ir) ; println ! (\"✅ Release built: {}-{}.tar.gz\" , APP_NAME , VERSION) } } } } fn main () { }\n  |                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `VERSION` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:937\n  |\n1 | ...ln ! (\"✅ Release built: {}-{}.tar.gz\" , APP_NAME , VERSION) } } } } fn main () { }\n  |                                                        ^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpts47tq/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn build_release () { { println ! (\"🔨 Building release version...\" . to_string ()) ; run_tests () ; { ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:106\n  |\n1 | ... { { println ! (\"🔨 Building release version...\" . to_string ()) ; run_tests () ; { let release_dir = format ! (\"{}{}\" , \"release_\" , VE...\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `run_tests` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:122\n  |\n1 | ...\"🔨 Building release version...\" . to_string ()) ; run_tests () ; { let release_dir = format ! (\"{}{}\" , \"release_\" , VERSION) ; { creat...\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:274\n  |\n1 | ...e_dir) ; copy_file (\"main.ruchy\" . to_string () , join_path (release_dir , APP_NAME)) ; copy_dir (\"resources\" . to_string () , join_pa...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `copy_file` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:233\n  |\n1 | ...e_\" , VERSION) ; { create_dir_all (release_dir) ; copy_file (\"main.ruchy\" . to_string () , join_path (release_dir , APP_NAME)) ; copy_...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:351\n  |\n1 | ...P_NAME)) ; copy_dir (\"resources\" . to_string () , join_path (release_dir , \"resources\" . to_string ())) ; generate_docs (join_path (re...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `copy_dir` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:312\n  |\n1 | ..._string () , join_path (release_dir , APP_NAME)) ; copy_dir (\"resources\" . to_string () , join_path (release_dir , \"resources\" . to_st...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:422\n  |\n1 | ...r , \"resources\" . to_string ())) ; generate_docs (join_path (release_dir , \"docs\" . to_string ())) ; let mut installer = format ! (\"#!...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `generate_docs` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:407\n  |\n1 | ...h (release_dir , \"resources\" . to_string ())) ; generate_docs (join_path (release_dir , \"docs\" . to_string ())) ; let mut installer = ...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:732\n  |\n1 | ...N , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"install.sh\" . to_string ()) , installer) ; create_archive ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:720\n  |\n1 | ...AME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"install.sh\" . to_string ()) , installer) ; cre...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `create_archive` in this scope\n --> /tmp/.tmpts47tq/main.rs:1:801\n  |\n1 | ...r , \"install.sh\" . to_string ()) , installer) ; create_archive (format ! (\"{}-{}.tar.gz\" , APP_NAME , VERSION) , release_dir) ; printl...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 25 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch15-00-macros-metaprogramming": {
      "chapter": "ch15-00-macros-metaprogramming",
      "total_examples": 9,
      "working_examples": 0,
      "failing_examples": 9,
      "examples": [
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Define a macro for JSON-like syntax\nmacro! json {\n    // Match JSON-like input\n    ({ $($key:ident : $value:expr),* }) => {\n        {\n            let mut map = HashMap::new()\n            $(\n                map.insert(stringify!($key), json!($value))\n            )*\n            Value::Object(map)\n        }\n    }\n    ([ $($element:expr),* ]) => {\n        Value::Array(vec![$(json!($element)),*])\n    }\n    ($other:expr) => {\n        Value::from($other)\n    }\n}\n\n// Use it like native syntax!\nlet user = json!({\n    name: \"Alice\",\n    age: 30,\n    emails: [\"alice@example.com\", \"alice@work.com\"],\n    active: true,\n    metadata: {\n        created: \"2024-01-01\",\n        tags: [\"premium\", \"verified\"]\n    }\n})\n\n// Macro for automatic implementation\n#[derive(Debug, Clone, Serialize)]\nstruct User {\n    name: String\n    email: String\n    age: i32\n}\n\n// The derive macro generates all the boilerplate!",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 2,
          "line_number": 90,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Simple macro\nmacro! say_hello {\n    () => {\n        println(\"Hello, World!\")\n    }\n    ($name:expr) => {\n        println(f\"Hello, {$name}!\")\n    }\n}\n\nsay_hello!()           // Prints: Hello, World!\nsay_hello!(\"Alice\")    // Prints: Hello, Alice!\n\n// Macro with repetition\nmacro! vec_of_strings {\n    ($($x:expr),*) => {\n        vec![$(String::from($x)),*]\n    }\n}\n\nlet strings = vec_of_strings![\"one\", \"two\", \"three\"]\n\n// Recursive macro\nmacro! count {\n    () => { 0 }\n    ($head:expr) => { 1 }\n    ($head:expr, $($tail:expr),*) => {\n        1 + count!($($tail),*)\n    }\n}\n\nlet n = count!(a, b, c, d)  // 4\n\n// Macro generating match arms\nmacro! handle_codes {\n    ($($code:expr => $message:expr),*) => {\n        match status_code {\n            $($code => println($message)),*\n            _ => println(\"Unknown status\")\n        }\n    }\n}\n\nhandle_codes! {\n    200 => \"OK\",\n    404 => \"Not Found\",\n    500 => \"Internal Error\"\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 3,
          "line_number": 153,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Derive macro for automatic implementation\n#[proc_macro_derive(Builder)]\nfun derive_builder(input: TokenStream) -> TokenStream {\n    let ast = parse(input)\n    let name = ast.name\n    let builder_name = f\"{name}Builder\"\n    \n    let fields = ast.fields.map(|f| {\n        let name = f.name\n        let ty = f.ty\n        quote! {\n            fn $name(mut self, value: $ty) -> Self {\n                self.$name = Some(value)\n                self\n            }\n        }\n    })\n    \n    quote! {\n        struct $builder_name {\n            $($fields.name: Option<$fields.ty>),*\n        }\n        \n        impl $builder_name {\n            fun new() -> Self {\n                Self {\n                    $($fields.name: None),*\n                }\n            }\n            \n            $fields\n            \n            fun build(self) -> Result<$name, String> {\n                Ok($name {\n                    $($fields.name: self.$fields.name\n                        .ok_or(\"Missing field: \" + stringify!($fields.name))?,)*\n                })\n            }\n        }\n        \n        impl $name {\n            fun builder() -> $builder_name {\n                $builder_name::new()\n            }\n        }\n    }\n}\n\n// Use the derive macro\n#[derive(Builder)]\nstruct Config {\n    host: String\n    port: u16\n    workers: usize\n}\n\n// Generated builder pattern!\nlet config = Config::builder()\n    .host(\"localhost\")\n    .port(8080)\n    .workers(4)\n    .build()?",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 4,
          "line_number": 230,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Attribute macro for benchmarking\n#[proc_macro_attribute]\nfun bench(args: TokenStream, input: TokenStream) -> TokenStream {\n    let func = parse(input)\n    let name = func.name\n    \n    quote! {\n        fn $name() {\n            let start = Instant::now()\n            let result = { $func.body }\n            let duration = start.elapsed()\n            println(stringify!($name) + \" took \" + duration.to_s())\n            result\n        }\n    }\n}\n\n#[bench]\nfun expensive_operation() {\n    // Function body\n    heavy_computation()\n}\n// Automatically prints timing!\n\n// Route attribute for web framework\n#[route(GET, \"/users/:id\")]\nasync fun get_user(id: i32) -> Response {\n    let user = fetch_user(id).await?\n    Response::json(user)\n}\n\n// Test attribute with custom behavior\n#[test_case(1, 2, 3)]\n#[test_case(10, 20, 30)]\n#[test_case(-1, -2, -3)]\nfun test_addition(a: i32, b: i32, expected: i32) {\n    assert_eq!(a + b, expected)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 5,
          "line_number": 283,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// SQL-like macro\nmacro! sql {\n    (SELECT $($field:ident),* FROM $table:ident WHERE $($cond:tt)*) => {\n        Query::select(vec![$(stringify!($field)),*])\n            .from(stringify!($table))\n            .where(parse_condition!($($cond)*))\n    }\n}\n\nlet query = sql! {\n    SELECT name, email, age \n    FROM users \n    WHERE age > 18 AND active = true\n}\n\n// HTML templating\nmacro! html {\n    (<$tag:ident $($attr:ident = $value:expr)*> $($content:tt)* </$close:ident>) => {\n        Element::new(stringify!($tag))\n            $(.attr(stringify!($attr), $value))*\n            .children(vec![$(html!($content)),*])\n    }\n    ($text:expr) => {\n        Text::new($text)\n    }\n}\n\nlet page = html! {\n    <div class=\"container\">\n        <h1>\"Welcome\"</h1>\n        <p>\"This is \"<strong>\"Ruchy\"</strong>\" macros!\"</p>\n    </div>\n}\n\n// Regular expression literals\nmacro! regex {\n    ($pattern:expr) => {\n        {\n            static REGEX: OnceCell<Regex> = OnceCell::new()\n            REGEX.get_or_init(|| {\n                Regex::new($pattern).expect(\"Invalid regex\")\n            })\n        }\n    }\n}\n\nlet email_regex = regex!(r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 6,
          "line_number": 345,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Debug print with variable names\nmacro! dbg {\n    ($($x:expr),*) => {\n        $(\n            eprintln!(\"{} = {:?}\", stringify!($x), $x)\n        )*\n    }\n}\n\nlet x = 42\nlet y = \"hello\"\ndbg!(x, y, x + 10)\n// Prints:\n// x = 42\n// y = \"hello\"\n// x + 10 = 52\n\n// Trace macro for function calls\nmacro! trace {\n    ($func:expr) => {\n        {\n            println(\"Entering \" + stringify!($func))\n            let result = $func\n            println(\"Leaving \" + stringify!($func) + \": \" + result.to_s())\n            result\n        }\n    }\n}\n\nlet result = trace!(expensive_calculation())\n\n// Assert with custom messages\nmacro! assert_eq_msg {\n    ($left:expr, $right:expr, $msg:expr) => {\n        if $left != $right {\n            panic($msg + \"\\nLeft: \" + $left.to_s() + \"\\nRight: \" + $right.to_s())\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 7,
          "line_number": 397,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Generate getters and setters\nmacro! accessors {\n    ($struct_name:ident { $($field:ident : $type:ty),* }) => {\n        impl $struct_name {\n            $(\n                fn $field(&self) -> &$type {\n                    &self.$field\n                }\n                \n                fn set_$field(&mut self, value: $type) {\n                    self.$field = value\n                }\n            )*\n        }\n    }\n}\n\nstruct Person {\n    name: String\n    age: i32\n}\n\naccessors!(Person { name: String, age: i32 })\n\n// Now person.name() and person.set_name() exist!\n\n// Generate enum variants and matchers\nmacro! define_opcodes {\n    ($($name:ident = $value:expr),*) => {\n        enum Opcode {\n            $($name = $value),*\n        }\n        \n        impl Opcode {\n            fun from_byte(byte: u8) -> Option<Opcode> {\n                match byte {\n                    $($value => Some(Opcode::$name)),*\n                    _ => None\n                }\n            }\n            \n            fun to_string(&self) -> &str {\n                match self {\n                    $(Opcode::$name => stringify!($name)),*\n                }\n            }\n        }\n    }\n}\n\ndefine_opcodes! {\n    ADD = 0x01,\n    SUB = 0x02,\n    MUL = 0x03,\n    DIV = 0x04,\n    JMP = 0x10,\n    JEQ = 0x11\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 8,
          "line_number": 468,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// State machine DSL\nmacro! state_machine {\n    (\n        states: [$($state:ident),*]\n        transitions: [\n            $($from:ident -> $to:ident on $event:ident),*\n        ]\n        initial: $initial:ident\n    ) => {\n        enum State {\n            $($state),*\n        }\n        \n        enum Event {\n            $($event),*\n        }\n        \n        struct StateMachine {\n            state: State\n        }\n        \n        impl StateMachine {\n            fun new() -> Self {\n                Self { state: State::$initial }\n            }\n            \n            fun transition(&mut self, event: Event) {\n                self.state = match (&self.state, event) {\n                    $(\n                        (State::$from, Event::$event) => State::$to,\n                    )*\n                    _ => panic(\"Invalid transition\")\n                }\n            }\n        }\n    }\n}\n\nstate_machine! {\n    states: [Idle, Running, Paused, Stopped]\n    transitions: [\n        Idle -> Running on Start,\n        Running -> Paused on Pause,\n        Paused -> Running on Resume,\n        Running -> Stopped on Stop,\n        Paused -> Stopped on Stop\n    ]\n    initial: Idle\n}\n\n// Configuration DSL\nmacro! config {\n    {\n        $($section:ident {\n            $($key:ident : $value:expr),*\n        })*\n    } => {\n        {\n            let mut config = Config::new()\n            $(\n                let mut section = ConfigSection::new(stringify!($section))\n                $(\n                    section.set(stringify!($key), $value)\n                )*\n                config.add_section(section)\n            )*\n            config\n        }\n    }\n}\n\nlet config = config! {\n    server {\n        host: \"localhost\",\n        port: 8080,\n        workers: 4\n    }\n    database {\n        url: \"postgres://localhost/myapp\",\n        pool_size: 20\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 9,
          "line_number": 563,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Hygienic macros prevent name collisions\nmacro! safe_swap {\n    ($a:expr, $b:expr) => {\n        {\n            // Generated names won't conflict\n            let __temp = $a\n            $a = $b\n            $b = __temp\n        }\n    }\n}\n\n// Best practices:\n// 1. Keep macros simple\n// 2. Provide good error messages\nmacro! validate {\n    ($expr:expr) => {\n        if !$expr {\n            compile_error!(concat!(\n                \"Validation failed: \",\n                stringify!($expr)\n            ))\n        }\n    }\n}\n\n// 3. Document macro syntax\n/// Creates a new vector with the given elements\n/// \n/// # Example\n/// ```\n/// let v = vec![1, 2, 3]\n/// ```\nmacro! vec {\n    // Implementation\n}\n\n// 4. Use macro namespaces\nmod macros {\n    macro! internal_helper {\n        // Not exported\n    }\n    \n    #[macro_export]\n    macro! public_macro {\n        // Exported\n    }\n}\n\n// 5. Test macros thoroughly\n#[test]\nfun test_macro() {\n    let result = my_macro!(input)\n    assert_eq!(result, expected)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch09-00-network-programming": {
      "chapter": "ch09-00-network-programming",
      "total_examples": 10,
      "working_examples": 0,
      "failing_examples": 10,
      "examples": [
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: web_server.ruchy\n// HTTP server with routing and middleware\n\nuse std::net::http;\n\nlet server = http::Server::new(\"0.0.0.0:8080\")\n\n// Middleware for logging\nserver.use(|req, res, next| {\n    let start = current_time_ms()\n    next()\n    let duration = current_time_ms() - start\n    println(req.method + \" \" + req.path + \" - \" + res.status.to_s() + \" (\" + duration.to_s() + \"ms)\")\n})\n\n// Routes\nserver.get(\"/\", |req, res| {\n    res.html(\"<h1>Welcome to Ruchy Server!</h1>\")\n})\n\nserver.get(\"/api/users\", |req, res| {\n    let users = [\n        {id: 1, name: \"Alice\", email: \"alice@example.com\"},\n        {id: 2, name: \"Bob\", email: \"bob@example.com\"}\n    ]\n    res.json(users)\n})\n\nserver.post(\"/api/users\", |req, res| {\n    let user = req.json()\n    println(\"Creating user: \" + user.name)\n    user.id = generate_id()\n    user.created = current_datetime()\n    res.status(201).json(user)\n})\n\n// Static files\nserver.static(\"/public\", \"./static\")\n\n// Start server\nprintln(f\"🚀 Server running on http://localhost:8080\")\nserver.listen()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 2,
          "line_number": 91,
          "code": "// Status: ❌ BROKEN\n\n// TCP Server\nlet server = net::TcpListener::bind(\"127.0.0.1:9000\")\nprintln(\"Server listening on port 9000\")\n\nloop {\n    let client = server.accept()\n    \n    // Handle each client in a separate thread\n    spawn {\n        println(\"Client connected: \" + client.remote_addr())\n        \n        loop {\n            let message = client.read_line()\n            if message.is_empty() {\n                break\n            }\n            \n            println(\"Received: \" + message)\n            client.write(\"Echo: \" + message + \"\\n\")\n        }\n        \n        println(\"Client disconnected\")\n    }\n}\n\n// TCP Client\nlet client = net::TcpStream::connect(\"127.0.0.1:9000\")\nclient.write(\"Hello, server!\\n\")\nlet response = client.read_line()\nprintln(\"Server replied: \" + response)",
          "passed": false,
          "status": "broken",
          "error": "\nthread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:\n\"net::TcpListener\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 3,
          "line_number": 136,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Simple GET request\nlet response = http::get(\"https://api.example.com/data\")\nlet data = response.json()\nprintln(\"Got \" + data.items.len().to_s() + \" items\")\n\n// POST with JSON\nlet user = {\n    name: \"Alice\",\n    email: \"alice@example.com\"\n}\nlet response = http::post(\"https://api.example.com/users\")\n    .json(user)\n    .send()\n\n// Advanced requests\nlet response = http::request(\"https://api.example.com/data\")\n    .method(\"GET\")\n    .header(\"Authorization\", \"Bearer \" + token)\n    .header(\"User-Agent\", \"Ruchy/1.0\")\n    .query(\"page\", 1)\n    .query(\"limit\", 100)\n    .timeout(5000)\n    .send()\n\nif response.is_success() {\n    let data = response.json()\n    process_data(data)\n} else {\n    println(\"Error: \" + response.status.to_s() + \" - \" + response.text())\n}\n\n// Download file with progress\nhttp::download(\"https://example.com/big-file.zip\", \"downloads/file.zip\")\n    .on_progress(|downloaded, total| {\n        let percent = (downloaded / total) * 100\n        print(\"\\rDownloading: \" + percent.to_s() + \"%\")\n    })\n    .await()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 4,
          "line_number": 189,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// WebSocket Server\nlet ws_server = ws::Server::new(\"0.0.0.0:8081\")\n\nws_server.on_connection(|socket| {\n    println(\"WebSocket connected: \" + socket.id)\n    \n    socket.on(\"message\", |data| {\n        println(\"Received: \" + data)\n        \n        // Broadcast to all clients\n        ws_server.broadcast({\n            type: \"chat\",\n            user: socket.id,\n            message: data\n        })\n    })\n    \n    socket.on(\"close\", || {\n        println(\"WebSocket disconnected: \" + socket.id)\n    })\n})\n\nws_server.listen()\n\n// WebSocket Client\nlet ws = ws::connect(\"ws://localhost:8081\")\n\nws.on(\"open\", || {\n    println(\"Connected to server\")\n    ws.send(\"Hello, server!\")\n})\n\nws.on(\"message\", |data| {\n    println(\"Server says: \" + data)\n})\n\nws.on(\"error\", |err| {\n    println(\"WebSocket error: \" + err.to_s())\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 5,
          "line_number": 243,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: api_server.ruchy\n// RESTful API with database\n\nuse std::net::http;\nuse std::db;\n\nlet app = http::Server::new(\"0.0.0.0:3000\")\nlet database = db::connect(\"sqlite:data.db\")\n\n// CORS middleware\napp.use(|req, res, next| {\n    res.header(\"Access-Control-Allow-Origin\", \"*\")\n    res.header(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE\")\n    next()\n})\n\n// Authentication middleware\nfun require_auth(req, res, next) {\n    let token = req.header(\"Authorization\")\n    if !token || !validate_token(token) {\n        return res.status(401).json({error: \"Unauthorized\"})\n    }\n    req.user = decode_token(token)\n    next()\n}\n\n// Routes\napp.get(\"/api/posts\", |req, res| {\n    let page = req.query(\"page\", 1)\n    let limit = req.query(\"limit\", 10)\n    \n    let posts = database.query(\"\n        SELECT * FROM posts \n        ORDER BY created_at DESC \n        LIMIT ? OFFSET ?\n    \", [limit, (page - 1) * limit])\n    \n    res.json({\n        posts: posts,\n        page: page,\n        total: database.count(\"posts\")\n    })\n})\n\napp.get(\"/api/posts/:id\", |req, res| {\n    let id = req.params.id\n    let post = database.find(\"posts\", id)\n    \n    if post {\n        res.json(post)\n    } else {\n        res.status(404).json({error: \"Post not found\"})\n    }\n})\n\napp.post(\"/api/posts\", require_auth, |req, res| {\n    let post = req.json()\n    post.author_id = req.user.id\n    post.created_at = current_datetime()\n    \n    let id = database.insert(\"posts\", post)\n    let created = database.find(\"posts\", id)\n    \n    res.status(201).json(created)\n})\n\napp.put(\"/api/posts/:id\", require_auth, |req, res| {\n    let id = req.params.id\n    let updates = req.json()\n    \n    // Check ownership\n    let post = database.find(\"posts\", id)\n    if post.author_id != req.user.id {\n        return res.status(403).json({error: \"Forbidden\"})\n    }\n    \n    updates.updated_at = current_datetime()\n    database.update(\"posts\", id, updates)\n    \n    res.json(database.find(\"posts\", id))\n})\n\napp.delete(\"/api/posts/:id\", require_auth, |req, res| {\n    let id = req.params.id\n    \n    // Check ownership\n    let post = database.find(\"posts\", id)\n    if post.author_id != req.user.id {\n        return res.status(403).json({error: \"Forbidden\"})\n    }\n    \n    database.delete(\"posts\", id)\n    res.status(204).send()\n})\n\n// Error handling\napp.use(|err, req, res, next| {\n    console.error(\"Error: \" + err.to_s())\n    res.status(500).json({\n        error: \"Internal server error\",\n        message: err.message\n    })\n})\n\nprintln(\"🚀 API server running on http://localhost:3000\")\napp.listen()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 6,
          "line_number": 362,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: chat_server.ruchy\n// Multi-room chat server with history\n\nuse std::net::ws;\n\nlet server = ws::Server::new(\"0.0.0.0:8080\")\nlet rooms = {}\nlet users = {}\n\nfun broadcast_to_room(room_id, message, exclude_user = null) {\n    if rooms.has_key(room_id) {\n        for user_id in rooms[room_id] {\n            if user_id != exclude_user {\n                users[user_id].socket.send(message)\n            }\n        }\n    }\n}\n\nserver.on_connection(|socket| {\n    let user = {\n        id: generate_id(),\n        socket: socket,\n        name: null,\n        room: null,\n        joined_at: current_datetime()\n    }\n    \n    users[user.id] = user\n    \n    socket.send(json({\n        type: \"welcome\",\n        user_id: user.id,\n        message: \"Welcome to chat! Send /help for commands\"\n    }))\n    \n    socket.on(\"message\", |data| {\n        let msg = parse_json(data)\n        \n        match msg.type {\n            \"join\" => {\n                user.name = msg.name\n                user.room = msg.room\n                \n                // Add user to room\n                if !rooms.has_key(msg.room) {\n                    rooms[msg.room] = []\n                }\n                rooms[msg.room].push(user.id)\n                \n                // Notify room\n                broadcast_to_room(msg.room, json({\n                    type: \"user_joined\",\n                    user: user.name,\n                    time: current_datetime()\n                }))\n                \n                // Send room history\n                let history = get_room_history(msg.room)\n                socket.send(json({\n                    type: \"history\",\n                    messages: history\n                }))\n            }\n            \n            \"message\" => {\n                let chat_msg = {\n                    type: \"message\",\n                    user: user.name,\n                    text: msg.text,\n                    time: current_datetime()\n                }\n                \n                // Save to history\n                save_message(user.room, chat_msg)\n                \n                // Broadcast to room\n                broadcast_to_room(user.room, json(chat_msg))\n            }\n            \n            \"private\" => {\n                let target = find_user_by_name(msg.to)\n                if target {\n                    target.socket.send(json({\n                        type: \"private\",\n                        from: user.name,\n                        text: msg.text,\n                        time: current_datetime()\n                    }))\n                }\n            }\n            \n            \"typing\" => {\n                broadcast_to_room(user.room, json({\n                    type: \"typing\",\n                    user: user.name\n                }), user.id)\n            }\n        }\n    })\n    \n    socket.on(\"close\", || {\n        // Remove from room\n        if user.room && rooms.has_key(user.room) {\n            rooms[user.room] = rooms[user.room].filter(|id| id != user.id)\n            \n            broadcast_to_room(user.room, json({\n                type: \"user_left\",\n                user: user.name,\n                time: current_datetime()\n            }))\n        }\n        \n        users.remove(user.id)\n    })\n})\n\nprintln(\"💬 Chat server running on ws://localhost:8080\")\nserver.listen()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 7,
          "line_number": 494,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: network_scanner.ruchy\n// Scan network for open ports and services\n\nuse std::net;\nuse std::async;\n\nprintln(\"=== Network Scanner ===\")\n\nfun scan_port(host, port, timeout = 1000) {\n    try {\n        let socket = net::TcpStream::connect_timeout(\n            host + \":\" + port.to_s(), \n            timeout\n        )\n        socket.close()\n        return true\n    } catch {\n        return false\n    }\n}\n\nfun identify_service(port) {\n    let services = {\n        21: \"FTP\",\n        22: \"SSH\",\n        23: \"Telnet\",\n        25: \"SMTP\",\n        53: \"DNS\",\n        80: \"HTTP\",\n        110: \"POP3\",\n        143: \"IMAP\",\n        443: \"HTTPS\",\n        445: \"SMB\",\n        3306: \"MySQL\",\n        5432: \"PostgreSQL\",\n        6379: \"Redis\",\n        8080: \"HTTP-Alt\",\n        8443: \"HTTPS-Alt\",\n        27017: \"MongoDB\"\n    }\n    \n    return services.get(port, \"Unknown\")\n}\n\nfun scan_host(host, ports) {\n    println(\"\\nScanning \" + host + \"...\")\n    let open_ports = []\n    \n    // Parallel port scanning\n    let tasks = []\n    for port in ports {\n        tasks.push(async {\n            if scan_port(host, port) {\n                return port\n            }\n            return null\n        })\n    }\n    \n    let results = async::wait_all(tasks)\n    \n    for port in results {\n        if port {\n            let service = identify_service(port)\n            open_ports.push({port: port, service: service})\n            println(\"  ✓ Port \" + port.to_s() + \" open - \" + service)\n        }\n    }\n    \n    return open_ports\n}\n\n// Get scan parameters\nlet target = input(\"Target host (IP or domain): \")\nlet scan_type = input(\"Scan type (quick/full/custom): \")\n\nlet ports = match scan_type {\n    \"quick\" => [21, 22, 23, 25, 80, 443, 3306, 5432, 8080]\n    \"full\" => range(1, 65535)\n    \"custom\" => {\n        let range_str = input(\"Port range (e.g., 1-1000): \")\n        let parts = range_str.split(\"-\")\n        range(parts[0].to_i(), parts[1].to_i())\n    }\n    _ => [80, 443]\n}\n\nprintln(\"\\nScanning \" + ports.len().to_s() + \" ports on \" + target + \"...\")\nlet start_time = current_time_ms()\n\nlet results = scan_host(target, ports)\n\nlet duration = (current_time_ms() - start_time) / 1000\nprintln(\"\\nScan complete in \" + duration.to_s() + \"s\")\nprintln(\"Found \" + results.len().to_s() + \" open ports\")\n\n// Generate report\nif results.len() > 0 {\n    println(\"\\n=== Open Services ===\")\n    for item in results.sort_by(|r| r.port) {\n        println(item.port.to_s() + \" - \" + item.service)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 8,
          "line_number": 610,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: load_balancer.ruchy\n// HTTP load balancer with health checking\n\nuse std::net::http;\n\nlet backends = [\n    {url: \"http://server1:8080\", weight: 1, healthy: true},\n    {url: \"http://server2:8080\", weight: 2, healthy: true},\n    {url: \"http://server3:8080\", weight: 1, healthy: true}\n]\n\nlet current_backend = 0\n\nfun select_backend() {\n    // Weighted round-robin selection\n    let healthy_backends = backends.filter(|b| b.healthy)\n    \n    if healthy_backends.is_empty() {\n        throw \"No healthy backends available\"\n    }\n    \n    // Simple round-robin for now\n    current_backend = (current_backend + 1) % healthy_backends.len()\n    return healthy_backends[current_backend]\n}\n\nfun health_check() {\n    for backend in backends {\n        try {\n            let response = http::get(backend.url + \"/health\")\n                .timeout(2000)\n                .send()\n            \n            backend.healthy = response.status == 200\n        } catch {\n            backend.healthy = false\n        }\n        \n        let status = backend.healthy ? \"✓\" : \"✗\"\n        println(\"Health check \" + backend.url + \": \" + status)\n    }\n}\n\n// Start health check timer\nspawn {\n    loop {\n        health_check()\n        sleep(10000)  // Check every 10 seconds\n    }\n}\n\n// Create load balancer server\nlet balancer = http::Server::new(\"0.0.0.0:80\")\n\nbalancer.all(\"*\", |req, res| {\n    let backend = select_backend()\n    \n    println(\"Routing \" + req.method + \" \" + req.path + \" -> \" + backend.url)\n    \n    // Forward request\n    let backend_response = http::request(backend.url + req.path)\n        .method(req.method)\n        .headers(req.headers)\n        .body(req.body)\n        .send()\n    \n    // Return response\n    res.status(backend_response.status)\n        .headers(backend_response.headers)\n        .send(backend_response.body)\n})\n\nprintln(\"🔄 Load balancer running on port 80\")\nprintln(\"Backends: \" + backends.len().to_s())\nbalancer.listen()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 9,
          "line_number": 702,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Custom protocol over TCP\nfun send_packet(socket, type, data) {\n    let packet = {\n        version: 1,\n        type: type,\n        timestamp: current_time_ms(),\n        data: data\n    }\n    \n    let json = to_json(packet)\n    let length = json.len()\n    \n    // Send length-prefixed message\n    socket.write_u32(length)\n    socket.write(json)\n}\n\nfun receive_packet(socket) {\n    let length = socket.read_u32()\n    let json = socket.read(length)\n    return parse_json(json)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 10,
          "line_number": 737,
          "code": "// Status: ❌ BROKEN\n\n// Monitor network traffic\nlet monitor = net::PacketCapture::new(\"eth0\")\n\nmonitor.on_packet(|packet| {\n    if packet.protocol == \"TCP\" {\n        println(\"TCP: \" + packet.src + \":\" + packet.src_port.to_s() + \" -> \" + packet.dst + \":\" + packet.dst_port.to_s())\n    } else if packet.protocol == \"UDP\" {\n        println(\"UDP: \" + packet.src + \" -> \" + packet.dst + \" (\" + packet.size.to_s() + \" bytes)\")\n    }\n})\n\nmonitor.start()",
          "passed": false,
          "status": "broken",
          "error": "\nthread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:\n\"net::PacketCapture\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch07-00-error-handling-tdd": {
      "chapter": "ch07-00-error-handling-tdd",
      "total_examples": 9,
      "working_examples": 0,
      "failing_examples": 9,
      "examples": [
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Before operation\");\n    if true {\n        println(\"Operation successful\");\n    }\n    println(\"After operation\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmp96zDBv/main.rs:1:82\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Before operation\" . to_string ()) ; if true { { println ! (\"Operation succ...\n  |                                                                                  ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmp96zDBv/main.rs:1:84\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Before operation\" . to_string ()) ; if true { { println ! (\"Operation succ...\n  |                                                               ------------------   ^^^^^^^^^^^^ argument never used\n  |                                                               |\n  |                                                               formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmp96zDBv/main.rs:1:146\n  |\n1 | ..._string ()) ; if true { { println ! (\"Operation successful\" . to_string ()) } } ; println ! (\"After operation\" . to_string ()) } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmp96zDBv/main.rs:1:148\n  |\n1 | ...o_string ()) ; if true { { println ! (\"Operation successful\" . to_string ()) } } ; println ! (\"After operation\" . to_string ()) } }\n  |                                          ----------------------   ^^^^^^^^^^^^ argument never used\n  |                                          |\n  |                                          formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmp96zDBv/main.rs:1:197\n  |\n1 | ...cessful\" . to_string ()) } } ; println ! (\"After operation\" . to_string ()) } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmp96zDBv/main.rs:1:199\n  |\n1 | ...essful\" . to_string ()) } } ; println ! (\"After operation\" . to_string ()) } }\n  |                                             -----------------   ^^^^^^^^^^^^ argument never used\n  |                                             |\n  |                                             formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp96zDBv/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Before operation\" . to_string ()) ; if true { { println ! (\"Operation succ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp96zDBv/main.rs:1:110\n  |\n1 | ... operation\" . to_string ()) ; if true { { println ! (\"Operation successful\" . to_string ()) } } ; println ! (\"After operation\" . to_st...\n  |                                            ^^                                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { println ! (\"Before operation\" . to_string ()) ; if true { { println ! (\"Operation successful\" . to_string ()) } } ; println ! (\"After operation\" . to_string ()) } }\n1 + use std :: collections :: HashMap ; fn main () { { println ! (\"Before operation\" . to_string ()) ; if true { println ! (\"Operation successful\" . to_string ()) } ; println ! (\"After operation\" . to_string ()) } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmp96zDBv/main.rs:1:84\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Before operation\" . to_string ()) ; if true { { println ! (\"Operation succ...\n  |                                                                                    ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmp96zDBv/main.rs:1:148\n  |\n1 | ...; if true { { println ! (\"Operation successful\" . to_string ()) } } ; println ! (\"After operation\" . to_string ()) } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmp96zDBv/main.rs:1:199\n  |\n1 | ...o_string ()) } } ; println ! (\"After operation\" . to_string ()) } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 9 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 2,
          "line_number": 56,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let number = 5;\n    if number > 0 {\n        println(\"Valid number\");\n    } else {\n        println(\"Invalid number\");\n    }\n    \n    let zero = 0;\n    if zero == 0 {\n        println(\"Warning: Zero value detected\");\n    } else {\n        println(\"Non-zero value\");\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpwCkJZ0/main.rs:1:123\n  |\n1 | ...r = 5i32 ; { if number > 0i32 { { println ! (\"Valid number\" . to_string ()) } } else { { println ! (\"Invalid number\" . to_string ()) }...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpwCkJZ0/main.rs:1:125\n  |\n1 | ... 5i32 ; { if number > 0i32 { { println ! (\"Valid number\" . to_string ()) } } else { { println ! (\"Invalid number\" . to_string ()) } } ...\n  |                                              --------------   ^^^^^^^^^^^^ argument never used\n  |                                              |\n  |                                              formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpwCkJZ0/main.rs:1:180\n  |\n1 | ...r\" . to_string ()) } } else { { println ! (\"Invalid number\" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpwCkJZ0/main.rs:1:182\n  |\n1 | ... . to_string ()) } } else { { println ! (\"Invalid number\" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! (\"...\n  |                                             ----------------   ^^^^^^^^^^^^ argument never used\n  |                                             |\n  |                                             formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpwCkJZ0/main.rs:1:286\n  |\n1 | ... zero == 0i32 { { println ! (\"Warning: Zero value detected\" . to_string ()) } } else { { println ! (\"Non-zero value\" . to_string ()) }...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpwCkJZ0/main.rs:1:288\n  |\n1 | ... ; if zero == 0i32 { { println ! (\"Warning: Zero value detected\" . to_string ()) } } else { { println ! (\"Non-zero value\" . to_string ...\n  |                                      ------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                      |\n  |                                      formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpwCkJZ0/main.rs:1:343\n  |\n1 | ...d\" . to_string ()) } } else { { println ! (\"Non-zero value\" . to_string ()) } } } } } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpwCkJZ0/main.rs:1:345\n  |\n1 | ... . to_string ()) } } else { { println ! (\"Non-zero value\" . to_string ()) } } } } } }\n  |                                             ----------------   ^^^^^^^^^^^^ argument never used\n  |                                             |\n  |                                             formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpwCkJZ0/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! (\"Valid number\" . to_string ())...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpwCkJZ0/main.rs:1:50\n  |\n1 | ... { { { let number = 5i32 ; { if number > 0i32 { { println ! (\"Valid number\" . to_string ()) } } else { { println ! (\"Invalid number\" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! (\"Warning: Zero value detected\" . to_string ()) } } else { { println ! (\"Non-zero value\" . to_string ()) } } } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! (\"Valid number\" . to_string ()) } } else { { println ! (\"Invalid number\" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! (\"Warning: Zero value detected\" . to_string ()) } } else { { println ! (\"Non-zero value\" . to_string ()) } } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let number = 5i32 ; { if number > 0i32 { { println ! (\"Valid number\" . to_string ()) } } else { { println ! (\"Invalid number\" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! (\"Warning: Zero value detected\" . to_string ()) } } else { { println ! (\"Non-zero value\" . to_string ()) } } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpwCkJZ0/main.rs:1:95\n  |\n1 | ... { let number = 5i32 ; { if number > 0i32 { { println ! (\"Valid number\" . to_string ()) } } else { { println ! (\"Invalid number\" . to_...\n  |                                                ^^                                         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! (\"Valid number\" . to_string ()) } } else { { println ! (\"Invalid number\" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! (\"Warning: Zero value detected\" . to_string ()) } } else { { println ! (\"Non-zero value\" . to_string ()) } } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { println ! (\"Valid number\" . to_string ()) } else { { println ! (\"Invalid number\" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! (\"Warning: Zero value detected\" . to_string ()) } } else { { println ! (\"Non-zero value\" . to_string ()) } } } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpwCkJZ0/main.rs:1:150\n  |\n1 | ...(\"Valid number\" . to_string ()) } } else { { println ! (\"Invalid number\" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 {...\n  |                                               ^^                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! (\"Valid number\" . to_string ()) } } else { { println ! (\"Invalid number\" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! (\"Warning: Zero value detected\" . to_string ()) } } else { { println ! (\"Non-zero value\" . to_string ()) } } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! (\"Valid number\" . to_string ()) } } else { println ! (\"Invalid number\" . to_string ()) } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! (\"Warning: Zero value detected\" . to_string ()) } } else { { println ! (\"Non-zero value\" . to_string ()) } } } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpwCkJZ0/main.rs:1:242\n  |\n1 | ...mut zero = 0i32 ; if zero == 0i32 { { println ! (\"Warning: Zero value detected\" . to_string ()) } } else { { println ! (\"Non-zero valu...\n  |                                        ^^                                                         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! (\"Valid number\" . to_string ()) } } else { { println ! (\"Invalid number\" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! (\"Warning: Zero value detected\" . to_string ()) } } else { { println ! (\"Non-zero value\" . to_string ()) } } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! (\"Valid number\" . to_string ()) } } else { { println ! (\"Invalid number\" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { println ! (\"Warning: Zero value detected\" . to_string ()) } else { { println ! (\"Non-zero value\" . to_string ()) } } } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpwCkJZ0/main.rs:1:313\n  |\n1 | ...value detected\" . to_string ()) } } else { { println ! (\"Non-zero value\" . to_string ()) } } } } } }\n  |                                               ^^                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! (\"Valid number\" . to_string ()) } } else { { println ! (\"Invalid number\" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! (\"Warning: Zero value detected\" . to_string ()) } } else { { println ! (\"Non-zero value\" . to_string ()) } } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let number = 5i32 ; { if number > 0i32 { { println ! (\"Valid number\" . to_string ()) } } else { { println ! (\"Invalid number\" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! (\"Warning: Zero value detected\" . to_string ()) } } else { println ! (\"Non-zero value\" . to_string ()) } } } } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpwCkJZ0/main.rs:1:125\n  |\n1 | ... if number > 0i32 { { println ! (\"Valid number\" . to_string ()) } } else { { println ! (\"Invalid number\" . to_string ()) } } ; let mut...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpwCkJZ0/main.rs:1:182\n  |\n1 | ...ng ()) } } else { { println ! (\"Invalid number\" . to_string ()) } } ; let mut zero = 0i32 ; if zero == 0i32 { { println ! (\"Warning: Z...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpwCkJZ0/main.rs:1:288\n  |\n1 | ...2 { { println ! (\"Warning: Zero value detected\" . to_string ()) } } else { { println ! (\"Non-zero value\" . to_string ()) } } } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpwCkJZ0/main.rs:1:345\n  |\n1 | ...ng ()) } } else { { println ! (\"Non-zero value\" . to_string ()) } } } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 12 previous errors; 6 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 3,
          "line_number": 87,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let age = 25;\n    match age {\n        0 => println(\"Error: Age cannot be zero\"),\n        1..=17 => println(\"Minor\"),\n        18..=65 => println(\"Adult\"),\n        _ => println(\"Senior\")\n    }\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmprBqv4s/main.rs:1:131\n  |\n1 | ... match age { 0i32 => println ! (\"Error: Age cannot be zero\" . to_string ()) , 1i32 ..= 17i32 => println ! (\"Minor\" . to_string ()) , 1...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmprBqv4s/main.rs:1:133\n  |\n1 | ...32 ; match age { 0i32 => println ! (\"Error: Age cannot be zero\" . to_string ()) , 1i32 ..= 17i32 => println ! (\"Minor\" . to_string ())...\n  |                                        ---------------------------   ^^^^^^^^^^^^ argument never used\n  |                                        |\n  |                                        formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmprBqv4s/main.rs:1:186\n  |\n1 | ...ero\" . to_string ()) , 1i32 ..= 17i32 => println ! (\"Minor\" . to_string ()) , 18i32 ..= 65i32 => println ! (\"Adult\" . to_string ()) , ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmprBqv4s/main.rs:1:188\n  |\n1 | ... to_string ()) , 1i32 ..= 17i32 => println ! (\"Minor\" . to_string ()) , 18i32 ..= 65i32 => println ! (\"Adult\" . to_string ()) , _ => p...\n  |                                                  -------   ^^^^^^^^^^^^ argument never used\n  |                                                  |\n  |                                                  formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmprBqv4s/main.rs:1:242\n  |\n1 | ...or\" . to_string ()) , 18i32 ..= 65i32 => println ! (\"Adult\" . to_string ()) , _ => println ! (\"Senior\" . to_string ()) , } } } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmprBqv4s/main.rs:1:244\n  |\n1 | ...to_string ()) , 18i32 ..= 65i32 => println ! (\"Adult\" . to_string ()) , _ => println ! (\"Senior\" . to_string ()) , } } } }\n  |                                                  -------   ^^^^^^^^^^^^ argument never used\n  |                                                  |\n  |                                                  formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmprBqv4s/main.rs:1:285\n  |\n1 | ...intln ! (\"Adult\" . to_string ()) , _ => println ! (\"Senior\" . to_string ()) , } } } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmprBqv4s/main.rs:1:287\n  |\n1 | ...! (\"Adult\" . to_string ()) , _ => println ! (\"Senior\" . to_string ()) , } } } }\n  |                                                 --------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmprBqv4s/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let age = 25i32 ; match age { 0i32 => println ! (\"Error: Age cannot be zero\" . to_st...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmprBqv4s/main.rs:1:50\n  |\n1 | ... { { { let age = 25i32 ; match age { 0i32 => println ! (\"Error: Age cannot be zero\" . to_string ()) , 1i32 ..= 17i32 => println ! (\"Minor\" . to_string ()) , 18i32 ..= 65i32 => println ! (\"Adult\" . to_string ()) , _ => println ! (\"Senior\" . to_string ()) , } } } }\n  |       ^^                                                                                                                                                                                                                                                              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let age = 25i32 ; match age { 0i32 => println ! (\"Error: Age cannot be zero\" . to_string ()) , 1i32 ..= 17i32 => println ! (\"Minor\" . to_string ()) , 18i32 ..= 65i32 => println ! (\"Adult\" . to_string ()) , _ => println ! (\"Senior\" . to_string ()) , } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let age = 25i32 ; match age { 0i32 => println ! (\"Error: Age cannot be zero\" . to_string ()) , 1i32 ..= 17i32 => println ! (\"Minor\" . to_string ()) , 18i32 ..= 65i32 => println ! (\"Adult\" . to_string ()) , _ => println ! (\"Senior\" . to_string ()) , } } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmprBqv4s/main.rs:1:133\n  |\n1 | ... 0i32 => println ! (\"Error: Age cannot be zero\" . to_string ()) , 1i32 ..= 17i32 => println ! (\"Minor\" . to_string ()) , 18i32 ..= 65i...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmprBqv4s/main.rs:1:188\n  |\n1 | ...ring ()) , 1i32 ..= 17i32 => println ! (\"Minor\" . to_string ()) , 18i32 ..= 65i32 => println ! (\"Adult\" . to_string ()) , _ => println...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmprBqv4s/main.rs:1:244\n  |\n1 | ...ing ()) , 18i32 ..= 65i32 => println ! (\"Adult\" . to_string ()) , _ => println ! (\"Senior\" . to_string ()) , } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmprBqv4s/main.rs:1:287\n  |\n1 | ...ult\" . to_string ()) , _ => println ! (\"Senior\" . to_string ()) , } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 12 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 4,
          "line_number": 130,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nif value > 0 {\n    println(\"Valid\");\n} else {\n    println(\"Invalid\");\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmptr7NIm/main.rs:1:102\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\" . to_string ()) } } else { { println...\n  |                                                                                                      ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmptr7NIm/main.rs:1:104\n  |\n1 | ...{ let result = if value > 0i32 { { println ! (\"Valid\" . to_string ()) } } else { { println ! (\"Invalid\" . to_string ()) } } ; if let S...\n  |                                                  -------   ^^^^^^^^^^^^ argument never used\n  |                                                  |\n  |                                                  formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmptr7NIm/main.rs:1:152\n  |\n1 | ... (\"Valid\" . to_string ()) } } else { { println ! (\"Invalid\" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: A...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmptr7NIm/main.rs:1:154\n  |\n1 | ...lid\" . to_string ()) } } else { { println ! (\"Invalid\" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) ....\n  |                                                 ---------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror[E0425]: cannot find value `value` in this scope\n --> /tmp/.tmptr7NIm/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\" . to_string ()) } } else { { println...\n  |                                                                  ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmptr7NIm/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\" . to_string ()) } } else { { println...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmptr7NIm/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\" . to_string ()) } } else { { println...\n  |                                                                                 ^^                                  ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\" . to_string ()) } } else { { println ! (\"Invalid\" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { println ! (\"Valid\" . to_string ()) } else { { println ! (\"Invalid\" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmptr7NIm/main.rs:1:129\n  |\n1 | ... println ! (\"Valid\" . to_string ()) } } else { { println ! (\"Invalid\" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :...\n  |                                                   ^^                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\" . to_string ()) } } else { { println ! (\"Invalid\" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\" . to_string ()) } } else { println ! (\"Invalid\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmptr7NIm/main.rs:1:104\n  |\n1 | ...result = if value > 0i32 { { println ! (\"Valid\" . to_string ()) } } else { { println ! (\"Invalid\" . to_string ()) } } ; if let Some (s...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmptr7NIm/main.rs:1:154\n  |\n1 | ...to_string ()) } } else { { println ! (\"Invalid\" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downca...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 7 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 5,
          "line_number": 143,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nmatch status {\n    0 => println(\"Error\"),\n    1 => println(\"Warning\"),\n    2 => println(\"Success\"),\n    _ => println(\"Unknown\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpl0sDIl/main.rs:1:105\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! (\"Error\" . to_string ()) , 1i32 => println...\n  |                                                                                                         ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpl0sDIl/main.rs:1:107\n  |\n1 | ...et result = match status { 0i32 => println ! (\"Error\" . to_string ()) , 1i32 => println ! (\"Warning\" . to_string ()) , 2i32 => println...\n  |                                                  -------   ^^^^^^^^^^^^ argument never used\n  |                                                  |\n  |                                                  formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpl0sDIl/main.rs:1:152\n  |\n1 | ...n ! (\"Error\" . to_string ()) , 1i32 => println ! (\"Warning\" . to_string ()) , 2i32 => println ! (\"Success\" . to_string ()) , _ => prin...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpl0sDIl/main.rs:1:154\n  |\n1 | ...\"Error\" . to_string ()) , 1i32 => println ! (\"Warning\" . to_string ()) , 2i32 => println ! (\"Success\" . to_string ()) , _ => println !...\n  |                                                 ---------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpl0sDIl/main.rs:1:199\n  |\n1 | ...! (\"Warning\" . to_string ()) , 2i32 => println ! (\"Success\" . to_string ()) , _ => println ! (\"Unknown\" . to_string ()) , } ; if let S...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpl0sDIl/main.rs:1:201\n  |\n1 | ...arning\" . to_string ()) , 2i32 => println ! (\"Success\" . to_string ()) , _ => println ! (\"Unknown\" . to_string ()) , } ; if let Some (...\n  |                                                 ---------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpl0sDIl/main.rs:1:243\n  |\n1 | ...ln ! (\"Success\" . to_string ()) , _ => println ! (\"Unknown\" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: A...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpl0sDIl/main.rs:1:245\n  |\n1 | ...(\"Success\" . to_string ()) , _ => println ! (\"Unknown\" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: Any) ....\n  |                                                 ---------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror[E0425]: cannot find value `status` in this scope\n --> /tmp/.tmpl0sDIl/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! (\"Error\" . to_string ()) , 1i32 => println...\n  |                                                                     ^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpl0sDIl/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! (\"Error\" . to_string ()) , 1i32 => println...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpl0sDIl/main.rs:1:107\n  |\n1 | ...ult = match status { 0i32 => println ! (\"Error\" . to_string ()) , 1i32 => println ! (\"Warning\" . to_string ()) , 2i32 => println ! (\"S...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpl0sDIl/main.rs:1:154\n  |\n1 | ... . to_string ()) , 1i32 => println ! (\"Warning\" . to_string ()) , 2i32 => println ! (\"Success\" . to_string ()) , _ => println ! (\"Unkn...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpl0sDIl/main.rs:1:201\n  |\n1 | ... . to_string ()) , 2i32 => println ! (\"Success\" . to_string ()) , _ => println ! (\"Unknown\" . to_string ()) , } ; if let Some (s) = (&...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpl0sDIl/main.rs:1:245\n  |\n1 | ...ss\" . to_string ()) , _ => println ! (\"Unknown\" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downca...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 13 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 6,
          "line_number": 157,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nmatch age {\n    0 => println(\"Invalid age\"),\n    1..=17 => println(\"Minor\"),\n    18..=65 => println(\"Adult\"),\n    _ => println(\"Senior\")\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpZptAQA/main.rs:1:108\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! (\"Invalid age\" . to_string ()) , 1i32 ..= 17i...\n  |                                                                                                            ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpZptAQA/main.rs:1:110\n  |\n1 | ...et result = match age { 0i32 => println ! (\"Invalid age\" . to_string ()) , 1i32 ..= 17i32 => println ! (\"Minor\" . to_string ()) , 18i3...\n  |                                               -------------   ^^^^^^^^^^^^ argument never used\n  |                                               |\n  |                                               formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpZptAQA/main.rs:1:163\n  |\n1 | ...age\" . to_string ()) , 1i32 ..= 17i32 => println ! (\"Minor\" . to_string ()) , 18i32 ..= 65i32 => println ! (\"Adult\" . to_string ()) , ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpZptAQA/main.rs:1:165\n  |\n1 | ... to_string ()) , 1i32 ..= 17i32 => println ! (\"Minor\" . to_string ()) , 18i32 ..= 65i32 => println ! (\"Adult\" . to_string ()) , _ => p...\n  |                                                  -------   ^^^^^^^^^^^^ argument never used\n  |                                                  |\n  |                                                  formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpZptAQA/main.rs:1:219\n  |\n1 | ...or\" . to_string ()) , 18i32 ..= 65i32 => println ! (\"Adult\" . to_string ()) , _ => println ! (\"Senior\" . to_string ()) , } ; if let So...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpZptAQA/main.rs:1:221\n  |\n1 | ...to_string ()) , 18i32 ..= 65i32 => println ! (\"Adult\" . to_string ()) , _ => println ! (\"Senior\" . to_string ()) , } ; if let Some (s)...\n  |                                                  -------   ^^^^^^^^^^^^ argument never used\n  |                                                  |\n  |                                                  formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpZptAQA/main.rs:1:262\n  |\n1 | ...intln ! (\"Adult\" . to_string ()) , _ => println ! (\"Senior\" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: A...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpZptAQA/main.rs:1:264\n  |\n1 | ...! (\"Adult\" . to_string ()) , _ => println ! (\"Senior\" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...\n  |                                                 --------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror[E0425]: cannot find value `age` in this scope\n --> /tmp/.tmpZptAQA/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! (\"Invalid age\" . to_string ()) , 1i32 ..= 17i...\n  |                                                                     ^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpZptAQA/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! (\"Invalid age\" . to_string ()) , 1i32 ..= 17i...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpZptAQA/main.rs:1:110\n  |\n1 | ... = match age { 0i32 => println ! (\"Invalid age\" . to_string ()) , 1i32 ..= 17i32 => println ! (\"Minor\" . to_string ()) , 18i32 ..= 65i...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpZptAQA/main.rs:1:165\n  |\n1 | ...ring ()) , 1i32 ..= 17i32 => println ! (\"Minor\" . to_string ()) , 18i32 ..= 65i32 => println ! (\"Adult\" . to_string ()) , _ => println...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpZptAQA/main.rs:1:221\n  |\n1 | ...ing ()) , 18i32 ..= 65i32 => println ! (\"Adult\" . to_string ()) , _ => println ! (\"Senior\" . to_string ()) , } ; if let Some (s) = (& ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpZptAQA/main.rs:1:264\n  |\n1 | ...ult\" . to_string ()) , _ => println ! (\"Senior\" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downca...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 13 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 7,
          "line_number": 185,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nif input < 0 {\n    println(\"Error: Negative input not allowed\");\n} else {\n    process_input(input);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpeAU7lr/main.rs:1:130\n  |\n1 | ...t < 0i32 { { println ! (\"Error: Negative input not allowed\" . to_string ()) } } else { { process_input (input) } } ; if let Some (s) =...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpeAU7lr/main.rs:1:132\n  |\n1 | ... if input < 0i32 { { println ! (\"Error: Negative input not allowed\" . to_string ()) } } else { { process_input (input) } } ; if let So...\n  |                                    -----------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                    |\n  |                                    formatting specifier missing\n\nerror[E0425]: cannot find value `input` in this scope\n --> /tmp/.tmpeAU7lr/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\" . to_str...\n  |                                                                  ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `input` in this scope\n --> /tmp/.tmpeAU7lr/main.rs:1:174\n  |\n1 | ...llowed\" . to_string ()) } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_re...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpeAU7lr/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\" . to_str...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpeAU7lr/main.rs:1:81\n  |\n1 | ... { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\" . to_string ()) } } else { { process_input (input) ...\n  |                                      ^^                                                              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\" . to_string ()) } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { println ! (\"Error: Negative input not allowed\" . to_string ()) } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpeAU7lr/main.rs:1:157\n  |\n1 | ...egative input not allowed\" . to_string ()) } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any ::...\n  |                                                          ^^                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\" . to_string ()) } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\" . to_string ()) } } else { process_input (input) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpeAU7lr/main.rs:1:132\n  |\n1 | ... println ! (\"Error: Negative input not allowed\" . to_string ()) } } else { { process_input (input) } } ; if let Some (s) = (& result a...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `process_input` in this scope\n --> /tmp/.tmpeAU7lr/main.rs:1:159\n  |\n1 | ...input not allowed\" . to_string ()) } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 8,
          "line_number": 198,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nmatch score {\n    0..=59 => println(\"Fail\"),\n    60..=79 => println(\"Pass\"),\n    80..=100 => println(\"Excellent\"),\n    _ => println(\"Invalid score\")\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpXG84uR/main.rs:1:113\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! (\"Fail\" . to_string ()) , 60i32 ....\n  |                                                                                                                 ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpXG84uR/main.rs:1:115\n  |\n1 | ... = match score { 0i32 ..= 59i32 => println ! (\"Fail\" . to_string ()) , 60i32 ..= 79i32 => println ! (\"Pass\" . to_string ()) , 80i32 .....\n  |                                                  ------   ^^^^^^^^^^^^ argument never used\n  |                                                  |\n  |                                                  formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpXG84uR/main.rs:1:168\n  |\n1 | ...ail\" . to_string ()) , 60i32 ..= 79i32 => println ! (\"Pass\" . to_string ()) , 80i32 ..= 100i32 => println ! (\"Excellent\" . to_string (...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpXG84uR/main.rs:1:170\n  |\n1 | ...to_string ()) , 60i32 ..= 79i32 => println ! (\"Pass\" . to_string ()) , 80i32 ..= 100i32 => println ! (\"Excellent\" . to_string ()) , _ ...\n  |                                                  ------   ^^^^^^^^^^^^ argument never used\n  |                                                  |\n  |                                                  formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpXG84uR/main.rs:1:229\n  |\n1 | ... to_string ()) , 80i32 ..= 100i32 => println ! (\"Excellent\" . to_string ()) , _ => println ! (\"Invalid score\" . to_string ()) , } ; if...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpXG84uR/main.rs:1:231\n  |\n1 | ...string ()) , 80i32 ..= 100i32 => println ! (\"Excellent\" . to_string ()) , _ => println ! (\"Invalid score\" . to_string ()) , } ; if let...\n  |                                                -----------   ^^^^^^^^^^^^ argument never used\n  |                                                |\n  |                                                formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpXG84uR/main.rs:1:279\n  |\n1 | ...xcellent\" . to_string ()) , _ => println ! (\"Invalid score\" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: A...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpXG84uR/main.rs:1:281\n  |\n1 | ...ellent\" . to_string ()) , _ => println ! (\"Invalid score\" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: Any...\n  |                                              ---------------   ^^^^^^^^^^^^ argument never used\n  |                                              |\n  |                                              formatting specifier missing\n\nerror[E0425]: cannot find value `score` in this scope\n --> /tmp/.tmpXG84uR/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! (\"Fail\" . to_string ()) , 60i32 ....\n  |                                                                     ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpXG84uR/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! (\"Fail\" . to_string ()) , 60i32 ....\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpXG84uR/main.rs:1:115\n  |\n1 | ...tch score { 0i32 ..= 59i32 => println ! (\"Fail\" . to_string ()) , 60i32 ..= 79i32 => println ! (\"Pass\" . to_string ()) , 80i32 ..= 100...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpXG84uR/main.rs:1:170\n  |\n1 | ...ring ()) , 60i32 ..= 79i32 => println ! (\"Pass\" . to_string ()) , 80i32 ..= 100i32 => println ! (\"Excellent\" . to_string ()) , _ => pr...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpXG84uR/main.rs:1:231\n  |\n1 | ...)) , 80i32 ..= 100i32 => println ! (\"Excellent\" . to_string ()) , _ => println ! (\"Invalid score\" . to_string ()) , } ; if let Some (s...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpXG84uR/main.rs:1:281\n  |\n1 | ...to_string ()) , _ => println ! (\"Invalid score\" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downca...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 13 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 9,
          "line_number": 212,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nif system_ready {\n    println(\"System operational\");\n} else {\n    println(\"System not ready\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmptMSX6i/main.rs:1:115\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\" . to_string ()) } } els...\n  |                                                                                                                   ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmptMSX6i/main.rs:1:117\n  |\n1 | ...esult = if system_ready { { println ! (\"System operational\" . to_string ()) } } else { { println ! (\"System not ready\" . to_string ())...\n  |                                           --------------------   ^^^^^^^^^^^^ argument never used\n  |                                           |\n  |                                           formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmptMSX6i/main.rs:1:174\n  |\n1 | ... . to_string ()) } } else { { println ! (\"System not ready\" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: A...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmptMSX6i/main.rs:1:176\n  |\n1 | .... to_string ()) } } else { { println ! (\"System not ready\" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: An...\n  |                                            ------------------   ^^^^^^^^^^^^ argument never used\n  |                                            |\n  |                                            formatting specifier missing\n\nerror[E0425]: cannot find value `system_ready` in this scope\n --> /tmp/.tmptMSX6i/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\" . to_string ()) } } els...\n  |                                                                  ^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmptMSX6i/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\" . to_string ()) } } els...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmptMSX6i/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\" . to_string ()) } } els...\n  |                                                                                 ^^                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\" . to_string ()) } } else { { println ! (\"System not ready\" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { println ! (\"System operational\" . to_string ()) } else { { println ! (\"System not ready\" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmptMSX6i/main.rs:1:142\n  |\n1 | ...m operational\" . to_string ()) } } else { { println ! (\"System not ready\" . to_string ()) } } ; if let Some (s) = (& result as & dyn s...\n  |                                              ^^                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\" . to_string ()) } } else { { println ! (\"System not ready\" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\" . to_string ()) } } else { println ! (\"System not ready\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmptMSX6i/main.rs:1:117\n  |\n1 | ...ystem_ready { { println ! (\"System operational\" . to_string ()) } } else { { println ! (\"System not ready\" . to_string ()) } } ; if le...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmptMSX6i/main.rs:1:176\n  |\n1 | ... ()) } } else { { println ! (\"System not ready\" . to_string ()) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downca...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 7 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch08-00-systems-programming": {
      "chapter": "ch08-00-systems-programming",
      "total_examples": 9,
      "working_examples": 0,
      "failing_examples": 9,
      "examples": [
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// File: system_monitor.ruchy\n// Real-time system resource monitoring\n\nuse std::system;\nuse std::process;\n\nprintln(\"=== System Monitor ===\")\n\n// Get system information\nlet cpu_count = system::cpu_count()\nlet total_memory = system::total_memory()\nlet hostname = system::hostname()\nlet os_info = system::os_info()\n\nprintln(\"Host: \" + hostname)\nprintln(\"OS: \" + os_info.name + \" \" + os_info.version)\nprintln(\"CPUs: \" + cpu_count.to_s())\nprintln(\"Memory: \" + format_size(total_memory))\nprintln(\"\")\n\n// Monitor resources in real-time\nloop {\n    let cpu_usage = system::cpu_usage()\n    let memory_info = system::memory_info()\n    let disk_io = system::disk_io_stats()\n    let network_stats = system::network_stats()\n    \n    // Clear screen and show header\n    clear_screen()\n    println(\"System Monitor - Press Ctrl+C to exit\")\n    println(\"=\" * 50)\n    \n    // CPU Usage\n    println(\"CPU: \" + cpu_usage.to_s() + \"% |\" + (\"█\" * (cpu_usage * 50).to_i()) + (\"░\" * (50 - cpu_usage * 50).to_i()) + \"|\")\n    \n    // Memory Usage\n    let mem_percent = memory_info.used / memory_info.total\n    println(\"MEM: \" + mem_percent.to_s() + \"% |\" + (\"█\" * (mem_percent * 50).to_i()) + (\"░\" * (50 - mem_percent * 50).to_i()) + \"|\")\n    println(\"     \" + format_size(memory_info.used) + \" / \" + format_size(memory_info.total))\n    \n    // Disk I/O\n    println(\"Disk Read:  \" + format_size(disk_io.read_bytes) + \"/s\")\n    println(\"Disk Write: \" + format_size(disk_io.write_bytes) + \"/s\")\n    \n    // Network\n    println(\"Net Down: \" + format_size(network_stats.download_speed) + \"/s\")\n    println(\"Net Up:   \" + format_size(network_stats.upload_speed) + \"/s\")\n    \n    // Top processes\n    println(\"\\nTop Processes by CPU:\")\n    let processes = process::list()\n        .sort_by(|p| -p.cpu_percent)\n        .take(5)\n    \n    for proc in processes {\n        println(\"  \" + proc.pid.to_s() + \" \" + proc.name + \" \" + proc.cpu_percent.to_s() + \"%\")\n    }\n    \n    sleep(1000)  // Update every second\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpc1GSEb/main.rs:1:146\n  |\n1 | ... use std :: process ; ; println ! (\"=== System Monitor ===\" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut tot...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpc1GSEb/main.rs:1:148\n  |\n1 | ... ; use std :: process ; ; println ! (\"=== System Monitor ===\" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut t...\n  |                                         ------------------------   ^^^^^^^^^^^^ argument never used\n  |                                         |\n  |                                         formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpc1GSEb/main.rs:1:683\n  |\n1 | ..., \"Memory: \" , format_size (total_memory))) ; println ! (\"\" . to_string ()) ; loop { { { let cpu_usage = system :: cpu_usage () ; { le...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpc1GSEb/main.rs:1:685\n  |\n1 | ...: \" , format_size (total_memory))) ; println ! (\"\" . to_string ()) ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut mem...\n  |                                                    --   ^^^^^^^^^^^^ argument never used\n  |                                                    |\n  |                                                    formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpc1GSEb/main.rs:1:973\n  |\n1 | ...een () ; println ! (\"System Monitor - Press Ctrl+C to exit\" . to_string ()) ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , forma...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpc1GSEb/main.rs:1:975\n  |\n1 | ... clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\" . to_string ()) ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{...\n  |                                  ---------------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                  |\n  |                                  formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpc1GSEb/main.rs:1:2185\n  |\n1 | ...oad_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpc1GSEb/main.rs:1:2187\n  |\n1 | ...upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\" . to_string ()) ; let mut processes = process :: list () . sort_by (| p...\n  |                                         -------------------------   ^^^^^^^^^^^^ argument never used\n  |                                         |\n  |                                         formatting specifier missing\n\nerror[E0432]: unresolved import `std::system`\n --> /tmp/.tmpc1GSEb/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monit...\n  |                                                                     ^^^^^^^^^^^^^ no `system` in the root\n\nerror[E0425]: cannot find function `list` in module `process`\n --> /tmp/.tmpc1GSEb/main.rs:1:2234\n  |\n1 | ...U:\" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes...\n  |                                                         ^^^^ not found in `process`\n\nerror[E0425]: cannot find function `sleep` in this scope\n --> /tmp/.tmpc1GSEb/main.rs:1:2516\n  |\n1 | ..., \" \") + proc . cpu_percent . to_s () , \"%\")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::sleep;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpc1GSEb/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monit...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpc1GSEb/main.rs:1:85\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monit...\n  |                                                                                     ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpc1GSEb/main.rs:1:108\n  |\n1 | ...sult = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\" . to_string ()) ; let mut cpu_count = system...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpc1GSEb/main.rs:1:708\n  |\n1 | ... { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\" . to_string ()) ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"CPU: \" , cpu_usage . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"MEM: \" , mem_percent . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } } ; sleep (1000i32) } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! (\"{}\" , format ! (\"{}{}\" , \"Host: \" , hostname)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"OS: \" , os_info . name) , \" \") + os_info . version) ; println ! (\"{}\" , format ! (\"{}{}\" , \"CPUs: \" , cpu_count . to_s ())) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Memory: \" , format_size (total_memory))) ; println ! (\"\" . to_string ()) ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\" . to_string ()) ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"CPU: \" , cpu_usage . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"MEM: \" , mem_percent . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! (\"{}\" , format ! (\"{}{}\" , \"Host: \" , hostname)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"OS: \" , os_info . name) , \" \") + os_info . version) ; println ! (\"{}\" , format ! (\"{}{}\" , \"CPUs: \" , cpu_count . to_s ())) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Memory: \" , format_size (total_memory))) ; println ! (\"\" . to_string ()) ; loop { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\" . to_string ()) ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"CPU: \" , cpu_usage . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"MEM: \" , mem_percent . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } } ; sleep (1000i32) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpc1GSEb/main.rs:1:2318\n  |\n1 | ... { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } } ...\n  |       ^^                                                                                                                                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! (\"{}\" , format ! (\"{}{}\" , \"Host: \" , hostname)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"OS: \" , os_info . name) , \" \") + os_info . version) ; println ! (\"{}\" , format ! (\"{}{}\" , \"CPUs: \" , cpu_count . to_s ())) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Memory: \" , format_size (total_memory))) ; println ! (\"\" . to_string ()) ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\" . to_string ()) ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"CPU: \" , cpu_usage . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"MEM: \" , mem_percent . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! (\"{}\" , format ! (\"{}{}\" , \"Host: \" , hostname)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"OS: \" , os_info . name) , \" \") + os_info . version) ; println ! (\"{}\" , format ! (\"{}{}\" , \"CPUs: \" , cpu_count . to_s ())) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Memory: \" , format_size (total_memory))) ; println ! (\"\" . to_string ()) ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\" . to_string ()) ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"CPU: \" , cpu_usage . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"MEM: \" , mem_percent . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpc1GSEb/main.rs:1:148\n  |\n1 | ...process ; ; println ! (\"=== System Monitor ===\" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpc1GSEb/main.rs:1:638\n  |\n1 | ...rintln ! (\"{}\" , format ! (\"{}{}\" , \"Memory: \" , format_size (total_memory))) ; println ! (\"\" . to_string ()) ; loop { { { let cpu_usa...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpc1GSEb/main.rs:1:685\n  |\n1 | ... , format_size (total_memory))) ; println ! (\"\" . to_string ()) ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `clear_screen` in this scope\n --> /tmp/.tmpc1GSEb/main.rs:1:904\n  |\n1 | ...mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\" . to_string ()) ...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpc1GSEb/main.rs:1:975\n  |\n1 | ...ntln ! (\"System Monitor - Press Ctrl+C to exit\" . to_string ()) ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , format ! (\"{}{}\" ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot multiply `&str` by `i32`\n --> /tmp/.tmpc1GSEb/main.rs:1:1013\n  |\n1 | ... Press Ctrl+C to exit\" . to_string ()) ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , form...\n  |                                                               --- ^ ----- i32\n  |                                                               |\n  |                                                               &str\n\nerror[E0599]: no method named `to_i` found for type `i32` in the current scope\n --> /tmp/.tmpc1GSEb/main.rs:1:1167\n  |\n1 | ...age . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpc1GSEb/main.rs:1:1141\n  |\n1 | ...\" , cpu_usage . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut me...\n  |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `str`\n  |\nhelp: consider borrowing here\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! (\"{}\" , format ! (\"{}{}\" , \"Host: \" , hostname)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"OS: \" , os_info . name) , \" \") + os_info . version) ; println ! (\"{}\" , format ! (\"{}{}\" , \"CPUs: \" , cpu_count . to_s ())) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Memory: \" , format_size (total_memory))) ; println ! (\"\" . to_string ()) ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\" . to_string ()) ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"CPU: \" , cpu_usage . to_s ()) , \"% |\") + &(\"█\" * cpu_usage * 50i32 . to_i ()) + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"MEM: \" , mem_percent . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++                                 +\n\nerror[E0369]: cannot multiply `&str` by `i32`\n --> /tmp/.tmpc1GSEb/main.rs:1:1181\n  |\n1 | ... . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = m...\n  |                                                               --- ^ ----- i32\n  |                                                               |\n  |                                                               &str\n\nerror[E0599]: no method named `to_i` found for type `i32` in the current scope\n --> /tmp/.tmpc1GSEb/main.rs:1:1211\n  |\n1 | ...50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ;...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_i` found for type `i32` in the current scope\n --> /tmp/.tmpc1GSEb/main.rs:1:1441\n  |\n1 | ...t . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{}\" , ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpc1GSEb/main.rs:1:1413\n  |\n1 | ... mem_percent . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println...\n  |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `str`\n  |\nhelp: consider borrowing here\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\" . to_string ()) ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! (\"{}\" , format ! (\"{}{}\" , \"Host: \" , hostname)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"OS: \" , os_info . name) , \" \") + os_info . version) ; println ! (\"{}\" , format ! (\"{}{}\" , \"CPUs: \" , cpu_count . to_s ())) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Memory: \" , format_size (total_memory))) ; println ! (\"\" . to_string ()) ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\" . to_string ()) ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"CPU: \" , cpu_usage . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"MEM: \" , mem_percent . to_s ()) , \"% |\") + &(\"█\" * mem_percent * 50i32 . to_i ()) + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ++                                   +\n\nerror[E0369]: cannot multiply `&str` by `i32`\n --> /tmp/.tmpc1GSEb/main.rs:1:1455\n  |\n1 | ... to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{}\" , for...\n  |                                                               --- ^ ----- i32\n  |                                                               |\n  |                                                               &str\n\nerror[E0599]: no method named `to_i` found for type `i32` in the current scope\n --> /tmp/.tmpc1GSEb/main.rs:1:1487\n  |\n1 | ...i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpc1GSEb/main.rs:1:1571\n  |\n1 | ... format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; pri...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpc1GSEb/main.rs:1:1616\n  |\n1 | ...\" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpc1GSEb/main.rs:1:1726\n  |\n1 | ... ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , f...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpc1GSEb/main.rs:1:1846\n  |\n1 | ... ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpc1GSEb/main.rs:1:1965\n  |\n1 | ...at ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{}\" , format ! (...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpc1GSEb/main.rs:1:2093\n  |\n1 | ...at ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpc1GSEb/main.rs:1:2187\n  |\n1 | ..., \"/s\")) ; println ! (\"\\nTop Processes by CPU:\" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_pe...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nwarning: unreachable expression\n --> /tmp/.tmpc1GSEb/main.rs:1:2544\n  |\n1 | ... ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\" . to_string ()) ; println ! (\"{}\" , \"=\" * 50i32) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"CPU: \" , cpu_usage . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"MEM: \" , mem_percent . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\" . to_string ()) ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |       --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression\n  |       |\n  |       any code following this expression is unreachable\n  |\n  = note: `#[warn(unreachable_code)]` on by default\n\nerror: aborting due to 32 previous errors; 6 warnings emitted\n\nSome errors have detailed explanations: E0308, E0369, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_i()"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 2,
          "line_number": 111,
          "code": "// Status: ❌ BROKEN\n\n// Current process information\nlet pid = process::current_pid()\nlet ppid = process::parent_pid()\nlet exe_path = process::executable_path()\nlet args = process::args()\nlet env = process::environment()\n\n// List all processes\nlet all_processes = process::list()\nfor proc in all_processes {\n    println(\"PID: \" + proc.pid.to_s() + \", Name: \" + proc.name + \", CPU: \" + proc.cpu_percent.to_s() + \"%\")\n}\n\n// Find specific process\nlet chrome_procs = process::find_by_name(\"chrome\")\nlet high_cpu_procs = process::list()\n    .filter(|p| p.cpu_percent > 50)\n\n// Process control\nlet proc = process::from_pid(1234)\nproc.suspend()  // Pause process\nproc.resume()   // Resume process\nproc.terminate() // Request termination\nproc.kill()     // Force kill\n\n// Launch new process\nlet child = process::spawn(\"ls\", [\"-la\"])\nlet output = child.wait_with_output()\nprintln(output.stdout)\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpQ5guIn/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: paren...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpQ5guIn/main.rs:1:351\n  |\n1 | ... { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"PID: \" , proc . pid . to_s ()) , \", Name: \") + proc . name , \", CPU: \") + proc . cpu_percent . to_s () , \"%\")) } } ...\n  |       ^^                                                                                                                                                                                                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = process :: args () ; let mut env = process :: environment () ; let mut all_processes = process :: list () ; for proc in all_processes { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"PID: \" , proc . pid . to_s ()) , \", Name: \") + proc . name , \", CPU: \") + proc . cpu_percent . to_s () , \"%\")) } } ; let mut chrome_procs = process :: find_by_name (\"chrome\" . to_string ()) ; let mut high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect () ; let mut proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc . kill () ; let mut child = process :: spawn (\"ls\" . to_string () , vec ! [\"-la\"]) ; let mut output = child . wait_with_output () ; println ! (\"{}\" , output . stdout) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = process :: args () ; let mut env = process :: environment () ; let mut all_processes = process :: list () ; for proc in all_processes { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"PID: \" , proc . pid . to_s ()) , \", Name: \") + proc . name , \", CPU: \") + proc . cpu_percent . to_s () , \"%\")) } ; let mut chrome_procs = process :: find_by_name (\"chrome\" . to_string ()) ; let mut high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect () ; let mut proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc . kill () ; let mut child = process :: spawn (\"ls\" . to_string () , vec ! [\"-la\"]) ; let mut output = child . wait_with_output () ; println ! (\"{}\" , output . stdout) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpQ5guIn/main.rs:1:79\n  |\n1 | ...in () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process ...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpQ5guIn/main.rs:1:122\n  |\n1 | ...s :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = proc...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpQ5guIn/main.rs:1:168\n  |\n1 | ...: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = process :: args () ; let mut env = process :: envi...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpQ5guIn/main.rs:1:215\n  |\n1 | ... executable_path () ; let mut args = process :: args () ; let mut env = process :: environment () ; let mut all_processes = process ::...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpQ5guIn/main.rs:1:250\n  |\n1 | ...= process :: args () ; let mut env = process :: environment () ; let mut all_processes = process :: list () ; for proc in all_processe...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpQ5guIn/main.rs:1:302\n  |\n1 | ...ronment () ; let mut all_processes = process :: list () ; for proc in all_processes { { println ! (\"{}\" , format ! (\"{}{}\" , format ! ...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpQ5guIn/main.rs:1:588\n  |\n1 | ..., \"%\")) } } ; let mut chrome_procs = process :: find_by_name (\"chrome\" . to_string ()) ; let mut high_cpu_procs = process :: list () ....\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpQ5guIn/main.rs:1:665\n  |\n1 | ...tring ()) ; let mut high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect () ; let mut...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpQ5guIn/main.rs:1:770\n  |\n1 | ...50i32) . collect () ; let mut proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpQ5guIn/main.rs:1:896\n  |\n1 | ...) ; proc . kill () ; let mut child = process :: spawn (\"ls\" . to_string () , vec ! [\"-la\"]) ; let mut output = child . wait_with_outpu...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror: aborting due to 10 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 3,
          "line_number": 157,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Register signal handlers\nsignal::on(SIGINT, || {\n    println(\"\\nGracefully shutting down...\")\n    cleanup()\n    exit(0)\n})\n\nsignal::on(SIGTERM, || {\n    save_state()\n    exit(0)\n})\n\nsignal::on(SIGUSR1, || {\n    reload_config()\n})\n\n// Send signals to other processes\nlet target_pid = 1234\nsignal::send(target_pid, SIGUSR1)\n\n// Block/unblock signals\nsignal::block([SIGPIPE])\ncritical_operation()\nsignal::unblock([SIGPIPE])",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 4,
          "line_number": 196,
          "code": "// Status: ❌ BROKEN\n\n// Get memory information\nlet mem_info = system::memory_info()\nprintln(\"Total: \" + mem_info.total.to_s())\nprintln(\"Used: \" + mem_info.used.to_s())\nprintln(\"Free: \" + mem_info.free.to_s())\nprintln(\"Available: \" + mem_info.available.to_s())\nprintln(\"Swap Used: \" + mem_info.swap_used.to_s())\n\n// Monitor memory pressure\nif mem_info.available < 100_000_000 {  // Less than 100MB\n    println(\"WARNING: Low memory!\")\n    free_caches()\n}\n\n// Memory-mapped files for large data\nlet mmap = memory::map_file(\"huge_dataset.bin\", READ_ONLY)\nlet data = mmap.read_range(0, 1000000)  // Read 1MB\nmmap.close()\n\n// Shared memory between processes\nlet shared = memory::create_shared(\"my_buffer\", 1024 * 1024)\nshared.write(0, data)\n\n// In another process\nlet shared = memory::open_shared(\"my_buffer\")\nlet data = shared.read(0, 1024)\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpo0SCZG/main.rs:1:1040\n  |\n1 | ... data = shared . read (0i32 , 1024i32) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpo0SCZG/main.rs:1:607\n  |\n1 | ...< 100i32 { _000_000 } ; { println ! (\"WARNING: Low memory!\" . to_string ()) ; free_caches () } ; let mut mmap = memory :: map_file (\"h...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpo0SCZG/main.rs:1:609\n  |\n1 | ... < 100i32 { _000_000 } ; { println ! (\"WARNING: Low memory!\" . to_string ()) ; free_caches () } ; let mut mmap = memory :: map_file (\"...\n  |                                          ----------------------   ^^^^^^^^^^^^ argument never used\n  |                                          |\n  |                                          formatting specifier missing\n\nerror[E0425]: cannot find value `_000_000` in this scope\n --> /tmp/.tmpo0SCZG/main.rs:1:558\n  |\n1 | ...d . to_s ())) ; if mem_info . available < 100i32 { _000_000 } ; { println ! (\"WARNING: Low memory!\" . to_string ()) ; free_caches () }...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `READ_ONLY` in this scope\n --> /tmp/.tmpo0SCZG/main.rs:1:715\n  |\n1 | ... :: map_file (\"huge_dataset.bin\" . to_string () , READ_ONLY) ; let mut data = mmap . read_range (0i32 , 1000000i32) ; mmap . close () ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpo0SCZG/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut mem_info = system :: memory_info () ; println ! (\"{}\" , format ! ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `system`\n --> /tmp/.tmpo0SCZG/main.rs:1:84\n  |\n1 | ...) { let result = { let mut mem_info = system :: memory_info () ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total: \" , mem_info . total . t...\n  |                                          ^^^^^^ use of unresolved module or unlinked crate `system`\n  |\n  = help: you might be missing a crate named `system`\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpo0SCZG/main.rs:1:609\n  |\n1 | ...000_000 } ; { println ! (\"WARNING: Low memory!\" . to_string ()) ; free_caches () } ; let mut mmap = memory :: map_file (\"huge_dataset....\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `free_caches` in this scope\n --> /tmp/.tmpo0SCZG/main.rs:1:625\n  |\n1 | ...ntln ! (\"WARNING: Low memory!\" . to_string ()) ; free_caches () } ; let mut mmap = memory :: map_file (\"huge_dataset.bin\" . to_string ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`\n --> /tmp/.tmpo0SCZG/main.rs:1:659\n  |\n1 | ...) ; free_caches () } ; let mut mmap = memory :: map_file (\"huge_dataset.bin\" . to_string () , READ_ONLY) ; let mut data = mmap . read_...\n  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`\n  |\n  = help: you might be missing a crate named `memory`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`\n --> /tmp/.tmpo0SCZG/main.rs:1:818\n  |\n1 | ... ; mmap . close () ; let mut shared = memory :: create_shared (\"my_buffer\" . to_string () , 1024i32 * 1024i32) ; shared . write (0i32 ...\n  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`\n  |\n  = help: you might be missing a crate named `memory`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`\n --> /tmp/.tmpo0SCZG/main.rs:1:941\n  |\n1 | ...rite (0i32 , data) ; let mut shared = memory :: open_shared (\"my_buffer\" . to_string ()) ; let mut data = shared . read (0i32 , 1024i3...\n  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`\n  |\n  = help: you might be missing a crate named `memory`\n\nerror: aborting due to 11 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 5,
          "line_number": 239,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: service_manager.ruchy\n// Manage system services\n\nprintln(\"=== Service Manager ===\")\n\nlet services = [\n    {name: \"web_server\", command: \"./server\", port: 8080},\n    {name: \"worker\", command: \"./worker\", count: 4},\n    {name: \"scheduler\", command: \"./scheduler\", interval: 60}\n]\n\nlet running_services = {}\n\nfun start_service(service) {\n    println(\"Starting \" + service.name + \"...\")\n    \n    match service.name {\n        \"web_server\" => {\n            let proc = process::spawn(service.command, [\n                \"--port\", service.port.to_s()\n            ])\n            running_services[service.name] = proc\n            \n            // Wait for port to be available\n            while !network::port_is_open(\"localhost\", service.port) {\n                sleep(100)\n            }\n            println(\"✅ \" + service.name + \" listening on port \" + service.port.to_s())\n        }\n        \"worker\" => {\n            let workers = []\n            for i in range(service.count) {\n                let proc = process::spawn(service.command, [\n                    \"--id\", i.to_s()\n                ])\n                workers.push(proc)\n            }\n            running_services[service.name] = workers\n            println(\"✅ Started \" + service.count.to_s() + \" workers\")\n        }\n        \"scheduler\" => {\n            let proc = process::spawn(service.command, [\n                \"--interval\", service.interval.to_s()\n            ])\n            running_services[service.name] = proc\n            println(\"✅ Scheduler running every \" + service.interval.to_s() + \"s\")\n        }\n    }\n}\n\nfun stop_service(name) {\n    if running_services.has_key(name) {\n        println(\"Stopping \" + name + \"...\")\n        let proc = running_services[name]\n        \n        if proc.is_array() {\n            // Multiple processes (workers)\n            for p in proc {\n                p.terminate()\n                p.wait()\n            }\n        } else {\n            // Single process\n            proc.terminate()\n            proc.wait()\n        }\n        \n        running_services.remove(name)\n        println(\"✅ \" + name + \" stopped\")\n    }\n}\n\nfun service_status() {\n    println(\"\\n=== Service Status ===\")\n    for service in services {\n        let status = if running_services.has_key(service.name) {\n            \"🟢 Running\"\n        } else {\n            \"🔴 Stopped\"\n        }\n        println(service.name + \" \" + status)\n    }\n}\n\n// Handle shutdown gracefully\nsignal::on(SIGTERM, || {\n    println(\"\\nShutting down all services...\")\n    for name in running_services.keys() {\n        stop_service(name)\n    }\n    exit(0)\n})\n\n// Interactive management\nloop {\n    service_status()\n    println(\"\\nCommands: start <name>, stop <name>, restart <name>, quit\")\n    let command = input(\"> \").split(\" \")\n    \n    match command[0] {\n        \"start\" => start_service(services.find(|s| s.name == command[1]))\n        \"stop\" => stop_service(command[1])\n        \"restart\" => {\n            stop_service(command[1])\n            start_service(services.find(|s| s.name == command[1]))\n        }\n        \"quit\" => break\n        _ => println(\"Unknown command\")\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 6,
          "line_number": 362,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: health_check.ruchy\n// Monitor system health and alert on issues\n\nprintln(\"=== System Health Checker ===\")\n\nlet checks = {\n    cpu_threshold: 80,      // Alert if CPU > 80%\n    memory_threshold: 90,   // Alert if memory > 90%\n    disk_threshold: 95,     // Alert if disk > 95%\n    load_threshold: 4.0,    // Alert if load average > 4\n    temp_threshold: 80      // Alert if CPU temp > 80°C\n}\n\nlet alerts = []\n\nfun check_cpu() {\n    let usage = system::cpu_usage() * 100\n    if usage > checks.cpu_threshold {\n        alerts.push({\n            level: \"WARNING\",\n            message: \"CPU usage high: \" + usage.to_s() + \"%\",\n            time: current_datetime()\n        })\n        return false\n    }\n    return true\n}\n\nfun check_memory() {\n    let mem = system::memory_info()\n    let usage = (mem.used / mem.total) * 100\n    if usage > checks.memory_threshold {\n        alerts.push({\n            level: \"CRITICAL\",\n            message: \"Memory usage critical: \" + usage.to_s() + \"%\",\n            time: current_datetime()\n        })\n        return false\n    }\n    return true\n}\n\nfun check_disk() {\n    let disks = system::disk_usage()\n    for disk in disks {\n        let usage = (disk.used / disk.total) * 100\n        if usage > checks.disk_threshold {\n            alerts.push({\n                level: \"WARNING\",\n                message: \"Disk \" + disk.mount + \" almost full: \" + usage.to_s() + \"%\",\n                time: current_datetime()\n            })\n            return false\n        }\n    }\n    return true\n}\n\nfun check_load() {\n    let load = system::load_average()\n    let cpu_count = system::cpu_count()\n    let normalized_load = load.one_minute / cpu_count\n    \n    if normalized_load > checks.load_threshold {\n        alerts.push({\n            level: \"WARNING\",\n            message: \"System load high: \" + load.one_minute.to_s() + \",\",\n            time: current_datetime()\n        })\n        return false\n    }\n    return true\n}\n\nfun check_temperature() {\n    let temps = system::temperatures()\n    for sensor in temps {\n        if sensor.current > checks.temp_threshold {\n            alerts.push({\n                level: \"CRITICAL\",\n                message: \"Temperature critical: \" + sensor.name + \" at \" + sensor.current.to_s() + \"°C\",\n                time: current_datetime()\n            })\n            return false\n        }\n    }\n    return true\n}\n\nfun run_health_checks() {\n    let all_healthy = true\n    \n    all_healthy = check_cpu() && all_healthy\n    all_healthy = check_memory() && all_healthy\n    all_healthy = check_disk() && all_healthy\n    all_healthy = check_load() && all_healthy\n    all_healthy = check_temperature() && all_healthy\n    \n    return all_healthy\n}\n\n// Main monitoring loop\nloop {\n    clear_screen()\n    println(\"System Health Check - \" + current_datetime())\n    println(\"=\" * 50)\n    \n    let healthy = run_health_checks()\n    \n    if healthy {\n        println(\"✅ All systems healthy\")\n    } else {\n        println(\"⚠️  Issues detected:\")\n        for alert in alerts.last(5) {\n            let icon = alert.level == \"CRITICAL\" ? \"🔴\" : \"🟡\"\n            println(icon + \" [\" + alert.level + \"] \" + alert.message)\n        }\n    }\n    \n    // Show current stats\n    println(\"\\nCurrent Status:\")\n    let cpu = system::cpu_usage() * 100\n    let mem = system::memory_info()\n    let mem_percent = (mem.used / mem.total) * 100\n    let load = system::load_average()\n    \n    println(\"CPU:    \" + cpu.to_s() + \"% / \" + checks.cpu_threshold.to_s() + \"%\")\n    println(\"Memory: \" + mem_percent.to_s() + \"% / \" + checks.memory_threshold.to_s() + \"%\")\n    println(\"Load:   \" + load.one_minute.to_s() + \" / \" + checks.load_threshold.to_s())\n    \n    // Send notifications for critical alerts\n    for alert in alerts {\n        if alert.level == \"CRITICAL\" {\n            system::notify(alert.message, \"System Health Alert\")\n        }\n    }\n    \n    sleep(5000)  // Check every 5 seconds\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 7,
          "line_number": 514,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: process_tree.ruchy\n// Visualize process hierarchy\n\nfun build_process_tree() {\n    let processes = process::list()\n    let tree = {}\n    \n    // Build parent-child relationships\n    for proc in processes {\n        let ppid = proc.parent_pid\n        if !tree.has_key(ppid) {\n            tree[ppid] = []\n        }\n        tree[ppid].push(proc)\n    }\n    \n    return tree\n}\n\nfun print_tree(pid, tree, indent = \"\") {\n    if !tree.has_key(pid) {\n        return\n    }\n    \n    let children = tree[pid].sort_by(|p| p.pid)\n    for i, proc in children.enumerate() {\n        let is_last = (i == children.len() - 1)\n        let prefix = is_last ? \"└─\" : \"├─\"\n        let extension = is_last ? \"  \" : \"│ \"\n        \n        let memory = format_size(proc.memory_info.rss)\n        println(indent + prefix + \" [\" + proc.pid.to_s() + \"] \" + proc.name + \" (\" + memory + \", \" + proc.cpu_percent.to_s() + \"%)\")\n        \n        // Recursively print children\n        print_tree(proc.pid, tree, indent + extension)\n    }\n}\n\nprintln(\"=== Process Tree ===\")\nlet tree = build_process_tree()\n\n// Start from init (PID 1) or system idle (PID 0)\nlet root_pid = tree.has_key(0) ? 0 : 1\nprintln(\"[\" + root_pid.to_s() + \"] System Root\")\nprint_tree(root_pid, tree)\n\n// Show process statistics\nlet all_procs = process::list()\nlet total_memory = all_procs.map(|p| p.memory_info.rss).sum()\nlet total_cpu = all_procs.map(|p| p.cpu_percent).sum()\n\nprintln(\"\\nTotal Processes: \" + all_procs.len().to_s())\nprintln(\"Total Memory: \" + format_size(total_memory))\nprintln(\"Total CPU: \" + total_cpu.to_s() + \"%\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 8,
          "line_number": 585,
          "code": "// Status: ❌ BROKEN\n\n// Watch for file system events\nlet watcher = fs::watch(\"/path/to/watch\", RECURSIVE)\n\nwatcher.on(\"created\", |path| {\n    println(\"File created: \" + path)\n})\n\nwatcher.on(\"modified\", |path| {\n    println(\"File modified: \" + path)\n    process_change(path)\n})\n\nwatcher.on(\"deleted\", |path| {\n    println(\"File deleted: \" + path)\n})\n\nwatcher.start()\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `RECURSIVE` in this scope\n --> /tmp/.tmpkYWXlu/main.rs:1:130\n  |\n1 | ... = fs :: watch (\"/path/to/watch\" . to_string () , RECURSIVE) ; watcher . on (\"created\" , | path | { println ! (\"{}\" , format ! (\"{}{}\"...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpkYWXlu/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut watcher = fs :: watch (\"/path/to/watch\" . to_string () , RECURSIV...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n --> /tmp/.tmpkYWXlu/main.rs:1:83\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut watcher = fs :: watch (\"/path/to/watch\" . to_string () , RECURSIV...\n  |                                                                                   ^^ use of unresolved module or unlinked crate `fs`\n  |\n  = help: you might be missing a crate named `fs`\n\nerror[E0425]: cannot find function `process_change` in this scope\n --> /tmp/.tmpkYWXlu/main.rs:1:352\n  |\n1 | ...format ! (\"{}{}\" , \"File modified: \" , path)) ; process_change (path) }) ; watcher . on (\"deleted\" , | path | { println ! (\"{}\" , form...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 9,
          "line_number": 617,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Automated system maintenance\nfun auto_cleanup() {\n    // Clean temp files older than 7 days\n    let temp_dir = \"/tmp\"\n    let cutoff_time = current_time() - days(7)\n    \n    for file in fs::walk(temp_dir) {\n        if fs::modified_time(file) < cutoff_time {\n            fs::remove(file)\n            println(\"Cleaned: \" + file)\n        }\n    }\n    \n    // Clear package manager cache\n    if fs::dir_size(\"/var/cache/apt\") > gb(1) {\n        run_command(\"apt-get clean\")\n    }\n    \n    // Rotate logs\n    for log in fs::glob(\"/var/log/*.log\") {\n        if fs::size(log) > mb(100) {\n            fs::rotate_log(log, keep_count: 5)\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch08-00-advanced-functions-tdd": {
      "chapter": "ch08-00-advanced-functions-tdd",
      "total_examples": 9,
      "working_examples": 5,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun double(x: i32) -> i32 {\n    return x * 2;\n}\n\nfun add_ten(x: i32) -> i32 {\n    return x + 10;\n}\n\nfun main() {\n    let x = 5;\n    let doubled = double(x);\n    let result = add_ten(doubled);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 2,
          "line_number": 61,
          "code": "// Status: ✅ WORKING\nfun classify_number(x: i32) -> i32 {\n    if x < 0 {\n        return -1;\n    }\n    if x == 0 {\n        return 0;\n    }\n    return 1;\n}\n\nfun main() {\n    println(classify_number(-5));\n    println(classify_number(0));\n    println(classify_number(10));\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 3,
          "line_number": 93,
          "code": "// Status: ✅ WORKING\nfun factorial(n: i32) -> i32 {\n    if n <= 1 {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nfun main() {\n    println(factorial(1));\n    println(factorial(3));\n    println(factorial(5));\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 4,
          "line_number": 141,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun step_one(x: Type) -> Type { ... }\nfun step_two(x: Type) -> Type { ... }\n\n// Usage\nlet intermediate = step_one(input);\nlet result = step_two(intermediate);",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 5,
          "line_number": 155,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfun categorize(input: Type) -> ResultType {\n    if condition1 {\n        return result1;\n    }\n    if condition2 {\n        return result2;\n    }\n    return default_result;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `Type` in this scope\n --> /tmp/.tmp3VYqAs/main.rs:1:60\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |                                                            ^^^^ not found in this scope\n\nerror[E0412]: cannot find type `ResultType` in this scope\n --> /tmp/.tmp3VYqAs/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |                                                                     ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `condition1` in this scope\n --> /tmp/.tmp3VYqAs/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |                                                                                       ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `result1` in this scope\n --> /tmp/.tmp3VYqAs/main.rs:1:109\n  |\n1 | ...: Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn m...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `condition2` in this scope\n --> /tmp/.tmp3VYqAs/main.rs:1:126\n  |\n1 | ...ype { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `result2` in this scope\n --> /tmp/.tmp3VYqAs/main.rs:1:148\n  |\n1 | ... { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `default_result` in this scope\n --> /tmp/.tmp3VYqAs/main.rs:1:169\n  |\n1 | ...; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp3VYqAs/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp3VYqAs/main.rs:1:100\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |                                                                                                    ^^              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { return result1 } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp3VYqAs/main.rs:1:139\n  |\n1 | ... { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |                                                              ^^              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { return result2 } ; return default_result } } fn main () { }\n  |\n\nerror: aborting due to 7 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 6,
          "line_number": 172,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfun recursive_func(n: Type) -> Type {\n    if base_condition {\n        return base_value;\n    }\n    return combine(n, recursive_func(reduce(n)));\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `Type` in this scope\n --> /tmp/.tmp6ZlffK/main.rs:1:60\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |                                                            ^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Type` in this scope\n --> /tmp/.tmp6ZlffK/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |                                                                     ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `base_condition` in this scope\n --> /tmp/.tmp6ZlffK/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |                                                                                 ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `base_value` in this scope\n --> /tmp/.tmp6ZlffK/main.rs:1:107\n  |\n1 | ... : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp6ZlffK/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp6ZlffK/main.rs:1:98\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |                                                                                                  ^^                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { return base_value } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n  |\n\nerror[E0425]: cannot find function `reduce` in this scope\n --> /tmp/.tmp6ZlffK/main.rs:1:160\n  |\n1 | ...ase_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `combine` in this scope\n --> /tmp/.tmp6ZlffK/main.rs:1:131\n  |\n1 | ... base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 7,
          "line_number": 200,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun validate(input: i32) -> i32 { ... }\nfun normalize(input: i32) -> i32 { ... }\nfun process(input: i32) -> i32 { ... }\n\n// Usage\nlet clean_input = validate(raw_input);\nlet normal_input = normalize(clean_input);\nlet result = process(normal_input);",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 8,
          "line_number": 216,
          "code": "// Status: ✅ WORKING\nfun get_grade(score: i32) -> i32 {\n    if score >= 90 {\n        return 4; // A\n    }\n    if score >= 80 {\n        return 3; // B\n    }\n    if score >= 70 {\n        return 2; // C\n    }\n    return 1; // D/F\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 9,
          "line_number": 235,
          "code": "// Status: ✅ WORKING\nfun countdown(n: i32) -> i32 {\n    if n <= 0 {\n        return 0;\n    }\n    println(n);\n    return countdown(n - 1);\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch13-00-error-handling": {
      "chapter": "ch13-00-error-handling",
      "total_examples": 12,
      "working_examples": 0,
      "failing_examples": 12,
      "examples": [
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Define error types\nenum AppError {\n    NetworkError(String)\n    ParseError(String)\n    NotFound(String)\n    Unauthorized\n}\n\n// Functions return Result\nfun fetch_user(id: i32) -> Result<User, AppError> {\n    // Note: In v0.11.0, the ? operator is removed. Use match for error handling:\n    let response = match http::get(\"/api/users/\" + id.to_s()) {\n        Ok(r) => r,\n        Err(e) => return Err(AppError::NetworkError(e))\n    }\n    \n    if response.status == 404 {\n        return Err(AppError::NotFound(\"User \" + id.to_s() + \" not found\"))\n    }\n    \n    if response.status == 401 {\n        return Err(AppError::Unauthorized)\n    }\n    \n    let user = match parse_json(response.body) {\n        Ok(u) => u,\n        Err(e) => return Err(AppError::ParseError(e.to_string()))\n    }\n    \n    return Ok(user)\n}\n\n// Handle errors explicitly\nmatch fetch_user(123) {\n    Ok(user) => {\n        println(\"Found user: \" + user.name)\n    }\n    Err(AppError::NotFound(msg)) => {\n        println(\"User not found: \" + msg)\n    }\n    Err(AppError::NetworkError(e)) => {\n        println(\"Network problem: \" + e.to_s())\n        retry_with_backoff()\n    }\n    Err(e) => {\n        log_error(e)\n        return_default_user()\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 2,
          "line_number": 98,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Result is an enum with two variants\nenum Result<T, E> {\n    Ok(T)    // Success with value\n    Err(E)   // Error with error value\n}\n\n// Functions that can fail return Result\nfun divide(a: f64, b: f64) -> Result<f64, String> {\n    if b == 0.0 {\n        return Err(\"Division by zero\")\n    }\n    return Ok(a / b)\n}\n\n// Check and handle results\nlet result = divide(10.0, 2.0)\nif result.is_ok() {\n    println(\"Result: \" + result.unwrap().to_s())\n} else {\n    println(\"Error: \" + result.unwrap_err().to_s())\n}\n\n// Pattern matching\nmatch divide(10.0, 0.0) {\n    Ok(value) => println(\"Success: \" + value.to_s())\n    Err(error) => println(\"Failed: \" + error.to_s())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 3,
          "line_number": 140,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Option represents nullable values\nenum Option<T> {\n    Some(T)  // Value present\n    None     // Value absent\n}\n\n// Functions that might not return a value\nfun find_user(name: String) -> Option<User> {\n    let users = load_users()\n    for user in users {\n        if user.name == name {\n            return Some(user)\n        }\n    }\n    return None\n}\n\n// Safe handling of missing values\nlet user = find_user(\"Alice\")\nif let Some(u) = user {\n    println(\"Found: \" + u.email)\n} else {\n    println(\"User not found\")\n}\n\n// Chain operations safely\nlet email = find_user(\"Bob\")\n    .map(|u| u.email)\n    .unwrap_or(\"no-email@example.com\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 4,
          "line_number": 184,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Without ? operator - verbose\nfun process_file_verbose(path: String) -> Result<String, Error> {\n    let file = match open_file(path) {\n        Ok(f) => f\n        Err(e) => return Err(e)\n    }\n    \n    let contents = match read_all(file) {\n        Ok(c) => c\n        Err(e) => return Err(e)\n    }\n    \n    let processed = match process(contents) {\n        Ok(p) => p\n        Err(e) => return Err(e)\n    }\n    \n    return Ok(processed)\n}\n\n// In v0.11.0 - use explicit error handling\nfun process_file(path: String) -> Result<String, Error> {\n    let file = match open_file(path) {\n        Ok(f) => f,\n        Err(e) => return Err(e)\n    }\n    let contents = match read_all(file) {\n        Ok(c) => c,\n        Err(e) => return Err(e)\n    }\n    let processed = match process(contents) {\n        Ok(p) => p,\n        Err(e) => return Err(e)\n    }\n    return Ok(processed)\n}\n\n// Chain multiple operations with explicit handling\nfun complex_operation() -> Result<Data, Error> {\n    let data = match fetch_data() {\n        Ok(d) => d,\n        Err(e) => return Err(e)\n    }\n    let validated = match data.validate() {\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    }\n    let transformed = match validated.transform() {\n        Ok(t) => t,\n        Err(e) => return Err(e)\n    }\n    let optimized = match transformed.optimize() {\n        Ok(o) => o,\n        Err(e) => return Err(e)\n    }\n    \n    return Ok(optimized)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 5,
          "line_number": 257,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Detailed error enum\nenum DatabaseError {\n    ConnectionFailed { host: String, port: i32 }\n    QueryFailed { query: String, error: String }\n    Timeout { duration: i32 }\n    InvalidCredentials\n}\n\nimpl Display for DatabaseError {\n    fun fmt(self, f: Formatter) -> Result {\n        match self {\n            ConnectionFailed{host, port} => \n                write(f, \"Failed to connect to \" + host + \":\" + port.to_s())\n            QueryFailed{query, error} => \n                write(f, \"Query failed: \" + query + \"\\nError: \" + error)\n            Timeout{duration} => \n                write(f, \"Operation timed out after \" + duration.to_s() + \"ms\")\n            InvalidCredentials => \n                write(f, \"Invalid database credentials\")\n        }\n    }\n}\n\n// Error with context\nstruct Error {\n    kind: ErrorKind\n    message: String\n    source: Option<Box<Error>>\n    backtrace: Backtrace\n}\n\nimpl Error {\n    fun new(kind: ErrorKind, message: String) -> Error {\n        return Error{\n            kind,\n            message,\n            source: None,\n            backtrace: Backtrace::capture()\n        }\n    }\n    \n    fun with_source(mut self, source: Error) -> Error {\n        self.source = Some(Box::new(source))\n        return self\n    }\n    \n    fun chain(self) -> Vec<String> {\n        let mut messages = vec![self.message]\n        let mut current = self.source\n        \n        while let Some(error) = current {\n            messages.push(error.message)\n            current = error.source\n        }\n        \n        return messages\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 6,
          "line_number": 332,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun validate_user(user: User) -> Result<User, ValidationError> {\n    // Early return on validation failures\n    if user.name.is_empty() {\n        return Err(ValidationError::EmptyName)\n    }\n    \n    if !is_valid_email(user.email) {\n        return Err(ValidationError::InvalidEmail(user.email))\n    }\n    \n    if user.age < 0 || user.age > 150 {\n        return Err(ValidationError::InvalidAge(user.age))\n    }\n    \n    // All validations passed\n    return Ok(user)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 7,
          "line_number": 364,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Retry with exponential backoff\nfun fetch_with_retry<T>(\n    operation: Fn() -> Result<T, Error>,\n    max_attempts: i32\n) -> Result<T, Error> {\n    let mut attempt = 0\n    let mut delay = 1000  // Start with 1 second\n    \n    loop {\n        match operation() {\n            Ok(result) => return Ok(result)\n            Err(e) if attempt >= max_attempts => {\n                return Err(e)\n            }\n            Err(e) => {\n                println(\"Attempt \" + (attempt + 1).to_s() + \" failed: \" + e.to_s())\n                sleep(delay)\n                delay *= 2  // Exponential backoff\n                attempt += 1\n            }\n        }\n    }\n}\n\n// Fallback strategies\nfun get_config() -> Config {\n    load_config_file()\n        .or_else(|| load_env_config())\n        .or_else(|| fetch_remote_config())\n        .unwrap_or_else(|| Config::default())\n}\n\n// Circuit breaker pattern\nstruct CircuitBreaker {\n    failure_count: i32\n    last_failure: Option<Instant>\n    state: State\n}\n\nimpl CircuitBreaker {\n    fn call<T>(mut self, f: Fn() -> Result<T, Error>) -> Result<T, Error> {\n        match self.state {\n            State::Open => {\n                if self.should_attempt() {\n                    self.state = State::HalfOpen\n                } else {\n                    return Err(Error::CircuitOpen)\n                }\n            }\n            _ => {}\n        }\n        \n        match f() {\n            Ok(result) => {\n                self.reset()\n                Ok(result)\n            }\n            Err(e) => {\n                self.record_failure()\n                Err(e)\n            }\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 8,
          "line_number": 443,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Trait for adding context\ntrait Context<T> {\n    fun context(self, msg: String) -> Result<T, Error>\n    fun with_context<F>(self, f: F) -> Result<T, Error>\n        where F: FnOnce() -> String\n}\n\nimpl<T, E: Into<Error>> Context<T> for Result<T, E> {\n    fun context(self, msg: String) -> Result<T, Error> {\n        self.map_err(|e| {\n            Error::new(e.into())\n                .with_message(msg)\n        })\n    }\n    \n    fun with_context<F>(self, f: F) -> Result<T, Error>\n        where F: FnOnce() -> String\n    {\n        self.map_err(|e| {\n            Error::new(e.into())\n                .with_message(f())\n        })\n    }\n}\n\n// Use context for better errors\nfun process_order(order_id: i32) -> Result<Order, Error> {\n    let order = fetch_order(order_id)\n        .context(\"Failed to fetch order \" + order_id)??\n    \n    let validated = validate_order(order)\n        .context(\"Order validation failed\")?\n    \n    let processed = process_payment(validated)\n        .with_context(|| \"Payment processing failed for $\" + validated.total.to_s())??\n    \n    return Ok(processed)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 9,
          "line_number": 496,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Structured API errors\nstruct ApiError {\n    status: i32\n    code: String\n    message: String\n    details: Option<Map<String, Any>>\n}\n\nimpl ApiError {\n    fun bad_request(message: String) -> ApiError {\n        ApiError{\n            status: 400,\n            code: \"BAD_REQUEST\",\n            message,\n            details: None\n        }\n    }\n    \n    fun unauthorized() -> ApiError {\n        ApiError{\n            status: 401,\n            code: \"UNAUTHORIZED\",\n            message: \"Authentication required\",\n            details: None\n        }\n    }\n    \n    fun internal_error(error: Error) -> ApiError {\n        // Log full error internally\n        log::error(\"Internal error: \" + error.chain().join(\" -> \"))\n        \n        // Return sanitized error to client\n        ApiError{\n            status: 500,\n            code: \"INTERNAL_ERROR\",\n            message: \"An internal error occurred\",\n            details: None\n        }\n    }\n}\n\n// Convert to HTTP response\nimpl IntoResponse for ApiError {\n    fun into_response(self) -> Response {\n        Response::builder()\n            .status(self.status)\n            .json(self)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 10,
          "line_number": 558,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Composable validators\ntype Validator<T> = Fn(T) -> Result<T, ValidationError>\n\nfun validate_pipeline<T>(\n    value: T,\n    validators: Vec<Validator<T>>\n) -> Result<T, Vec<ValidationError>> {\n    let mut errors = Vec::new()\n    let mut current = value\n    \n    for validator in validators {\n        match validator(current) {\n            Ok(validated) => current = validated\n            Err(e) => errors.push(e)\n        }\n    }\n    \n    if errors.is_empty() {\n        Ok(current)\n    } else {\n        Err(errors)\n    }\n}\n\n// Use validation pipeline\nlet user_validators = vec![\n    validate_required_fields,\n    validate_email_format,\n    validate_age_range,\n    validate_unique_username\n]\n\nmatch validate_pipeline(user, user_validators) {\n    Ok(valid_user) => save_user(valid_user)\n    Err(errors) => {\n        for error in errors {\n            println(\"Validation error: \" + error.to_s())\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 11,
          "line_number": 611,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Async Result type\nasync fun fetch_data(url: String) -> Result<Data, Error> {\n    let response = http::get(url).await?\n    let parsed = parse_response(response).await?\n    return Ok(parsed)\n}\n\n// Try multiple sources\nasync fun get_data_with_fallback() -> Result<Data, Error> {\n    // Try primary source\n    if let Ok(data) = fetch_data(PRIMARY_URL).await {\n        return Ok(data)\n    }\n    \n    // Try backup source\n    if let Ok(data) = fetch_data(BACKUP_URL).await {\n        return Ok(data)\n    }\n    \n    // Try cache\n    if let Some(cached) = get_cached_data().await {\n        log::warn(\"Using stale cached data\")\n        return Ok(cached)\n    }\n    \n    return Err(Error::NoDataAvailable)\n}\n\n// Parallel error handling\nasync fun fetch_all(urls: Vec<String>) -> Vec<Result<Data, Error>> {\n    let futures = urls.map(|url| fetch_data(url))\n    return join_all(futures).await\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 12,
          "line_number": 657,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n#[test]\nfun test_error_handling() {\n    // Test expected errors\n    let result = divide(10.0, 0.0)\n    assert!(result.is_err())\n    assert_eq!(result.unwrap_err(), \"Division by zero\")\n    \n    // Test error propagation\n    let result = process_invalid_file()\n    assert!(matches!(result, Err(FileError::NotFound(_))))\n    \n    // Test recovery\n    let config = get_config_with_fallback()\n    assert!(config.is_valid())  // Should always succeed\n}\n\n#[test]\n#[should_panic(expected = \"assertion failed\")]\nfun test_panic_condition() {\n    unsafe_operation()\n}\n\n// Property-based testing for error conditions\n#[property_test]\nfun never_panics(input: RandomInput) {\n    let _ = safe_process(input)  // Should never panic\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch03-01-testing-functions": {
      "chapter": "ch03-01-testing-functions",
      "total_examples": 12,
      "working_examples": 0,
      "failing_examples": 12,
      "examples": [
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Your function\nfun add(a, b) {\n    a + b\n}\n\n// Your test\n#[test]\nfun test_add() {\n    assert_eq!(add(2, 3), 5)\n    assert_eq!(add(0, 0), 0)\n    assert_eq!(add(-1, 1), 0)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 2,
          "line_number": 68,
          "code": "// Status: ❌ BROKEN\n#[test]\nfun test_function_name() {\n    // Test code here\n    assert_eq!(actual, expected)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 3,
          "line_number": 98,
          "code": "// Status: ❌ BROKEN\n// tests/calculator_test.ruchy\n\nuse super::*;  // Import functions from main module\n\n#[test]\nfun test_addition() {\n    assert_eq!(add(2, 3), 5)\n}\n\n#[test]  \nfun test_subtraction() {\n    assert_eq!(subtract(10, 4), 6)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 4,
          "line_number": 128,
          "code": "// Status: ❌ BROKEN\n// calculator.ruchy\nfun multiply(a, b) {\n    a * b\n}\n\nfun divide(a, b) {\n    if b == 0 {\n        0  // Simple handling for now\n    } else {\n        a / b\n    }\n}\n\nfun is_even(n) {\n    n % 2 == 0\n}\n\n// tests/calculator_test.ruchy  \n#[test]\nfun test_multiply() {\n    assert_eq!(multiply(3, 4), 12)\n    assert_eq!(multiply(0, 5), 0)\n    assert_eq!(multiply(-2, 3), -6)\n}\n\n#[test]\nfun test_divide() {\n    assert_eq!(divide(10, 2), 5)\n    assert_eq!(divide(7, 3), 2)  // Integer division\n    assert_eq!(divide(5, 0), 0)  // Division by zero handled\n}\n\n#[test]\nfun test_is_even() {\n    assert!(is_even(4))        // 4 is even\n    assert!(!is_even(3))       // 3 is not even  \n    assert!(is_even(0))        // 0 is even\n    assert!(!is_even(-1))      // -1 is not even\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 5,
          "line_number": 182,
          "code": "// Status: ❌ BROKEN\nfun find_max(numbers) {\n    if numbers.len() == 0 {\n        -999999  // Sentinel value for empty\n    } else {\n        let mut max_val = numbers[0]\n        let mut i = 1\n        while i < numbers.len() {\n            if numbers[i] > max_val {\n                max_val = numbers[i]\n            }\n            i = i + 1\n        }\n        max_val\n    }\n}\n\n#[test]\nfun test_find_max() {\n    // Normal cases\n    assert_eq!(find_max([1, 5, 3, 9, 2]), 9)\n    assert_eq!(find_max([10]), 10)\n    \n    // Edge cases\n    assert_eq!(find_max([]), -999999)        // Empty list\n    assert_eq!(find_max([-5, -1, -10]), -1)  // All negative\n    assert_eq!(find_max([5, 5, 5]), 5)       // All same\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 6,
          "line_number": 222,
          "code": "// Status: ❌ BROKEN\nfun clean_username(raw_username) {\n    // Simple cleaning - replace spaces with underscores\n    raw_username.replace(\" \", \"_\")\n}\n\nfun count_vowels(text) {\n    let vowels = \"aeiouAEIOU\"\n    let mut count = 0\n    let mut i = 0\n    while i < text.len() {\n        if vowels.contains(text[i]) {\n            count = count + 1\n        }\n        i = i + 1\n    }\n    count\n}\n\n#[test]\nfun test_clean_username() {\n    assert_eq!(clean_username(\"Alice Johnson\"), \"Alice_Johnson\")\n    assert_eq!(clean_username(\"JOHN\"), \"JOHN\")\n    assert_eq!(clean_username(\"\"), \"\")\n}\n\n#[test]\nfun test_count_vowels() {\n    assert_eq!(count_vowels(\"hello\"), 2)      // e, o\n    assert_eq!(count_vowels(\"HELLO\"), 2)      // Case insensitive\n    assert_eq!(count_vowels(\"xyz\"), 0)        // No vowels\n    assert_eq!(count_vowels(\"aeiou\"), 5)      // All vowels\n    assert_eq!(count_vowels(\"\"), 0)           // Empty string\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 7,
          "line_number": 268,
          "code": "// Status: ❌ BROKEN\nfun calculate_grade(score) {\n    if score >= 90 { \"A\" }\n    else if score >= 80 { \"B\" } \n    else if score >= 70 { \"C\" }\n    else if score >= 60 { \"D\" }\n    else { \"F\" }\n}\n\nfun can_vote(age, is_citizen) {\n    age >= 18 && is_citizen\n}\n\n#[test]\nfun test_calculate_grade() {\n    // Boundary testing\n    assert_eq!(calculate_grade(95), \"A\")\n    assert_eq!(calculate_grade(90), \"A\")  // Exactly 90\n    assert_eq!(calculate_grade(89), \"B\")  // Just below A\n    assert_eq!(calculate_grade(80), \"B\")  // Exactly 80\n    assert_eq!(calculate_grade(79), \"C\")  // Just below B\n    assert_eq!(calculate_grade(59), \"F\")  // Failing grade\n    assert_eq!(calculate_grade(0), \"F\")   // Very low\n}\n\n#[test]\nfun test_can_vote() {\n    // All combinations\n    assert!(can_vote(18, true))      // Minimum age, citizen\n    assert!(can_vote(25, true))      // Adult citizen\n    assert!(!can_vote(17, true))     // Too young\n    assert!(!can_vote(25, false))    // Not citizen\n    assert!(!can_vote(17, false))    // Too young AND not citizen\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 8,
          "line_number": 320,
          "code": "// Status: ❌ BROKEN\n\n// Step 1: Write the test first\n#[test]\nfun test_fahrenheit_to_celsius() {\n    assert_eq!(fahrenheit_to_celsius(32), 0)    // Freezing point\n    assert_eq!(fahrenheit_to_celsius(212), 100) // Boiling point\n    assert_eq!(fahrenheit_to_celsius(98.6), 37) // Body temperature\n}\n\n// Step 2: Write minimal code to pass\nfun fahrenheit_to_celsius(fahrenheit) {\n    return (fahrenheit - 32) * 5 / 9\n}\n\n// Step 3: Run tests, refactor if needed\n// All tests pass! Code is ready to use.\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 9,
          "line_number": 351,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Only testing happy path\n#[test]\nfun test_divide_bad() {\n    assert_eq!(divide(10, 2), 5)  // What about divide by zero?\n}\n\n// ✅ Testing edge cases\n#[test]\nfun test_divide_good() {\n    assert_eq!(divide(10, 2), 5)      // Normal case\n    assert_eq!(divide(0, 5), 0)       // Zero dividend\n    // Should handle divide by zero gracefully\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 10,
          "line_number": 378,
          "code": "// Status: ❌ BROKEN\n\n// ❌ This test will always pass\n#[test]\nfun test_useless() {\n    let result = add(2, 3)\n    assert!(result > 0)  // Too vague!\n}\n\n// ✅ This test verifies exact behavior\n#[test]  \nfun test_useful() {\n    assert_eq!(add(2, 3), 5)  // Exact expectation\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 11,
          "line_number": 404,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Unclear what this tests\n#[test]\nfun test1() {\n    assert_eq!(is_valid(\"abc\"), false)\n}\n\n// ✅ Clear, descriptive name\n#[test]\nfun test_password_too_short() {\n    assert_eq!(is_valid_password(\"abc\"), false)\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 12,
          "line_number": 467,
          "code": "// Status: ❌ BROKEN\n\n// 1. Write failing tests first\n#[test]\nfun test_is_strong_password() {\n    assert!(is_strong_password(\"MyPass123!\"))      // Valid\n    assert!(!is_strong_password(\"weak\"))           // Too short\n    assert!(!is_strong_password(\"NoNumbers!\"))     // No digits\n    assert!(!is_strong_password(\"nonumbers123\"))   // No special chars\n}\n\n// 2. Write minimal code to pass\nfun is_strong_password(password) {\n    if password.len() < 8 { return false }\n    \n    let has_digit = password.chars().any(|c| c.is_digit())\n    let has_special = password.chars().any(|c| \"!@#$%^&*\".contains(c))\n    \n    return has_digit && has_special\n}\n\n// 3. Run tests - they should all pass now!\n\n// 4. Add more edge case tests\n#[test]\nfun test_password_edge_cases() {\n    assert!(!is_strong_password(\"\"))              // Empty\n    assert!(!is_strong_password(\"12345678\"))      // Only digits\n    assert!(!is_strong_password(\"!!!!!!!!\"))      // Only special\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch16-00-testing-quality": {
      "chapter": "ch16-00-testing-quality",
      "total_examples": 11,
      "working_examples": 0,
      "failing_examples": 11,
      "examples": [
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Unit test with multiple assertions\n#[test]\nfun test_user_validation() {\n    // Arrange\n    let valid_user = User {\n        name: \"Alice\",\n        email: \"alice@example.com\",\n        age: 25\n    }\n    \n    // Act\n    let result = validate_user(valid_user)\n    \n    // Assert\n    assert!(result.is_ok())\n    assert_eq!(result.unwrap().name, \"Alice\")\n}\n\n// Property-based testing\n#[proptest]\nfun test_serialization_roundtrip(user: User) {\n    let serialized = user.serialize()\n    let deserialized = User::deserialize(serialized)\n    assert_eq!(user, deserialized)\n}\n\n// Integration test\n#[integration_test]\nasync fun test_api_workflow() {\n    // Start test server\n    let server = TestServer::new()\n    \n    // Create user\n    let response = server.post(\"/users\")\n        .json(new_user)\n        .send()\n        .await\n    \n    assert_eq!(response.status(), 201)\n    let user: User = response.json().await\n    \n    // Verify user exists\n    let get_response = server.get(\"/users/\" + user.id.to_s())\n        .send()\n        .await\n    \n    assert_eq!(get_response.status(), 200)\n}\n\n// Benchmark\n#[bench]\nfun bench_data_processing(b: &mut Bencher) {\n    let data = generate_test_data(10000)\n    b.iter(|| {\n        process_data(data.clone())\n    })\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 2,
          "line_number": 106,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Basic test\n#[test]\nfun test_addition() {\n    assert_eq!(2 + 2, 4)\n}\n\n// Test with setup\n#[test]\nfun test_calculator() {\n    // Arrange\n    let calc = Calculator::new()\n    \n    // Act\n    let result = calc.add(5, 3)\n    \n    // Assert\n    assert_eq!(result, 8)\n}\n\n// Test expected failures\n#[test]\n#[should_panic(expected = \"Division by zero\")]\nfun test_divide_by_zero() {\n    divide(10, 0)\n}\n\n// Async tests\n#[async_test]\nasync fun test_async_operation() {\n    let result = fetch_data().await\n    assert!(result.is_ok())\n}\n\n// Parameterized tests\n#[test_case(0, 0, 0)]\n#[test_case(1, 1, 2)]\n#[test_case(-1, 1, 0)]\n#[test_case(100, 200, 300)]\nfun test_add_parameterized(a: i32, b: i32, expected: i32) {\n    assert_eq!(add(a, b), expected)\n}\n\n// Test groups\nmod calculator_tests {\n    use super::*\n    \n    #[test]\n    fun test_add() { /* ... */ }\n    \n    #[test]\n    fun test_subtract() { /* ... */ }\n    \n    #[test]\n    fun test_multiply() { /* ... */ }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 3,
          "line_number": 176,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Fixture trait\ntrait TestFixture {\n    fun setup() -> Self\n    fun teardown(self)\n}\n\n// Database fixture\nstruct DatabaseFixture {\n    db: Database\n    test_data: Vec<User>\n}\n\nimpl TestFixture for DatabaseFixture {\n    fun setup() -> Self {\n        let db = Database::connect(\":memory:\")\n        db.migrate()\n        \n        let test_data = vec![\n            User::new(\"Alice\", \"alice@example.com\"),\n            User::new(\"Bob\", \"bob@example.com\")\n        ]\n        \n        for user in &test_data {\n            db.insert(user)\n        }\n        \n        DatabaseFixture { db, test_data }\n    }\n    \n    fun teardown(self) {\n        self.db.drop_all_tables()\n        self.db.disconnect()\n    }\n}\n\n// Use fixture in tests\n#[test]\nfun test_user_query() {\n    let fixture = DatabaseFixture::setup()\n    \n    let users = fixture.db.query(\"SELECT * FROM users\")\n    assert_eq!(users.len(), 2)\n    \n    fixture.teardown()\n}\n\n// Fixture macro for automatic cleanup\n#[with_fixture(DatabaseFixture)]\nfun test_with_auto_cleanup(fixture: DatabaseFixture) {\n    // Fixture automatically cleaned up after test\n    let user = fixture.db.find_user(\"Alice\")\n    assert!(user.is_some())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 4,
          "line_number": 244,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Mock trait\ntrait EmailService {\n    fun send_email(to: String, subject: String, body: String) -> Result<(), Error>\n}\n\n// Mock implementation\n#[mockable]\nstruct MockEmailService {\n    sent_emails: RefCell<Vec<Email>>\n}\n\nimpl EmailService for MockEmailService {\n    fun send_email(to: String, subject: String, body: String) -> Result<(), Error> {\n        self.sent_emails.borrow_mut().push(Email { to, subject, body })\n        Ok(())\n    }\n}\n\n// Test with mock\n#[test]\nfun test_user_registration() {\n    let email_service = MockEmailService::new()\n    let user_service = UserService::new(email_service)\n    \n    user_service.register_user(\"alice@example.com\")\n    \n    // Verify email was sent\n    assert_eq!(email_service.sent_emails.borrow().len(), 1)\n    assert_eq!(email_service.sent_emails.borrow()[0].subject, \"Welcome!\")\n}\n\n// Spy to verify behavior\n#[test]\nfun test_with_spy() {\n    let spy = Spy::new(RealService::new())\n    \n    spy.method_call()\n    \n    assert!(spy.was_called(\"method_call\"))\n    assert_eq!(spy.call_count(\"method_call\"), 1)\n    assert_eq!(spy.last_args(\"method_call\"), expected_args)\n}\n\n// Stub for predetermined responses\n#[test]\nfun test_with_stub() {\n    let stub = Stub::new()\n        .with_response(\"get_user\", User::test_user())\n        .with_error(\"network_call\", NetworkError)\n    \n    let result = service_using_stub.process()\n    assert_eq!(result, expected)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 5,
          "line_number": 312,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nuse proptest::prelude::*\n\n// Generate arbitrary test data\n#[derive(Arbitrary)]\nstruct TestUser {\n    #[proptest(regex = \"[a-z]{3,10}\")]\n    name: String\n    \n    #[proptest(range = 0..150)]\n    age: u8\n    \n    #[proptest(strategy = \"email_strategy()\")]\n    email: String\n}\n\n// Property test\n#[proptest]\nfun test_user_serialization(user: TestUser) {\n    // Property: serialization round-trip preserves data\n    let json = to_json(user)\n    let restored: TestUser = from_json(json)\n    prop_assert_eq!(user, restored)\n}\n\n// Custom strategies\nfun email_strategy() -> impl Strategy<Value = String> {\n    \"[a-z]{3,10}@[a-z]{3,10}\\\\.(com|org|net)\"\n        .prop_map(|s| s.to_string())\n}\n\n// Shrinking for minimal failing case\n#[proptest]\nfun test_no_panic(input: Vec<u8>) {\n    // Proptest will find minimal input that causes panic\n    process_bytes(input)  // Should never panic\n}\n\n// Stateful property testing\n#[proptest]\nfun test_database_consistency(operations: Vec<DbOperation>) {\n    let db = Database::new()\n    \n    for op in operations {\n        op.apply(&db)\n    }\n    \n    // Properties that should always hold\n    prop_assert!(db.is_consistent())\n    prop_assert_eq!(db.total_balance(), INITIAL_BALANCE)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 6,
          "line_number": 377,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Integration test in tests/ directory\n#[integration_test]\nasync fun test_full_api_flow() {\n    // Start services\n    let db = TestDatabase::new()\n    let cache = TestCache::new()\n    let server = TestServer::with_services(db, cache)\n    \n    // Register user\n    let register_response = server\n        .post(\"/api/register\")\n        .json(json!({\n            \"email\": \"test@example.com\",\n            \"password\": \"secure123\"\n        }))\n        .send()\n        .await\n    \n    assert_eq!(register_response.status(), 201)\n    let user: User = register_response.json().await\n    \n    // Login\n    let login_response = server\n        .post(\"/api/login\")\n        .json(json!({\n            \"email\": \"test@example.com\",\n            \"password\": \"secure123\"\n        }))\n        .send()\n        .await\n    \n    assert_eq!(login_response.status(), 200)\n    let token = login_response.header(\"Authorization\")\n    \n    // Use authenticated endpoint\n    let profile_response = server\n        .get(\"/api/profile\")\n        .header(\"Authorization\", token)\n        .send()\n        .await\n    \n    assert_eq!(profile_response.status(), 200)\n    let profile: Profile = profile_response.json().await\n    assert_eq!(profile.email, \"test@example.com\")\n}\n\n// Database integration test\n#[test]\nfun test_database_transactions() {\n    let db = Database::connect(TEST_DATABASE_URL)\n    \n    db.transaction(|tx| {\n        tx.insert_user(user1)?\n        tx.insert_user(user2)?\n        \n        // Verify within transaction\n        let count = tx.count_users()?\n        assert_eq!(count, 2)\n        \n        // Rollback for test isolation\n        Err(TestRollback)\n    })\n    \n    // Verify rollback worked\n    assert_eq!(db.count_users(), 0)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 7,
          "line_number": 458,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Benchmarks\n#[bench]\nfun bench_sorting_algorithms(b: &mut Bencher) {\n    let data = generate_random_vec(10000)\n    \n    b.iter(|| {\n        let mut copy = data.clone()\n        copy.sort()\n    })\n}\n\n// Comparative benchmarks\n#[bench_group]\nmod sorting_benchmarks {\n    #[bench]\n    fun quick_sort(b: &mut Bencher) {\n        let data = generate_data()\n        b.iter(|| quick_sort(data.clone()))\n    }\n    \n    #[bench]\n    fun merge_sort(b: &mut Bencher) {\n        let data = generate_data()\n        b.iter(|| merge_sort(data.clone()))\n    }\n    \n    #[bench]\n    fun heap_sort(b: &mut Bencher) {\n        let data = generate_data()\n        b.iter(|| heap_sort(data.clone()))\n    }\n}\n\n// Load testing\n#[load_test]\nasync fun test_api_under_load() {\n    let config = LoadTestConfig {\n        concurrent_users: 1000,\n        requests_per_user: 100,\n        ramp_up_time: Duration::from_secs(10)\n    }\n    \n    let results = load_test(config, |client| async {\n        client.get(\"/api/endpoint\").send().await\n    }).await\n    \n    assert!(results.median_response_time < Duration::from_millis(100))\n    assert!(results.p99_response_time < Duration::from_millis(500))\n    assert!(results.error_rate < 0.01)\n}\n\n// Profiling in tests\n#[test]\n#[profile]\nfun test_with_profiling() {\n    let profiler = CpuProfiler::start()\n    \n    expensive_operation()\n    \n    let report = profiler.report()\n    assert!(report.total_time < Duration::from_secs(1))\n    \n    // Generate flame graph\n    report.save_flamegraph(\"profile.svg\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 8,
          "line_number": 538,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Run tests with coverage\n$ ruchy test --coverage\n\n// Coverage report\n================================\nFile            Lines  Covered  %\nsrc/lib.rs      245    238     97.1%\nsrc/parser.rs   512    487     95.1%\nsrc/executor.rs 380    360     94.7%\n================================\nTotal           1137   1085    95.4%\n\n// Coverage annotations\n#[test]\nfun test_all_branches() {\n    // Tool shows which branches are not covered\n    if condition {      // ✓ true branch covered\n        do_something()\n    } else {           // ✗ false branch not covered\n        do_other()\n    }\n}\n\n// Exclude from coverage\n#[cfg(not(tarpaulin_include))]\nfun debug_function() {\n    // Not included in coverage metrics\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 9,
          "line_number": 579,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Mutation testing finds gaps in tests\n$ ruchy mutate\n\n// Mutations that survived (tests didn't catch)\nsrc/calculator.rs:15\n- Original: x + y\n+ Mutation: x - y\nStatus: SURVIVED ❌\n\n// Add test to catch mutation\n#[test]\nfun test_addition_not_subtraction() {\n    assert_ne!(add(5, 3), subtract(5, 3))\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 10,
          "line_number": 606,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Fuzz testing for security\n#[fuzz_test]\nfun fuzz_parser(data: &[u8]) {\n    // Fuzzer generates random inputs\n    if let Ok(s) = std::str::from_utf8(data) {\n        // Should never panic or crash\n        let _ = parse_input(s)\n    }\n}\n\n// Run fuzzer\n$ ruchy fuzz parser_fuzz\n=== Fuzzing parser_fuzz ===\nIterations: 1000000\nCrashes found: 0\nHangs found: 0\nCoverage: 95%\n\n// Targeted fuzzing\n#[fuzz_target]\nfun fuzz_api_endpoint(input: FuzzInput) {\n    let request = Request::from_fuzz(input)\n    let response = handle_request(request)\n    \n    // Properties that should hold\n    assert!(response.status() < 600)\n    assert!(response.body().len() < 10_000_000)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 11,
          "line_number": 681,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// quality.ruchy - Quality gate script\nfun main() {\n    let mut passed = true\n    \n    // Test coverage gate\n    let coverage = run_coverage_analysis()\n    if coverage.percentage < 80.0 {\n        println(\"❌ Coverage too low: \" + coverage.percentage.to_s() + \"%\")\n        passed = false\n    }\n    \n    // Performance gate\n    let benchmarks = run_benchmarks()\n    for (name, result) in benchmarks {\n        if result.regression > 0.1 {  // 10% regression\n            println(\"❌ Performance regression in \" + name + \": \" + (result.regression * 100).to_s() + \"%\")\n            passed = false\n        }\n    }\n    \n    // Complexity gate\n    let complexity = analyze_complexity()\n    if complexity.max_cyclomatic > 10 {\n        println(\"❌ Complexity too high: \" + complexity.max_cyclomatic.to_s())\n        passed = false\n    }\n    \n    // Security gate\n    let vulnerabilities = security_scan()\n    if !vulnerabilities.is_empty() {\n        println(\"❌ Security vulnerabilities found: \" + vulnerabilities.len().to_s())\n        passed = false\n    }\n    \n    if !passed {\n        exit(1)\n    }\n    \n    println(\"✅ All quality gates passed!\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch14-00-concurrency": {
      "chapter": "ch14-00-concurrency",
      "total_examples": 13,
      "working_examples": 0,
      "failing_examples": 13,
      "examples": [
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nuse std::sync;\nuse std::async;\n\n// Parallel processing with channels\nfun process_files(files: Vec<String>) -> Vec<Result> {\n    let (sender, receiver) = channel()\n    \n    // Spawn worker for each file\n    for file in files {\n        let tx = sender.clone()\n        spawn {\n            let result = process_file(file)\n            tx.send((file, result))\n        }\n    }\n    \n    // Collect results\n    let results = Vec::new()\n    for _ in files.len() {\n        let (file, result) = receiver.recv()\n        results.push(result)\n    }\n    \n    return results\n}\n\n// Async/await for I/O\nasync fun fetch_all_data(urls: Vec<String>) -> Vec<Data> {\n    let futures = urls.map(|url| async {\n        let response = http::get(url).await?\n        parse_response(response)\n    })\n    \n    return join_all(futures).await\n}\n\n// Thread pool for CPU-bound work\nlet pool = ThreadPool::new(num_cpus())\nlet results = pool.parallel_map(items, |item| {\n    expensive_computation(item)\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 2,
          "line_number": 90,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// Spawn a thread\nlet handle = spawn {\n    println(\"Running in parallel!\")\n    compute_result()\n}\n\n// Wait for thread to complete\nlet result = handle.join()\n\n// Spawn with move semantics\nlet data = vec![1, 2, 3]\nlet handle = spawn move {\n    let sum = data.sum()  // data moved into thread\n    println(\"Sum: \" + sum.to_s())\n}\n\n// Thread builder for configuration\nlet handle = Thread::builder()\n    .name(\"worker\")\n    .stack_size(4 * 1024 * 1024)\n    .spawn(|| {\n        heavy_computation()\n    })\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmp8UZb1d/main.rs:1:513\n  |\n1 | ... . spawn (|| { heavy_computation () }) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: expected `,`, found `.`\n --> /tmp/.tmp8UZb1d/main.rs:1:126\n  |\n1 | ...et mut handle = spawn ; { println ! (\"Running in parallel!\" . to_string ()) ; compute_result () } ; let mut result = handle . join () ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmp8UZb1d/main.rs:1:128\n  |\n1 | ...let mut handle = spawn ; { println ! (\"Running in parallel!\" . to_string ()) ; compute_result () } ; let mut result = handle . join ()...\n  |                                          ----------------------   ^^^^^^^^^^^^ argument never used\n  |                                          |\n  |                                          formatting specifier missing\n\nerror[E0425]: cannot find value `spawn` in this scope\n --> /tmp/.tmp8UZb1d/main.rs:1:82\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut handle = spawn ; { println ! (\"Running in parallel!\" . to_string ...\n  |                                                                                  ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::spawn;\n  |\n\nerror[E0425]: cannot find value `spawn` in this scope\n --> /tmp/.tmp8UZb1d/main.rs:1:263\n  |\n1 | ...ata = vec ! [1i32 , 2i32 , 3i32] ; let mut handle = spawn ; r#move ; { { let sum = data . sum () ; println ! (\"{}\" , format ! (\"{}{}\" ...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::spawn;\n  |\n\nerror[E0425]: cannot find value `r#move` in this scope\n --> /tmp/.tmp8UZb1d/main.rs:1:271\n  |\n1 | ...c ! [1i32 , 2i32 , 3i32] ; let mut handle = spawn ; r#move ; { { let sum = data . sum () ; println ! (\"{}\" , format ! (\"{}{}\" , \"Sum: ...\n  |                                                        ^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp8UZb1d/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut handle = spawn ; { println ! (\"Running in parallel!\" . to_string ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmp8UZb1d/main.rs:1:128\n  |\n1 | ...e = spawn ; { println ! (\"Running in parallel!\" . to_string ()) ; compute_result () } ; let mut result = handle . join () ; let mut da...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `compute_result` in this scope\n --> /tmp/.tmp8UZb1d/main.rs:1:144\n  |\n1 | ...tln ! (\"Running in parallel!\" . to_string ()) ; compute_result () } ; let mut result = handle . join () ; let mut data = vec ! [1i32 ,...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `sum` found for struct `Vec<i32>` in the current scope\n --> /tmp/.tmp8UZb1d/main.rs:1:301\n  |\n1 | ...ut handle = spawn ; r#move ; { { let sum = data . sum () ; println ! (\"{}\" , format ! (\"{}{}\" , \"Sum: \" , sum . to_s ())) } } ; let mu...\n  |                                                      ^^^ `Vec<i32>` is not an iterator\n  |\nhelp: call `.into_iter()` first\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut handle = spawn ; { println ! (\"Running in parallel!\" . to_string ()) ; compute_result () } ; let mut result = handle . join () ; let mut data = vec ! [1i32 , 2i32 , 3i32] ; let mut handle = spawn ; r#move ; { { let sum = data . into_iter().sum () ; println ! (\"{}\" , format ! (\"{}{}\" , \"Sum: \" , sum . to_s ())) } } ; let mut handle = Thread :: builder () . name (\"worker\") . stack_size (4i32 * 1024i32 * 1024i32) . spawn (|| { heavy_computation () }) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |                                                                                                                                                                                                                                                                                                             ++++++++++++\n\nerror: aborting due to 9 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: sum()"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 3,
          "line_number": 130,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Create a channel\nlet (sender, receiver) = channel()\n\n// Multiple producers\nfor i in range(10) {\n    let tx = sender.clone()\n    spawn move {\n        let result = process(i)\n        tx.send(result)\n    }\n}\n\n// Single consumer\nspawn move {\n    while let Ok(result) = receiver.recv() {\n        println(\"Got: \" + result.to_s())\n    }\n}\n\n// Bounded channels for backpressure\nlet (tx, rx) = sync_channel(100)  // Buffer size 100\n\n// Select from multiple channels\nloop {\n    select! {\n        msg = rx1.recv() => {\n            process_message(msg)\n        }\n        data = rx2.recv() => {\n            process_data(data)\n        }\n        _ = timeout(1000) => {\n            println(\"Timeout!\")\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 4,
          "line_number": 181,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Mutex for mutual exclusion\nlet counter = Arc::new(Mutex::new(0))\n\nlet handles = Vec::new()\nfor _ in range(10) {\n    let counter = counter.clone()\n    handles.push(spawn move {\n        let mut num = counter.lock()\n        *num += 1\n    })\n}\n\nfor handle in handles {\n    handle.join()\n}\n\nprintln(\"Result: \" + (*counter.lock()).to_s())\n\n// RwLock for multiple readers\nlet data = Arc::new(RwLock::new(HashMap::new()))\n\n// Multiple readers\nlet data_clone = data.clone()\nspawn move {\n    let map = data_clone.read()  // Shared read access\n    println(\"Value: \" + map.get(\"key\").to_s())\n}\n\n// Single writer\nlet data_clone = data.clone()\nspawn move {\n    let mut map = data_clone.write()  // Exclusive write access\n    map.insert(\"key\", \"value\")\n}\n\n// Atomic operations for lock-free programming\nlet counter = Arc::new(AtomicI32::new(0))\ncounter.fetch_add(1, Ordering::SeqCst)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 5,
          "line_number": 234,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Async function\nasync fun fetch_user(id: i32) -> Result<User, Error> {\n    let response = http::get(\"/api/users/\" + id.to_s()).await?\n    let user = parse_json(response.body).await?\n    return Ok(user)\n}\n\n// Await multiple futures\nasync fun fetch_all_users(ids: Vec<i32>) -> Vec<User> {\n    let futures = ids.map(|id| fetch_user(id))\n    let results = join_all(futures).await\n    \n    return results\n        .filter_map(|r| r.ok())\n        .collect()\n}\n\n// Select first to complete\nasync fun fetch_with_timeout(url: String) -> Result<Data, Error> {\n    select! {\n        result = fetch_data(url) => result,\n        _ = sleep(5000) => Err(Error::Timeout)\n    }\n}\n\n// Async streams\nasync fun process_stream(stream: AsyncStream<Item>) {\n    while let Some(item) = stream.next().await {\n        process_item(item).await\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 6,
          "line_number": 282,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nstruct ThreadPool {\n    workers: Vec<Worker>\n    sender: Sender<Job>\n}\n\nimpl ThreadPool {\n    fun new(size: usize) -> ThreadPool {\n        let (sender, receiver) = channel()\n        let receiver = Arc::new(Mutex::new(receiver))\n        \n        let workers = Vec::with_capacity(size)\n        for id in range(size) {\n            workers.push(Worker::new(id, receiver.clone()))\n        }\n        \n        ThreadPool { workers, sender }\n    }\n    \n    fn execute<F>(&self, f: F)\n    where F: FnOnce() + Send + 'static\n    {\n        self.sender.send(Box::new(f))\n    }\n    \n    fn parallel_map<T, R, F>(&self, items: Vec<T>, f: F) -> Vec<R>\n    where\n        F: Fn(T) -> R + Send + Clone + 'static,\n        T: Send + 'static,\n        R: Send + 'static\n    {\n        let (tx, rx) = channel()\n        \n        for item in items {\n            let tx = tx.clone()\n            let f = f.clone()\n            self.execute(move || {\n                let result = f(item)\n                tx.send(result)\n            })\n        }\n        \n        let results = Vec::new()\n        for _ in items.len() {\n            results.push(rx.recv())\n        }\n        \n        return results\n    }\n}\n\n// Use thread pool\nlet pool = ThreadPool::new(4)\n\nfor i in range(100) {\n    pool.execute(move || {\n        println(\"Task \" + i.to_s() + \" on thread \" + current_thread_id().to_s())\n        heavy_work()\n    })\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 7,
          "line_number": 356,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun producer_consumer_pipeline<T>() {\n    let (tx, rx) = channel()\n    \n    // Multiple producers\n    for i in range(4) {\n        let tx = tx.clone()\n        spawn move {\n            loop {\n                let work = generate_work(i)\n                if tx.send(work).is_err() {\n                    break  // Channel closed\n                }\n            }\n        }\n    }\n    \n    // Multiple consumers  \n    for i in range(2) {\n        let rx = rx.clone()\n        spawn move {\n            while let Ok(work) = rx.recv() {\n                process_work(work)\n            }\n        }\n    }\n}\n\n// With bounded queue for backpressure\nfun bounded_pipeline() {\n    let (tx, rx) = sync_channel(100)  // Max 100 items\n    \n    spawn move {\n        for item in generate_items() {\n            tx.send(item)  // Blocks if queue full\n        }\n    }\n    \n    spawn move {\n        while let Ok(item) = rx.recv() {\n            slow_process(item)\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 8,
          "line_number": 414,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun parallel_merge_sort<T: Ord + Send>(mut items: Vec<T>) -> Vec<T> {\n    if items.len() <= 1 {\n        return items\n    }\n    \n    let mid = items.len() / 2\n    let right = items.split_off(mid)\n    \n    // Fork: sort halves in parallel\n    let (left_sorted, right_sorted) = join(\n        || parallel_merge_sort(items),\n        || parallel_merge_sort(right)\n    )\n    \n    // Join: merge sorted halves\n    return merge(left_sorted, right_sorted)\n}\n\n// Parallel reduce\nfun parallel_sum(numbers: Vec<i32>) -> i32 {\n    if numbers.len() <= 1000 {\n        return numbers.sum()  // Sequential for small inputs\n    }\n    \n    let chunk_size = numbers.len() / num_cpus()\n    let chunks = numbers.chunks(chunk_size)\n    \n    let sums = chunks\n        .parallel_map(|chunk| chunk.sum())\n        .collect()\n    \n    return sums.sum()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 9,
          "line_number": 462,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Actor trait\ntrait Actor {\n    type Message\n    \n    fun handle(&mut self, msg: Self::Message)\n}\n\n// Example actor\nstruct CounterActor {\n    count: i32\n}\n\nenum CounterMessage {\n    Increment\n    Decrement\n    Get(Sender<i32>)\n}\n\nimpl Actor for CounterActor {\n    type Message = CounterMessage\n    \n    fun handle(&mut self, msg: CounterMessage) {\n        match msg {\n            Increment => self.count += 1\n            Decrement => self.count -= 1\n            Get(reply) => reply.send(self.count)\n        }\n    }\n}\n\n// Actor system\nstruct ActorSystem {\n    actors: HashMap<String, Box<dyn Actor>>\n}\n\nimpl ActorSystem {\n    fn spawn<A: Actor>(&mut self, name: String, actor: A) -> ActorRef<A> {\n        let (tx, rx) = channel()\n        \n        spawn move {\n            let mut actor = actor\n            while let Ok(msg) = rx.recv() {\n                actor.handle(msg)\n            }\n        }\n        \n        ActorRef { name, sender: tx }\n    }\n}\n\n// Use actors\nlet system = ActorSystem::new()\nlet counter = system.spawn(\"counter\", CounterActor { count: 0 })\n\ncounter.send(Increment)\ncounter.send(Increment)\n\nlet (tx, rx) = channel()\ncounter.send(Get(tx))\nlet count = rx.recv()\nprintln(\"Count: \" + count.to_s())  // 2",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 10,
          "line_number": 540,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nasync fun web_server() {\n    let listener = TcpListener::bind(\"0.0.0.0:8080\").await\n    \n    loop {\n        let (socket, addr) = listener.accept().await\n        \n        // Handle each connection concurrently\n        spawn async {\n            handle_connection(socket, addr).await\n        }\n    }\n}\n\nasync fun handle_connection(socket: TcpStream, addr: SocketAddr) {\n    let (reader, writer) = socket.split()\n    \n    let request = read_http_request(reader).await\n    let response = route_request(request).await\n    \n    write_http_response(writer, response).await\n}\n\n// Connection pool for database\nlet db_pool = ConnectionPool::new(20)\n\nasync fun handle_request(req: Request) -> Response {\n    let conn = db_pool.get().await\n    \n    let data = conn.query(\"SELECT * FROM users\").await\n    \n    db_pool.return(conn)\n    \n    Response::json(data)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 11,
          "line_number": 589,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun process_dataset(data: Vec<Record>) -> Vec<Result> {\n    // Partition data for parallel processing\n    let chunk_size = data.len() / num_cpus()\n    let chunks = data.chunks(chunk_size)\n    \n    // Process chunks in parallel\n    let handles = chunks.map(|chunk| {\n        spawn move {\n            chunk.iter()\n                .map(|record| process_record(record))\n                .collect()\n        }\n    })\n    \n    // Collect results\n    let mut results = Vec::new()\n    for handle in handles {\n        results.extend(handle.join())\n    }\n    \n    return results\n}\n\n// Pipeline with stages\nfun parallel_pipeline(input: Stream<Data>) -> Stream<Output> {\n    input\n        .parallel_map(stage1, workers: 4)\n        .parallel_filter(stage2, workers: 2)\n        .parallel_flat_map(stage3, workers: 4)\n        .collect()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 12,
          "line_number": 635,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n#[test]\nfun test_concurrent_access() {\n    let shared = Arc::new(Mutex::new(Vec::new()))\n    let handles = Vec::new()\n    \n    // Spawn concurrent writers\n    for i in range(100) {\n        let shared = shared.clone()\n        handles.push(spawn move {\n            let mut vec = shared.lock()\n            vec.push(i)\n        })\n    }\n    \n    // Wait for completion\n    for handle in handles {\n        handle.join()\n    }\n    \n    // Verify all writes succeeded\n    let vec = shared.lock()\n    assert_eq!(vec.len(), 100)\n}\n\n#[test]\nasync fun test_async_operations() {\n    let results = join_all(vec![\n        async_operation(1),\n        async_operation(2),\n        async_operation(3)\n    ]).await\n    \n    assert!(results.all(|r| r.is_ok()))\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 13,
          "line_number": 682,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// 1. Choose the right abstraction\n// Threads: OS parallelism, CPU-bound work\n// Async: I/O-bound work, many concurrent tasks\n// Channels: Decoupled communication\n// Shared state: When necessary, with proper synchronization\n\n// 2. Avoid contention\nlet shards = (0..16).map(|_| Mutex::new(HashMap::new()))\nfun get_shard(key: &str) -> &Mutex<HashMap> {\n    let hash = hash(key)\n    return &shards[hash % 16]\n}\n\n// 3. Use work stealing\nlet queue = WorkStealingQueue::new()\n// Threads steal work from other threads when idle\n\n// 4. Batch operations\ninstead_of {\n    for item in items {\n        channel.send(item)  // Many small sends\n    }\n}\n\ndo {\n    channel.send(items)  // One batch send\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch04-00-command-line-tools": {
      "chapter": "ch04-00-command-line-tools",
      "total_examples": 14,
      "working_examples": 0,
      "failing_examples": 14,
      "examples": [
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n\n// File: word_counter.ruchy\n// Simple word counter tool\n\n// Get filename from user\nprintln(\"Word Counter Tool\")\nprint(\"Enter filename: \")\nlet filename = input()\n\n// Read and process file\nlet content = read_file(filename)\nlet words = content.split_whitespace()\nlet word_count = words.len()\nlet char_count = content.len()\nlet line_count = content.lines().len()\n\n// Display results\nprintln(\"\\nFile Analysis: \" + filename)\nprintln(\"Characters: \" + char_count.to_s())\nprintln(\"Words: \" + word_count.to_s())  \nprintln(\"Lines: \" + line_count.to_s())\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpCg3E49/main.rs:1:96\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"Word Counter Tool\" . to_string ()) ; print ! (\"Enter filename...\n  |                                                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpCg3E49/main.rs:1:98\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"Word Counter Tool\" . to_string ()) ; print ! (\"Enter filename...\n  |                                                                            -------------------   ^^^^^^^^^^^^ argument never used\n  |                                                                            |\n  |                                                                            formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpCg3E49/main.rs:1:142\n  |\n1 | ...Counter Tool\" . to_string ()) ; print ! (\"Enter filename: \" . to_string ()) ; let mut filename = input () ; let mut content = read_fil...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpCg3E49/main.rs:1:144\n  |\n1 | ...ounter Tool\" . to_string ()) ; print ! (\"Enter filename: \" . to_string ()) ; let mut filename = input () ; let mut content = read_file...\n  |                                            ------------------   ^^^^^^^^^^^^ argument never used\n  |                                            |\n  |                                            formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpCg3E49/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"Word Counter Tool\" . to_string ()) ; print ! (\"Enter filename...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpCg3E49/main.rs:1:98\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"Word Counter Tool\" . to_string ()) ; print ! (\"Enter filename...\n  |                                                                                                  ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpCg3E49/main.rs:1:144\n  |\n1 | ...\" . to_string ()) ; print ! (\"Enter filename: \" . to_string ()) ; let mut filename = input () ; let mut content = read_file (filename)...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpCg3E49/main.rs:1:179\n  |\n1 | ...er filename: \" . to_string ()) ; let mut filename = input () ; let mut content = read_file (filename) ; let mut words = content . spli...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpCg3E49/main.rs:1:208\n  |\n1 | ...; let mut filename = input () ; let mut content = read_file (filename) ; let mut words = content . split_whitespace () ; let mut word_...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 8 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 2,
          "line_number": 82,
          "code": "// Status: ❌ BROKEN\n\nlet name = input(\"What's your name? \")\nlet age = input(\"How old are you? \").to_i()\nlet is_student = input(\"Are you a student? (y/n) \") == \"y\"\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmp5f9UYu/main.rs:1:274\n  |\n1 | ...tudent? (y/n) \" . to_string ()) == \"y\" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp5f9UYu/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut name = input (\"What's your name? \" . to_string ()) ; let mut age ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmp5f9UYu/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut name = input (\"What's your name? \" . to_string ()) ; let mut age ...\n  |                                                                                ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmp5f9UYu/main.rs:1:140\n  |\n1 | ...What's your name? \" . to_string ()) ; let mut age = input (\"How old are you? \" . to_string ()) . to_i () ; let mut is_student = input ...\n  |                                                        ^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 3,
          "line_number": 101,
          "code": "// Status: ❌ BROKEN\n\n// Reading files\nlet content = read_file(\"data.txt\")\nlet lines = read_lines(\"data.txt\")\n\n// Writing files\nwrite_file(\"output.txt\", \"Hello, World!\")\nappend_file(\"log.txt\", \"New entry: \" + timestamp())\n\n// File information\nlet exists = file_exists(\"config.txt\")\nlet size = file_size(\"data.txt\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmp5yiL2U/main.rs:1:462\n  |\n1 | ... file_size (\"data.txt\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp5yiL2U/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut content = read_file (\"data.txt\" . to_string ()) ; let mut lines =...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmp5yiL2U/main.rs:1:83\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut content = read_file (\"data.txt\" . to_string ()) ; let mut lines =...\n  |                                                                                   ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_lines` in this scope\n --> /tmp/.tmp5yiL2U/main.rs:1:139\n  |\n1 | ...ile (\"data.txt\" . to_string ()) ; let mut lines = read_lines (\"data.txt\" . to_string ()) ; write_file (\"output.txt\" . to_string () , \"...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmp5yiL2U/main.rs:1:180\n  |\n1 | ... lines = read_lines (\"data.txt\" . to_string ()) ; write_file (\"output.txt\" . to_string () , \"Hello, World!\" . to_string ()) ; append_f...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `timestamp` in this scope\n --> /tmp/.tmp5yiL2U/main.rs:1:331\n  |\n1 | ...to_string () , format ! (\"{}{}\" , \"New entry: \" , timestamp ())) ; let mut exists = file_exists (\"config.txt\" . to_string ()) ; let mu...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `append_file` in this scope\n --> /tmp/.tmp5yiL2U/main.rs:1:256\n  |\n1 | ...to_string () , \"Hello, World!\" . to_string ()) ; append_file (\"log.txt\" . to_string () , format ! (\"{}{}\" , \"New entry: \" , timestamp ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmp5yiL2U/main.rs:1:365\n  |\n1 | ...New entry: \" , timestamp ())) ; let mut exists = file_exists (\"config.txt\" . to_string ()) ; let mut size = file_size (\"data.txt\" . to...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 7 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 4,
          "line_number": 128,
          "code": "// Status: ❌ BROKEN\n\n// Usage: ruchy run script.ruchy file1.txt file2.txt\nlet args = command_args()\nlet program_name = args[0]\nlet first_file = args[1]\nlet second_file = args[2]\n\nprintln(\"Processing: \" + first_file + \" and \" + second_file)\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpyCDbEL/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut args = command_args () ; let mut program_name = args [0i32] ; let...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `command_args` in this scope\n --> /tmp/.tmpyCDbEL/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut args = command_args () ; let mut program_name = args [0i32] ; let...\n  |                                                                                ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 5,
          "line_number": 152,
          "code": "// Status: ❌ BROKEN\n\n// File: text_processor.ruchy\n// Processes text files with various operations\n\nprintln(\"=== Text Processor ===\")\nlet filename = input(\"Enter filename: \")\n\nif !file_exists(filename) {\n    println(\"Error: File '\" + filename + \"' not found!\")\n    exit(1)\n}\n\nlet content = read_file(filename)\nlet lines = content.lines()\n\nprintln(\"\\nChoose operation:\")\nprintln(\"1. Count lines\")\nprintln(\"2. Find and replace\")\nprintln(\"3. Convert to uppercase\") \nprintln(\"4. Remove empty lines\")\n\nlet choice = input(\"Enter choice (1-4): \").to_i()\n\nmatch choice {\n    1 => {\n        println(\"Total lines: \" + lines.len().to_s())\n    }\n    2 => {\n        let find = input(\"Find: \")\n        let replace = input(\"Replace with: \")\n        let new_content = content.replace(find, replace)\n        let output_file = filename.replace(\".txt\", \"_modified.txt\")\n        write_file(output_file, new_content)\n        println(\"Saved to: \" + output_file)\n    }\n    3 => {\n        let upper_content = content.to_uppercase()\n        let output_file = filename.replace(\".txt\", \"_upper.txt\")\n        write_file(output_file, upper_content)\n        println(\"Saved to: \" + output_file)\n    }\n    4 => {\n        let clean_lines = lines.filter(|line| !line.trim().is_empty())\n        let clean_content = clean_lines.join(\"\\n\")\n        let output_file = filename.replace(\".txt\", \"_clean.txt\")\n        write_file(output_file, clean_content)\n        println(\"Saved to: \" + output_file)\n    }\n    _ => {\n        println(\"Invalid choice!\")\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmppZXgVv/main.rs:1:101\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Text Processor ===\" . to_string ()) ; let mut filename = ...\n  |                                                                                                     ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmppZXgVv/main.rs:1:103\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Text Processor ===\" . to_string ()) ; let mut filename = ...\n  |                                                                            ------------------------   ^^^^^^^^^^^^ argument never used\n  |                                                                            |\n  |                                                                            formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmppZXgVv/main.rs:1:448\n  |\n1 | ...nes = content . lines () ; println ! (\"\\nChoose operation:\" . to_string ()) ; println ! (\"1. Count lines\" . to_string ()) ; println ! ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmppZXgVv/main.rs:1:450\n  |\n1 | ...ines = content . lines () ; println ! (\"\\nChoose operation:\" . to_string ()) ; println ! (\"1. Count lines\" . to_string ()) ; println !...\n  |                                           ---------------------   ^^^^^^^^^^^^ argument never used\n  |                                           |\n  |                                           formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmppZXgVv/main.rs:1:494\n  |\n1 | ...e operation:\" . to_string ()) ; println ! (\"1. Count lines\" . to_string ()) ; println ! (\"2. Find and replace\" . to_string ()) ; print...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmppZXgVv/main.rs:1:496\n  |\n1 | ...operation:\" . to_string ()) ; println ! (\"1. Count lines\" . to_string ()) ; println ! (\"2. Find and replace\" . to_string ()) ; println...\n  |                                             ----------------   ^^^^^^^^^^^^ argument never used\n  |                                             |\n  |                                             formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmppZXgVv/main.rs:1:545\n  |\n1 | ...t lines\" . to_string ()) ; println ! (\"2. Find and replace\" . to_string ()) ; println ! (\"3. Convert to uppercase\" . to_string ()) ; p...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmppZXgVv/main.rs:1:547\n  |\n1 | ...nt lines\" . to_string ()) ; println ! (\"2. Find and replace\" . to_string ()) ; println ! (\"3. Convert to uppercase\" . to_string ()) ; ...\n  |                                           ---------------------   ^^^^^^^^^^^^ argument never used\n  |                                           |\n  |                                           formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmppZXgVv/main.rs:1:600\n  |\n1 | ...ace\" . to_string ()) ; println ! (\"3. Convert to uppercase\" . to_string ()) ; println ! (\"4. Remove empty lines\" . to_string ()) ; let...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmppZXgVv/main.rs:1:602\n  |\n1 | ...eplace\" . to_string ()) ; println ! (\"3. Convert to uppercase\" . to_string ()) ; println ! (\"4. Remove empty lines\" . to_string ()) ; ...\n  |                                         -------------------------   ^^^^^^^^^^^^ argument never used\n  |                                         |\n  |                                         formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmppZXgVv/main.rs:1:653\n  |\n1 | ...rcase\" . to_string ()) ; println ! (\"4. Remove empty lines\" . to_string ()) ; let mut choice = input (\"Enter choice (1-4): \" . to_stri...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmppZXgVv/main.rs:1:655\n  |\n1 | ...percase\" . to_string ()) ; println ! (\"4. Remove empty lines\" . to_string ()) ; let mut choice = input (\"Enter choice (1-4): \" . to_st...\n  |                                          -----------------------   ^^^^^^^^^^^^ argument never used\n  |                                          |\n  |                                          formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmppZXgVv/main.rs:1:1857\n  |\n1 | ..., output_file)) } } } , _ => { println ! (\"Invalid choice!\" . to_string ()) } , } } ; if let Some (s) = (& result as & dyn std :: any ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmppZXgVv/main.rs:1:1859\n  |\n1 | ... output_file)) } } } , _ => { println ! (\"Invalid choice!\" . to_string ()) } , } } ; if let Some (s) = (& result as & dyn std :: any :...\n  |                                             -----------------   ^^^^^^^^^^^^ argument never used\n  |                                             |\n  |                                             formatting specifier missing\n\nerror[E0425]: cannot find function `exit` in this scope\n --> /tmp/.tmppZXgVv/main.rs:1:319\n  |\n1 | ...\" , \"Error: File '\" , filename) , \"' not found!\")) ; exit (1i32) } } ; let mut content = read_file (filename) ; let mut lines = conten...\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::process::exit;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmppZXgVv/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Text Processor ===\" . to_string ()) ; let mut filename = ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmppZXgVv/main.rs:1:103\n  |\n1 | ... result = { println ! (\"=== Text Processor ===\" . to_string ()) ; let mut filename = input (\"Enter filename: \" . to_string ()) ; if ! ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmppZXgVv/main.rs:1:138\n  |\n1 | ...Processor ===\" . to_string ()) ; let mut filename = input (\"Enter filename: \" . to_string ()) ; if ! file_exists (filename) { { printl...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmppZXgVv/main.rs:1:187\n  |\n1 | ...input (\"Enter filename: \" . to_string ()) ; if ! file_exists (filename) { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"E...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmppZXgVv/main.rs:1:355\n  |\n1 | ...t found!\")) ; exit (1i32) } } ; let mut content = read_file (filename) ; let mut lines = content . lines () ; println ! (\"\\nChoose ope...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmppZXgVv/main.rs:1:450\n  |\n1 | ...t . lines () ; println ! (\"\\nChoose operation:\" . to_string ()) ; println ! (\"1. Count lines\" . to_string ()) ; println ! (\"2. Find an...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmppZXgVv/main.rs:1:496\n  |\n1 | ...\" . to_string ()) ; println ! (\"1. Count lines\" . to_string ()) ; println ! (\"2. Find and replace\" . to_string ()) ; println ! (\"3. Co...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmppZXgVv/main.rs:1:547\n  |\n1 | ...o_string ()) ; println ! (\"2. Find and replace\" . to_string ()) ; println ! (\"3. Convert to uppercase\" . to_string ()) ; println ! (\"4...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmppZXgVv/main.rs:1:602\n  |\n1 | ...ring ()) ; println ! (\"3. Convert to uppercase\" . to_string ()) ; println ! (\"4. Remove empty lines\" . to_string ()) ; let mut choice ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmppZXgVv/main.rs:1:655\n  |\n1 | ...string ()) ; println ! (\"4. Remove empty lines\" . to_string ()) ; let mut choice = input (\"Enter choice (1-4): \" . to_string ()) . to_...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmppZXgVv/main.rs:1:688\n  |\n1 | ...ove empty lines\" . to_string ()) ; let mut choice = input (\"Enter choice (1-4): \" . to_string ()) . to_i () ; match choice { 1i32 => {...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmppZXgVv/main.rs:1:880\n  |\n1 | ...nes . len () . to_s ())) } , 2i32 => { { let find = input (\"Find: \" . to_string ()) ; { let mut replace = input (\"Replace with: \" . to...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmppZXgVv/main.rs:1:934\n  |\n1 | ...put (\"Find: \" . to_string ()) ; { let mut replace = input (\"Replace with: \" . to_string ()) ; let mut new_content = content . replace ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmppZXgVv/main.rs:1:1105\n  |\n1 | ...= filename . replace (\".txt\" , \"_modified.txt\") ; write_file (output_file , new_content) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Saved...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmppZXgVv/main.rs:1:1349\n  |\n1 | ...le = filename . replace (\".txt\" , \"_upper.txt\") ; write_file (output_file , upper_content) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Sav...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmppZXgVv/main.rs:1:1704\n  |\n1 | ...le = filename . replace (\".txt\" , \"_clean.txt\") ; write_file (output_file , clean_content) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Sav...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmppZXgVv/main.rs:1:1859\n  |\n1 | ...e)) } } } , _ => { println ! (\"Invalid choice!\" . to_string ()) } , } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . do...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 31 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 6,
          "line_number": 218,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// File: log_analyzer.ruchy\n// Analyzes server log files\n\nprintln(\"=== Log Analyzer ===\")\nlet log_file = input(\"Enter log file path: \")\n\nlet lines = read_lines(log_file)\nlet total_requests = lines.len()\n\n// Count different status codes\nlet success_count = 0\nlet error_count = 0\nlet not_found_count = 0\n\nfor line in lines {\n    if line.contains(\" 200 \") {\n        success_count += 1\n    } else if line.contains(\" 404 \") {\n        not_found_count += 1\n    } else if line.contains(\" 500 \") {\n        error_count += 1\n    }\n}\n\n// Calculate percentages\nlet success_percent = (success_count * 100) / total_requests\nlet error_percent = (error_count * 100) / total_requests\nlet not_found_percent = (not_found_count * 100) / total_requests\n\nprintln(\"\\n=== Analysis Results ===\")\nprintln(\"Total Requests: \" + total_requests.to_s())\nprintln(\"Success (200): \" + success_count.to_s() + \" (\" + success_percent.to_s() + \"%)\")\nprintln(\"Not Found (404): \" + not_found_count.to_s() + \" (\" + not_found_percent.to_s() + \"%)\")\nprintln(\"Server Error (500): \" + error_count.to_s() + \" (\" + error_percent.to_s() + \"%)\")\n\n// Find busiest hour\nlet hour_counts = {}\nfor line in lines {\n    let timestamp = extract_hour(line)  // Custom function\n    hour_counts[timestamp] = hour_counts.get(timestamp, 0) + 1\n}\n\nlet busiest_hour = hour_counts.max_by_value().key\nprintln(\"Busiest Hour: \" + busiest_hour.to_s() + \":00\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpiAzpEG/main.rs:1:99\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\" . to_string ()) ; let mut log_file = in...\n  |                                                                                                   ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpiAzpEG/main.rs:1:101\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\" . to_string ()) ; let mut log_file = in...\n  |                                                                            ----------------------   ^^^^^^^^^^^^ argument never used\n  |                                                                            |\n  |                                                                            formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpiAzpEG/main.rs:1:827\n  |\n1 | ... / total_requests ; println ! (\"\\n=== Analysis Results ===\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total Requests: \" ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpiAzpEG/main.rs:1:829\n  |\n1 | ...0i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total Requests...\n  |                                       ----------------------------   ^^^^^^^^^^^^ argument never used\n  |                                       |\n  |                                       formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpiAzpEG/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\" . to_string ()) ; let mut log_file = in...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpiAzpEG/main.rs:1:380\n  |\n1 | ... { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ...\n  |       ^^                                                                                                                                                                                                  ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\" . to_string ()) ; let mut log_file = input (\"Enter log file path: \" . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\" . to_string ()) ; let mut log_file = input (\"Enter log file path: \" . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpiAzpEG/main.rs:1:413\n  |\n1 | ... for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_co...\n  |                                                          ^^                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\" . to_string ()) ; let mut log_file = input (\"Enter log file path: \" . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\" . to_string ()) ; let mut log_file = input (\"Enter log file path: \" . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { success_count += 1i32 } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpiAzpEG/main.rs:1:479\n  |\n1 | ...nt += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count...\n  |                                                         ^^                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\" . to_string ()) ; let mut log_file = input (\"Enter log file path: \" . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\" . to_string ()) ; let mut log_file = input (\"Enter log file path: \" . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { not_found_count += 1i32 } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpiAzpEG/main.rs:1:547\n  |\n1 | ...ount += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 1...\n  |                                                           ^^                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\" . to_string ()) ; let mut log_file = input (\"Enter log file path: \" . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\" . to_string ()) ; let mut log_file = input (\"Enter log file path: \" . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { error_count += 1i32 } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpiAzpEG/main.rs:1:1487\n  |\n1 | ... lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let m...\n  |             ^^                                                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\" . to_string ()) ; let mut log_file = input (\"Enter log file path: \" . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\" . to_string ()) ; let mut log_file = input (\"Enter log file path: \" . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpiAzpEG/main.rs:1:101\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\" . to_string ()) ; let mut log_file = in...\n  |                                                                                                     ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpiAzpEG/main.rs:1:136\n  |\n1 | ... Analyzer ===\" . to_string ()) ; let mut log_file = input (\"Enter log file path: \" . to_string ()) ; let mut lines = read_lines (log_f...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_lines` in this scope\n --> /tmp/.tmpiAzpEG/main.rs:1:201\n  |\n1 | ...og file path: \" . to_string ()) ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_co...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpiAzpEG/main.rs:1:829\n  |\n1 | ...uests ; println ! (\"\\n=== Analysis Results ===\" . to_string ()) ; println ! (\"{}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpiAzpEG/main.rs:1:1043\n  |\n1 | ...mat ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format !...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpiAzpEG/main.rs:1:1080\n  |\n1 | ...uccess_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpiAzpEG/main.rs:1:1214\n  |\n1 | ...! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpiAzpEG/main.rs:1:1253\n  |\n1 | ...ound_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpiAzpEG/main.rs:1:1386\n  |\n1 | ... ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; f...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpiAzpEG/main.rs:1:1421\n  |\n1 | ... , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestam...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0425]: cannot find function `extract_hour` in this scope\n --> /tmp/.tmpiAzpEG/main.rs:1:1507\n  |\n1 | ...s = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) ...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `get` found for unit type `()` in the current scope\n    --> /tmp/.tmpiAzpEG/main.rs:1:1569\n     |\n1    | ... = extract_hour (line) ; hour_counts [timestamp] = hour_counts . get (timestamp , 0i32) + 1i32 } } } ; let mut busiest_hour = hour_cou...\n     |                                                                     ^^^\n     |\nhelp: there is a method `ge` with a similar name, but with different arguments\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1438:5\n     |\n1438 |     fn ge(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `max_by_value` found for unit type `()` in the current scope\n --> /tmp/.tmpiAzpEG/main.rs:1:1644\n  |\n1 | ...32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busie...\n  |                                                    ^^^^^^^^^^^^ method not found in `()`\n\nerror: aborting due to 17 previous errors; 6 warnings emitted\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 7,
          "line_number": 277,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// File: batch_renamer.ruchy  \n// Renames multiple files with patterns\n\nprintln(\"=== Batch File Renamer ===\")\nlet directory = input(\"Enter directory path: \")\nlet pattern = input(\"Enter pattern to find: \")\nlet replacement = input(\"Enter replacement: \")\n\nlet files = list_files(directory)\nlet renamed_count = 0\n\nfor file in files {\n    if file.contains(pattern) {\n        let new_name = file.replace(pattern, replacement)\n        let old_path = join_path(directory, file)\n        let new_path = join_path(directory, new_name)\n        \n        if rename_file(old_path, new_path) {\n            println(\"Renamed: \" + file + \" -> \" + new_name)\n            renamed_count += 1\n        } else {\n            println(\"Failed to rename: \" + file)\n        }\n    }\n}\n\nprintln(\"\\nRenamed \" + renamed_count.to_s() + \" files\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpBRTfsV/main.rs:1:105\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\" . to_string ()) ; let mut directo...\n  |                                                                                                         ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpBRTfsV/main.rs:1:107\n  |\n1 | ...ain () { let result = { println ! (\"=== Batch File Renamer ===\" . to_string ()) ; let mut directory = input (\"Enter directory path: \" ...\n  |                                       ----------------------------   ^^^^^^^^^^^^ argument never used\n  |                                       |\n  |                                       formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpBRTfsV/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\" . to_string ()) ; let mut directo...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpBRTfsV/main.rs:1:423\n  |\n1 | ... { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\" . to_string ()) ; let mut directory = input (\"Enter directory path: \" . to_string ()) ; let mut pattern = input (\"Enter pattern to find: \" . to_string ()) ; let mut replacement = input (\"Enter replacement: \" . to_string ()) ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\" . to_string ()) ; let mut directory = input (\"Enter directory path: \" . to_string ()) ; let mut pattern = input (\"Enter pattern to find: \" . to_string ()) ; let mut replacement = input (\"Enter replacement: \" . to_string ()) ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpBRTfsV/main.rs:1:456\n  |\n1 | ... { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\" . to_string ()) ; let mut directory = input (\"Enter directory path: \" . to_string ()) ; let mut pattern = input (\"Enter pattern to find: \" . to_string ()) ; let mut replacement = input (\"Enter replacement: \" . to_string ()) ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\" . to_string ()) ; let mut directory = input (\"Enter directory path: \" . to_string ()) ; let mut pattern = input (\"Enter pattern to find: \" . to_string ()) ; let mut replacement = input (\"Enter replacement: \" . to_string ()) ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpBRTfsV/main.rs:1:796\n  |\n1 | ...enamed_count += 1i32 } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } } ; println ! (\"{}\"...\n  |                                    ^^                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\" . to_string ()) ; let mut directory = input (\"Enter directory path: \" . to_string ()) ; let mut pattern = input (\"Enter pattern to find: \" . to_string ()) ; let mut replacement = input (\"Enter replacement: \" . to_string ()) ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\" . to_string ()) ; let mut directory = input (\"Enter directory path: \" . to_string ()) ; let mut pattern = input (\"Enter pattern to find: \" . to_string ()) ; let mut replacement = input (\"Enter replacement: \" . to_string ()) ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") + new_name) ; renamed_count += 1i32 } } else { println ! (\"{}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpBRTfsV/main.rs:1:107\n  |\n1 | ...ult = { println ! (\"=== Batch File Renamer ===\" . to_string ()) ; let mut directory = input (\"Enter directory path: \" . to_string ()) ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpBRTfsV/main.rs:1:143\n  |\n1 | ... Renamer ===\" . to_string ()) ; let mut directory = input (\"Enter directory path: \" . to_string ()) ; let mut pattern = input (\"Enter ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpBRTfsV/main.rs:1:211\n  |\n1 | ...rectory path: \" . to_string ()) ; let mut pattern = input (\"Enter pattern to find: \" . to_string ()) ; let mut replacement = input (\"E...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpBRTfsV/main.rs:1:284\n  |\n1 | ... to find: \" . to_string ()) ; let mut replacement = input (\"Enter replacement: \" . to_string ()) ; let mut files = list_files (directo...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `list_files` in this scope\n --> /tmp/.tmpBRTfsV/main.rs:1:347\n  |\n1 | ... replacement: \" . to_string ()) ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if fil...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpBRTfsV/main.rs:1:537\n  |\n1 | ...ce (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ;...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpBRTfsV/main.rs:1:587\n  |\n1 | ...y , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , format ! ...\n  |                                   ^^^^^^^^^ help: a local variable with a similar name exists: `old_path`\n\nerror[E0425]: cannot find function `rename_file` in this scope\n --> /tmp/.tmpBRTfsV/main.rs:1:625\n  |\n1 | ...new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpBRTfsV/main.rs:1:970\n  |\n1 | ..., format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror: aborting due to 11 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 8,
          "line_number": 321,
          "code": "// Status: ❌ BROKEN\n\n// Robust file processor with error handling\n\nfun process_file(filename) {\n    // Check if file exists\n    if !file_exists(filename) {\n        println(\"❌ Error: File '\" + filename + \"' does not exist\")\n        return false\n    }\n    \n    // Check if file is readable\n    if !file_readable(filename) {\n        println(\"❌ Error: Cannot read file '\" + filename + \"' (permission denied?)\")\n        return false\n    }\n    \n    // Try to read file\n    let content = try {\n        read_file(filename)\n    } catch error {\n        println(\"❌ Error reading file: \" + error.to_s())\n        return false\n    }\n    \n    // Process content\n    let word_count = content.split_whitespace().len()\n    println(\"✅ File processed: \" + word_count.to_s() + \" words\")\n    return true\n}\n\n// Main program\nlet filename = input(\"Enter filename: \")\nif process_file(filename) {\n    println(\"Processing completed successfully!\")\n} else {\n    println(\"Processing failed!\")\n    exit(1)\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpppMZXm/main.rs:1:1076\n  |\n1 | ...lename) { { println ! (\"Processing completed successfully!\" . to_string ()) } } else { { println ! (\"Processing failed!\" . to_string (...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpppMZXm/main.rs:1:1078\n  |\n1 | ...file (filename) { { println ! (\"Processing completed successfully!\" . to_string ()) } } else { { println ! (\"Processing failed!\" . to_...\n  |                                   ------------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                   |\n  |                                   formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpppMZXm/main.rs:1:1137\n  |\n1 | ... to_string ()) } } else { { println ! (\"Processing failed!\" . to_string ()) ; exit (1i32) } } ; }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpppMZXm/main.rs:1:1139\n  |\n1 | ... to_string ()) } } else { { println ! (\"Processing failed!\" . to_string ()) ; exit (1i32) } } ; }\n  |                                           --------------------   ^^^^^^^^^^^^ argument never used\n  |                                           |\n  |                                           formatting specifier missing\n\nerror[E0423]: expected value, found macro `try`\n --> /tmp/.tmpppMZXm/main.rs:1:567\n  |\n1 | ...rmission denied?)\")) ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{}\" , for...\n  |                                                              ^^^^^ not a value\n\nerror[E0425]: cannot find value `catch` in this scope\n --> /tmp/.tmpppMZXm/main.rs:1:604\n  |\n1 | ... let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ Error reading file: \" , e...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpppMZXm/main.rs:1:612\n  |\n1 | ...tent = r#try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ Error reading file: \" , error . t...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpppMZXm/main.rs:1:686\n  |\n1 | ...{}\" , format ! (\"{}{}\" , \"❌ Error reading file: \" , error . to_s ())) ; return false } ; let mut word_count = content . split_whitespac...\n  |                                                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `exit` in this scope\n --> /tmp/.tmpppMZXm/main.rs:1:1155\n  |\n1 | ... { println ! (\"Processing failed!\" . to_string ()) ; exit (1i32) } } ; }\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::process::exit;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpppMZXm/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fm...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpppMZXm/main.rs:1:1026\n  |\n1 | ...) ; if process_file (filename) { { println ! (\"Processing completed successfully!\" . to_string ()) } } else { { println ! (\"Processing...\n  |                                     ^^                                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Error: File '\" , filename) , \"' does not exist\")) ; return false } } ; if ! file_readable (filename) { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Error: Cannot read file '\" , filename) , \"' (permission denied?)\")) ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ Error reading file: \" , error . to_s ())) ; return false } ; let mut word_count = content . split_whitespace () . len () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"✅ File processed: \" , word_count . to_s ()) , \" words\")) ; return true } } } } fn main () { let mut filename = input (\"Enter filename: \" . to_string ()) ; if process_file (filename) { { println ! (\"Processing completed successfully!\" . to_string ()) } } else { { println ! (\"Processing failed!\" . to_string ()) ; exit (1i32) } } ; }\n1 + use std :: collections :: HashMap ; fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Error: File '\" , filename) , \"' does not exist\")) ; return false } } ; if ! file_readable (filename) { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Error: Cannot read file '\" , filename) , \"' (permission denied?)\")) ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ Error reading file: \" , error . to_s ())) ; return false } ; let mut word_count = content . split_whitespace () . len () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"✅ File processed: \" , word_count . to_s ()) , \" words\")) ; return true } } } } fn main () { let mut filename = input (\"Enter filename: \" . to_string ()) ; if process_file (filename) { println ! (\"Processing completed successfully!\" . to_string ()) } else { { println ! (\"Processing failed!\" . to_string ()) ; exit (1i32) } } ; }\n  |\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpppMZXm/main.rs:1:212\n  |\n1 | ... :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpppMZXm/main.rs:1:357\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) -> T { { if ! file_exists (filename) { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Error: File '\" , filename) , \"' does not exist\")) ; return false } }...\n  |       - expected this type parameter                                                                                                                    - expected `T` because of return type                                                                                                                        ^^^^^ expected type parameter `T`, found `bool`\n  |\n  = note: expected type parameter `T`\n                       found type `bool`\n  = note: the caller chooses a type for `T` which can be different from `bool`\n\nerror[E0425]: cannot find function `file_readable` in this scope\n --> /tmp/.tmpppMZXm/main.rs:1:374\n  |\n1 | ... \"' does not exist\")) ; return false } } ; if ! file_readable (filename) { { println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpppMZXm/main.rs:1:579\n  |\n1 | ... ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{}\" , format ! (\"{}{}\" , \"❌ Er...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nwarning: unreachable statement\n --> /tmp/.tmpppMZXm/main.rs:1:723\n  |\n1 | ...or . to_s ())) ; return false } ; let mut word_count = content . split_whitespace () . len () ; println ! (\"{}\" , format ! (\"{}{}\" , f...\n  |                     ------------     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable statement\n  |                     |\n  |                     any code following this expression is unreachable\n  |\n  = note: `#[warn(unreachable_code)]` on by default\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpppMZXm/main.rs:1:953\n  |\n1 | ...return true } } } } fn main () { let mut filename = input (\"Enter filename: \" . to_string ()) ; if process_file (filename) { { println...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0277]: cannot add `bool` to `bool`\n --> /tmp/.tmpppMZXm/main.rs:1:1014\n  |\n1 | ...nter filename: \" . to_string ()) ; if process_file (filename) { { println ! (\"Processing completed successfully!\" . to_string ()) } } ...\n  |                                          ------------  ^^^^^^^^ no implementation for `bool + bool`\n  |                                          |\n  |                                          required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `bool`\nnote: required by a bound in `process_file`\n --> /tmp/.tmpppMZXm/main.rs:1:59\n  |\n1 | use std :: collections :: HashMap ; fn process_file < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fm...\n  |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `process_file`\n\nerror[E0277]: cannot multiply `bool` by `bool`\n --> /tmp/.tmpppMZXm/main.rs:1:1014\n  |\n1 | ...nter filename: \" . to_string ()) ; if process_file (filename) { { println ! (\"Processing completed successfully!\" . to_string ()) } } ...\n  |                                          ------------  ^^^^^^^^ no implementation for `bool * bool`\n  |                                          |\n  |                                          required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `bool`\nnote: required by a bound in `process_file`\n --> /tmp/.tmpppMZXm/main.rs:1:94\n  |\n1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (filename : T) ...\n  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `process_file`\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpppMZXm/main.rs:1:1078\n  |\n1 | ...println ! (\"Processing completed successfully!\" . to_string ()) } } else { { println ! (\"Processing failed!\" . to_string ()) ; exit (1...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpppMZXm/main.rs:1:1139\n  |\n1 | ...)) } } else { { println ! (\"Processing failed!\" . to_string ()) ; exit (1i32) } } ; }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 18 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 9,
          "line_number": 375,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// Good CLI tool practices\n\nfun show_help() {\n    println(\"File Statistics Tool v1.0\")\n    println(\"\")\n    println(\"Usage:\")\n    println(\"  ruchy run file_stats.ruchy <filename>\")\n    println(\"\")\n    println(\"Examples:\")\n    println(\"  ruchy run file_stats.ruchy document.txt\")\n    println(\"  ruchy run file_stats.ruchy data/*.csv\")\n    println(\"\")\n    println(\"Options:\")\n    println(\"  --help     Show this help message\")\n    println(\"  --verbose  Show detailed output\")\n}\n\nfun process_with_progress(files) {\n    let total = files.len()\n    let mut i = 0\n    \n    while i < total {\n        let file = files[i]\n        let progress = ((i + 1) * 100) / total\n        print(\"\\rProcessing... [\" + progress.to_s() + \"%] \" + file)\n        \n        // Do the actual work\n        process_file(file)\n        \n        // Small delay to show progress\n        sleep(100)  // 100ms\n        i = i + 1\n    }\n    \n    println(\"\\n✅ All files processed!\")\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpma1F6K/main.rs:1:96\n  |\n1 | use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\" . to_string ()) ; println ! (\"\" . to_strin...\n  |                                                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpma1F6K/main.rs:1:98\n  |\n1 | use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\" . to_string ()) ; println ! (\"\" . to_strin...\n  |                                                                    ---------------------------   ^^^^^^^^^^^^ argument never used\n  |                                                                    |\n  |                                                                    formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpma1F6K/main.rs:1:128\n  |\n1 | ...\"File Statistics Tool v1.0\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Usage:\" . to_string ()) ; println ! (\"  ruch...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpma1F6K/main.rs:1:130\n  |\n1 | ...tistics Tool v1.0\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Usage:\" . to_string ()) ; println ! (\"  ruchy run fil...\n  |                                                    --   ^^^^^^^^^^^^ argument never used\n  |                                                    |\n  |                                                    formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpma1F6K/main.rs:1:166\n  |\n1 | ...g ()) ; println ! (\"\" . to_string ()) ; println ! (\"Usage:\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy <filename>\" . t...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpma1F6K/main.rs:1:168\n  |\n1 | ...; println ! (\"\" . to_string ()) ; println ! (\"Usage:\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy <filename>\" . to_stri...\n  |                                                 --------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpma1F6K/main.rs:1:237\n  |\n1 | ... ()) ; println ! (\"  ruchy run file_stats.ruchy <filename>\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Examples:\" ....\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpma1F6K/main.rs:1:239\n  |\n1 | .... to_string ()) ; println ! (\"  ruchy run file_stats.ruchy <filename>\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"E...\n  |                                 -----------------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                 |\n  |                                 formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpma1F6K/main.rs:1:269\n  |\n1 | ...ile_stats.ruchy <filename>\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Examples:\" . to_string ()) ; println ! (\"  r...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpma1F6K/main.rs:1:271\n  |\n1 | ....ruchy <filename>\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Examples:\" . to_string ()) ; println ! (\"  ruchy run ...\n  |                                                    --   ^^^^^^^^^^^^ argument never used\n  |                                                    |\n  |                                                    formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpma1F6K/main.rs:1:310\n  |\n1 | ...)) ; println ! (\"\" . to_string ()) ; println ! (\"Examples:\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy document.txt\" ....\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpma1F6K/main.rs:1:312\n  |\n1 | ... println ! (\"\" . to_string ()) ; println ! (\"Examples:\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy document.txt\" . to_...\n  |                                                -----------   ^^^^^^^^^^^^ argument never used\n  |                                                |\n  |                                                formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpma1F6K/main.rs:1:383\n  |\n1 | ...)) ; println ! (\"  ruchy run file_stats.ruchy document.txt\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\" . t...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpma1F6K/main.rs:1:385\n  |\n1 | ... to_string ()) ; println ! (\"  ruchy run file_stats.ruchy document.txt\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy dat...\n  |                                -------------------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                |\n  |                                formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpma1F6K/main.rs:1:454\n  |\n1 | ... ()) ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Options:\" . ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpma1F6K/main.rs:1:456\n  |\n1 | .... to_string ()) ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"O...\n  |                                 -----------------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                 |\n  |                                 formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpma1F6K/main.rs:1:486\n  |\n1 | ...ile_stats.ruchy data/*.csv\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Options:\" . to_string ()) ; println ! (\"  --...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpma1F6K/main.rs:1:488\n  |\n1 | ....ruchy data/*.csv\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Options:\" . to_string ()) ; println ! (\"  --help     ...\n  |                                                    --   ^^^^^^^^^^^^ argument never used\n  |                                                    |\n  |                                                    formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpma1F6K/main.rs:1:526\n  |\n1 | ...()) ; println ! (\"\" . to_string ()) ; println ! (\"Options:\" . to_string ()) ; println ! (\"  --help     Show this help message\" . to_st...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpma1F6K/main.rs:1:528\n  |\n1 | ... println ! (\"\" . to_string ()) ; println ! (\"Options:\" . to_string ()) ; println ! (\"  --help     Show this help message\" . to_string ...\n  |                                                ----------   ^^^^^^^^^^^^ argument never used\n  |                                                |\n  |                                                formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpma1F6K/main.rs:1:593\n  |\n1 | ...ring ()) ; println ! (\"  --help     Show this help message\" . to_string ()) ; println ! (\"  --verbose  Show detailed output\" . to_stri...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpma1F6K/main.rs:1:595\n  |\n1 | ...\" . to_string ()) ; println ! (\"  --help     Show this help message\" . to_string ()) ; println ! (\"  --verbose  Show detailed output\" ...\n  |                                   -------------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                   |\n  |                                   formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpma1F6K/main.rs:1:658\n  |\n1 | ...string ()) ; println ! (\"  --verbose  Show detailed output\" . to_string ()) } } fn process_with_progress < T : std :: ops :: Add < Out...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpma1F6K/main.rs:1:660\n  |\n1 | ...e\" . to_string ()) ; println ! (\"  --verbose  Show detailed output\" . to_string ()) } } fn process_with_progress < T : std :: ops :: A...\n  |                                    -----------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                    |\n  |                                    formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpma1F6K/main.rs:1:1215\n  |\n1 | ... = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\" . to_string ()) } } } } fn main () { }\n  |                                                                 ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpma1F6K/main.rs:1:1217\n  |\n1 | ...; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\" . to_string ()) } } } } fn main () { }\n  |                                        ---------------------------   ^^^^^^^^^^^^ argument never used\n  |                                        |\n  |                                        formatting specifier missing\n\nerror[E0425]: cannot find function `sleep` in this scope\n --> /tmp/.tmpma1F6K/main.rs:1:1137\n  |\n1 | .... to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\" . to_...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::sleep;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpma1F6K/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\" . to_string ()) ; println ! (\"\" . to_strin...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpma1F6K/main.rs:1:852\n  |\n1 | ... { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\" . to_string ()) } } } } f...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Usage:\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy <filename>\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Examples:\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy document.txt\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Options:\" . to_string ()) ; println ! (\"  --help     Show this help message\" . to_string ()) ; println ! (\"  --verbose  Show detailed output\" . to_string ()) } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\" . to_string ()) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Usage:\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy <filename>\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Examples:\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy document.txt\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Options:\" . to_string ()) ; println ! (\"  --help     Show this help message\" . to_string ()) ; println ! (\"  --verbose  Show detailed output\" . to_string ()) } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\" . to_string ()) } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpma1F6K/main.rs:1:924\n  |\n1 | ... { { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ...\n  |       ^^                                                                                                                                                                                                                                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Usage:\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy <filename>\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Examples:\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy document.txt\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Options:\" . to_string ()) ; println ! (\"  --help     Show this help message\" . to_string ()) ; println ! (\"  --verbose  Show detailed output\" . to_string ()) } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\" . to_string ()) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Usage:\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy <filename>\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Examples:\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy document.txt\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Options:\" . to_string ()) ; println ! (\"  --help     Show this help message\" . to_string ()) ; println ! (\"  --verbose  Show detailed output\" . to_string ()) } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } ; println ! (\"\\n✅ All files processed!\" . to_string ()) } } } } fn main () { }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpma1F6K/main.rs:1:98\n  |\n1 | use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\" . to_string ()) ; println ! (\"\" . to_strin...\n  |                                                                                                  ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpma1F6K/main.rs:1:130\n  |\n1 | ...tics Tool v1.0\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Usage:\" . to_string ()) ; println ! (\"  ruchy run file_s...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpma1F6K/main.rs:1:168\n  |\n1 | ...tln ! (\"\" . to_string ()) ; println ! (\"Usage:\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy <filename>\" . to_string ())...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpma1F6K/main.rs:1:239\n  |\n1 | ...ln ! (\"  ruchy run file_stats.ruchy <filename>\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Examples:\" . to_string (...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpma1F6K/main.rs:1:271\n  |\n1 | ...chy <filename>\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Examples:\" . to_string ()) ; println ! (\"  ruchy run fil...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpma1F6K/main.rs:1:312\n  |\n1 | ... ! (\"\" . to_string ()) ; println ! (\"Examples:\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy document.txt\" . to_string (...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpma1F6K/main.rs:1:385\n  |\n1 | ... ! (\"  ruchy run file_stats.ruchy document.txt\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\" . to_string ())...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpma1F6K/main.rs:1:456\n  |\n1 | ...ln ! (\"  ruchy run file_stats.ruchy data/*.csv\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Options:\" . to_string ()...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpma1F6K/main.rs:1:488\n  |\n1 | ...chy data/*.csv\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Options:\" . to_string ()) ; println ! (\"  --help     Sho...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpma1F6K/main.rs:1:528\n  |\n1 | ...n ! (\"\" . to_string ()) ; println ! (\"Options:\" . to_string ()) ; println ! (\"  --help     Show this help message\" . to_string ()) ; p...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpma1F6K/main.rs:1:595\n  |\n1 | ...rintln ! (\"  --help     Show this help message\" . to_string ()) ; println ! (\"  --verbose  Show detailed output\" . to_string ()) } } f...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpma1F6K/main.rs:1:660\n  |\n1 | ... println ! (\"  --verbose  Show detailed output\" . to_string ()) } } fn process_with_progress < T : std :: ops :: Add < Output = T > + ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmpma1F6K/main.rs:1:876\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                           ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Usage:\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy <filename>\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Examples:\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy document.txt\" . to_string ()) ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\" . to_string ()) ; println ! (\"\" . to_string ()) ; println ! (\"Options:\" . to_string ()) ; println ! (\"  --help     Show this help message\" . to_string ()) ; println ! (\"  --verbose  Show detailed output\" . to_string ()) } } fn process_with_progress < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\" . to_string ()) } } } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               +++++++++++++++++++\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmpma1F6K/main.rs:1:945\n  |\n1 | ...() ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" ...\n  |                                                                     ^^^\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpma1F6K/main.rs:1:1087\n  |\n1 | ...format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0425]: cannot find function `process_file` in this scope\n --> /tmp/.tmpma1F6K/main.rs:1:1115\n  |\n1 | ...g... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All file...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpma1F6K/main.rs:1:1217\n  |\n1 | ...} } } } ; println ! (\"\\n✅ All files processed!\" . to_string ()) } } } } fn main () { }\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpma1F6K/main.rs:1:1177\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (files : T) -> T { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\" . to_string ()) } }...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 45 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0425, E0599, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: len()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 10,
          "line_number": 431,
          "code": "// Status: ❌ BROKEN\n// Example: Manual line counting implementation\n\nfun main() {\n    // Sample file content for demonstration\n    let content = \"line 1\\nline 2\\nline 3\";\n    \n    // Manual line counting implementation\n    let mut lines = 1;\n    let mut i = 0;\n    while i < content.len() {\n        if content[i] == '\\n' {\n            lines = lines + 1;\n        }\n        i = i + 1;\n    }\n    \n    println(\"File has\", lines, \"lines\");\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpnaMoQV/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" ; { let mut lines = 1i32 ; let mut i = 0i32 ;...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpnaMoQV/main.rs:1:50\n  |\n1 | ... { { { let content = \"line 1\\nline 2\\nline 3\" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {} {}\" , \"File has\" . to_string () , lines , \"lines\" . to_string ()) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                      ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {} {}\" , \"File has\" . to_string () , lines , \"lines\" . to_string ()) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let content = \"line 1\\nline 2\\nline 3\" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {} {}\" , \"File has\" . to_string () , lines , \"lines\" . to_string ()) } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpnaMoQV/main.rs:1:195\n  |\n1 | ...hile i < content . len () { { if content [i] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {} {}\" , \"File h...\n  |                                                           ^^                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {} {}\" , \"File has\" . to_string () , lines , \"lines\" . to_string ()) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\\n' { lines = lines + 1i32 } ; i = i + 1i32 } } ; println ! (\"{} {} {}\" , \"File has\" . to_string () , lines , \"lines\" . to_string ()) } } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpnaMoQV/main.rs:1:149\n  |\n1 | ...t lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 ...\n  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`\n  |                                              |\n  |                                              expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len ().try_into().unwrap() { { if content [i] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {} {}\" , \"File has\" . to_string () , lines , \"lines\" . to_string ()) } } } }\n  |                                                                                                                                                                     ++++++++++++++++++++\n\nerror[E0277]: the type `str` cannot be indexed by `i32`\n --> /tmp/.tmpnaMoQV/main.rs:1:182\n  |\n1 | ...32 ; while i < content . len () { { if content [i] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"{} {} {}\" , \"...\n  |                                                    ^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `str` to implement `Index<i32>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 11,
          "line_number": 534,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// task_manager.ruchy - A simple but useful task management tool\n\nlet TASK_FILE = \"tasks.txt\"\n\nfun show_menu() {\n    println(\"\\n=== Task Manager ===\")\n    println(\"1. List tasks\")\n    println(\"2. Add task\")\n    println(\"3. Complete task\")\n    println(\"4. Delete task\")\n    println(\"5. Quit\")\n}\n\nfun load_tasks() {\n    if file_exists(TASK_FILE) {\n        return read_lines(TASK_FILE)\n    }\n    return []\n}\n\nfun save_tasks(tasks) {\n    let content = tasks.join(\"\\n\")\n    write_file(TASK_FILE, content)\n}\n\nfun list_tasks(tasks) {\n    if tasks.is_empty() {\n        println(\"\\n📝 No tasks yet!\")\n        return\n    }\n    \n    println(\"\\n📋 Your Tasks (\" + tasks.len().to_s() + \" items):\")\n    let mut i = 0\n    while i < tasks.len() {\n        let task = tasks[i]\n        let status = if task.starts_with(\"✅\") { \"DONE\" } else { \"PENDING\" }\n        println((i + 1).to_s() + \". \" + task)\n        i = i + 1\n    }\n}\n\nfun add_task(tasks) {\n    let new_task = input(\"\\nWhat do you want to add? \")\n    tasks.push(\"📌 \" + new_task)\n    save_tasks(tasks)\n    println(\"✅ Task added!\")\n}\n\nfun complete_task(tasks) {\n    list_tasks(tasks)\n    let index = input(\"\\nWhich task to complete? (number): \").to_i() - 1\n    \n    if index >= 0 && index < tasks.len() {\n        tasks[index] = tasks[index].replace(\"📌\", \"✅\")\n        save_tasks(tasks)\n        println(\"🎉 Task completed!\")\n    } else {\n        println(\"❌ Invalid task number\")\n    }\n}\n\n// Main program loop\nlet tasks = load_tasks()\n\nloop {\n    show_menu()\n    let choice = input(\"\\nChoose option: \")\n    \n    match choice {\n        \"1\" => list_tasks(tasks)\n        \"2\" => add_task(tasks)\n        \"3\" => complete_task(tasks)\n        \"4\" => {\n            list_tasks(tasks)\n            let index = input(\"Which task to delete? (number): \").to_i() - 1\n            if index >= 0 && index < tasks.len() {\n                tasks.remove(index)\n                save_tasks(tasks)\n                println(\"🗑️  Task deleted!\")\n            }\n        }\n        \"5\" => {\n            println(\"👋 Goodbye!\")\n            break\n        }\n        _ => println(\"❌ Invalid choice\")\n    }\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpcEBfWZ/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" ...\n  |                                                                                             ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpcEBfWZ/main.rs:1:95\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" ...\n  |                                                                    ------------------------   ^^^^^^^^^^^^ argument never used\n  |                                                                    |\n  |                                                                    formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpcEBfWZ/main.rs:1:138\n  |\n1 | ...k Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpcEBfWZ/main.rs:1:140\n  |\n1 | ...Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. ...\n  |                                              ---------------   ^^^^^^^^^^^^ argument never used\n  |                                              |\n  |                                              formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpcEBfWZ/main.rs:1:181\n  |\n1 | ...(\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpcEBfWZ/main.rs:1:183\n  |\n1 | .... List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (...\n  |                                               -------------   ^^^^^^^^^^^^ argument never used\n  |                                               |\n  |                                               formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpcEBfWZ/main.rs:1:229\n  |\n1 | .... Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpcEBfWZ/main.rs:1:231\n  |\n1 | ... Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (...\n  |                                            ------------------   ^^^^^^^^^^^^ argument never used\n  |                                            |\n  |                                            formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpcEBfWZ/main.rs:1:275\n  |\n1 | ...omplete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks (...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpcEBfWZ/main.rs:1:277\n  |\n1 | ...plete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () ...\n  |                                             ----------------   ^^^^^^^^^^^^ argument never used\n  |                                             |\n  |                                             formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpcEBfWZ/main.rs:1:314\n  |\n1 | ... ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { re...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpcEBfWZ/main.rs:1:316\n  |\n1 | ...4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return ...\n  |                                                 ---------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpcEBfWZ/main.rs:1:907\n  |\n1 | ...{ if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ...\n  |                                                                 ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpcEBfWZ/main.rs:1:909\n  |\n1 | ...{ if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ...\n  |                                            --------------------   ^^^^^^^^^^^^ argument never used\n  |                                            |\n  |                                            formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpcEBfWZ/main.rs:1:1655\n  |\n1 | ...ew_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output =...\n  |                                                                 ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpcEBfWZ/main.rs:1:1657\n  |\n1 | ..._task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T...\n  |                                              ----------------   ^^^^^^^^^^^^ argument never used\n  |                                              |\n  |                                              formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2116\n  |\n1 | ... \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string (...\n  |                                                                  ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpcEBfWZ/main.rs:1:2118\n  |\n1 | ... \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string (...\n  |                                             --------------------   ^^^^^^^^^^^^ argument never used\n  |                                             |\n  |                                             formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2180\n  |\n1 | ..._string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; le...\n  |                                                                 ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpcEBfWZ/main.rs:1:2182\n  |\n1 | ...to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; ...\n  |                                          ------------------------   ^^^^^^^^^^^^ argument never used\n  |                                          |\n  |                                          formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2721\n  |\n1 | ... save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpcEBfWZ/main.rs:1:2723\n  |\n1 | ...) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string (...\n  |                                        --------------------------   ^^^^^^^^^^^^ argument never used\n  |                                        |\n  |                                        formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2780\n  |\n1 | ... . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string (...\n  |                                                                 ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpcEBfWZ/main.rs:1:2782\n  |\n1 | ...o_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) ,...\n  |                                               -------------   ^^^^^^^^^^^^ argument never used\n  |                                               |\n  |                                               formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2843\n  |\n1 | ...o_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n  |                                                                 ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpcEBfWZ/main.rs:1:2845\n  |\n1 | ..._string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n  |                                            -------------------   ^^^^^^^^^^^^ argument never used\n  |                                            |\n  |                                            formatting specifier missing\n\nerror[E0425]: cannot find value `TASK_FILE` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:371\n  |\n1 | ...ring ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `TASK_FILE` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:405\n  |\n1 | ...if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `TASK_FILE` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:657\n  |\n1 | ...{ let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + st...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpcEBfWZ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpcEBfWZ/main.rs:1:384\n  |\n1 | ...fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std ::...\n  |                                                      ^^                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { return read_lines (TASK_FILE) } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpcEBfWZ/main.rs:1:605\n  |\n1 | ...+ Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std ::...\n  |                                 ^^                                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpcEBfWZ/main.rs:1:1104\n  |\n1 | ... { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } }...\n  |       ^^                                                                                                                                                                                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpcEBfWZ/main.rs:1:1180\n  |\n1 | ... tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" ...\n  |                                                                   ^^      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { \"DONE\" } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpcEBfWZ/main.rs:1:1200\n  |\n1 | ... status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () ,...\n  |                                                                 ^^         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { \"PENDING\" } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpcEBfWZ/main.rs:1:1478\n  |\n1 | ... { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn...\n  |       ^^                                                                                                                                                                                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpcEBfWZ/main.rs:1:2143\n  |\n1 | ... completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE =...\n  |                                            ^^                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { println ! (\"❌ Invalid task number\" . to_string ()) } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:95\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" ...\n  |                                                                                               ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:140\n  |\n1 | ...=\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete t...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:183\n  |\n1 | ...sks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delet...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:231\n  |\n1 | .... to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" ....\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:277\n  |\n1 | ...\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if fil...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:316\n  |\n1 | ...te task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_li...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:358\n  |\n1 | ...uit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } f...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_lines` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:393\n  |\n1 | ...asks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: A...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `join` found for type parameter `T` in the current scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:631\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"...\n  |       - method `join` not found for this type parameter                                                                                                                            ^^^^ method not found in `T`\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:645\n  |\n1 | ...T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Outpu...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `is_empty` found for type parameter `T` in the current scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:860\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty ()...\n  |       - method `is_empty` not found for this type parameter                                                                                                           ^^^^^^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following traits define an item `is_empty`, perhaps you need to restrict type parameter `T` with one of them:\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + RangeBounds</* T */> > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ++++++++++++++++++++++\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:909\n  |\n1 | ... is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , ...\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0069]: `return;` in a function whose return type is not `()`\n --> /tmp/.tmpcEBfWZ/main.rs:1:925\n  |\n1 | ...ks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"...\n  |               - expected `T` because of this return type                                         ^^^^^^ return type is not `()`\n  |\nhelp: give the `return` a value of the expected type\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return /* value */ } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     +++++++++++\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:1023\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () ....\n  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                                                                     ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:1095\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () {...\n  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                                                                                                                                             ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmpcEBfWZ/main.rs:1:1125\n  |\n1 | ...t mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } el...\n  |                                                                     ^^^\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:1266\n  |\n1 | ...} ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops ::...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpcEBfWZ/main.rs:1:1077\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } f...\n  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                                                                                                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: the caller chooses a type for `T` which can be different from `()`\n  = note: `while` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } /* `T` value */ } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    +++++++++++++++\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:1497\n  |\n1 | ...bug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0599]: no method named `push` found for type parameter `T` in the current scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:1562\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (f...\n  |       - method `push` not found for this type parameter                                                                                                                                                                                      ^^^^ method not found in `T`\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:1657\n  |\n1 | ...save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :...\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpcEBfWZ/main.rs:1:1628\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } ...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:1882\n  |\n1 | ...ks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; i...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:1999\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                                                                                                                                                             ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\" . to_string ()) ; println ! (\"1. List tasks\" . to_string ()) ; println ! (\"2. Add task\" . to_string ()) ; println ! (\"3. Complete task\" . to_string ()) ; println ! (\"4. Delete task\" . to_string ()) ; println ! (\"5. Quit\" . to_string ()) } } fn load_tasks () { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\" . to_string ()) ; return } } ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = input (\"\\nWhat do you want to add? \" . to_string ()) ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\" . to_string ()) } } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     +++++++++++++++++++\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:2118\n  |\n1 | ..._tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } ...\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpcEBfWZ/main.rs:1:2085\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } e...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:2182\n  |\n1 | ...} } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" ; let mut tasks ...\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpcEBfWZ/main.rs:1:2145\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { let index = input (\"\\nWhich task to complete? (number): \" . to_string ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index] = tasks [index] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\" . to_string ()) } } else { { println ! (\"❌ Invalid task number\" . to_string ()) } } } ...\n  |       - expected this type parameter                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:2324\n  |\n1 | ...d_tasks () ; loop { { show_menu () ; { let choice = input (\"\\nChoose option: \" . to_string ()) ; match choice { \"1\" => list_tasks (tas...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0277]: cannot add `()` to `()`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2403\n  |\n1 | .... to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_ta...\n  |                                            ----------  ^^^^^ no implementation for `() + ()`\n  |                                            |\n  |                                            required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `()`\nnote: required by a bound in `list_tasks`\n --> /tmp/.tmpcEBfWZ/main.rs:1:704\n  |\n1 | ...ent) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`\n\nerror[E0277]: cannot multiply `()` by `()`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2403\n  |\n1 | .... to_string ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_ta...\n  |                                            ----------  ^^^^^ no implementation for `() * ()`\n  |                                            |\n  |                                            required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `()`\nnote: required by a bound in `list_tasks`\n --> /tmp/.tmpcEBfWZ/main.rs:1:739\n  |\n1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) ->...\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2403\n  |\n1 | ... ()) ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks)...\n  |                                 ----------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`\n  |                                 |\n  |                                 required by a bound introduced by this call\n  |\nnote: required by a bound in `list_tasks`\n --> /tmp/.tmpcEBfWZ/main.rs:1:774\n  |\n1 | ...+ std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty ()...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`\n\nerror[E0277]: cannot add `()` to `()`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2429\n  |\n1 | ...ice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index =...\n  |                                             --------  ^^^^^ no implementation for `() + ()`\n  |                                             |\n  |                                             required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `()`\nnote: required by a bound in `add_task`\n --> /tmp/.tmpcEBfWZ/main.rs:1:1335\n  |\n1 | ...2 } } } } } } fn add_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: f...\n  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `add_task`\n\nerror[E0277]: cannot multiply `()` by `()`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2429\n  |\n1 | ...ice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index =...\n  |                                             --------  ^^^^^ no implementation for `() * ()`\n  |                                             |\n  |                                             required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `()`\nnote: required by a bound in `add_task`\n --> /tmp/.tmpcEBfWZ/main.rs:1:1370\n  |\n1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -...\n  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `add_task`\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2429\n  |\n1 | ...> list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Wh...\n  |                                  --------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`\n  |                                  |\n  |                                  required by a bound introduced by this call\n  |\nnote: required by a bound in `add_task`\n --> /tmp/.tmpcEBfWZ/main.rs:1:1405\n  |\n1 | ... + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let new_task = inpu...\n  |                                          ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `add_task`\n\nerror[E0277]: cannot add `()` to `()`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2460\n  |\n1 | ...s) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete...\n  |                                          -------------  ^^^^^ no implementation for `() + ()`\n  |                                          |\n  |                                          required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `()`\nnote: required by a bound in `complete_task`\n --> /tmp/.tmpcEBfWZ/main.rs:1:1702\n  |\n1 | ... } } } fn complete_task < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...\n  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `complete_task`\n\nerror[E0277]: cannot multiply `()` by `()`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2460\n  |\n1 | ...s) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete...\n  |                                          -------------  ^^^^^ no implementation for `() * ()`\n  |                                          |\n  |                                          required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `()`\nnote: required by a bound in `complete_task`\n --> /tmp/.tmpcEBfWZ/main.rs:1:1737\n  |\n1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> ...\n  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `complete_task`\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2460\n  |\n1 | ...> add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number)...\n  |                                -------------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`\n  |                                |\n  |                                required by a bound introduced by this call\n  |\nnote: required by a bound in `complete_task`\n --> /tmp/.tmpcEBfWZ/main.rs:1:1772\n  |\n1 | ...std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { list_tasks (tasks) ; { l...\n  |                                       ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `complete_task`\n\nerror[E0277]: cannot add `()` to `()`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2490\n  |\n1 | ...\"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) ....\n  |                                            ----------  ^^^^^ no implementation for `() + ()`\n  |                                            |\n  |                                            required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `()`\nnote: required by a bound in `list_tasks`\n --> /tmp/.tmpcEBfWZ/main.rs:1:704\n  |\n1 | ...ent) } } } fn list_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`\n\nerror[E0277]: cannot multiply `()` by `()`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2490\n  |\n1 | ...\"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) ....\n  |                                            ----------  ^^^^^ no implementation for `() * ()`\n  |                                            |\n  |                                            required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `()`\nnote: required by a bound in `list_tasks`\n --> /tmp/.tmpcEBfWZ/main.rs:1:739\n  |\n1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) ->...\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2490\n  |\n1 | ...lete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - ...\n  |                                 ----------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`\n  |                                 |\n  |                                 required by a bound introduced by this call\n  |\nnote: required by a bound in `list_tasks`\n --> /tmp/.tmpcEBfWZ/main.rs:1:774\n  |\n1 | ...+ std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { if tasks . is_empty ()...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `list_tasks`\n\nerror[E0425]: cannot find function `input` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:2513\n  |\n1 | ...asks) , \"4\" => { list_tasks (tasks) ; { let index = input (\"Which task to delete? (number): \" . to_string ()) . to_i () - 1i32 ; if in...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0599]: no method named `len` found for unit type `()` in the current scope\n    --> /tmp/.tmpcEBfWZ/main.rs:1:2626\n     |\n1    | ...tring ()) . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"...\n     |                                                                     ^^^\n     |\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1402:5\n     |\n1402 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `remove` found for unit type `()` in the current scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:2645\n  |\n1 | ...ndex >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_st...\n  |                                                       ^^^^^^ method not found in `()`\n\nerror[E0277]: cannot add `()` to `()`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2674\n  |\n1 | ...s . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { ...\n  |                                            ----------  ^^^^^ no implementation for `() + ()`\n  |                                            |\n  |                                            required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `()`\nnote: required by a bound in `save_tasks`\n --> /tmp/.tmpcEBfWZ/main.rs:1:462\n  |\n1 | ...c ! [] } } fn save_tasks < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `save_tasks`\n\nerror[E0277]: cannot multiply `()` by `()`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2674\n  |\n1 | ...s . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { ...\n  |                                            ----------  ^^^^^ no implementation for `() * ()`\n  |                                            |\n  |                                            required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `()`\nnote: required by a bound in `save_tasks`\n --> /tmp/.tmpcEBfWZ/main.rs:1:497\n  |\n1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) ->...\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `save_tasks`\n\nerror[E0277]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpcEBfWZ/main.rs:1:2674\n  |\n1 | ...{ { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"...\n  |                                 ----------  ^^^^^ the trait `std::fmt::Display` is not implemented for `()`\n  |                                 |\n  |                                 required by a bound introduced by this call\n  |\nnote: required by a bound in `save_tasks`\n --> /tmp/.tmpcEBfWZ/main.rs:1:532\n  |\n1 | ...+ std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (tasks : T) -> T { { { let content = tasks ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `save_tasks`\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:2723\n  |\n1 | ...(tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\" . to_string ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:2782\n  |\n1 | ... ()) } } } } , \"5\" => { println ! (\"👋 Goodbye!\" . to_string ()) ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } }...\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpcEBfWZ/main.rs:1:2845\n  |\n1 | ... ; break } , _ => println ! (\"❌ Invalid choice\" . to_string ()) , } } } } ; }\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 79 previous errors; 8 warnings emitted\n\nSome errors have detailed explanations: E0069, E0277, E0308, E0425, E0599, E0608.\nFor more information about an error, try `rustc --explain E0069`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: join()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 12,
          "line_number": 655,
          "code": "// Status: ✅ WORKING\n// ❌ This demonstrates what NOT to do - no error handling\n\nfun main() {\n    // Example of code that would fail without proper error checking\n    println(\"Example: Unsafe file operations\");\n    println(\"This pattern would crash if file doesn't exist:\");\n    println(\"// let content = read_file(\\\"missing.txt\\\");\");\n    \n    // Better approach would include error checking\n    println(\"Always check if operations can fail before using them\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpFLT6Gm/main.rs:1:97\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Example: Unsafe file operations\" . to_string ()) ; println ! (\"This patter...\n  |                                                                                                 ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpFLT6Gm/main.rs:1:99\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Example: Unsafe file operations\" . to_string ()) ; println ! (\"This patter...\n  |                                                               ---------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                                               |\n  |                                                               formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpFLT6Gm/main.rs:1:176\n  |\n1 | ...rintln ! (\"This pattern would crash if file doesn't exist:\" . to_string ()) ; println ! (\"// let content = read_file(\\\"missing.txt\\\");...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpFLT6Gm/main.rs:1:178\n  |\n1 | ..._string ()) ; println ! (\"This pattern would crash if file doesn't exist:\" . to_string ()) ; println ! (\"// let content = read_file(\\\"...\n  |                             -------------------------------------------------   ^^^^^^^^^^^^ argument never used\n  |                             |\n  |                             formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpFLT6Gm/main.rs:1:252\n  |\n1 | ...; println ! (\"// let content = read_file(\\\"missing.txt\\\");\" . to_string ()) ; println ! (\"Always check if operations can fail before u...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpFLT6Gm/main.rs:1:254\n  |\n1 | ...o_string ()) ; println ! (\"// let content = read_file(\\\"missing.txt\\\");\" . to_string ()) ; println ! (\"Always check if operations can ...\n  |                              ----------------------------------------------   ^^^^^^^^^^^^ argument never used\n  |                              |\n  |                              formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpFLT6Gm/main.rs:1:337\n  |\n1 | ... ! (\"Always check if operations can fail before using them\" . to_string ()) } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpFLT6Gm/main.rs:1:339\n  |\n1 | ...ring ()) ; println ! (\"Always check if operations can fail before using them\" . to_string ()) } }\n  |                          -------------------------------------------------------   ^^^^^^^^^^^^ argument never used\n  |                          |\n  |                          formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpFLT6Gm/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Example: Unsafe file operations\" . to_string ()) ; println ! (\"This patter...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpFLT6Gm/main.rs:1:99\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Example: Unsafe file operations\" . to_string ()) ; println ! (\"This patter...\n  |                                                                                                   ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpFLT6Gm/main.rs:1:178\n  |\n1 | ...his pattern would crash if file doesn't exist:\" . to_string ()) ; println ! (\"// let content = read_file(\\\"missing.txt\\\");\" . to_strin...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpFLT6Gm/main.rs:1:254\n  |\n1 | ...(\"// let content = read_file(\\\"missing.txt\\\");\" . to_string ()) ; println ! (\"Always check if operations can fail before using them\" ....\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpFLT6Gm/main.rs:1:339\n  |\n1 | ...check if operations can fail before using them\" . to_string ()) } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 12 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 13,
          "line_number": 677,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Confusing and unhelpful\nprintln(\"Enter thing:\")\nlet thing = input()\n// What thing? What format?\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpB9dZYx/main.rs:1:134\n  |\n1 | ..._string ()) ; let mut thing = input () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpB9dZYx/main.rs:1:91\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"Enter thing:\" . to_string ()) ; let mut thing = input () } ; ...\n  |                                                                                           ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpB9dZYx/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"Enter thing:\" . to_string ()) ; let mut thing = input () } ; ...\n  |                                                                            --------------   ^^^^^^^^^^^^ argument never used\n  |                                                                            |\n  |                                                                            formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpB9dZYx/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"Enter thing:\" . to_string ()) ; let mut thing = input () } ; ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpB9dZYx/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"Enter thing:\" . to_string ()) ; let mut thing = input () } ; ...\n  |                                                                                             ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 14,
          "line_number": 695,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Only works on your computer\nlet data = read_file(\"/Users/noah/Desktop/data.txt\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found `let` statement\n --> /tmp/.tmpBs03FE/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let mut data = read_file (\"/Users/noah/Desktop/data.txt\" . to_string ()) ; ...\n  |                                                               ^^^\n  |\n  = note: only supported directly in conditions of `if` and `while` expressions\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpBs03FE/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let mut data = read_file (\"/Users/noah/Desktop/data.txt\" . to_string ()) ; ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpBs03FE/main.rs:1:78\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let mut data = read_file (\"/Users/noah/Desktop/data.txt\" . to_string ()) ; ...\n  |                                                                              ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch12-00-traits-generics": {
      "chapter": "ch12-00-traits-generics",
      "total_examples": 11,
      "working_examples": 0,
      "failing_examples": 11,
      "examples": [
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Define behavior with traits\ntrait Serializable {\n    fun serialize(self) -> String\n    fun deserialize(String) -> Self\n}\n\n// Generic function works with any Serializable type\nfun save_to_file<T: Serializable>(item: T, path: String) {\n    let serialized = item.serialize()\n    write_file(path, serialized)\n}\n\nfun load_from_file<T: Serializable>(path: String) -> T {\n    let content = read_file(path)\n    return T::deserialize(content)\n}\n\n// Implement trait for your types\nstruct User {\n    name: String\n    email: String\n    age: i32\n}\n\nimpl Serializable for User {\n    fun serialize(self) -> String {\n        return to_json(self)\n    }\n    \n    fun deserialize(data: String) -> User {\n        return parse_json(data)\n    }\n}\n\n// Now it just works!\nlet user = User{name: \"Alice\", email: \"alice@example.com\", age: 30}\nsave_to_file(user, \"user.json\")  // Generic function, specific type\nlet loaded: User = load_from_file(\"user.json\")  // Type safe!",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 2,
          "line_number": 87,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Simple trait\ntrait Drawable {\n    fun draw(self)\n}\n\n// Trait with multiple methods\ntrait Container {\n    fun len(self) -> i32\n    fun is_empty(self) -> bool {\n        return self.len() == 0  // Default implementation\n    }\n    fun clear(mut self)\n}\n\n// Traits with associated types\ntrait Iterator {\n    type Item\n    \n    fun next(mut self) -> Option<Item>\n    \n    fun collect(mut self) -> Vec<Item> {\n        let result = Vec::new()\n        while let Some(item) = self.next() {\n            result.push(item)\n        }\n        return result\n    }\n}\n\n// Traits with constraints\ntrait Comparable: Eq {\n    fun compare(self, other: Self) -> Ordering\n}\n\n// Trait inheritance\ntrait Animal {\n    fun speak(self)\n}\n\ntrait Dog: Animal {\n    fun wag_tail(self)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 3,
          "line_number": 144,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nstruct Point {\n    x: f64\n    y: f64\n}\n\nimpl Drawable for Point {\n    fun draw(self) {\n        println(\"Point at (\" + self.x.to_s() + \", \" + self.y.to_s() + \")\")\n    }\n}\n\nstruct Circle {\n    center: Point\n    radius: f64\n}\n\nimpl Drawable for Circle {\n    fun draw(self) {\n        println(\"Circle at (\" + self.center.x.to_s() + \", \" + self.center.y.to_s() + \") with radius \" + self.radius.to_s())\n    }\n}\n\n// Now both types can be drawn\nlet p = Point{x: 10, y: 20}\nlet c = Circle{center: p, radius: 5}\n\np.draw()  // Trait method\nc.draw()  // Same interface, different implementation\n\n// Implement traits for existing types\nimpl Drawable for String {\n    fun draw(self) {\n        println(\"Text: \" + self)\n    }\n}\n\n\"Hello\".draw()  // Extension methods!",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 4,
          "line_number": 196,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Simple generic function\nfun swap<T>(a: mut T, b: mut T) {\n    let temp = a\n    a = b\n    b = temp\n}\n\n// Multiple type parameters\nfun pair<K, V>(key: K, value: V) -> (K, V) {\n    return (key, value)\n}\n\n// Trait bounds\nfun print_all<T: Display>(items: Vec<T>) {\n    for item in items {\n        println(item)  // Works because T implements Display\n    }\n}\n\n// Multiple bounds\nfun process<T: Clone + Debug + Send>(item: T) {\n    let copy = item.clone()\n    debug(copy)\n    send_to_thread(item)\n}\n\n// Where clauses for complex bounds\nfun complex_function<T, U>(x: T, y: U) -> Vec<T>\nwhere\n    T: Clone + From<U>,\n    U: Display + Into<String>\n{\n    let converted: T = T::from(y)\n    return vec![x.clone(), converted]\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 5,
          "line_number": 246,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Generic struct\nstruct Pair<T> {\n    first: T\n    second: T\n}\n\nimpl<T> Pair<T> {\n    fun new(first: T, second: T) -> Pair<T> {\n        return Pair{first, second}\n    }\n    \n    fun swap(mut self) {\n        let temp = self.first\n        self.first = self.second\n        self.second = temp\n    }\n}\n\n// Generic enum\nenum Option<T> {\n    Some(T)\n    None\n}\n\nenum Result<T, E> {\n    Ok(T)\n    Err(E)\n}\n\n// Generic with constraints\nstruct SortedVec<T: Ord> {\n    items: Vec<T>\n}\n\nimpl<T: Ord> SortedVec<T> {\n    fun insert(mut self, item: T) {\n        let pos = self.items.binary_search(item)\n        self.items.insert(pos, item)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 6,
          "line_number": 301,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Custom collection with traits\nstruct Cache<K: Hash + Eq, V> {\n    map: HashMap<K, V>\n    max_size: usize\n    access_order: Vec<K>\n}\n\nimpl<K: Hash + Eq + Clone, V: Clone> Cache<K, V> {\n    fun new(max_size: usize) -> Cache<K, V> {\n        return Cache{\n            map: HashMap::new(),\n            max_size,\n            access_order: Vec::new()\n        }\n    }\n    \n    fun get(mut self, key: K) -> Option<V> {\n        if let Some(value) = self.map.get(key) {\n            // Update access order\n            self.access_order.retain(|k| k != key)\n            self.access_order.push(key.clone())\n            return Some(value.clone())\n        }\n        return None\n    }\n    \n    fun put(mut self, key: K, value: V) {\n        if self.map.len() >= self.max_size && !self.map.contains_key(key) {\n            // Evict least recently used\n            let lru = self.access_order.remove(0)\n            self.map.remove(lru)\n        }\n        \n        self.map.insert(key.clone(), value)\n        self.access_order.push(key)\n    }\n}\n\n// Use with any hashable types\nlet cache: Cache<String, User> = Cache::new(100)\ncache.put(\"alice\", alice_user)\n\nlet cache2: Cache<i32, Vec<String>> = Cache::new(50)\ncache2.put(1, vec![\"data\"])",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 7,
          "line_number": 360,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Trait for plugins\ntrait Plugin {\n    fun name(self) -> String\n    fun execute(self, context: Context) -> Result<(), Error>\n}\n\nstruct LogPlugin {\n    level: String\n}\n\nimpl Plugin for LogPlugin {\n    fun name(self) -> String {\n        return \"Logger\"\n    }\n    \n    fun execute(self, context: Context) -> Result<(), Error> {\n        log(self.level, context.message)\n        return Ok(())\n    }\n}\n\n// Store different plugin types\nlet plugins: Vec<Box<dyn Plugin>> = vec![\n    Box::new(LogPlugin{level: \"INFO\"}),\n    Box::new(MetricsPlugin{...}),\n    Box::new(CachePlugin{...})\n]\n\n// Execute all plugins\nfor plugin in plugins {\n    plugin.execute(context)?\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 8,
          "line_number": 405,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Generic builder\nstruct Builder<T> {\n    value: T\n}\n\nimpl<T> Builder<T> {\n    fun new(initial: T) -> Builder<T> {\n        return Builder{value: initial}\n    }\n    \n    fun with<F>(mut self, f: F) -> Builder<T>\n    where F: FnOnce(mut T) -> T\n    {\n        self.value = f(self.value)\n        return self\n    }\n    \n    fun build(self) -> T {\n        return self.value\n    }\n}\n\n// Use with any type\nlet config = Builder::new(Config::default())\n    .with(|c| { c.port = 8080; c })\n    .with(|c| { c.host = \"localhost\"; c })\n    .with(|c| { c.workers = 4; c })\n    .build()\n\nlet user = Builder::new(User::new())\n    .with(|u| { u.name = \"Alice\"; u })\n    .with(|u| { u.role = Role::Admin; u })\n    .build()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 9,
          "line_number": 451,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Associated types pattern\ntrait Graph {\n    type Node\n    type Edge\n    \n    fun nodes(self) -> Vec<Node>\n    fun edges(self) -> Vec<Edge>\n    fun neighbors(self, node: Node) -> Vec<Node>\n}\n\nstruct SocialNetwork {\n    users: Vec<User>\n    connections: Vec<Friendship>\n}\n\nimpl Graph for SocialNetwork {\n    type Node = User\n    type Edge = Friendship\n    \n    fun nodes(self) -> Vec<User> {\n        return self.users\n    }\n    \n    fun edges(self) -> Vec<Friendship> {\n        return self.connections\n    }\n    \n    fun neighbors(self, user: User) -> Vec<User> {\n        self.connections\n            .filter(|f| f.from == user.id || f.to == user.id)\n            .map(|f| self.get_user(f.other_id(user.id)))\n            .collect()\n    }\n}\n\n// Phantom types for compile-time guarantees\nstruct Id<T> {\n    value: String\n    _phantom: PhantomData<T>\n}\n\nimpl<T> Id<T> {\n    fun new(value: String) -> Id<T> {\n        return Id{value, _phantom: PhantomData}\n    }\n}\n\n// Type-safe IDs\nlet user_id: Id<User> = Id::new(\"user_123\")\nlet post_id: Id<Post> = Id::new(\"post_456\")\n\n// Won't compile - type safety!\n// let wrong = user_id == post_id",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 10,
          "line_number": 519,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Generics are monomorphized - no runtime cost\nfun generic_add<T: Add>(a: T, b: T) -> T {\n    return a + b  // Compiles to specific add instruction\n}\n\n// This generates two functions at compile time:\nlet int_result = generic_add(5, 10)      // Generates add_i32\nlet float_result = generic_add(5.0, 10.0) // Generates add_f64\n\n// Trait bounds are checked at compile time\nfun process<T: Send + Sync>(item: T) {\n    // Can safely send to another thread\n    spawn(|| {\n        use_item(item)\n    })\n}\n\n// Inline hints for performance\n#[inline]\nfun hot_path<T: Copy>(x: T) -> T {\n    return x  // Will be inlined\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 11,
          "line_number": 554,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Static dispatch (faster)\nfun static_dispatch<T: Display>(item: T) {\n    println(item)  // Direct call, no indirection\n}\n\n// Dynamic dispatch (flexible)\nfun dynamic_dispatch(item: Box<dyn Display>) {\n    println(item)  // Virtual call through vtable\n}\n\n// Choose based on needs:\n// - Static: Known types, performance critical\n// - Dynamic: Plugin systems, heterogeneous collections",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch03-00-functions-tdd": {
      "chapter": "ch03-00-functions-tdd",
      "total_examples": 9,
      "working_examples": 7,
      "failing_examples": 2,
      "examples": [
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun greet() {\n    println(\"Hello from function!\");\n}\n\nfun main() {\n    greet();\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmp9pvGsv/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn greet () { { println ! (\"Hello from function!\" . to_string ()) } } fn main () { { greet () } }\n  |                                                                                       ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmp9pvGsv/main.rs:1:89\n  |\n1 | use std :: collections :: HashMap ; fn greet () { { println ! (\"Hello from function!\" . to_string ()) } } fn main () { { greet () } }\n  |                                                                ----------------------   ^^^^^^^^^^^^ argument never used\n  |                                                                |\n  |                                                                formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp9pvGsv/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn greet () { { println ! (\"Hello from function!\" . to_string ()) } } fn main () { { greet () } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp9pvGsv/main.rs:1:51\n  |\n1 | use std :: collections :: HashMap ; fn greet () { { println ! (\"Hello from function!\" . to_string ()) } } fn main () { { greet () } }\n  |                                                   ^^                                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn greet () { { println ! (\"Hello from function!\" . to_string ()) } } fn main () { { greet () } }\n1 + use std :: collections :: HashMap ; fn greet () { println ! (\"Hello from function!\" . to_string ()) } fn main () { { greet () } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp9pvGsv/main.rs:1:120\n  |\n1 | use std :: collections :: HashMap ; fn greet () { { println ! (\"Hello from function!\" . to_string ()) } } fn main () { { greet () } }\n  |                                                                                                                        ^^        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn greet () { { println ! (\"Hello from function!\" . to_string ()) } } fn main () { { greet () } }\n1 + use std :: collections :: HashMap ; fn greet () { { println ! (\"Hello from function!\" . to_string ()) } } fn main () { greet () }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmp9pvGsv/main.rs:1:89\n  |\n1 | use std :: collections :: HashMap ; fn greet () { { println ! (\"Hello from function!\" . to_string ()) } } fn main () { { greet () } }\n  |                                                                                         ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 2,
          "line_number": 54,
          "code": "// Status: ✅ WORKING\nfun add(a, b) {\n    a + b\n}\n\nfun main() {\n    let result = add(5, 3);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 3,
          "line_number": 77,
          "code": "// Status: ✅ WORKING\nfun multiply(x: i32, y: i32) -> i32 {\n    x * y\n}\n\nfun main() {\n    let product = multiply(6, 7);\n    println(product);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 4,
          "line_number": 100,
          "code": "// Status: ✅ WORKING\nfun square(n: i32) -> i32 {\n    n * n\n}\n\nfun sum_of_squares(a: i32, b: i32) -> i32 {\n    square(a) + square(b)\n}\n\nfun main() {\n    let result = sum_of_squares(3, 4);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 5,
          "line_number": 127,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfun function_name(parameters) -> return_type {\n    // function body\n    return_expression\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `return_type` in this scope\n --> /tmp/.tmpk7UNiM/main.rs:1:204\n  |\n1 | ...td :: fmt :: Debug + Clone > (parameters : T) -> return_type { { return_expression } } fn main () { }\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `return_expression` in this scope\n --> /tmp/.tmpk7UNiM/main.rs:1:220\n  |\n1 | ...+ Clone > (parameters : T) -> return_type { { return_expression } } fn main () { }\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpk7UNiM/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn function_name < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: f...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpk7UNiM/main.rs:1:218\n  |\n1 | ...mt :: Debug + Clone > (parameters : T) -> return_type { { return_expression } } fn main () { }\n  |                                                            ^^                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn function_name < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (parameters : T) -> return_type { { return_expression } } fn main () { }\n1 + use std :: collections :: HashMap ; fn function_name < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (parameters : T) -> return_type { return_expression } fn main () { }\n  |\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 6,
          "line_number": 166,
          "code": "// Status: ✅ WORKING\nfun calculate(x: i32, y: i32) -> i32 {\n    x * 2 + y * 3\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 7,
          "line_number": 195,
          "code": "// Status: ✅ WORKING\nfun calculate(input: i32) -> i32 {\n    input * 2\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 8,
          "line_number": 205,
          "code": "// Status: ✅ WORKING\nfun combine(a: i32, b: i32, c: i32) -> i32 {\n    a + b + c\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 9,
          "line_number": 215,
          "code": "// Status: ✅ WORKING\nfun helper(x: i32) -> i32 {\n    x * x\n}\n\nfun main_calculation(n: i32) -> i32 {\n    helper(n) + helper(n + 1)\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch11-00-file-operations-tdd": {
      "chapter": "ch11-00-file-operations-tdd",
      "total_examples": 10,
      "working_examples": 2,
      "failing_examples": 8,
      "examples": [
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun read_config() -> i32 {\n    // Simulate reading a config value\n    return 42;\n}\n\nfun write_status(value: i32) -> bool {\n    // Simulate writing status\n    if value > 0 {\n        return true;\n    }\n    return false;\n}\n\nfun main() {\n    let config = read_config();\n    println(\"Config value:\");\n    println(config);\n    \n    let success = write_status(config);\n    println(\"Write success:\");\n    println(success);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpSkR8Wi/main.rs:1:256\n  |\n1 | ... let config = read_config () ; { println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , config) ; let mut success = write_stat...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpSkR8Wi/main.rs:1:258\n  |\n1 | ...et config = read_config () ; { println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , config) ; let mut success = write_status...\n  |                                              ---------------   ^^^^^^^^^^^^ argument never used\n  |                                              |\n  |                                              formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpSkR8Wi/main.rs:1:372\n  |\n1 | ...ccess = write_status (config) ; println ! (\"Write success:\" . to_string ()) ; println ! (\"{}\" , success) } } } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpSkR8Wi/main.rs:1:374\n  |\n1 | ...ess = write_status (config) ; println ! (\"Write success:\" . to_string ()) ; println ! (\"{}\" , success) } } } }\n  |                                             ----------------   ^^^^^^^^^^^^ argument never used\n  |                                             |\n  |                                             formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpSkR8Wi/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn read_config () -> i32 { { return 42i32 } } fn write_status (value : i32) -> bool { { if value > 0i...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpSkR8Wi/main.rs:1:64\n  |\n1 | use std :: collections :: HashMap ; fn read_config () -> i32 { { return 42i32 } } fn write_status (value : i32) -> bool { { if value > 0i...\n  |                                                                ^^            ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn read_config () -> i32 { { return 42i32 } } fn write_status (value : i32) -> bool { { if value > 0i32 { { return true } } ; return false } } fn main () { { { let config = read_config () ; { println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , config) ; let mut success = write_status (config) ; println ! (\"Write success:\" . to_string ()) ; println ! (\"{}\" , success) } } } }\n1 + use std :: collections :: HashMap ; fn read_config () -> i32 { return 42i32 } fn write_status (value : i32) -> bool { { if value > 0i32 { { return true } } ; return false } } fn main () { { { let config = read_config () ; { println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , config) ; let mut success = write_status (config) ; println ! (\"Write success:\" . to_string ()) ; println ! (\"{}\" , success) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpSkR8Wi/main.rs:1:143\n  |\n1 | ...n write_status (value : i32) -> bool { { if value > 0i32 { { return true } } ; return false } } fn main () { { { let config = read_con...\n  |                                                               ^^           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn read_config () -> i32 { { return 42i32 } } fn write_status (value : i32) -> bool { { if value > 0i32 { { return true } } ; return false } } fn main () { { { let config = read_config () ; { println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , config) ; let mut success = write_status (config) ; println ! (\"Write success:\" . to_string ()) ; println ! (\"{}\" , success) } } } }\n1 + use std :: collections :: HashMap ; fn read_config () -> i32 { { return 42i32 } } fn write_status (value : i32) -> bool { { if value > 0i32 { return true } ; return false } } fn main () { { { let config = read_config () ; { println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , config) ; let mut success = write_status (config) ; println ! (\"Write success:\" . to_string ()) ; println ! (\"{}\" , success) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpSkR8Wi/main.rs:1:193\n  |\n1 | ... { { { let config = read_config () ; { println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , config) ; let mut success = write_status (config) ; println ! (\"Write success:\" . to_string ()) ; println ! (\"{}\" , success) } } } }\n  |       ^^                                                                                                                                                                                                                                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn read_config () -> i32 { { return 42i32 } } fn write_status (value : i32) -> bool { { if value > 0i32 { { return true } } ; return false } } fn main () { { { let config = read_config () ; { println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , config) ; let mut success = write_status (config) ; println ! (\"Write success:\" . to_string ()) ; println ! (\"{}\" , success) } } } }\n1 + use std :: collections :: HashMap ; fn read_config () -> i32 { { return 42i32 } } fn write_status (value : i32) -> bool { { if value > 0i32 { { return true } } ; return false } } fn main () { { let config = read_config () ; { println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , config) ; let mut success = write_status (config) ; println ! (\"Write success:\" . to_string ()) ; println ! (\"{}\" , success) } } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpSkR8Wi/main.rs:1:258\n  |\n1 | ...= read_config () ; { println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , config) ; let mut success = write_status (config) ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpSkR8Wi/main.rs:1:374\n  |\n1 | ...e_status (config) ; println ! (\"Write success:\" . to_string ()) ; println ! (\"{}\" , success) } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 2,
          "line_number": 72,
          "code": "// Status: ✅ WORKING\nfun save_game_state(level: i32, score: i32) {\n    println(\"Saving game state...\");\n    println(\"Level:\");\n    println(level);\n    println(\"Score:\");\n    println(score);\n    println(\"State saved successfully\");\n}\n\nfun load_game_state() {\n    println(\"Loading game state...\");\n    println(\"Level: 5\");\n    println(\"Score: 1000\");\n    println(\"State loaded successfully\");\n}\n\nfun main() {\n    save_game_state(5, 1000);\n    println(\"---\");\n    load_game_state();\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpaLDMJT/main.rs:1:122\n  |\n1 | ... : i32 , score : i32) { { println ! (\"Saving game state...\" . to_string ()) ; println ! (\"Level:\" . to_string ()) ; println ! (\"{}\" , ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpaLDMJT/main.rs:1:124\n  |\n1 | ...l : i32 , score : i32) { { println ! (\"Saving game state...\" . to_string ()) ; println ! (\"Level:\" . to_string ()) ; println ! (\"{}\" ,...\n  |                                          ----------------------   ^^^^^^^^^^^^ argument never used\n  |                                          |\n  |                                          formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpaLDMJT/main.rs:1:160\n  |\n1 | ...Saving game state...\" . to_string ()) ; println ! (\"Level:\" . to_string ()) ; println ! (\"{}\" , level) ; println ! (\"Score:\" . to_stri...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpaLDMJT/main.rs:1:162\n  |\n1 | ... game state...\" . to_string ()) ; println ! (\"Level:\" . to_string ()) ; println ! (\"{}\" , level) ; println ! (\"Score:\" . to_string ())...\n  |                                                 --------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpaLDMJT/main.rs:1:225\n  |\n1 | ...string ()) ; println ! (\"{}\" , level) ; println ! (\"Score:\" . to_string ()) ; println ! (\"{}\" , score) ; println ! (\"State saved succe...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpaLDMJT/main.rs:1:227\n  |\n1 | ... ()) ; println ! (\"{}\" , level) ; println ! (\"Score:\" . to_string ()) ; println ! (\"{}\" , score) ; println ! (\"State saved successfull...\n  |                                                 --------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpaLDMJT/main.rs:1:308\n  |\n1 | ...ln ! (\"{}\" , score) ; println ! (\"State saved successfully\" . to_string ()) } } fn load_game_state () { { println ! (\"Loading game sta...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpaLDMJT/main.rs:1:310\n  |\n1 | ...intln ! (\"{}\" , score) ; println ! (\"State saved successfully\" . to_string ()) } } fn load_game_state () { { println ! (\"Loading game ...\n  |                                        --------------------------   ^^^^^^^^^^^^ argument never used\n  |                                        |\n  |                                        formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpaLDMJT/main.rs:1:389\n  |\n1 | ...n load_game_state () { { println ! (\"Loading game state...\" . to_string ()) ; println ! (\"Level: 5\" . to_string ()) ; println ! (\"Scor...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpaLDMJT/main.rs:1:391\n  |\n1 | ... fn load_game_state () { { println ! (\"Loading game state...\" . to_string ()) ; println ! (\"Level: 5\" . to_string ()) ; println ! (\"Sc...\n  |                                          -----------------------   ^^^^^^^^^^^^ argument never used\n  |                                          |\n  |                                          formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpaLDMJT/main.rs:1:429\n  |\n1 | ...ding game state...\" . to_string ()) ; println ! (\"Level: 5\" . to_string ()) ; println ! (\"Score: 1000\" . to_string ()) ; println ! (\"S...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpaLDMJT/main.rs:1:431\n  |\n1 | ...game state...\" . to_string ()) ; println ! (\"Level: 5\" . to_string ()) ; println ! (\"Score: 1000\" . to_string ()) ; println ! (\"State ...\n  |                                                ----------   ^^^^^^^^^^^^ argument never used\n  |                                                |\n  |                                                formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpaLDMJT/main.rs:1:472\n  |\n1 | ...ln ! (\"Level: 5\" . to_string ()) ; println ! (\"Score: 1000\" . to_string ()) ; println ! (\"State loaded successfully\" . to_string ()) }...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpaLDMJT/main.rs:1:474\n  |\n1 | ...! (\"Level: 5\" . to_string ()) ; println ! (\"Score: 1000\" . to_string ()) ; println ! (\"State loaded successfully\" . to_string ()) } } ...\n  |                                               -------------   ^^^^^^^^^^^^ argument never used\n  |                                               |\n  |                                               formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpaLDMJT/main.rs:1:529\n  |\n1 | ...0\" . to_string ()) ; println ! (\"State loaded successfully\" . to_string ()) } } fn main () { { save_game_state (5i32 , 1000i32) ; prin...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpaLDMJT/main.rs:1:531\n  |\n1 | ... 1000\" . to_string ()) ; println ! (\"State loaded successfully\" . to_string ()) } } fn main () { { save_game_state (5i32 , 1000i32) ; ...\n  |                                        ---------------------------   ^^^^^^^^^^^^ argument never used\n  |                                        |\n  |                                        formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpaLDMJT/main.rs:1:616\n  |\n1 | ... () { { save_game_state (5i32 , 1000i32) ; println ! (\"---\" . to_string ()) ; load_game_state () } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpaLDMJT/main.rs:1:618\n  |\n1 | ... save_game_state (5i32 , 1000i32) ; println ! (\"---\" . to_string ()) ; load_game_state () } }\n  |                                                   -----   ^^^^^^^^^^^^ argument never used\n  |                                                   |\n  |                                                   formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpaLDMJT/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn save_game_state (level : i32 , score : i32) { { println ! (\"Saving game state...\" . to_string ()) ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpaLDMJT/main.rs:1:124\n  |\n1 | ...re : i32) { { println ! (\"Saving game state...\" . to_string ()) ; println ! (\"Level:\" . to_string ()) ; println ! (\"{}\" , level) ; pri...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpaLDMJT/main.rs:1:162\n  |\n1 | ...state...\" . to_string ()) ; println ! (\"Level:\" . to_string ()) ; println ! (\"{}\" , level) ; println ! (\"Score:\" . to_string ()) ; pri...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpaLDMJT/main.rs:1:227\n  |\n1 | ... println ! (\"{}\" , level) ; println ! (\"Score:\" . to_string ()) ; println ! (\"{}\" , score) ; println ! (\"State saved successfully\" . t...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpaLDMJT/main.rs:1:310\n  |\n1 | ... score) ; println ! (\"State saved successfully\" . to_string ()) } } fn load_game_state () { { println ! (\"Loading game state...\" . to_...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpaLDMJT/main.rs:1:391\n  |\n1 | ...state () { { println ! (\"Loading game state...\" . to_string ()) ; println ! (\"Level: 5\" . to_string ()) ; println ! (\"Score: 1000\" . t...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpaLDMJT/main.rs:1:431\n  |\n1 | ...ate...\" . to_string ()) ; println ! (\"Level: 5\" . to_string ()) ; println ! (\"Score: 1000\" . to_string ()) ; println ! (\"State loaded ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpaLDMJT/main.rs:1:474\n  |\n1 | ...: 5\" . to_string ()) ; println ! (\"Score: 1000\" . to_string ()) ; println ! (\"State loaded successfully\" . to_string ()) } } fn main (...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpaLDMJT/main.rs:1:531\n  |\n1 | ...ng ()) ; println ! (\"State loaded successfully\" . to_string ()) } } fn main () { { save_game_state (5i32 , 1000i32) ; println ! (\"---\"...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpaLDMJT/main.rs:1:618\n  |\n1 | ..._game_state (5i32 , 1000i32) ; println ! (\"---\" . to_string ()) ; load_game_state () } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 27 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 3,
          "line_number": 118,
          "code": "// Status: ✅ WORKING\nfun get_default_config() -> i32 {\n    return 100;\n}\n\nfun validate_config(value: i32) -> bool {\n    if value > 0 && value <= 1000 {\n        return true;\n    }\n    return false;\n}\n\nfun apply_config(value: i32) {\n    println(\"Applying configuration...\");\n    println(\"Config value:\");\n    println(value);\n    if validate_config(value) {\n        println(\"Configuration applied successfully\");\n    } else {\n        println(\"Invalid configuration\");\n    }\n}\n\nfun main() {\n    let config = get_default_config();\n    apply_config(config);\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpmrOd45/main.rs:1:284\n  |\n1 | ...ig (value : i32) { { println ! (\"Applying configuration...\" . to_string ()) ; println ! (\"Config value:\" . to_string ()) ; println ! (...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpmrOd45/main.rs:1:286\n  |\n1 | ...config (value : i32) { { println ! (\"Applying configuration...\" . to_string ()) ; println ! (\"Config value:\" . to_string ()) ; println...\n  |                                        ---------------------------   ^^^^^^^^^^^^ argument never used\n  |                                        |\n  |                                        formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpmrOd45/main.rs:1:329\n  |\n1 | ...figuration...\" . to_string ()) ; println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , value) ; if validate_config (value) { ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpmrOd45/main.rs:1:331\n  |\n1 | ...guration...\" . to_string ()) ; println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , value) ; if validate_config (value) { { ...\n  |                                              ---------------   ^^^^^^^^^^^^ argument never used\n  |                                              |\n  |                                              formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpmrOd45/main.rs:1:453\n  |\n1 | ...(value) { { println ! (\"Configuration applied successfully\" . to_string ()) } } else { { println ! (\"Invalid configuration\" . to_strin...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpmrOd45/main.rs:1:455\n  |\n1 | ..._config (value) { { println ! (\"Configuration applied successfully\" . to_string ()) } } else { { println ! (\"Invalid configuration\" . ...\n  |                                   ------------------------------------   ^^^^^^^^^^^^ argument never used\n  |                                   |\n  |                                   formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpmrOd45/main.rs:1:517\n  |\n1 | ..._string ()) } } else { { println ! (\"Invalid configuration\" . to_string ()) } } } } fn main () { { { let config = get_default_config (...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpmrOd45/main.rs:1:519\n  |\n1 | ...to_string ()) } } else { { println ! (\"Invalid configuration\" . to_string ()) } } } } fn main () { { { let config = get_default_config...\n  |                                          -----------------------   ^^^^^^^^^^^^ argument never used\n  |                                          |\n  |                                          formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpmrOd45/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpmrOd45/main.rs:1:71\n  |\n1 | use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if...\n  |                                                                       ^^             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! (\"Applying configuration...\" . to_string ()) ; println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\" . to_string ()) } } else { { println ! (\"Invalid configuration\" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { return 100i32 } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! (\"Applying configuration...\" . to_string ()) ; println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\" . to_string ()) } } else { { println ! (\"Invalid configuration\" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpmrOd45/main.rs:1:174\n  |\n1 | ...e : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { prin...\n  |                                                               ^^           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! (\"Applying configuration...\" . to_string ()) ; println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\" . to_string ()) } } else { { println ! (\"Invalid configuration\" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { return true } ; return false } } fn apply_config (value : i32) { { println ! (\"Applying configuration...\" . to_string ()) ; println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\" . to_string ()) } } else { { println ! (\"Invalid configuration\" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpmrOd45/main.rs:1:403\n  |\n1 | ...) ; if validate_config (value) { { println ! (\"Configuration applied successfully\" . to_string ()) } } else { { println ! (\"Invalid co...\n  |                                     ^^                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! (\"Applying configuration...\" . to_string ()) ; println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\" . to_string ()) } } else { { println ! (\"Invalid configuration\" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! (\"Applying configuration...\" . to_string ()) ; println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , value) ; if validate_config (value) { println ! (\"Configuration applied successfully\" . to_string ()) } else { { println ! (\"Invalid configuration\" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpmrOd45/main.rs:1:480\n  |\n1 | ...uccessfully\" . to_string ()) } } else { { println ! (\"Invalid configuration\" . to_string ()) } } } } fn main () { { { let config = get...\n  |                                            ^^                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! (\"Applying configuration...\" . to_string ()) ; println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\" . to_string ()) } } else { { println ! (\"Invalid configuration\" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! (\"Applying configuration...\" . to_string ()) ; println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\" . to_string ()) } } else { println ! (\"Invalid configuration\" . to_string ()) } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpmrOd45/main.rs:1:554\n  |\n1 | ...o_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n  |                                      ^^                                                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! (\"Applying configuration...\" . to_string ()) ; println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\" . to_string ()) } } else { { println ! (\"Invalid configuration\" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) { { println ! (\"Applying configuration...\" . to_string ()) ; println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\" . to_string ()) } } else { { println ! (\"Invalid configuration\" . to_string ()) } } } } fn main () { { let config = get_default_config () ; apply_config (config) } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpmrOd45/main.rs:1:286\n  |\n1 | ...i32) { { println ! (\"Applying configuration...\" . to_string ()) ; println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , value...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpmrOd45/main.rs:1:331\n  |\n1 | ....\" . to_string ()) ; println ! (\"Config value:\" . to_string ()) ; println ! (\"{}\" , value) ; if validate_config (value) { { println ! ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpmrOd45/main.rs:1:455\n  |\n1 | ...println ! (\"Configuration applied successfully\" . to_string ()) } } else { { println ! (\"Invalid configuration\" . to_string ()) } } } ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpmrOd45/main.rs:1:519\n  |\n1 | ...} } else { { println ! (\"Invalid configuration\" . to_string ()) } } } } fn main () { { { let config = get_default_config () ; apply_co...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 12 previous errors; 6 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 4,
          "line_number": 181,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfun read_data() -> DataType {\n    // Return simulated data\n    return default_value;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `DataType` in this scope\n --> /tmp/.tmpKrvGIN/main.rs:1:56\n  |\n1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n  |                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `default_value` in this scope\n --> /tmp/.tmpKrvGIN/main.rs:1:76\n  |\n1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n  |                                                                            ^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpKrvGIN/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpKrvGIN/main.rs:1:67\n  |\n1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n  |                                                                   ^^                    ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n1 + use std :: collections :: HashMap ; fn read_data () -> DataType { return default_value } fn main () { }\n  |\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 5,
          "line_number": 193,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfun write_data(value: DataType) -> bool {\n    // Validate and \"write\"\n    if valid(value) {\n        return true;\n    }\n    return false;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `DataType` in this scope\n --> /tmp/.tmpff0YXm/main.rs:1:60\n  |\n1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...\n  |                                                            ^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpff0YXm/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpff0YXm/main.rs:1:101\n  |\n1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...\n  |                                                                                                     ^^           ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } fn main () { }\n1 + use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { return true } ; return false } } fn main () { }\n  |\n\nerror[E0425]: cannot find function `valid` in this scope\n --> /tmp/.tmpff0YXm/main.rs:1:85\n  |\n1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...\n  |                                                                                     ^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 6,
          "line_number": 208,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfun load_config() -> ConfigType {\n    return default_config;\n}\n\nfun save_config(config: ConfigType) -> bool {\n    return validate(config);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `ConfigType` in this scope\n --> /tmp/.tmpq3LaC3/main.rs:1:58\n  |\n1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...\n  |                                                          ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `default_config` in this scope\n --> /tmp/.tmpq3LaC3/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...\n  |                                                                                ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `ConfigType` in this scope\n --> /tmp/.tmpq3LaC3/main.rs:1:124\n  |\n1 | ...eturn default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpq3LaC3/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpq3LaC3/main.rs:1:71\n  |\n1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...\n  |                                                                       ^^                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { return default_config } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpq3LaC3/main.rs:1:146\n  |\n1 | ...g } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n  |                                                         ^^                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { return validate (config) } fn main () { }\n  |\n\nerror[E0425]: cannot find function `validate` in this scope\n --> /tmp/.tmpq3LaC3/main.rs:1:155\n  |\n1 | ...ve_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 7,
          "line_number": 237,
          "code": "// Status: ✅ WORKING\nfun load_settings() -> i32 {\n    return 50; // Default volume\n}\n\nfun save_settings(volume: i32) -> bool {\n    return volume >= 0 && volume <= 100;\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 8,
          "line_number": 251,
          "code": "// Status: ✅ WORKING\nfun save_progress(level: i32, score: i32) {\n    println(\"Saving progress...\");\n    println(level);\n    println(score);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpJ9gLO4/main.rs:1:118\n  |\n1 | use std :: collections :: HashMap ; fn save_progress (level : i32 , score : i32) { { println ! (\"Saving progress...\" . to_string ()) ; pr...\n  |                                                                                                                      ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpJ9gLO4/main.rs:1:120\n  |\n1 | ...el : i32 , score : i32) { { println ! (\"Saving progress...\" . to_string ()) ; println ! (\"{}\" , level) ; println ! (\"{}\" , score) } } ...\n  |                                           --------------------   ^^^^^^^^^^^^ argument never used\n  |                                           |\n  |                                           formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpJ9gLO4/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn save_progress (level : i32 , score : i32) { { println ! (\"Saving progress...\" . to_string ()) ; pr...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpJ9gLO4/main.rs:1:120\n  |\n1 | ...core : i32) { { println ! (\"Saving progress...\" . to_string ()) ; println ! (\"{}\" , level) ; println ! (\"{}\" , score) } } fn main () { }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 9,
          "line_number": 263,
          "code": "// Status: ✅ WORKING\nfun get_cached_value(key: i32) -> i32 {\n    // Simulate cache lookup\n    if key == 1 {\n        return 100;\n    }\n    return 0;\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 10,
          "line_number": 277,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun log_event(message: &str, severity: i32) {\n    println(\"LOG:\");\n    println(message);\n    println(\"Severity:\");\n    println(severity);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch05-00-control-flow-tdd": {
      "chapter": "ch05-00-control-flow-tdd",
      "total_examples": 14,
      "working_examples": 1,
      "failing_examples": 13,
      "examples": [
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let x = 10;\n    if x > 5 {\n        println(\"x is greater than 5\");\n    } else {\n        println(\"x is not greater than 5\");\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpgEjcMk/main.rs:1:119\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let x = 10i32 ; if x > 5i32 { { println ! (\"x is greater than 5\" . to_string ()) } }...\n  |                                                                                                                       ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpgEjcMk/main.rs:1:121\n  |\n1 | ...x = 10i32 ; if x > 5i32 { { println ! (\"x is greater than 5\" . to_string ()) } } else { { println ! (\"x is not greater than 5\" . to_st...\n  |                                           ---------------------   ^^^^^^^^^^^^ argument never used\n  |                                           |\n  |                                           formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpgEjcMk/main.rs:1:185\n  |\n1 | ...tring ()) } } else { { println ! (\"x is not greater than 5\" . to_string ()) } } } } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpgEjcMk/main.rs:1:187\n  |\n1 | ...o_string ()) } } else { { println ! (\"x is not greater than 5\" . to_string ()) } } } } }\n  |                                         -------------------------   ^^^^^^^^^^^^ argument never used\n  |                                         |\n  |                                         formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpgEjcMk/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let x = 10i32 ; if x > 5i32 { { println ! (\"x is greater than 5\" . to_string ()) } }...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpgEjcMk/main.rs:1:50\n  |\n1 | ... { { { let x = 10i32 ; if x > 5i32 { { println ! (\"x is greater than 5\" . to_string ()) } } else { { println ! (\"x is not greater than 5\" . to_string ()) } } } } }\n  |       ^^                                                                                                                                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let x = 10i32 ; if x > 5i32 { { println ! (\"x is greater than 5\" . to_string ()) } } else { { println ! (\"x is not greater than 5\" . to_string ()) } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let x = 10i32 ; if x > 5i32 { { println ! (\"x is greater than 5\" . to_string ()) } } else { { println ! (\"x is not greater than 5\" . to_string ()) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpgEjcMk/main.rs:1:84\n  |\n1 | ...n () { { { let x = 10i32 ; if x > 5i32 { { println ! (\"x is greater than 5\" . to_string ()) } } else { { println ! (\"x is not greater ...\n  |                                             ^^                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let x = 10i32 ; if x > 5i32 { { println ! (\"x is greater than 5\" . to_string ()) } } else { { println ! (\"x is not greater than 5\" . to_string ()) } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let x = 10i32 ; if x > 5i32 { println ! (\"x is greater than 5\" . to_string ()) } else { { println ! (\"x is not greater than 5\" . to_string ()) } } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpgEjcMk/main.rs:1:146\n  |\n1 | ...ter than 5\" . to_string ()) } } else { { println ! (\"x is not greater than 5\" . to_string ()) } } } } }\n  |                                           ^^                                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let x = 10i32 ; if x > 5i32 { { println ! (\"x is greater than 5\" . to_string ()) } } else { { println ! (\"x is not greater than 5\" . to_string ()) } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let x = 10i32 ; if x > 5i32 { { println ! (\"x is greater than 5\" . to_string ()) } } else { println ! (\"x is not greater than 5\" . to_string ()) } } } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpgEjcMk/main.rs:1:121\n  |\n1 | ...f x > 5i32 { { println ! (\"x is greater than 5\" . to_string ()) } } else { { println ! (\"x is not greater than 5\" . to_string ()) } } ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpgEjcMk/main.rs:1:187\n  |\n1 | ...} else { { println ! (\"x is not greater than 5\" . to_string ()) } } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 2,
          "line_number": 55,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let score = 85;\n    if score >= 80 {\n        println(\"Great job!\");\n    }\n    println(\"Score processed\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpDGTXGL/main.rs:1:122\n  |\n1 | ...e = 85i32 ; { if score >= 80i32 { { println ! (\"Great job!\" . to_string ()) } } ; println ! (\"Score processed\" . to_string ()) } } } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpDGTXGL/main.rs:1:124\n  |\n1 | ...85i32 ; { if score >= 80i32 { { println ! (\"Great job!\" . to_string ()) } } ; println ! (\"Score processed\" . to_string ()) } } } }\n  |                                               ------------   ^^^^^^^^^^^^ argument never used\n  |                                               |\n  |                                               formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpDGTXGL/main.rs:1:173\n  |\n1 | ...at job!\" . to_string ()) } } ; println ! (\"Score processed\" . to_string ()) } } } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpDGTXGL/main.rs:1:175\n  |\n1 | ...t job!\" . to_string ()) } } ; println ! (\"Score processed\" . to_string ()) } } } }\n  |                                             -----------------   ^^^^^^^^^^^^ argument never used\n  |                                             |\n  |                                             formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpDGTXGL/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let score = 85i32 ; { if score >= 80i32 { { println ! (\"Great job!\" . to_string ()) ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpDGTXGL/main.rs:1:50\n  |\n1 | ... { { { let score = 85i32 ; { if score >= 80i32 { { println ! (\"Great job!\" . to_string ()) } } ; println ! (\"Score processed\" . to_string ()) } } } }\n  |       ^^                                                                                                                                            ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let score = 85i32 ; { if score >= 80i32 { { println ! (\"Great job!\" . to_string ()) } } ; println ! (\"Score processed\" . to_string ()) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let score = 85i32 ; { if score >= 80i32 { { println ! (\"Great job!\" . to_string ()) } } ; println ! (\"Score processed\" . to_string ()) } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpDGTXGL/main.rs:1:96\n  |\n1 | ... { let score = 85i32 ; { if score >= 80i32 { { println ! (\"Great job!\" . to_string ()) } } ; println ! (\"Score processed\" . to_string ...\n  |                                                 ^^                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let score = 85i32 ; { if score >= 80i32 { { println ! (\"Great job!\" . to_string ()) } } ; println ! (\"Score processed\" . to_string ()) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let score = 85i32 ; { if score >= 80i32 { println ! (\"Great job!\" . to_string ()) } ; println ! (\"Score processed\" . to_string ()) } } } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpDGTXGL/main.rs:1:124\n  |\n1 | ...{ if score >= 80i32 { { println ! (\"Great job!\" . to_string ()) } } ; println ! (\"Score processed\" . to_string ()) } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpDGTXGL/main.rs:1:175\n  |\n1 | ...o_string ()) } } ; println ! (\"Score processed\" . to_string ()) } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 3,
          "line_number": 78,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let grade = 75;\n    if grade >= 90 {\n        println(\"A grade\");\n    } else if grade >= 80 {\n        println(\"B grade\");\n    } else if grade >= 70 {\n        println(\"C grade\");\n    } else {\n        println(\"Below C\");\n    }\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpbFqMeD/main.rs:1:117\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! (\"A grade\" . to_string ()) } } e...\n  |                                                                                                                     ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpbFqMeD/main.rs:1:119\n  |\n1 | ...e = 75i32 ; if grade >= 90i32 { { println ! (\"A grade\" . to_string ()) } } else { if grade >= 80i32 { { println ! (\"B grade\" . to_stri...\n  |                                                 ---------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpbFqMeD/main.rs:1:187\n  |\n1 | ...g ()) } } else { if grade >= 80i32 { { println ! (\"B grade\" . to_string ()) } } else { if grade >= 70i32 { { println ! (\"C grade\" . to...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpbFqMeD/main.rs:1:189\n  |\n1 | ... } } else { if grade >= 80i32 { { println ! (\"B grade\" . to_string ()) } } else { if grade >= 70i32 { { println ! (\"C grade\" . to_stri...\n  |                                                 ---------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpbFqMeD/main.rs:1:257\n  |\n1 | ...g ()) } } else { if grade >= 70i32 { { println ! (\"C grade\" . to_string ()) } } else { { println ! (\"Below C\" . to_string ()) } } } } ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpbFqMeD/main.rs:1:259\n  |\n1 | ... } } else { if grade >= 70i32 { { println ! (\"C grade\" . to_string ()) } } else { { println ! (\"Below C\" . to_string ()) } } } } } } }\n  |                                                 ---------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpbFqMeD/main.rs:1:307\n  |\n1 | ...\"C grade\" . to_string ()) } } else { { println ! (\"Below C\" . to_string ()) } } } } } } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpbFqMeD/main.rs:1:309\n  |\n1 | ...ade\" . to_string ()) } } else { { println ! (\"Below C\" . to_string ()) } } } } } } }\n  |                                                 ---------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpbFqMeD/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! (\"A grade\" . to_string ()) } } e...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpbFqMeD/main.rs:1:50\n  |\n1 | ... { { { let grade = 75i32 ; if grade >= 90i32 { { println ! (\"A grade\" . to_string ()) } } else { if grade >= 80i32 { { println ! (\"B grade\" . to_string ()) } } else { if grade >= 70i32 { { println ! (\"C grade\" . to_string ()) } } else { { println ! (\"Below C\" . to_string ()) } } } } } } }\n  |       ^^                                                                                                                                                                                                                                                                                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! (\"A grade\" . to_string ()) } } else { if grade >= 80i32 { { println ! (\"B grade\" . to_string ()) } } else { if grade >= 70i32 { { println ! (\"C grade\" . to_string ()) } } else { { println ! (\"Below C\" . to_string ()) } } } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let grade = 75i32 ; if grade >= 90i32 { { println ! (\"A grade\" . to_string ()) } } else { if grade >= 80i32 { { println ! (\"B grade\" . to_string ()) } } else { if grade >= 70i32 { { println ! (\"C grade\" . to_string ()) } } else { { println ! (\"Below C\" . to_string ()) } } } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpbFqMeD/main.rs:1:94\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! (\"A grade\" . to_string ()) } } e...\n  |                                                                                              ^^                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! (\"A grade\" . to_string ()) } } else { if grade >= 80i32 { { println ! (\"B grade\" . to_string ()) } } else { if grade >= 70i32 { { println ! (\"C grade\" . to_string ()) } } else { { println ! (\"Below C\" . to_string ()) } } } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { println ! (\"A grade\" . to_string ()) } else { if grade >= 80i32 { { println ! (\"B grade\" . to_string ()) } } else { if grade >= 70i32 { { println ! (\"C grade\" . to_string ()) } } else { { println ! (\"Below C\" . to_string ()) } } } } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpbFqMeD/main.rs:1:164\n  |\n1 | .... to_string ()) } } else { if grade >= 80i32 { { println ! (\"B grade\" . to_string ()) } } else { if grade >= 70i32 { { println ! (\"C g...\n  |                                                   ^^                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! (\"A grade\" . to_string ()) } } else { if grade >= 80i32 { { println ! (\"B grade\" . to_string ()) } } else { if grade >= 70i32 { { println ! (\"C grade\" . to_string ()) } } else { { println ! (\"Below C\" . to_string ()) } } } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! (\"A grade\" . to_string ()) } } else { if grade >= 80i32 { println ! (\"B grade\" . to_string ()) } else { if grade >= 70i32 { { println ! (\"C grade\" . to_string ()) } } else { { println ! (\"Below C\" . to_string ()) } } } } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpbFqMeD/main.rs:1:234\n  |\n1 | .... to_string ()) } } else { if grade >= 70i32 { { println ! (\"C grade\" . to_string ()) } } else { { println ! (\"Below C\" . to_string ()...\n  |                                                   ^^                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! (\"A grade\" . to_string ()) } } else { if grade >= 80i32 { { println ! (\"B grade\" . to_string ()) } } else { if grade >= 70i32 { { println ! (\"C grade\" . to_string ()) } } else { { println ! (\"Below C\" . to_string ()) } } } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! (\"A grade\" . to_string ()) } } else { if grade >= 80i32 { { println ! (\"B grade\" . to_string ()) } } else { if grade >= 70i32 { println ! (\"C grade\" . to_string ()) } else { { println ! (\"Below C\" . to_string ()) } } } } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpbFqMeD/main.rs:1:284\n  |\n1 | ...rintln ! (\"C grade\" . to_string ()) } } else { { println ! (\"Below C\" . to_string ()) } } } } } } }\n  |                                                   ^^                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! (\"A grade\" . to_string ()) } } else { if grade >= 80i32 { { println ! (\"B grade\" . to_string ()) } } else { if grade >= 70i32 { { println ! (\"C grade\" . to_string ()) } } else { { println ! (\"Below C\" . to_string ()) } } } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let grade = 75i32 ; if grade >= 90i32 { { println ! (\"A grade\" . to_string ()) } } else { if grade >= 80i32 { { println ! (\"B grade\" . to_string ()) } } else { if grade >= 70i32 { { println ! (\"C grade\" . to_string ()) } } else { println ! (\"Below C\" . to_string ()) } } } } } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpbFqMeD/main.rs:1:119\n  |\n1 | ...32 ; if grade >= 90i32 { { println ! (\"A grade\" . to_string ()) } } else { if grade >= 80i32 { { println ! (\"B grade\" . to_string ()) ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpbFqMeD/main.rs:1:189\n  |\n1 | ...se { if grade >= 80i32 { { println ! (\"B grade\" . to_string ()) } } else { if grade >= 70i32 { { println ! (\"C grade\" . to_string ()) ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpbFqMeD/main.rs:1:259\n  |\n1 | ...se { if grade >= 70i32 { { println ! (\"C grade\" . to_string ()) } } else { { println ! (\"Below C\" . to_string ()) } } } } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpbFqMeD/main.rs:1:309\n  |\n1 | ...to_string ()) } } else { { println ! (\"Below C\" . to_string ()) } } } } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 12 previous errors; 6 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 4,
          "line_number": 105,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let mut i = 0;\n    while i < 3 {\n        println(i);\n        i = i + 1;\n    }\n    println(\"Done\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpDUdhgT/main.rs:1:150\n  |\n1 | ...println ! (\"{}\" , i) ; i = i + 1i32 } } ; println ! (\"Done\" . to_string ()) } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpDUdhgT/main.rs:1:152\n  |\n1 | ... ! (\"{}\" , i) ; i = i + 1i32 } } ; println ! (\"Done\" . to_string ()) } }\n  |                                                  ------   ^^^^^^^^^^^^ argument never used\n  |                                                  |\n  |                                                  formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpDUdhgT/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { let mut i = 0i32 ; while i < 3i32 { { println ! (\"{}\" , i) ; i = i + 1i32 } } ; printl...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpDUdhgT/main.rs:1:152\n  |\n1 | ...{}\" , i) ; i = i + 1i32 } } ; println ! (\"Done\" . to_string ()) } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 5,
          "line_number": 131,
          "code": "// Status: ✅ WORKING\nfun main() {\n    for i in 0..3 {\n        println(i);\n    }\n    println(\"For loop done\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpDULVQK/main.rs:1:132\n  |\n1 | ...2 { { println ! (\"{}\" , i) } } ; println ! (\"For loop done\" . to_string ()) } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpDULVQK/main.rs:1:134\n  |\n1 | ...{ { println ! (\"{}\" , i) } } ; println ! (\"For loop done\" . to_string ()) } }\n  |                                              ---------------   ^^^^^^^^^^^^ argument never used\n  |                                              |\n  |                                              formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpDULVQK/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { for i in 0i32 .. 3i32 { { println ! (\"{}\" , i) } } ; println ! (\"For loop done\" . to_s...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpDULVQK/main.rs:1:76\n  |\n1 | use std :: collections :: HashMap ; fn main () { { for i in 0i32 .. 3i32 { { println ! (\"{}\" , i) } } ; println ! (\"For loop done\" . to_s...\n  |                                                                            ^^                    ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { for i in 0i32 .. 3i32 { { println ! (\"{}\" , i) } } ; println ! (\"For loop done\" . to_string ()) } }\n1 + use std :: collections :: HashMap ; fn main () { { for i in 0i32 .. 3i32 { println ! (\"{}\" , i) } ; println ! (\"For loop done\" . to_string ()) } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpDULVQK/main.rs:1:134\n  |\n1 | ...n ! (\"{}\" , i) } } ; println ! (\"For loop done\" . to_string ()) } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 6,
          "line_number": 155,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let number = 2;\n    match number {\n        1 => println(\"One\"),\n        2 => println(\"Two\"),\n        3 => println(\"Three\"),\n        _ => println(\"Other\")\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpxdWlgO/main.rs:1:114\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let number = 2i32 ; match number { 1i32 => println ! (\"One\" . to_string ()) , 2i32 =...\n  |                                                                                                                  ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpxdWlgO/main.rs:1:116\n  |\n1 | ...ber = 2i32 ; match number { 1i32 => println ! (\"One\" . to_string ()) , 2i32 => println ! (\"Two\" . to_string ()) , 3i32 => println ! (\"...\n  |                                                   -----   ^^^^^^^^^^^^ argument never used\n  |                                                   |\n  |                                                   formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpxdWlgO/main.rs:1:157\n  |\n1 | ...println ! (\"One\" . to_string ()) , 2i32 => println ! (\"Two\" . to_string ()) , 3i32 => println ! (\"Three\" . to_string ()) , _ => printl...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpxdWlgO/main.rs:1:159\n  |\n1 | ... ! (\"One\" . to_string ()) , 2i32 => println ! (\"Two\" . to_string ()) , 3i32 => println ! (\"Three\" . to_string ()) , _ => println ! (\"O...\n  |                                                   -----   ^^^^^^^^^^^^ argument never used\n  |                                                   |\n  |                                                   formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpxdWlgO/main.rs:1:202\n  |\n1 | ...intln ! (\"Two\" . to_string ()) , 3i32 => println ! (\"Three\" . to_string ()) , _ => println ! (\"Other\" . to_string ()) , } } } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpxdWlgO/main.rs:1:204\n  |\n1 | ...! (\"Two\" . to_string ()) , 3i32 => println ! (\"Three\" . to_string ()) , _ => println ! (\"Other\" . to_string ()) , } } } }\n  |                                                  -------   ^^^^^^^^^^^^ argument never used\n  |                                                  |\n  |                                                  formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpxdWlgO/main.rs:1:244\n  |\n1 | ...rintln ! (\"Three\" . to_string ()) , _ => println ! (\"Other\" . to_string ()) , } } } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpxdWlgO/main.rs:1:246\n  |\n1 | ... ! (\"Three\" . to_string ()) , _ => println ! (\"Other\" . to_string ()) , } } } }\n  |                                                  -------   ^^^^^^^^^^^^ argument never used\n  |                                                  |\n  |                                                  formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpxdWlgO/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let number = 2i32 ; match number { 1i32 => println ! (\"One\" . to_string ()) , 2i32 =...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpxdWlgO/main.rs:1:50\n  |\n1 | ... { { { let number = 2i32 ; match number { 1i32 => println ! (\"One\" . to_string ()) , 2i32 => println ! (\"Two\" . to_string ()) , 3i32 => println ! (\"Three\" . to_string ()) , _ => println ! (\"Other\" . to_string ()) , } } } }\n  |       ^^                                                                                                                                                                                                                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let number = 2i32 ; match number { 1i32 => println ! (\"One\" . to_string ()) , 2i32 => println ! (\"Two\" . to_string ()) , 3i32 => println ! (\"Three\" . to_string ()) , _ => println ! (\"Other\" . to_string ()) , } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let number = 2i32 ; match number { 1i32 => println ! (\"One\" . to_string ()) , 2i32 => println ! (\"Two\" . to_string ()) , 3i32 => println ! (\"Three\" . to_string ()) , _ => println ! (\"Other\" . to_string ()) , } } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpxdWlgO/main.rs:1:116\n  |\n1 | ... 2i32 ; match number { 1i32 => println ! (\"One\" . to_string ()) , 2i32 => println ! (\"Two\" . to_string ()) , 3i32 => println ! (\"Three...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpxdWlgO/main.rs:1:159\n  |\n1 | ...One\" . to_string ()) , 2i32 => println ! (\"Two\" . to_string ()) , 3i32 => println ! (\"Three\" . to_string ()) , _ => println ! (\"Other\"...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpxdWlgO/main.rs:1:204\n  |\n1 | ...o\" . to_string ()) , 3i32 => println ! (\"Three\" . to_string ()) , _ => println ! (\"Other\" . to_string ()) , } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpxdWlgO/main.rs:1:246\n  |\n1 | ...hree\" . to_string ()) , _ => println ! (\"Other\" . to_string ()) , } } } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 12 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 7,
          "line_number": 179,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let mut i = 0;\n    while i < 10 {\n        i = i + 1;\n        if i == 3 {\n            continue;\n        }\n        if i == 6 {\n            break;\n        }\n        println(i);\n    }\n    println(\"Loop ended\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpF5UlTq/main.rs:1:218\n  |\n1 | ...ak } } ; println ! (\"{}\" , i) } } ; println ! (\"Loop ended\" . to_string ()) } }\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpF5UlTq/main.rs:1:220\n  |\n1 | ... } ; println ! (\"{}\" , i) } } ; println ! (\"Loop ended\" . to_string ()) } }\n  |                                               ------------   ^^^^^^^^^^^^ argument never used\n  |                                               |\n  |                                               formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpF5UlTq/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { let mut i = 0i32 ; while i < 10i32 { { i = i + 1i32 ; if i == 3i32 { { continue } } ; ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpF5UlTq/main.rs:1:121\n  |\n1 | use std :: collections :: HashMap ; fn main () { { let mut i = 0i32 ; while i < 10i32 { { i = i + 1i32 ; if i == 3i32 { { continue } } ; ...\n  |                                                                                                                         ^^        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { let mut i = 0i32 ; while i < 10i32 { { i = i + 1i32 ; if i == 3i32 { { continue } } ; if i == 6i32 { { break } } ; println ! (\"{}\" , i) } } ; println ! (\"Loop ended\" . to_string ()) } }\n1 + use std :: collections :: HashMap ; fn main () { { let mut i = 0i32 ; while i < 10i32 { { i = i + 1i32 ; if i == 3i32 { continue } ; if i == 6i32 { { break } } ; println ! (\"{}\" , i) } } ; println ! (\"Loop ended\" . to_string ()) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpF5UlTq/main.rs:1:153\n  |\n1 | ...i = i + 1i32 ; if i == 3i32 { { continue } } ; if i == 6i32 { { break } } ; println ! (\"{}\" , i) } } ; println ! (\"Loop ended\" . to_st...\n  |                                                                  ^^     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { let mut i = 0i32 ; while i < 10i32 { { i = i + 1i32 ; if i == 3i32 { { continue } } ; if i == 6i32 { { break } } ; println ! (\"{}\" , i) } } ; println ! (\"Loop ended\" . to_string ()) } }\n1 + use std :: collections :: HashMap ; fn main () { { let mut i = 0i32 ; while i < 10i32 { { i = i + 1i32 ; if i == 3i32 { { continue } } ; if i == 6i32 { break } ; println ! (\"{}\" , i) } } ; println ! (\"Loop ended\" . to_string ()) } }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpF5UlTq/main.rs:1:220\n  |\n1 | ...ntln ! (\"{}\" , i) } } ; println ! (\"Loop ended\" . to_string ()) } }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 8,
          "line_number": 236,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nif condition {\n    // true branch\n} else if other_condition {\n    // else if branch\n} else {\n    // false branch\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `condition` in this scope\n --> /tmp/.tmpH5Q0LF/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...\n  |                                                                  ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `other_condition` in this scope\n --> /tmp/.tmpH5Q0LF/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...\n  |                                                                                             ^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpH5Q0LF/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 9,
          "line_number": 251,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\n// While loop\nwhile condition {\n    // loop body\n}\n\n// For loop with range\nfor variable in start..end {\n    // loop body\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `condition` in this scope\n --> /tmp/.tmpV3BGu3/main.rs:1:71\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...\n  |                                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `start` in this scope\n --> /tmp/.tmpV3BGu3/main.rs:1:106\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...\n  |                                                                                                          ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `end` in this scope\n --> /tmp/.tmpV3BGu3/main.rs:1:115\n  |\n1 | ... { while condition { () } ; for variable in start .. end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast...\n  |                                                         ^^^ not found in this scope\n  |\nhelp: you might have meant to write `.` instead of `..`\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start.end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpV3BGu3/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 10,
          "line_number": 268,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nmatch value {\n    pattern1 => action1,\n    pattern2 => action2,\n    _ => default_action\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `value` in this scope\n --> /tmp/.tmpsp6qt2/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...\n  |                                                                     ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `action1` in this scope\n --> /tmp/.tmpsp6qt2/main.rs:1:89\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...\n  |                                                                                         ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `action2` in this scope\n --> /tmp/.tmpsp6qt2/main.rs:1:111\n  |\n1 | ... = match value { pattern1 => action1 , pattern2 => action2 , _ => default_action , } ; if let Some (s) = (& result as & dyn std :: any...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `default_action` in this scope\n --> /tmp/.tmpsp6qt2/main.rs:1:126\n  |\n1 | ...attern1 => action1 , pattern2 => action2 , _ => default_action , } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcas...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpsp6qt2/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 11,
          "line_number": 295,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nif user_input > threshold {\n    process_high_value();\n} else {\n    process_normal_value();\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `user_input` in this scope\n --> /tmp/.tmpQWyksn/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...\n  |                                                                  ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `threshold` in this scope\n --> /tmp/.tmpQWyksn/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...\n  |                                                                               ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpQWyksn/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpQWyksn/main.rs:1:91\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...\n  |                                                                                           ^^                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { process_high_value () } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpQWyksn/main.rs:1:126\n  |\n1 | ...put > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :...\n  |                                                         ^^                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { process_normal_value () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `process_high_value` in this scope\n --> /tmp/.tmpQWyksn/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...\n  |                                                                                             ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `process_normal_value` in this scope\n --> /tmp/.tmpQWyksn/main.rs:1:128\n  |\n1 | ...shold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . d...\n  |                                                 ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 12,
          "line_number": 308,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet mut count = 0;\nwhile count < 10 {\n    do_something();\n    count = count + 1;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmptsp08z/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; while count < 10i32 { { do_something () ; count = ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `do_something` in this scope\n --> /tmp/.tmptsp08z/main.rs:1:112\n  |\n1 | ...{ let mut count = 0i32 ; while count < 10i32 { { do_something () ; count = count + 1i32 } } } ; if let Some (s) = (& result as & dyn s...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 13,
          "line_number": 321,
          "code": "// Status: ✅ WORKING\nfor i in 1..5 {\n    println(\"Processing item \" + i);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 14,
          "line_number": 331,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nmatch status_code {\n    200 => println(\"Success\"),\n    404 => println(\"Not Found\"),\n    500 => println(\"Server Error\"),\n    _ => println(\"Unknown Status\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpCeo095/main.rs:1:114\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match status_code { 200i32 => println ! (\"Success\" . to_string ()) , 404i32...\n  |                                                                                                                  ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpCeo095/main.rs:1:116\n  |\n1 | ...t = match status_code { 200i32 => println ! (\"Success\" . to_string ()) , 404i32 => println ! (\"Not Found\" . to_string ()) , 500i32 => ...\n  |                                                 ---------   ^^^^^^^^^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpCeo095/main.rs:1:165\n  |\n1 | ...Success\" . to_string ()) , 404i32 => println ! (\"Not Found\" . to_string ()) , 500i32 => println ! (\"Server Error\" . to_string ()) , _ ...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpCeo095/main.rs:1:167\n  |\n1 | ...ess\" . to_string ()) , 404i32 => println ! (\"Not Found\" . to_string ()) , 500i32 => println ! (\"Server Error\" . to_string ()) , _ => p...\n  |                                                -----------   ^^^^^^^^^^^^ argument never used\n  |                                                |\n  |                                                formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpCeo095/main.rs:1:219\n  |\n1 | ...ound\" . to_string ()) , 500i32 => println ! (\"Server Error\" . to_string ()) , _ => println ! (\"Unknown Status\" . to_string ()) , } ; i...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpCeo095/main.rs:1:221\n  |\n1 | ...d\" . to_string ()) , 500i32 => println ! (\"Server Error\" . to_string ()) , _ => println ! (\"Unknown Status\" . to_string ()) , } ; if l...\n  |                                              --------------   ^^^^^^^^^^^^ argument never used\n  |                                              |\n  |                                              formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpCeo095/main.rs:1:270\n  |\n1 | ...r Error\" . to_string ()) , _ => println ! (\"Unknown Status\" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: A...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpCeo095/main.rs:1:272\n  |\n1 | ...Error\" . to_string ()) , _ => println ! (\"Unknown Status\" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: Any...\n  |                                             ----------------   ^^^^^^^^^^^^ argument never used\n  |                                             |\n  |                                             formatting specifier missing\n\nerror[E0425]: cannot find value `status_code` in this scope\n --> /tmp/.tmpCeo095/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match status_code { 200i32 => println ! (\"Success\" . to_string ()) , 404i32...\n  |                                                                     ^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpCeo095/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match status_code { 200i32 => println ! (\"Success\" . to_string ()) , 404i32...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpCeo095/main.rs:1:116\n  |\n1 | ...ch status_code { 200i32 => println ! (\"Success\" . to_string ()) , 404i32 => println ! (\"Not Found\" . to_string ()) , 500i32 => println...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpCeo095/main.rs:1:167\n  |\n1 | ...o_string ()) , 404i32 => println ! (\"Not Found\" . to_string ()) , 500i32 => println ! (\"Server Error\" . to_string ()) , _ => println !...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpCeo095/main.rs:1:221\n  |\n1 | ...tring ()) , 500i32 => println ! (\"Server Error\" . to_string ()) , _ => println ! (\"Unknown Status\" . to_string ()) , } ; if let Some (...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpCeo095/main.rs:1:272\n  |\n1 | ...o_string ()) , _ => println ! (\"Unknown Status\" . to_string ()) , } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downca...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 13 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "appendix-c-troubleshooting": {
      "chapter": "appendix-c-troubleshooting",
      "total_examples": 20,
      "working_examples": 1,
      "failing_examples": 19,
      "examples": [
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 1,
          "line_number": 25,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Error\nlet x = 42\nlet y = 24\n\n// ✅ Fixed\nlet x = 42;\nlet y = 24;\n\n// Note: Semicolons needed for statements, not expressions\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmphWCv33/main.rs:1:143\n  |\n1 | ... let mut x = 42i32 ; let mut y = 24i32 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmphWCv33/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut x = 42i32 ; let mut y = 24i32 ; let mut x = 42i32 ; let mut y = 2...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 2,
          "line_number": 48,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Error\nif condition {\n    do_something()\n// Missing closing brace\n\n// ✅ Fixed  \nif condition {\n    do_something()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 3,
          "line_number": 69,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Error\nlet 123invalid = \"nope\"\nlet my-var = \"no hyphens\"\nlet fn = \"keyword\"\n\n// ✅ Fixed\nlet invalid_123 = \"ok\"\nlet my_var = \"underscores ok\"\nlet function_name = \"not keyword\"",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 4,
          "line_number": 92,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Error\nlet x: i32 = \"string\"\n\n\n\n// ✅ Fixed\nlet x: i32 = 42\n// or\nlet x = \"string\"  // Let compiler infer type\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmptOV3vr/main.rs:1:129\n  |\n1 | ...t mut x = 42i32 ; let mut x = \"string\" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmptOV3vr/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut x = \"string\" ; let mut x = 42i32 ; let mut x = \"string\" } ; if le...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 5,
          "line_number": 115,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Error\nlet s = String::from(\"hello\")\nlet r = &s\nlet moved = *r  // Cannot move out of borrowed content\n\n// ✅ Fixed\nlet s = String::from(\"hello\")\nlet r = &s\nlet copied = r.clone()  // Clone instead of move",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 6,
          "line_number": 136,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Error\nlet s = String::from(\"hello\")\ntakes_ownership(s)\nprintln(s)  \n\n// ✅ Fixed - Option 1: Clone\nlet s = String::from(\"hello\")\ntakes_ownership(s.clone())\nprintln(s)  // s still valid\n\n// ✅ Fixed - Option 2: Borrow\nlet s = String::from(\"hello\")\nborrows_value(&s)\nprintln(s)  // s still valid\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpLP5ERZ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut s = String :: from (\"hello\" . to_string ()) ; takes_ownership (s)...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `takes_ownership` in this scope\n --> /tmp/.tmpLP5ERZ/main.rs:1:119\n  |\n1 | ... s = String :: from (\"hello\" . to_string ()) ; takes_ownership (s) ; println ! (\"{}\" , s) ; let mut s = String :: from (\"hello\" . to_s...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `takes_ownership` in this scope\n --> /tmp/.tmpLP5ERZ/main.rs:1:218\n  |\n1 | ... s = String :: from (\"hello\" . to_string ()) ; takes_ownership (s . clone ()) ; println ! (\"{}\" , s) ; let mut s = String :: from (\"he...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `borrows_value` in this scope\n --> /tmp/.tmpLP5ERZ/main.rs:1:328\n  |\n1 | ...t s = String :: from (\"hello\" . to_string ()) ; borrows_value (& s) ; println ! (\"{}\" , s) } ; if let Some (s) = (& result as & dyn st...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 7,
          "line_number": 166,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Error\nfun dangle() -> &String {\n    let s = String::from(\"hello\")\n    &s  // s goes out of scope\n}\n\n// ✅ Fixed - Return owned value\nfun not_dangle() -> String {\n    let s = String::from(\"hello\")\n    s  // Move ownership\n}\n\n// ✅ Fixed - Use static lifetime\nfun static_str() -> &'static str {\n    \"hello\"  // String literals have static lifetime\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 8,
          "line_number": 194,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Error\nlet mut s = String::from(\"hello\")\nlet r1 = &mut s\nlet r2 = &mut s  // Error: ✗ Compilation failed: Failed to parse Ruchy source\nprintln(r1)\nprintln(r2)\n\n// ✅ Fixed - Use references sequentially\nlet mut s = String::from(\"hello\")\n{\n    let r1 = &mut s\n    // r1 scope ends here\n}\nlet r2 = &mut s  // Now ok",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 9,
          "line_number": 224,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Runtime panic\nlet v = vec![1, 2, 3]\nlet item = v[5]  // Panic: index out of bounds\n\n// ✅ Safe access\nlet v = vec![1, 2, 3]\nmatch v.get(5) {\n    Some(item) => println(\"Item: {}\", item),\n    None => println(\"Index out of bounds\"),\n}\n\n// ✅ Or use safe indexing\nif let Some(item) = v.get(5) {\n    println(\"Item: {}\", item)\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpkUWZ8s/main.rs:1:307\n  |\n1 | ...: {{}}\") , item) , None => println ! (\"Index out of bounds\" . to_string ()) , } ; if let Some (item) = v . get (5i32) { { println ! (\"...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpkUWZ8s/main.rs:1:309\n  |\n1 | ...m: {{}}\") , item) , None => println ! (\"Index out of bounds\" . to_string ()) , } ; if let Some (item) = v . get (5i32) { { println ! (...\n  |                                           ---------------------   ^^^^^^^^^^^^ argument never used\n  |                                           |\n  |                                           formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpkUWZ8s/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut v = vec ! [1i32 , 2i32 , 3i32] ; let mut item = v [5i32] ; let mu...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpkUWZ8s/main.rs:1:367\n  |\n1 | ... if let Some (item) = v . get (5i32) { { println ! (\"{} {}\" , format ! (\"Item: {{}}\") , item) } } } ; if let Some (s) = (& result as &...\n  |                                           ^^                                                    ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let mut v = vec ! [1i32 , 2i32 , 3i32] ; let mut item = v [5i32] ; let mut v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) { Some (item) => println ! (\"{} {}\" , format ! (\"Item: {{}}\") , item) , None => println ! (\"Index out of bounds\" . to_string ()) , } ; if let Some (item) = v . get (5i32) { { println ! (\"{} {}\" , format ! (\"Item: {{}}\") , item) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let mut v = vec ! [1i32 , 2i32 , 3i32] ; let mut item = v [5i32] ; let mut v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) { Some (item) => println ! (\"{} {}\" , format ! (\"Item: {{}}\") , item) , None => println ! (\"Index out of bounds\" . to_string ()) , } ; if let Some (item) = v . get (5i32) { println ! (\"{} {}\" , format ! (\"Item: {{}}\") , item) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n --> /tmp/.tmpkUWZ8s/main.rs:1:124\n  |\n1 | ...2 , 2i32 , 3i32] ; let mut item = v [5i32] ; let mut v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) { Some (item) => println ! ...\n  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<i32>` to implement `Index<i32>`\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n   --> /tmp/.tmpkUWZ8s/main.rs:1:188\n    |\n1   | ...! [1i32 , 2i32 , 3i32] ; match v . get (5i32) { Some (item) => println ! (\"{} {}\" , format ! (\"Item: {{}}\") , item) , None => println ...\n    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`\n    |                                       |\n    |                                       required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n    = help: the following other types implement trait `SliceIndex<T>`:\n              `usize` implements `SliceIndex<ByteStr>`\n              `usize` implements `SliceIndex<[T]>`\nnote: required by a bound in `core::slice::<impl [T]>::get`\n   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12\n    |\n571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>\n    |            --- required by a bound in this associated function\n572 |     where\n573 |         I: SliceIndex<Self>,\n    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpkUWZ8s/main.rs:1:309\n  |\n1 | ...tem) , None => println ! (\"Index out of bounds\" . to_string ()) , } ; if let Some (item) = v . get (5i32) { { println ! (\"{} {}\" , for...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n   --> /tmp/.tmpkUWZ8s/main.rs:1:359\n    |\n1   | ...()) , } ; if let Some (item) = v . get (5i32) { { println ! (\"{} {}\" , format ! (\"Item: {{}}\") , item) } } } ; if let Some (s) = (& re...\n    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`\n    |                                       |\n    |                                       required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n    = help: the following other types implement trait `SliceIndex<T>`:\n              `usize` implements `SliceIndex<ByteStr>`\n              `usize` implements `SliceIndex<[T]>`\nnote: required by a bound in `core::slice::<impl [T]>::get`\n   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12\n    |\n571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>\n    |            --- required by a bound in this associated function\n572 |     where\n573 |         I: SliceIndex<Self>,\n    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`\n\nerror: aborting due to 6 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 10,
          "line_number": 253,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Runtime panic\nlet maybe_value: Option<i32> = None\nlet value = maybe_value.unwrap()  // Panic: called unwrap on None\n\n// ✅ Safe handling\nlet maybe_value: Option<i32> = None\nmatch maybe_value {\n    Some(value) => println(\"Value: {}\", value),\n    None => println(\"No value\"),\n}\n\n// ✅ Or provide default\nlet value = maybe_value.unwrap_or(0)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 11,
          "line_number": 278,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Runtime panic\nfun divide(a: i32, b: i32) -> i32 {\n    a / b  // Panic if b is 0\n}\n\n// ✅ Safe division\nfun safe_divide(a: i32, b: i32) -> Option<i32> {\n    if b != 0 {\n        Some(a / b)\n    } else {\n        None\n    }\n}\n\n// ✅ Or return Result\nfun divide_result(a: i32, b: i32) -> Result<i32, String> {\n    if b != 0 {\n        Ok(a / b)\n    } else {\n        Err(\"Division by zero\".to_string())\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 12,
          "line_number": 314,
          "code": "// Status: ✅ WORKING\n\n// ❌ Infinite recursion causes stack overflow\nfun infinite_recursion(n: i32) -> i32 {\n    infinite_recursion(n + 1)  // No base case\n}\n\n// ✅ Proper recursion with base case\nfun factorial(n: i32) -> i32 {\n    if n <= 1 {\n        1  // Base case\n    } else {\n        n * factorial(n - 1)\n    }\n}\n\n// ✅ Or use iteration\nfun factorial_iterative(n: i32) -> i32 {\n    let mut result = 1\n    for i in 1..=n {\n        result *= i\n    }\n    result\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 13,
          "line_number": 349,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ May cause stack overflow\nfun large_array() {\n    let big_array: [i32; 1_000_000] = [0; 1_000_000]  // 4MB on stack\n}\n\n// ✅ Use heap allocation\nfun large_vector() {\n    let big_vector: Vec<i32> = vec![0; 1_000_000]  // Allocated on heap\n}\n\n// ✅ Or use Box for single large items\nfun boxed_array() {\n    let big_array: Box<[i32; 1_000_000]> = Box::new([0; 1_000_000])\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 14,
          "line_number": 377,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Inefficient - unnecessary clones\nfun process_strings(strings: Vec<String>) -> Vec<String> {\n    strings.iter()\n        .map(|s| s.clone().to_uppercase())  // Unnecessary clone\n        .collect()\n}\n\n// ✅ More efficient - work with references\nfun process_strings_efficient(strings: &[String]) -> Vec<String> {\n    strings.iter()\n        .map(|s| s.to_uppercase())  // to_uppercase() works on &str\n        .collect()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 15,
          "line_number": 402,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Inefficient - creates many temporary strings\nfun concat_inefficient(strings: &[&str]) -> String {\n    let mut result = String::new()\n    for s in strings {\n        result = result + s  // Creates new string each time\n    }\n    result\n}\n\n// ✅ Efficient - reuses buffer\nfun concat_efficient(strings: &[&str]) -> String {\n    let mut result = String::new()\n    for s in strings {\n        result.push_str(s)  // Appends to existing string\n    }\n    result\n}\n\n// ✅ Even better - pre-allocate capacity\nfun concat_with_capacity(strings: &[&str]) -> String {\n    let total_len: usize = strings.iter().map(|s| s.len()).sum()\n    let mut result = String::with_capacity(total_len)\n    for s in strings {\n        result.push_str(s)\n    }\n    result\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 16,
          "line_number": 441,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Wrong collection for use case\nuse std::collections::VecDeque\n\nlet mut list = Vec::new()\n// Frequent insertions at beginning - O(n) for each insert\nfor i in 0..1000 {\n    list.insert(0, i)\n}\n\n// ✅ Better collection choice\nlet mut deque = VecDeque::new()\n// Efficient insertion at front - O(1)\nfor i in 0..1000 {\n    deque.push_front(i)\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpaUfQCC/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpaUfQCC/main.rs:1:102\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for...\n  |                                                                                                      ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpaUfQCC/main.rs:1:162\n  |\n1 | ...ut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i...\n  |                                                         ^^                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { list . insert (0i32 , i) } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpaUfQCC/main.rs:1:259\n  |\n1 | ...que = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any...\n  |                                                          ^^                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { deque . push_front (i) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0308]: mismatched types\n    --> /tmp/.tmpaUfQCC/main.rs:1:179\n     |\n1    | ...ew () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { ...\n     |                                                ------  ^^^^ expected `usize`, found `i32`\n     |                                                |\n     |                                                arguments to this method are incorrect\n     |\nnote: method defined here\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2034:12\n     |\n2034 |     pub fn insert(&mut self, index: usize, element: T) {\n     |            ^^^^^^\nhelp: change the type of the numeric literal from `i32` to `usize`\n     |\n1    - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1    + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0usize , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n     |\n\nerror: aborting due to 1 previous error; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 17,
          "line_number": 485,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\n// ❌ Error: no method named `json` found for type `Response`\nlet response = reqwest::get(url).await?\nlet data = response.json().await?  // Feature not enabled\n\n// ✅ Enable required features in Cargo.toml\n// [dependencies]\n// reqwest = { version = \"0.11\", features = [\"json\"] }",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmplhkvPR/main.rs:1:161\n  |\n1 | ...ut data = response . json () . await ? } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]: cannot find value `url` in this scope\n --> /tmp/.tmplhkvPR/main.rs:1:100\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut response = reqwest :: get (url) . await ? ; let mut data = respon...\n  |                                                                                                    ^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmplhkvPR/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut response = reqwest :: get (url) . await ? ; let mut data = respon...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`\n --> /tmp/.tmplhkvPR/main.rs:1:84\n  |\n1 | ... { let result = { let mut response = reqwest :: get (url) . await ? ; let mut data = response . json () . await ? } ; if let Some (s) ...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `reqwest`\n  |\n  = help: you might be missing a crate named `reqwest`\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 18,
          "line_number": 607,
          "code": "// Status: ❌ BROKEN\n\n// Simple debug prints\nprintln!(\"Debug: x = {}\", x)\nprintln!(\"Debug: {:?}\", complex_struct)  // Debug formatting\nprintln!(\"Debug: {:#?}\", nested_struct)  // Pretty debug formatting\n\n// Conditional debug prints\n#[cfg(debug_assertions)]\nprintln!(\"This only prints in debug builds\")\n\n// Debug macro\ndebug!(\"Variable state: x={}, y={}\", x, y)\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 19,
          "line_number": 647,
          "code": "// Status: ❌ BROKEN\n\nuse log::{debug, info, warn, error}\n\nfun main() {\n    env_logger::init()\n    \n    debug!(\"This is a debug message\")\n    info!(\"This is info\")\n    warn!(\"This is a warning\")\n    error!(\"This is an error\")\n}\n\n// Control log level with environment variable\n// RUST_LOG=debug cargo run\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 20,
          "line_number": 674,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n#[cfg(test)]\nmod tests {\n    use super::*\n    \n    #[test]\n    fun test_with_debug_output() {\n        let result = my_function(42)\n        \n        // Print for debugging (use -- --nocapture to see output)\n        println!(\"Result: {:?}\", result)\n        \n        assert_eq!(result, expected)\n    }\n    \n    // Run with: cargo test -- --nocapture\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch05-00-data-processing": {
      "chapter": "ch05-00-data-processing",
      "total_examples": 10,
      "working_examples": 0,
      "failing_examples": 10,
      "examples": [
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: sales_analyzer.ruchy\n// Analyzes sales data from CSV file\n\nprintln(\"=== Sales Data Analyzer ===\")\n\n// Read CSV data (simplified - in practice you'd use CSV parser)\nlet sales_data = [\n    [\"Date\", \"Product\", \"Amount\", \"Region\"],\n    [\"2024-01-15\", \"Laptop\", \"1299\", \"North\"],\n    [\"2024-01-16\", \"Mouse\", \"25\", \"South\"], \n    [\"2024-01-17\", \"Keyboard\", \"79\", \"North\"],\n    [\"2024-01-18\", \"Laptop\", \"1299\", \"East\"],\n    [\"2024-01-19\", \"Monitor\", \"399\", \"West\"]\n]\n\n// Process data\nlet total_sales = 0\nlet product_counts = {}\nlet region_sales = {}\n\nfor row in sales_data[1..] {  // Skip header\n    let product = row[1]\n    let amount = row[2].to_f()\n    let region = row[3]\n    \n    // Calculate totals\n    total_sales += amount\n    \n    // Count products\n    product_counts[product] = product_counts.get(product, 0) + 1\n    \n    // Sum by region\n    region_sales[region] = region_sales.get(region, 0) + amount\n}\n\n// Display results\nprintln(\"Total Sales: $\" + total_sales.to_s())\nprintln(\"Average Sale: $\" + (total_sales / (sales_data.len() - 1)).to_s())\n\nprintln(\"\\nTop Products:\")\nfor product, count in product_counts.items() {\n    println(\"  \" + product + \": \" + count.to_s() + \" sales\")\n}\n\nprintln(\"\\nSales by Region:\")\nfor region, amount in region_sales.items() {\n    println(\"  \" + region + \": $\" + amount.to_s())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 2,
          "line_number": 115,
          "code": "// Status: ❌ BROKEN\n\n// Arrays for sequences\nlet sales_amounts = [1299, 25, 79, 1299, 399]\nlet monthly_revenue = [45000, 52000, 48000, 61000]\n\n// Dictionaries for key-value mapping  \nlet customer_orders = {\n    \"alice@email.com\": 5,\n    \"bob@email.com\": 2,\n    \"carol@email.com\": 8\n}\n\n// Arrays of dictionaries for structured records\nlet transactions = [\n    {\"id\": 1001, \"amount\": 1299, \"customer\": \"alice@email.com\"},\n    {\"id\": 1002, \"amount\": 25, \"customer\": \"bob@email.com\"},\n    {\"id\": 1003, \"amount\": 79, \"customer\": \"alice@email.com\"}\n]",
          "passed": false,
          "status": "broken",
          "error": "\nthread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:\n\"alice@email.com\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 3,
          "line_number": 147,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// Sum and averages\nlet total = numbers.sum()\nlet average = numbers.sum() / numbers.len()\nlet maximum = numbers.max()\nlet minimum = numbers.min()\n\n// Grouping and counting\nfun group_by_field(records, field) {\n    let groups = {}\n    for record in records {\n        let key = record[field]\n        if !groups.has_key(key) {\n            groups[key] = []\n        }\n        groups[key].push(record)\n    }\n    return groups\n}\n\n// Filtering and transformation\nlet high_value = transactions.filter(|t| t.amount > 100)\nlet customer_ids = transactions.map(|t| t.customer)\nlet amounts_only = transactions.map(|t| t.amount)\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmpTpKV4W/main.rs:1:451\n  |\n1 | ...return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut ...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmpTpKV4W/main.rs:1:488\n  |\n1 | ...t mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut ...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmpTpKV4W/main.rs:1:507\n  |\n1 | ...rs . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers ....\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmpTpKV4W/main.rs:1:544\n  |\n1 | ...rs . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transa...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmpTpKV4W/main.rs:1:581\n  |\n1 | ...mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t |...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `transactions` in this scope\n --> /tmp/.tmpTpKV4W/main.rs:1:621\n  |\n1 | ...inimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let m...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `transactions` in this scope\n --> /tmp/.tmpTpKV4W/main.rs:1:724\n  |\n1 | ... > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let ...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `transactions` in this scope\n --> /tmp/.tmpTpKV4W/main.rs:1:828\n  |\n1 | ...lect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpTpKV4W/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTpKV4W/main.rs:1:218\n  |\n1 | ... { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } ...\n  |       ^^                                                                                                                                                                                                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n1 + use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTpKV4W/main.rs:1:266\n  |\n1 | ... { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ...\n  |       ^^                                                                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n1 + use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTpKV4W/main.rs:1:329\n  |\n1 | ...y = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return gro...\n  |                                                         ^^                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n1 + use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { groups [key] = vec ! [] } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n  |\n\nerror[E0277]: `T` is not an iterator\n --> /tmp/.tmpTpKV4W/main.rs:1:256\n  |\n1 | ...d : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups ...\n  |                                                        ^^^^^^^ `T` is not an iterator\n  |\n  = note: required for `T` to implement `IntoIterator`\nhelp: consider further restricting type parameter `T` with trait `Iterator`\n  |\n1 | use std :: collections :: HashMap ; fn group_by_field < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::iter::Iterator > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n  |                                                                                                                                                                                       +++++++++++++++++++++\n\nerror[E0599]: no method named `has_key` found for unit type `()` in the current scope\n --> /tmp/.tmpTpKV4W/main.rs:1:313\n  |\n1 | ...s { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } ...\n  |                                                       ^^^^^^^ method not found in `()`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpTpKV4W/main.rs:1:407\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (records : T , field : T) -> T { { { let groups = () ; { for record in records { { { let key = record [field] ; { if ! groups . has_key (key) { { groups [key] = vec ! [] } } ; groups [key] . push (record) } } } } ; return groups } ...\n  |       - expected this type parameter                                                                                                                               - expected `T` because of return type                                                                                                                                                            ^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: the caller chooses a type for `T` which can be different from `()`\n\nerror: aborting due to 11 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: has_key()"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 4,
          "line_number": 186,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// CSV-like processing (simplified)\nfun parse_csv_line(line) {\n    return line.split(\",\").map(|field| field.trim())\n}\n\nfun load_csv(filename) {\n    let lines = read_lines(filename)\n    let header = parse_csv_line(lines[0])\n    let data = []\n    \n    for line in lines[1..] {\n        let fields = parse_csv_line(line)\n        let record = {}\n        for i, field in fields.enumerate() {\n            record[header[i]] = field\n        }\n        data.push(record)\n    }\n    \n    return data\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 5,
          "line_number": 222,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: customer_analytics.ruchy\n// Analyzes customer purchase patterns\n\nprintln(\"=== Customer Analytics Tool ===\")\n\n// Sample customer data (in practice, load from file)\nlet customers = [\n    {\"name\": \"Alice\", \"email\": \"alice@email.com\", \"orders\": 5, \"total_spent\": 2500, \"signup_date\": \"2023-06-15\"},\n    {\"name\": \"Bob\", \"email\": \"bob@email.com\", \"orders\": 2, \"total_spent\": 150, \"signup_date\": \"2024-01-20\"},\n    {\"name\": \"Carol\", \"email\": \"carol@email.com\", \"orders\": 8, \"total_spent\": 4200, \"signup_date\": \"2023-03-10\"},\n    {\"name\": \"David\", \"email\": \"david@email.com\", \"orders\": 1, \"total_spent\": 75, \"signup_date\": \"2024-02-01\"}\n]\n\n// Calculate key metrics\nlet total_customers = customers.len()\nlet total_revenue = customers.map(|c| c.total_spent).sum()\nlet average_order_value = total_revenue / customers.map(|c| c.orders).sum()\nlet average_customer_value = total_revenue / total_customers\n\nprintln(\"Customer Base: \" + total_customers.to_s() + \" customers\")\nprintln(\"Total Revenue: $\" + total_revenue.to_s())\nprintln(\"Average Order Value: $\" + average_order_value.to_s())\nprintln(\"Average Customer Value: $\" + average_customer_value.to_s())\n\n// Segment customers\nlet vip_customers = customers.filter(|c| c.total_spent > 1000)\nlet new_customers = customers.filter(|c| c.signup_date.starts_with(\"2024\"))\nlet frequent_buyers = customers.filter(|c| c.orders > 5)\n\nprintln(f\"\\nCustomer Segments:\")\nprintln(\"VIP Customers (>$1000): \" + vip_customers.len().to_s())\nprintln(\"New Customers (2024): \" + new_customers.len().to_s())\nprintln(\"Frequent Buyers (>5 orders): \" + frequent_buyers.len().to_s())\n\n// Top customers by spending\nlet top_spenders = customers.sort_by(|c| -c.total_spent)[..3]\nprintln(f\"\\nTop Spenders:\")\nfor i, customer in top_spenders.enumerate() {\n    println(\"  \" + (i+1).to_s() + \". \" + customer.name + \": $\" + customer.total_spent.to_s() + \" (\" + customer.orders.to_s() + \" orders)\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 6,
          "line_number": 275,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: advanced_log_analyzer.ruchy\n// Comprehensive log file analysis\n\nprintln(\"=== Advanced Log Analyzer ===\")\n\n// Sample log entries (in practice, read from file)\nlet log_entries = [\n    \"2024-08-19 10:15:32 INFO User login: alice@email.com\",\n    \"2024-08-19 10:16:45 ERROR Database connection failed\", \n    \"2024-08-19 10:17:12 INFO User login: bob@email.com\",\n    \"2024-08-19 10:18:33 WARN Slow query detected: 2.5s\",\n    \"2024-08-19 10:19:44 ERROR 404 Not Found: /api/users/999\",\n    \"2024-08-19 10:20:15 INFO User logout: alice@email.com\"\n]\n\n// Parse log entries\nfun parse_log_entry(entry) {\n    let parts = entry.split(\" \")\n    return {\n        \"date\": parts[0],\n        \"time\": parts[1], \n        \"level\": parts[2],\n        \"message\": parts[3..].join(\" \")\n    }\n}\n\nlet parsed_logs = log_entries.map(parse_log_entry)\n\n// Analyze by level\nlet level_counts = {}\nfor log in parsed_logs {\n    let level = log.level\n    level_counts[level] = level_counts.get(level, 0) + 1\n}\n\nprintln(\"Log Level Summary:\")\nfor level, count in level_counts.items() {\n    let emoji = match level {\n        \"INFO\" => \"ℹ️\",\n        \"WARN\" => \"⚠️\", \n        \"ERROR\" => \"❌\",\n        _ => \"📝\"\n    }\n    println(\"  \" + emoji + \" \" + level + \": \" + count.to_s() + \" entries\")\n}\n\n// Find errors and warnings\nlet issues = parsed_logs.filter(|log| log.level == \"ERROR\" || log.level == \"WARN\")\nprintln(\"\\nIssues Found (\" + issues.len().to_s() + \"):\")\nfor issue in issues {\n    println(\"  \" + issue.time + \" \" + issue.level + \": \" + issue.message)\n}\n\n// Extract user activity\nlet user_actions = parsed_logs.filter(|log| log.message.contains(\"User\"))\nprintln(\"\\nUser Activity (\" + user_actions.len().to_s() + \" actions):\")\nfor action in user_actions {\n    println(\"  \" + action.time + \": \" + action.message)\n}\n\n// Time-based analysis\nlet hours = parsed_logs.map(|log| log.time.split(\":\")[0])\nlet hour_counts = {}\nfor hour in hours {\n    hour_counts[hour] = hour_counts.get(hour, 0) + 1\n}\n\nlet busiest_hour = hour_counts.max_by_value()\nprintln(\"\\nBusiest Hour: \" + busiest_hour.key + \":xx (\" + busiest_hour.value.to_s() + \" entries)\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 7,
          "line_number": 357,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: finance_processor.ruchy\n// Processes financial transactions and generates reports\n\nprintln(\"=== Financial Data Processor ===\")\n\n// Transaction data structure\nlet transactions = [\n    {\"date\": \"2024-01-15\", \"type\": \"income\", \"category\": \"salary\", \"amount\": 5000, \"description\": \"Monthly salary\"},\n    {\"date\": \"2024-01-16\", \"type\": \"expense\", \"category\": \"rent\", \"amount\": 1200, \"description\": \"Apartment rent\"},\n    {\"date\": \"2024-01-17\", \"type\": \"expense\", \"category\": \"groceries\", \"amount\": 85, \"description\": \"Weekly shopping\"},\n    {\"date\": \"2024-01-18\", \"type\": \"expense\", \"category\": \"utilities\", \"amount\": 150, \"description\": \"Electricity bill\"},\n    {\"date\": \"2024-01-20\", \"type\": \"income\", \"category\": \"freelance\", \"amount\": 800, \"description\": \"Web design project\"}\n]\n\n// Calculate totals\nlet total_income = transactions.filter(|t| t.type == \"income\").map(|t| t.amount).sum()\nlet total_expenses = transactions.filter(|t| t.type == \"expense\").map(|t| t.amount).sum()\nlet net_income = total_income - total_expenses\n\nprintln(f\"Financial Summary:\")\nprintln(\"Total Income: $\" + total_income.to_s())\nprintln(\"Total Expenses: $\" + total_expenses.to_s())\nprintln(\"Net Income: $\" + net_income.to_s())\nprintln(\"Savings Rate: \" + (net_income * 100 / total_income).to_s() + \"%\")\n\n// Expense breakdown by category\nlet expense_categories = {}\nfor transaction in transactions.filter(|t| t.type == \"expense\") {\n    let category = transaction.category\n    expense_categories[category] = expense_categories.get(category, 0) + transaction.amount\n}\n\nprintln(f\"\\nExpense Breakdown:\")\nfor category, amount in expense_categories.items() {\n    let percentage = (amount * 100) / total_expenses\n    println(\"  \" + category.capitalize() + \": $\" + amount.to_s() + \" (\" + percentage.to_s() + \"%)\")\n}\n\n// Budget analysis\nlet budget_limits = {\n    \"rent\": 1500,\n    \"groceries\": 400, \n    \"utilities\": 200,\n    \"entertainment\": 300\n}\n\nprintln(f\"\\nBudget Analysis:\")\nfor category, limit in budget_limits.items() {\n    let spent = expense_categories.get(category, 0)\n    let remaining = limit - spent\n    let status = if remaining >= 0 { \"✅ Under budget\" } else { \"❌ Over budget\" }\n    println(\"  \" + category.capitalize() + \": $\" + spent.to_s() + \"/$\" + limit.to_s() + \" - \" + status)\n}\n\n// Monthly trend (if we had multiple months of data)\nprintln(\"\\nTransaction History (\" + transactions.len().to_s() + \" transactions):\")\nfor transaction in transactions.sort_by(|t| t.date) {\n    let emoji = if transaction.type == \"income\" { \"💰\" } else { \"💸\" }\n    println(\"  \" + transaction.date + \" \" + emoji + \" $\" + transaction.amount.to_s() + \" - \" + transaction.description)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 8,
          "line_number": 432,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n// Error: ✗ Compilation failed: Compilation failed:\n// Simple bar chart function\nfun draw_bar_chart(data, title) {\n    println(\"\\n\" + title)\n    println(\"=\" * title.len())\n    \n    let max_value = data.values().max()\n    let max_bar_width = 50\n    \n    for key, value in data.items() {\n        let bar_width = (value * max_bar_width) / max_value\n        let bar = \"█\" * bar_width.to_i()\n        println(key + \" │\" + bar + \" \" + value.to_s())\n    }\n}\n\n// Usage example\nlet monthly_sales = {\n    \"January\": 45000,\n    \"February\": 52000,\n    \"March\": 48000,\n    \"April\": 61000,\n    \"May\": 58000\n}\n\ndraw_bar_chart(monthly_sales, \"Monthly Sales Report\")",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: struct literal body without path\n --> /tmp/.tmpmF20kx/main.rs:1:685\n  |\n1 | ...monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart...\n  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + bar , \" \") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { SomeStruct { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++                                                                                                       +\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpmF20kx/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpmF20kx/main.rs:1:432\n  |\n1 | ... { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + bar , \" \") + value . to_s ()) } } } } ...\n  |       ^^                                                                                                                                                                                                         ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + bar , \" \") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n1 + use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { let bar_width = value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + bar , \" \") + value . to_s ()) } } } } } } } fn main () { let mut monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n  |\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmpmF20kx/main.rs:1:303\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{}\" , \"=\" * title . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                                                                                                      ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (data : T , title : T) -> T { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + bar , \" \") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n  |                                                                                                                                                                                       +++++++++++++++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpmF20kx/main.rs:1:289\n  |\n1 | ...\" , \"\\n\" , title)) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width =...\n  |                                     --    ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n  |                                     |\n  |                                     required by this formatting parameter\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `values` found for type parameter `T` in the current scope\n --> /tmp/.tmpmF20kx/main.rs:1:338\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values ()...\n  |       - method `values` not found for this type parameter                                                                                                                                                                                                                                      ^^^^^^ method not found in `T`\n\nerror[E0599]: no method named `items` found for type parameter `T` in the current scope\n --> /tmp/.tmpmF20kx/main.rs:1:421\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items ()...\n  |       - method `items` not found for this type parameter                                                                                                                                                                                                                                                                                                                          ^^^^^ method not found in `T`\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpmF20kx/main.rs:1:494\n  |\n1 | ...value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" ...\n  |                                              ^^^^^^^ doesn't have a size known at compile-time\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: all local variables must have a statically known size\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpmF20kx/main.rs:1:602\n  |\n1 | ...ormat ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + bar , \" \") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = ...\n  |                                                       ^^^ expected `&str`, found `str`\n  |\nhelp: consider borrowing here\n  |\n1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + &bar , \" \") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpmF20kx/main.rs:1:393\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + bar , \" \") + value . to_s ()) } } } } } ...\n  |       - expected this type parameter                                                                                                                            - expected `T` because of return type                                                                                                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `()`\n  |\n  = note: expected type parameter `T`\n                  found unit type `()`\n  = note: the caller chooses a type for `T` which can be different from `()`\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn draw_bar_chart < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (data : T , title : T) -> T { { println ! (\"{}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . items () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + bar , \" \") + value . to_s ()) } } } } /* `T` value */ } } } } fn main () { let mut monthly_sales = { January : 45000i32 , February : 52000i32 , March : 48000i32 , April : 61000i32 , May : 58000i32 , } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +++++++++++++++\n\nerror: aborting due to 8 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: len()"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 9,
          "line_number": 487,
          "code": "// Status: ❌ BROKEN\n\nlet sales_data = load_csv(\"sales.csv\")\nlet total = sales_data.map(|row| row.amount.to_f()).sum()\nlet average = total / sales_data.len()\nprintln(\"Average sale: $\" + average.to_s())\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp4suJNW/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut sales_data = load_csv (\"sales.csv\" . to_string ()) ; let mut tota...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `load_csv` in this scope\n --> /tmp/.tmp4suJNW/main.rs:1:86\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut sales_data = load_csv (\"sales.csv\" . to_string ()) ; let mut tota...\n  |                                                                                      ^^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 10,
          "line_number": 584,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// expense_tracker.ruchy - Track and analyze personal expenses\n\nlet EXPENSES_FILE = \"expenses.csv\"\n\nfun save_expense(date, category, amount, description) {\n    let entry = date + \",\" + category + \",\" + amount.to_s() + \",\" + description + \"\\n\"\n    append_file(EXPENSES_FILE, entry)\n}\n\nfun load_expenses() {\n    if !file_exists(EXPENSES_FILE) {\n        // Create header if file doesn't exist\n        write_file(EXPENSES_FILE, \"Date,Category,Amount,Description\\n\")\n        return []\n    }\n    \n    let lines = read_lines(EXPENSES_FILE)[1..]  // Skip header\n    let expenses = []\n    \n    for line in lines {\n        let parts = line.split(\",\")\n        expenses.push({\n            \"date\": parts[0],\n            \"category\": parts[1], \n            \"amount\": parts[2].to_f(),\n            \"description\": parts[3]\n        })\n    }\n    \n    return expenses\n}\n\nfun analyze_expenses(expenses) {\n    let total = expenses.map(|e| e.amount).sum()\n    let average = total / expenses.len()\n    \n    // Category breakdown\n    let categories = {}\n    for expense in expenses {\n        categories[expense.category] = categories.get(expense.category, 0) + expense.amount\n    }\n    \n    println(\"\\n💰 Expense Analysis (\" + expenses.len().to_s() + \" transactions)\")\n    println(\"Total Spent: $\" + total.to_s())\n    println(\"Average Transaction: $\" + average.to_s())\n    \n    println(f\"\\n📊 Spending by Category:\")\n    for category, amount in categories.items().sort_by(|item| -item.value) {\n        let percentage = (amount * 100) / total\n        println(\"  \" + category + \": $\" + amount.to_s() + \" (\" + percentage.to_s() + \"%)\")\n    }\n    \n    // Recent transactions\n    let recent = expenses.sort_by(|e| -e.date)[..5]  // Last 5\n    println(f\"\\n🕒 Recent Transactions:\")\n    for expense in recent {\n        println(\"  \" + expense.date + \" $\" + expense.amount.to_s() + \" \" + expense.category + \" \" + expense.description)\n    }\n}\n\nfun main_menu() {\n    println(\"\\n=== Personal Expense Tracker ===\")\n    println(\"1. Add expense\")\n    println(\"2. View analysis\") \n    println(\"3. Export data\")\n    println(\"4. Quit\")\n    \n    let choice = input(\"\\nChoose option: \")\n    \n    match choice {\n        \"1\" => {\n            let date = input(\"Date (YYYY-MM-DD): \")\n            let category = input(\"Category: \")\n            let amount = input(\"Amount: $\").to_f()\n            let description = input(\"Description: \")\n            \n            save_expense(date, category, amount, description)\n            println(\"✅ Expense added!\")\n        }\n        \"2\" => {\n            let expenses = load_expenses()\n            if expenses.is_empty() {\n                println(\"📝 No expenses recorded yet\")\n            } else {\n                analyze_expenses(expenses)\n            }\n        }\n        \"3\" => {\n            println(\"📁 Data exported to: \" + EXPENSES_FILE)\n            println(\"Open in spreadsheet application for advanced analysis\")\n        }\n        \"4\" => {\n            println(\"💸 Happy budgeting!\")\n            return false\n        }\n        _ => {\n            println(\"❌ Invalid choice\")\n        }\n    }\n    \n    return true\n}\n\n// Main program loop\nwhile main_menu() {\n    // Continue until user quits\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch01-02-hello-world": {
      "chapter": "ch01-02-hello-world",
      "total_examples": 8,
      "working_examples": 3,
      "failing_examples": 5,
      "examples": [
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Hello, World!\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmphbmHjd/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                                               ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmphbmHjd/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                               ---------------   ^^^^^^^^^^^^ argument never used\n  |                                                               |\n  |                                                               formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmphbmHjd/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmphbmHjd/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                  ^^                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n1 + use std :: collections :: HashMap ; fn main () { println ! (\"Hello, World!\" . to_string ()) }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmphbmHjd/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                                                 ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 2,
          "line_number": 86,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Hello\", \"World\", \"from\", \"Ruchy\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 3,
          "line_number": 106,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let name = \"Alice\";\n    println(\"Hello,\", name);\n    \n    // String concatenation (interpolation coming in future versions)\n    println(\"Hello, \" + name + \"!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 4,
          "line_number": 131,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"The answer is\", 42);\n    println(\"Pi is approximately\", 3.14159);\n    println(\"Is Ruchy awesome?\", true);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 5,
          "line_number": 156,
          "code": "// Status: ✅ WORKING\n// ❌ This won't work - intentional error example\n// println(Hello, World!);\n//\n\n// Always use quotes for literal text.\n\nfun main() {\n    // ✅ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmp13HP0j/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                                               ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmp13HP0j/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                               ---------------   ^^^^^^^^^^^^ argument never used\n  |                                                               |\n  |                                                               formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp13HP0j/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp13HP0j/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                  ^^                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n1 + use std :: collections :: HashMap ; fn main () { println ! (\"Hello, World!\" . to_string ()) }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmp13HP0j/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                                                 ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 6,
          "line_number": 176,
          "code": "// Status: ✅ WORKING\n// ❌ Quotes don't match - intentional error example\n// println(\"Hello, World!');\n//\n\n// Use either \"...\" or '...' but be consistent.\n\nfun main() {\n    // ✅ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpjOjXvn/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                                               ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpjOjXvn/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                               ---------------   ^^^^^^^^^^^^ argument never used\n  |                                                               |\n  |                                                               formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpjOjXvn/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpjOjXvn/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                  ^^                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n1 + use std :: collections :: HashMap ; fn main () { println ! (\"Hello, World!\" . to_string ()) }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpjOjXvn/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                                                 ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 7,
          "line_number": 196,
          "code": "// Status: ✅ WORKING\n// ❌ Wrong capitalization - intentional error example\n// PrintLn(\"Hello, World!\");\n//\n\n\nfun main() {\n    // ✅ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpmsH6p5/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                                               ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpmsH6p5/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                               ---------------   ^^^^^^^^^^^^ argument never used\n  |                                                               |\n  |                                                               formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpmsH6p5/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpmsH6p5/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                  ^^                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n1 + use std :: collections :: HashMap ; fn main () { println ! (\"Hello, World!\" . to_string ()) }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpmsH6p5/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                                                 ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 8,
          "line_number": 222,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Hello, World!\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpa1XT8J/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                                               ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpa1XT8J/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                               ---------------   ^^^^^^^^^^^^ argument never used\n  |                                                               |\n  |                                                               formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpa1XT8J/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpa1XT8J/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                  ^^                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n1 + use std :: collections :: HashMap ; fn main () { println ! (\"Hello, World!\" . to_string ()) }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpa1XT8J/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                                                 ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch02-00-variables-types": {
      "chapter": "ch02-00-variables-types",
      "total_examples": 9,
      "working_examples": 6,
      "failing_examples": 3,
      "examples": [
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let name = \"Alice\"\n    let age = 25\n    let is_learning = true\n\n    println(\"Hi\", name, \", you're\", age, \"years old!\")\n    println(\"Currently learning Ruchy:\", is_learning)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 2,
          "line_number": 86,
          "code": "// Status: ✅ WORKING\nfun main() {\n    // Text data\n    let first_name = \"John\"\n    let last_name = \"Doe\"\n    let full_name = first_name + \" \" + last_name\n\n    // Numeric data\n    let score = 95\n    let percentage = 95.5\n    let temperature = -10\n\n    // Boolean (true/false) data\n    let is_student = true\n    let has_graduated = false\n    let is_enrolled = !has_graduated\n\n    println(\"Student:\", full_name)\n    println(\"Score:\", score, \"(\", percentage, \"%)\")\n    println(\"Temperature:\", temperature, \"°C\")\n    println(\"Status: student=\", is_student, \", graduated=\", has_graduated)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 3,
          "line_number": 119,
          "code": "// Status: ✅ WORKING\nfun main() {\n    // Store user information\n    let username = \"programmer2024\"\n    let mut login_count = 1\n    let mut is_premium = false\n\n    // Use variables in calculations\n    let welcome_bonus = 100\n    let total_points = welcome_bonus + (login_count * 10)\n\n    // Update information (use mut for mutable variables)\n    login_count = login_count + 1\n    is_premium = total_points > 150\n\n    println(\"Welcome back,\", username, \"!\")\n    println(\"Logins:\", login_count, \", Points:\", total_points)\n    println(\"Premium status:\", is_premium)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 4,
          "line_number": 149,
          "code": "// Status: ❌ BROKEN\nfun main() {\n    // Store multiple values\n    let favorite_languages = [\"Python\", \"Rust\", \"Ruchy\"]\n    let daily_temperatures = [22.5, 25.0, 23.8, 26.2]\n    let task_completed = [true, false, true, true]\n\n    // Access items by index (starting from 0)\n    println(\"First language:\", favorite_languages[0])\n    println(\"Today's temp:\", daily_temperatures[0], \"°C\")\n\n    // Get list length\n    println(\"I know\", favorite_languages.len(), \"languages\")\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpNVv5iM/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let favorite_languages = vec ! [\"Python\" , \"Rust\" , \"Ruchy\"] ; { let mut daily_tempe...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpNVv5iM/main.rs:1:50\n  |\n1 | ... { { { let favorite_languages = vec ! [\"Python\" , \"Rust\" , \"Ruchy\"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! (\"{} {}\" , \"First language:\" . to_string () , favorite_languages [0i32]) ; println ! (\"{} {} {}\" , \"Today's temp:\" . to_string () , daily_temperatures [0i32] , \"°C\" . to_string ()) ; println ! (\"{} {} {}\" , \"I know\" . to_string () , favorite_languages . len () , \"languages\" . to_string ()) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let favorite_languages = vec ! [\"Python\" , \"Rust\" , \"Ruchy\"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! (\"{} {}\" , \"First language:\" . to_string () , favorite_languages [0i32]) ; println ! (\"{} {} {}\" , \"Today's temp:\" . to_string () , daily_temperatures [0i32] , \"°C\" . to_string ()) ; println ! (\"{} {} {}\" , \"I know\" . to_string () , favorite_languages . len () , \"languages\" . to_string ()) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let favorite_languages = vec ! [\"Python\" , \"Rust\" , \"Ruchy\"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! (\"{} {}\" , \"First language:\" . to_string () , favorite_languages [0i32]) ; println ! (\"{} {} {}\" , \"Today's temp:\" . to_string () , daily_temperatures [0i32] , \"°C\" . to_string ()) ; println ! (\"{} {} {}\" , \"I know\" . to_string () , favorite_languages . len () , \"languages\" . to_string ()) } } }\n  |\n\nerror[E0277]: the type `[&str]` cannot be indexed by `i32`\n --> /tmp/.tmpNVv5iM/main.rs:1:332\n  |\n1 | .... to_string () , favorite_languages [0i32]) ; println ! (\"{} {} {}\" , \"Today's temp:\" . to_string () , daily_temperatures [0i32] , \"°C...\n  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[&str]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<&str>` to implement `Index<i32>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `i32`\n --> /tmp/.tmpNVv5iM/main.rs:1:418\n  |\n1 | .... to_string () , daily_temperatures [0i32] , \"°C\" . to_string ()) ; println ! (\"{} {} {}\" , \"I know\" . to_string () , favorite_languag...\n  |                                         ^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[f64]>` is not implemented for `i32`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `Vec<f64>` to implement `Index<i32>`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 5,
          "line_number": 176,
          "code": "// Status: ❌ BROKEN\n// ❌ This won't work\nfun main() {\n    user_name = \"Alice\"  \n}\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `user_name` in this scope\n --> /tmp/.tmpVQcVC5/main.rs:1:52\n  |\n1 | use std :: collections :: HashMap ; fn main () { { user_name = \"Alice\" } }\n  |                                                    ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpVQcVC5/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { user_name = \"Alice\" } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpVQcVC5/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { user_name = \"Alice\" } }\n  |                                                  ^^                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { user_name = \"Alice\" } }\n1 + use std :: collections :: HashMap ; fn main () { user_name = \"Alice\" }\n  |\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 6,
          "line_number": 192,
          "code": "// Status: ❌ BROKEN\n// ❌ This might not work as expected\nfun main() {\n    let age = \"25\"  // String, not number\n    let next_year = age + 1  // Can't add number to string\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpvWmajy/main.rs:1:102\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let age = \"25\" ; let mut next_year = age + 1i32 } } }\n  |                                                                                                      ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpvWmajy/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let age = \"25\" ; let mut next_year = age + 1i32 } } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpvWmajy/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let age = \"25\" ; let mut next_year = age + 1i32 } } }\n  |                                                  ^^                                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let age = \"25\" ; let mut next_year = age + 1i32 } } }\n1 + use std :: collections :: HashMap ; fn main () { { let age = \"25\" ; let mut next_year = age + 1i32 } }\n  |\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 7,
          "line_number": 210,
          "code": "// Status: ✅ WORKING\n// ❌ These are different variables\nfun main() {\n    let userName = \"Alice\"\n    let username = \"Bob\"\n    println(userName)  // Prints \"Alice\", not \"Bob\"\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 8,
          "line_number": 235,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let name = \"Alice\"\n    let age = 25\n    println(\"Hi\", name, \", age\", age)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 9,
          "line_number": 304,
          "code": "// Status: ✅ WORKING\nfun main() {\n    // Personal profile\n    let name = \"Alex\"\n    let age = 28\n    let city = \"San Francisco\"\n    let hobby = \"rock climbing\"\n    let goal = \"master Ruchy in 30 days\"\n\n    // Data calculator  \n    let num1 = 15\n    let num2 = 25\n    let sum = num1 + num2\n    let difference = num1 - num2\n    let average = (num1 + num2) / 2\n\n    // Text manipulation\n    let first_name = \"Alex\"\n    let last_name = \"Johnson\"\n    let username = first_name + \"_\" + last_name\n    let email = username + \"@example.com\"\n\n    // Boolean logic\n    let is_adult = age >= 18\n    let lives_in_tech_city = city == \"San Francisco\"\n    let ready_for_job = is_adult && lives_in_tech_city\n\n    println(\"Profile:\", name, age, city)\n    println(\"Math:\", sum, difference, average)\n    println(\"Contact:\", username, email)\n    println(\"Status:\", is_adult, lives_in_tech_city, ready_for_job)\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch06-00-data-structures-tdd": {
      "chapter": "ch06-00-data-structures-tdd",
      "total_examples": 8,
      "working_examples": 3,
      "failing_examples": 5,
      "examples": [
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let greeting = \"Hello\";\n    let name = \"World\";\n    println(greeting);\n    println(name);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 2,
          "line_number": 54,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let first = \"Hello\";\n    let second = \"Beautiful\";\n    let third = \"World\";\n    println(first);\n    println(second);\n    println(third);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 3,
          "line_number": 79,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let number = 42;\n    let text = \"Answer\";\n    println(text);\n    println(number);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 4,
          "line_number": 119,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet message = \"Hello World\";\nlet name = \"Alice\";\nlet greeting = \"Welcome\";",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpZlrp0a/main.rs:1:153\n  |\n1 | ...\"Alice\" ; let mut greeting = \"Welcome\" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpZlrp0a/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut message = \"Hello World\" ; let mut name = \"Alice\" ; let mut greeti...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 5,
          "line_number": 130,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet text = \"Count\";\nlet number = 100;\nlet flag = true;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmp76xuV8/main.rs:1:136\n  |\n1 | ... number = 100i32 ; let mut flag = true } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp76xuV8/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut text = \"Count\" ; let mut number = 100i32 ; let mut flag = true } ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 6,
          "line_number": 155,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet first_name = \"John\";\nlet last_name = \"Doe\";\nlet title = \"Mr.\";",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpeA2ZAg/main.rs:1:145\n  |\n1 | ...t_name = \"Doe\" ; let mut title = \"Mr.\" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpeA2ZAg/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut first_name = \"John\" ; let mut last_name = \"Doe\" ; let mut title =...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 7,
          "line_number": 166,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet label = \"Temperature\";\nlet value = 72;\nlet unit = \"Fahrenheit\";",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpmLyYyf/main.rs:1:149\n  |\n1 | ... = 72i32 ; let mut unit = \"Fahrenheit\" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpmLyYyf/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut label = \"Temperature\" ; let mut value = 72i32 ; let mut unit = \"F...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 8,
          "line_number": 177,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet app_name = \"MyApp\";\nlet version = \"1.0\";\nlet debug = true;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmp1sQ5pQ/main.rs:1:141\n  |\n1 | ...version = \"1.0\" ; let mut debug = true } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp1sQ5pQ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut app_name = \"MyApp\" ; let mut version = \"1.0\" ; let mut debug = tr...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch03-00-functions": {
      "chapter": "ch03-00-functions",
      "total_examples": 12,
      "working_examples": 2,
      "failing_examples": 10,
      "examples": [
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\nfun main() {\n    // Organize calculations\n    let name = \"Alice\"  \n    let a = 15\n    let b = 27\n\n    // Reusable greeting logic\n    let greeting = \"Hello, \" + name + \"! Welcome to Ruchy!\"\n\n    // Reusable calculation logic  \n    let sum = a + b\n    let result_message = a + \" + \" + b + \" = \" + sum\n\n    println(greeting)\n    println(result_message)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpVrgG3w/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" ; { let mut a = 15i32 ; let mut b = 27i32 ; let mut greeting = fo...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpVrgG3w/main.rs:1:50\n  |\n1 | ... { { { let name = \"Alice\" ; { let mut a = 15i32 ; let mut b = 27i32 ; let mut greeting = format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hello, \" , name) , \"! Welcome to Ruchy!\") ; let mut sum = a + b ; let mut result_message = format ! (\"{}{}\" , format ! (\"{}{}\" , a , \" + \") + b , \" = \") + sum ; println ! (\"{}\" , greeting) ; println ! (\"{}\" , result_message) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" ; { let mut a = 15i32 ; let mut b = 27i32 ; let mut greeting = format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hello, \" , name) , \"! Welcome to Ruchy!\") ; let mut sum = a + b ; let mut result_message = format ! (\"{}{}\" , format ! (\"{}{}\" , a , \" + \") + b , \" = \") + sum ; println ! (\"{}\" , greeting) ; println ! (\"{}\" , result_message) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let name = \"Alice\" ; { let mut a = 15i32 ; let mut b = 27i32 ; let mut greeting = format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hello, \" , name) , \"! Welcome to Ruchy!\") ; let mut sum = a + b ; let mut result_message = format ! (\"{}{}\" , format ! (\"{}{}\" , a , \" + \") + b , \" = \") + sum ; println ! (\"{}\" , greeting) ; println ! (\"{}\" , result_message) } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpVrgG3w/main.rs:1:317\n  |\n1 | ... format ! (\"{}{}\" , format ! (\"{}{}\" , a , \" + \") + b , \" = \") + sum ; println ! (\"{}\" , greeting) ; println ! (\"{}\" , result_message)...\n  |                                                        ^ expected `&str`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpVrgG3w/main.rs:1:330\n  |\n1 | ...{}\" , format ! (\"{}{}\" , a , \" + \") + b , \" = \") + sum ; println ! (\"{}\" , greeting) ; println ! (\"{}\" , result_message) } } } }\n  |                                                       ^^^ expected `&str`, found `i32`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 2,
          "line_number": 70,
          "code": "// Status: ❌ BROKEN\nfun main() {\n    // Store inputs\n    let input1 = 10\n    let input2 = 20\n\n    // Organize calculations  \n    let sum = input1 + input2\n    let product = input1 * input2\n    let average = sum / 2\n\n    // Organize output\n    let result = \"Sum: \" + sum + \", Product: \" + product + \", Average: \" + average\n    println(result)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpbxsOJx/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpbxsOJx/main.rs:1:50\n  |\n1 | ... { { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let mut product = input1 * input2 ; let mut average = sum / 2i32 ; let mut result = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Sum: \" , sum) , \", Product: \") + product , \", Average: \") + average ; println ! (\"{}\" , result) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let mut product = input1 * input2 ; let mut average = sum / 2i32 ; let mut result = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Sum: \" , sum) , \", Product: \") + product , \", Average: \") + average ; println ! (\"{}\" , result) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let mut product = input1 * input2 ; let mut average = sum / 2i32 ; let mut result = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Sum: \" , sum) , \", Product: \") + product , \", Average: \") + average ; println ! (\"{}\" , result) } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpbxsOJx/main.rs:1:309\n  |\n1 | ...at ! (\"{}{}\" , \"Sum: \" , sum) , \", Product: \") + product , \", Average: \") + average ; println ! (\"{}\" , result) } } } }\n  |                                                     ^^^^^^^ expected `&str`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpbxsOJx/main.rs:1:336\n  |\n1 | ...m) , \", Product: \") + product , \", Average: \") + average ; println ! (\"{}\" , result) } } } }\n  |                                                     ^^^^^^^ expected `&str`, found `i32`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 3,
          "line_number": 98,
          "code": "// Status: ❌ BROKEN\nfun main() {\n    // Template: greeting with name\n    let user_name = \"Alice\"\n    let greeting_template = \"Hello, \" + user_name + \"! Welcome!\"\n\n    // Template: calculation display\n    let num1 = 15\n    let num2 = 27  \n    let operation = \"addition\"\n    let calc_result = num1 + num2\n    let calc_display = operation + \": \" + num1 + \" + \" + num2 + \" = \" + calc_result\n    \n    println(greeting_template)\n    println(calc_display)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp5CDMGl/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let user_name = \"Alice\" ; { let mut greeting_template = format ! (\"{}{}\" , format ! ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5CDMGl/main.rs:1:50\n  |\n1 | ... { { { let user_name = \"Alice\" ; { let mut greeting_template = format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hello, \" , user_name) , \"! Welcome!\") ; let mut num1 = 15i32 ; let mut num2 = 27i32 ; let mut operation = \"addition\" ; let mut calc_result = num1 + num2 ; let mut calc_display = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , operation , \": \") + num1 , \" + \") + num2 , \" = \") + calc_result ; println ! (\"{}\" , greeting_template) ; println ! (\"{}\" , calc_display) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let user_name = \"Alice\" ; { let mut greeting_template = format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hello, \" , user_name) , \"! Welcome!\") ; let mut num1 = 15i32 ; let mut num2 = 27i32 ; let mut operation = \"addition\" ; let mut calc_result = num1 + num2 ; let mut calc_display = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , operation , \": \") + num1 , \" + \") + num2 , \" = \") + calc_result ; println ! (\"{}\" , greeting_template) ; println ! (\"{}\" , calc_display) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let user_name = \"Alice\" ; { let mut greeting_template = format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hello, \" , user_name) , \"! Welcome!\") ; let mut num1 = 15i32 ; let mut num2 = 27i32 ; let mut operation = \"addition\" ; let mut calc_result = num1 + num2 ; let mut calc_display = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , operation , \": \") + num1 , \" + \") + num2 , \" = \") + calc_result ; println ! (\"{}\" , greeting_template) ; println ! (\"{}\" , calc_display) } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp5CDMGl/main.rs:1:404\n  |\n1 | ... (\"{}{}\" , format ! (\"{}{}\" , operation , \": \") + num1 , \" + \") + num2 , \" = \") + calc_result ; println ! (\"{}\" , greeting_template) ;...\n  |                                                      ^^^^ expected `&str`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp5CDMGl/main.rs:1:420\n  |\n1 | ...t ! (\"{}{}\" , operation , \": \") + num1 , \" + \") + num2 , \" = \") + calc_result ; println ! (\"{}\" , greeting_template) ; println ! (\"{}\"...\n  |                                                      ^^^^ expected `&str`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp5CDMGl/main.rs:1:436\n  |\n1 | ...tion , \": \") + num1 , \" + \") + num2 , \" = \") + calc_result ; println ! (\"{}\" , greeting_template) ; println ! (\"{}\" , calc_display) } ...\n  |                                                   ^^^^^^^^^^^ expected `&str`, found `i32`\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 4,
          "line_number": 127,
          "code": "// Status: ❌ BROKEN\nfun main() {\n    // Input section\n    let temperature_f = 68\n    let user_location = \"San Francisco\"\n\n    // Processing section  \n    let temperature_c = (temperature_f - 32) * 5 / 9\n    let is_comfortable = temperature_c > 18 && temperature_c < 25\n\n    // Output section\n    let weather_report = \"Weather in \" + user_location + \": \" + temperature_f + \"°F (\" + temperature_c + \"°C)\"\n    let comfort_message = if is_comfortable { \"Perfect weather!\" } else { \"Dress accordingly\" }\n\n    println(weather_report)\n    println(comfort_message)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpXOxC2b/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = \"San Francisco\" ; let mut temp...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXOxC2b/main.rs:1:50\n  |\n1 | ... { { { let temperature_f = 68i32 ; { let mut user_location = \"San Francisco\" ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Weather in \" , user_location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{}\" , weather_report) ; println ! (\"{}\" , comfort_message) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = \"San Francisco\" ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Weather in \" , user_location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{}\" , weather_report) ; println ! (\"{}\" , comfort_message) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let temperature_f = 68i32 ; { let mut user_location = \"San Francisco\" ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Weather in \" , user_location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{}\" , weather_report) ; println ! (\"{}\" , comfort_message) } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXOxC2b/main.rs:1:501\n  |\n1 | ... \"°C)\") ; let mut comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{}\" , ...\n  |                                                            ^^                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = \"San Francisco\" ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Weather in \" , user_location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{}\" , weather_report) ; println ! (\"{}\" , comfort_message) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = \"San Francisco\" ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Weather in \" , user_location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfortable { \"Perfect weather!\" } else { { \"Dress accordingly\" } } ; println ! (\"{}\" , weather_report) ; println ! (\"{}\" , comfort_message) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXOxC2b/main.rs:1:533\n  |\n1 | ... = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{}\" , weather_report) ; println ! (\"{}\"...\n  |                                                           ^^                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = \"San Francisco\" ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Weather in \" , user_location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{}\" , weather_report) ; println ! (\"{}\" , comfort_message) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = \"San Francisco\" ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Weather in \" , user_location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { \"Dress accordingly\" } ; println ! (\"{}\" , weather_report) ; println ! (\"{}\" , comfort_message) } } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXOxC2b/main.rs:1:404\n  |\n1 | ...}\" , \"Weather in \" , user_location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfo...\n  |                                                  ^^^^^^^^^^^^^ expected `&str`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXOxC2b/main.rs:1:430\n  |\n1 | ...location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfortable { { \"Perfect weathe...\n  |                                                  ^^^^^^^^^^^^^ expected `&str`, found `i32`\n\nerror: aborting due to 2 previous errors; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 5,
          "line_number": 158,
          "code": "// Status: ❌ BROKEN\n// Mathematical operations\nfun square(x) {\n    x * x\n}\n\nfun circle_area(radius) {\n    let pi = 3.14159\n    pi * square(radius)\n}\n\n// Text processing\nfun make_username(first_name, last_name) {\n    first_name + \"_\" + last_name\n}\n\nfun shout(message) {\n    message + \"!!!\"\n}\n\nfun main() {\n    // Use them together\n    let area = circle_area(5)\n    let username = make_username(\"Alice\", \"Johnson\") \n    let excited = shout(\"I love functions\")\n\n    println(\"Circle area:\", area)\n    println(\"Username:\", username)\n    println(excited)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpkH0a0e/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: D...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpkH0a0e/main.rs:1:192\n  |\n1 | ...fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std ...\n  |                                                                  ^^     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"{} {}\" , \"Circle area:\" . to_string () , area) ; println ! (\"{} {}\" , \"Username:\" . to_string () , username) ; println ! (\"{}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { x * x } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"{} {}\" , \"Circle area:\" . to_string () , area) ; println ! (\"{} {}\" , \"Username:\" . to_string () , username) ; println ! (\"{}\" , excited) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpkH0a0e/main.rs:1:369\n  |\n1 | ...mt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Ad...\n  |                                              ^^                                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"{} {}\" , \"Circle area:\" . to_string () , area) ; println ! (\"{} {}\" , \"Username:\" . to_string () , username) ; println ! (\"{}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { let pi = 3.14159f64 ; pi * square (radius) } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"{} {}\" , \"Circle area:\" . to_string () , area) ; println ! (\"{} {}\" , \"Username:\" . to_string () , username) ; println ! (\"{}\" , excited) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpkH0a0e/main.rs:1:609\n  |\n1 | ... (first_name : T , last_name : T) -> T { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout < T : std :: ops :: Add < Out...\n  |                                             ^^                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"{} {}\" , \"Circle area:\" . to_string () , area) ; println ! (\"{} {}\" , \"Username:\" . to_string () , username) ; println ! (\"{}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { format ! (\"{}{}\" , first_name , \"_\") + last_name } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"{} {}\" , \"Circle area:\" . to_string () , area) ; println ! (\"{} {}\" , \"Username:\" . to_string () , username) ; println ! (\"{}\" , excited) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpkH0a0e/main.rs:1:824\n  |\n1 | ...:: fmt :: Debug + Clone > (message : T) -> T { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32...\n  |                                                   ^^                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"{} {}\" , \"Circle area:\" . to_string () , area) ; println ! (\"{} {}\" , \"Username:\" . to_string () , username) ; println ! (\"{}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { format ! (\"{}{}\" , message , \"!!!\") } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"{} {}\" , \"Circle area:\" . to_string () , area) ; println ! (\"{} {}\" , \"Username:\" . to_string () , username) ; println ! (\"{}\" , excited) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpkH0a0e/main.rs:1:879\n  |\n1 | ... { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"{} {}\" , \"Circle area:\" . to_string () , area) ; println ! (\"{} {}\" , \"Username:\" . to_string () , username) ; println ! (\"{}\" , excited) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"{} {}\" , \"Circle area:\" . to_string () , area) ; println ! (\"{} {}\" , \"Username:\" . to_string () , username) ; println ! (\"{}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"{} {}\" , \"Circle area:\" . to_string () , area) ; println ! (\"{} {}\" , \"Username:\" . to_string () , username) ; println ! (\"{}\" , excited) } } }\n  |\n\nerror[E0277]: cannot multiply `f64` by `T`\n --> /tmp/.tmpkH0a0e/main.rs:1:398\n  |\n1 | ... (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + st...\n  |                                                      ^ no implementation for `f64 * T`\n  |\n  = help: the trait `Mul<T>` is not implemented for `f64`\nhelp: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n  |\n1 | use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T where f64: Mul<T> { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"{} {}\" , \"Circle area:\" . to_string () , area) ; println ! (\"{} {}\" , \"Username:\" . to_string () , username) ; println ! (\"{}\" , excited) } } } }\n  |                                                                                                                                                                                                                                                                                                                                                                               +++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpkH0a0e/main.rs:1:650\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! (\"{}{}\" , first_name , \"_\") + last_name } ...\n  |       - found this type parameter                                                                                                                                                                                      ^^^^^^^^^ expected `&str`, found type parameter `T`\n  |\n  = note:   expected reference `&str`\n          found type parameter `T`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpkH0a0e/main.rs:1:611\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! (\"{}{}\" , first_name , \"_\") + last_name } ...\n  |       -                                                                                                                                                                   -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `String`\n  |       |                                                                                                                                                                   |\n  |       expected this type parameter                                                                                                                                        expected `T` because of return type\n  |\n  = note: expected type parameter `T`\n                     found struct `String`\n  = note: the caller chooses a type for `T` which can be different from `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpkH0a0e/main.rs:1:826\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! (\"{}{}\" , message , \"!!!\") } ...\n  |       -                                                                                                                                                -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `String`\n  |       |                                                                                                                                                |\n  |       expected this type parameter                                                                                                                     expected `T` because of return type\n  |\n  = note: expected type parameter `T`\n                     found struct `String`\n  = note: the caller chooses a type for `T` which can be different from `String`\n  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add `String` to `String`\n --> /tmp/.tmpkH0a0e/main.rs:1:936\n  |\n1 | ...rcle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"...\n  |                                            ^^^^^^^^^^^^^ no implementation for `String + String`\n  |\n  = help: the trait `Add<String>` is not implemented for `String`\n          but trait `Add<&str>` is implemented for it\n  = help: for that trait implementation, expected `&str`, found `String`\nnote: required by a bound in `make_username`\n --> /tmp/.tmpkH0a0e/main.rs:1:445\n  |\n1 | ... } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...\n  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `make_username`\n\nerror[E0277]: cannot multiply `String` by `String`\n --> /tmp/.tmpkH0a0e/main.rs:1:936\n  |\n1 | ...rcle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"...\n  |                                            ^^^^^^^^^^^^^ no implementation for `String * String`\n  |\n  = help: the trait `Mul` is not implemented for `String`\nnote: required by a bound in `make_username`\n --> /tmp/.tmpkH0a0e/main.rs:1:480\n  |\n1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T...\n  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `make_username`\n\nerror[E0277]: cannot add `String` to `String`\n --> /tmp/.tmpkH0a0e/main.rs:1:1029\n  |\n1 | ...ng ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"{} {}\" , \"Circle area:\" . to_string () , area) ; pr...\n  |                               -----  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String + String`\n  |                               |\n  |                               required by a bound introduced by this call\n  |\n  = help: the trait `Add<String>` is not implemented for `String`\n          but trait `Add<&str>` is implemented for it\n  = help: for that trait implementation, expected `&str`, found `String`\nnote: required by a bound in `shout`\n --> /tmp/.tmpkH0a0e/main.rs:1:679\n  |\n1 | ...\") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std ::...\n  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `shout`\n\nerror[E0277]: cannot multiply `String` by `String`\n --> /tmp/.tmpkH0a0e/main.rs:1:1029\n  |\n1 | ...ng ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"{} {}\" , \"Circle area:\" . to_string () , area) ; pr...\n  |                               -----  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String * String`\n  |                               |\n  |                               required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `String`\nnote: required by a bound in `shout`\n --> /tmp/.tmpkH0a0e/main.rs:1:714\n  |\n1 | ...td :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : ...\n  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `shout`\n\nerror[E0382]: use of moved value: `x`\n   --> /tmp/.tmpkH0a0e/main.rs:1:198\n    |\n1   | ...: fmt :: Debug + Clone > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output...\n    |                              -               ----^\n    |                              |               |   |\n    |                              |               |   value used here after move\n    |                              |               `x` moved due to usage in operator\n    |                              move occurs because `x` has type `T`, which does not implement the `Copy` trait\n    |\nnote: calling this operator moves the left-hand side\n   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:333:12\n    |\n333 |     fn mul(self, rhs: Rhs) -> Self::Output;\n    |            ^^^^\nhelp: consider cloning the value if the performance cost is acceptable\n    |\n1   | use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x.clone() * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"{} {}\" , \"Circle area:\" . to_string () , area) ; println ! (\"{} {}\" , \"Username:\" . to_string () , username) ; println ! (\"{}\" , excited) } } } }\n    |                                                                                                                                                                                                   ++++++++\nhelp: consider further restricting type parameter `T` with trait `Copy`\n    |\n1   | use std :: collections :: HashMap ; fn square < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + Copy > (x : T) -> T { { x * x } } fn circle_area < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (radius : T) -> T { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (first_name : T , last_name : T) -> T { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (message : T) -> T { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"{} {}\" , \"Circle area:\" . to_string () , area) ; println ! (\"{} {}\" , \"Username:\" . to_string () , username) ; println ! (\"{}\" , excited) } } } }\n    |                                                                                                                                                                               ++++++\n\nerror: aborting due to 9 previous errors; 6 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0382.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 6,
          "line_number": 200,
          "code": "// Status: ❌ BROKEN\nfun is_even(number) {\n    number % 2 == 0\n}\n\nfun grade_letter(score) {\n    if score >= 90 {\n        \"A\"\n    } else if score >= 80 {\n        \"B\"\n    } else if score >= 70 {\n        \"C\"\n    } else if score >= 60 {\n        \"D\"\n    } else {\n        \"F\"\n    }\n}\n\nfun describe_number(n) {\n    let even_odd = if is_even(n) { \"even\" } else { \"odd\" }\n    let size = if n > 100 { \"large\" } else { \"small\" }\n    n + \" is a \" + size + \" \" + even_odd + \" number\"\n}\n\nfun main() {\n    // Test your functions\n    println(describe_number(42))   // \"42 is a small even number\"\n    println(describe_number(150))  // \"150 is a large even number\"\n    println(grade_letter(85))      // \"B\"\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpWGC9HN/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpWGC9HN/main.rs:1:198\n  |\n1 | ...y + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T...\n  |                                                          ^^                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { number % 2i32 == 0i32 } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpWGC9HN/main.rs:1:391\n  |\n1 | ... { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } ...\n  |       ^^                                                                                                                                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpWGC9HN/main.rs:1:413\n  |\n1 | ...mt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { \"A\" } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpWGC9HN/main.rs:1:450\n  |\n1 | ...T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { \"B\" } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpWGC9HN/main.rs:1:487\n  |\n1 | ...lse { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } }...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { \"C\" } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpWGC9HN/main.rs:1:524\n  |\n1 | ...lse { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: op...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { \"D\" } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpWGC9HN/main.rs:1:541\n  |\n1 | ... 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { \"F\" } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpWGC9HN/main.rs:1:725\n  |\n1 | ... { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } ...\n  |       ^^                                                                                                                                                                                                                                                          ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpWGC9HN/main.rs:1:761\n  |\n1 | ... + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"la...\n  |                                                                  ^^      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { \"even\" } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpWGC9HN/main.rs:1:781\n  |\n1 | ...> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"s...\n  |                                                                  ^^     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { \"odd\" } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpWGC9HN/main.rs:1:828\n  |\n1 | ...n\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" ...\n  |                                                                 ^^       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { \"large\" } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpWGC9HN/main.rs:1:849\n  |\n1 | ... } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , ...\n  |                                                                 ^^       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { \"small\" } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |\n\nerror[E0369]: cannot calculate the remainder of `T` divided by `i32`\n --> /tmp/.tmpWGC9HN/main.rs:1:207\n  |\n1 | ...lay + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output =...\n  |                                                              ------ ^ ---- i32\n  |                                                              |\n  |                                                              T\n  |\nhelp: consider further restricting type parameter `T` with trait `Rem`\n  |\n1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Rem<i32> > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |                                                                                                                                                                                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpWGC9HN/main.rs:1:200\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } ...\n  |       -                                                                                                                                               -     ^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `bool`\n  |       |                                                                                                                                               |\n  |       expected this type parameter                                                                                                                    expected `T` because of return type\n  |\n  = note: expected type parameter `T`\n                       found type `bool`\n  = note: the caller chooses a type for `T` which can be different from `bool`\n\nerror[E0369]: binary operation `>=` cannot be applied to type `T`\n --> /tmp/.tmpWGC9HN/main.rs:1:402\n  |\n1 | ...y + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if sc...\n  |                                                              ----- ^^ ----- i32\n  |                                                              |\n  |                                                              T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpWGC9HN/main.rs:1:415\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } ...\n  |       -                                                                                                                                              -                           ^^^ expected type parameter `T`, found `&str`\n  |       |                                                                                                                                              |\n  |       expected this type parameter                                                                                                                   expected `T` because of return type\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n  = note: the caller chooses a type for `T` which can be different from `&'static str`\n\nerror[E0369]: binary operation `>=` cannot be applied to type `T`\n --> /tmp/.tmpWGC9HN/main.rs:1:439\n  |\n1 | ...ore : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if sc...\n  |                                                              ----- ^^ ----- i32\n  |                                                              |\n  |                                                              T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpWGC9HN/main.rs:1:452\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } ...\n  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                            ^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n  = note: the caller chooses a type for `T` which can be different from `&'static str`\n\nerror[E0369]: binary operation `>=` cannot be applied to type `T`\n --> /tmp/.tmpWGC9HN/main.rs:1:476\n  |\n1 | ... { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\"...\n  |                                                              ----- ^^ ----- i32\n  |                                                              |\n  |                                                              T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpWGC9HN/main.rs:1:489\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } ...\n  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                 ^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n  = note: the caller chooses a type for `T` which can be different from `&'static str`\n\nerror[E0369]: binary operation `>=` cannot be applied to type `T`\n --> /tmp/.tmpWGC9HN/main.rs:1:513\n  |\n1 | ... { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T...\n  |                                                              ----- ^^ ----- i32\n  |                                                              |\n  |                                                              T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                  +++++++++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpWGC9HN/main.rs:1:526\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } ...\n  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                                                      ^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n  = note: the caller chooses a type for `T` which can be different from `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpWGC9HN/main.rs:1:543\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } ...\n  |       - expected this type parameter                                                                                                                 - expected `T` because of return type                                                                                                                       ^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n  = note: the caller chooses a type for `T` which can be different from `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpWGC9HN/main.rs:1:756\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) {...\n  |       -                                                                                                                                                                    -------  ^ expected `bool`, found type parameter `T`\n  |       |                                                                                                                                                                    |\n  |       found this type parameter                                                                                                                                            arguments to this function are incorrect\n  |\n  = note:        expected type `bool`\n          found type parameter `T`\nhelp: the return type of this call is `T` due to the type of the argument passed\n --> /tmp/.tmpWGC9HN/main.rs:1:747\n  |\n1 | ... : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else...\n  |                                       ^^^^^^^^^-^\n  |                                                |\n  |                                                this argument influences the return type of `is_even`\nnote: function defined here\n --> /tmp/.tmpWGC9HN/main.rs:1:40\n  |\n1 | ...fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -...\n  |       ^^^^^^^                                                                                                                                    ----------\n\nerror[E0277]: cannot add `bool` to `bool`\n --> /tmp/.tmpWGC9HN/main.rs:1:756\n  |\n1 | ...e > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } ...\n  |                                             -------  ^ no implementation for `bool + bool`\n  |                                             |\n  |                                             required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `bool`\nnote: required by a bound in `is_even`\n --> /tmp/.tmpWGC9HN/main.rs:1:54\n  |\n1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: ...\n  |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_even`\n\nerror[E0277]: cannot multiply `bool` by `bool`\n --> /tmp/.tmpWGC9HN/main.rs:1:756\n  |\n1 | ...e > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } ...\n  |                                             -------  ^ no implementation for `bool * bool`\n  |                                             |\n  |                                             required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `bool`\nnote: required by a bound in `is_even`\n --> /tmp/.tmpWGC9HN/main.rs:1:89\n  |\n1 | ...d :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T)...\n  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_even`\n\nerror[E0369]: binary operation `>` cannot be applied to type `T`\n --> /tmp/.tmpWGC9HN/main.rs:1:817\n  |\n1 | ...(n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , forma...\n  |                                                                - ^ ------ i32\n  |                                                                |\n  |                                                                T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn is_even < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (number : T) -> T { { number % 2i32 == 0i32 } } fn grade_letter < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (score : T) -> T { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{}\" , describe_number (42i32)) ; println ! (\"{}\" , describe_number (150i32)) ; println ! (\"{}\" , grade_letter (85i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    +++++++++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpWGC9HN/main.rs:1:865\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (n : T) -> T { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } ...\n  |       - expected this type parameter                                                                                                             - expected `T` because of return type                                                                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `String`\n  |\n  = note: expected type parameter `T`\n                     found struct `String`\n  = note: the caller chooses a type for `T` which can be different from `String`\n  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 16 previous errors; 13 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 7,
          "line_number": 243,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\nfun calculate_total(prices) {\n    let mut total = 0.0\n    let mut i = 0\n    while i < prices.len() {\n        total = total + prices[i]\n        i = i + 1\n    }\n    total\n}\n\nfun find_max(numbers) {\n    let mut max_val = numbers[0]\n    let mut i = 0\n    while i < numbers.len() {\n        if numbers[i] > max_val {\n            max_val = numbers[i]\n        }\n        i = i + 1\n    }\n    max_val\n}\n\nfun count_words(text) {\n    let words = text.split(\" \")\n    words.len()\n}\n\nfun main() {\n    // Real-world usage\n    let shopping_cart = [19.99, 5.50, 12.00, 8.75]\n    let test_scores = [85, 92, 78, 96, 88]\n    let essay = \"Functions make code reusable and testable\"\n\n    println(\"Total cost: $\", calculate_total(shopping_cart))\n    println(\"Highest score:\", find_max(test_scores))\n    println(\"Word count:\", count_words(essay))\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpi3fHcZ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std ::...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpi3fHcZ/main.rs:1:615\n  |\n1 | ...e i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T ...\n  |                                                          ^^                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" . to_string () , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" . to_string () , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" . to_string () , count_words (essay)) } } } }\n1 + use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { max_val = numbers [i] } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" . to_string () , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" . to_string () , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" . to_string () , count_words (essay)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpi3fHcZ/main.rs:1:839\n  |\n1 | ...t :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = ...\n  |                                           ^^                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" . to_string () , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" . to_string () , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" . to_string () , count_words (essay)) } } } }\n1 + use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { let words = text . split (\" \") ; words . len () } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" . to_string () , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" . to_string () , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" . to_string () , count_words (essay)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpi3fHcZ/main.rs:1:910\n  |\n1 | ... { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" . to_string () , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" . to_string () , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" . to_string () , count_words (essay)) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" . to_string () , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" . to_string () , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" . to_string () , count_words (essay)) } } } }\n1 + use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" . to_string () , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" . to_string () , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" . to_string () , count_words (essay)) } } }\n  |\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmpi3fHcZ/main.rs:1:269\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                                                                   ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" . to_string () , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" . to_string () , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" . to_string () , count_words (essay)) } } } }\n  |                                                                                                                                                                                        +++++++++++++++++++\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmpi3fHcZ/main.rs:1:303\n  |\n1 | ... i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Ad...\n  |                                                                     ^^^\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpi3fHcZ/main.rs:1:328\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } ...\n  |       - expected this type parameter                                                                                                                  - expected `T` because of return type                                                                                         ^^^^^ expected type parameter `T`, found `f64`\n  |\n  = note: expected type parameter `T`\n                       found type `f64`\n  = note: the caller chooses a type for `T` which can be different from `f64`\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmpi3fHcZ/main.rs:1:529\n  |\n1 | ...ebug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers ...\n  |                                                                    ^^^^^^\n\nerror[E0599]: no method named `len` found for type parameter `T` in the current scope\n --> /tmp/.tmpi3fHcZ/main.rs:1:577\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len ()...\n  |       - method `len` not found for this type parameter                                                                                                                                                                                 ^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `len`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + ExactSizeIterator > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" . to_string () , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" . to_string () , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" . to_string () , count_words (essay)) } } } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              +++++++++++++++++++\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmpi3fHcZ/main.rs:1:599\n  |\n1 | ...] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_...\n  |                                                                     ^^^\n\nerror[E0608]: cannot index into a value of type `T`\n --> /tmp/.tmpi3fHcZ/main.rs:1:635\n  |\n1 | ...bers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ...\n  |                                                                     ^^^\n\nerror[E0599]: no method named `split` found for type parameter `T` in the current scope\n --> /tmp/.tmpi3fHcZ/main.rs:1:862\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\"...\n  |       - method `split` not found for this type parameter                                                                                                                       ^^^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `split`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i] ; i = i + 1i32 } } ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = numbers [0i32] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i] > max_val { { max_val = numbers [i] } } ; i = i + 1i32 } } ; max_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + BufRead > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" ; println ! (\"{} {}\" , \"Total cost: $\" . to_string () , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" . to_string () , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" . to_string () , count_words (essay)) } } } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   +++++++++\n\nerror[E0277]: cannot add `Vec<f64>` to `Vec<f64>`\n --> /tmp/.tmpi3fHcZ/main.rs:1:1185\n  |\n1 | ...tal cost: $\" . to_string () , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" . to_string () , find_max (test...\n  |                                  ---------------  ^^^^^^^^^^^^^ no implementation for `Vec<f64> + Vec<f64>`\n  |                                  |\n  |                                  required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `Vec<f64>`\nnote: required by a bound in `calculate_total`\n --> /tmp/.tmpi3fHcZ/main.rs:1:62\n  |\n1 | ...p ; fn calculate_total < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt ...\n  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `calculate_total`\n\nerror[E0277]: cannot multiply `Vec<f64>` by `Vec<f64>`\n --> /tmp/.tmpi3fHcZ/main.rs:1:1185\n  |\n1 | ...tal cost: $\" . to_string () , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" . to_string () , find_max (test...\n  |                                  ---------------  ^^^^^^^^^^^^^ no implementation for `Vec<f64> * Vec<f64>`\n  |                                  |\n  |                                  required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `Vec<f64>`\nnote: required by a bound in `calculate_total`\n --> /tmp/.tmpi3fHcZ/main.rs:1:97\n  |\n1 | ... ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> ...\n  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `calculate_total`\n\nerror[E0277]: `Vec<f64>` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpi3fHcZ/main.rs:1:1185\n  |\n1 | ...$\" . to_string () , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" . to_string () , find_max (test_scores)) ...\n  |                        ---------------  ^^^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `Vec<f64>`\n  |                        |\n  |                        required by a bound introduced by this call\n  |\nnote: required by a bound in `calculate_total`\n --> /tmp/.tmpi3fHcZ/main.rs:1:132\n  |\n1 | ...td :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (prices : T) -> T { { let mut total = 0f64 ; l...\n  |                                      ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `calculate_total`\n\nerror[E0277]: `Vec<f64>` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpi3fHcZ/main.rs:1:1168\n  |\n1 | ...{} {}\" , \"Total cost: $\" . to_string () , calculate_total (shopping_cart)) ; println ! (\"{} {}\" , \"Highest score:\" . to_string () , fi...\n  |       --                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `Vec<f64>` cannot be formatted with the default formatter\n  |       |\n  |       required by this formatting parameter\n  |\n  = help: the trait `std::fmt::Display` is not implemented for `Vec<f64>`\n  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add `Vec<i32>` to `Vec<i32>`\n --> /tmp/.tmpi3fHcZ/main.rs:1:1268\n  |\n1 | ...\"Highest score:\" . to_string () , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" . to_string () , count_words (essay)) }...\n  |                                      --------  ^^^^^^^^^^^ no implementation for `Vec<i32> + Vec<i32>`\n  |                                      |\n  |                                      required by a bound introduced by this call\n  |\n  = help: the trait `Add` is not implemented for `Vec<i32>`\nnote: required by a bound in `find_max`\n --> /tmp/.tmpi3fHcZ/main.rs:1:356\n  |\n1 | ...} ; total } } fn find_max < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: f...\n  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`\n\nerror[E0277]: cannot multiply `Vec<i32>` by `Vec<i32>`\n --> /tmp/.tmpi3fHcZ/main.rs:1:1268\n  |\n1 | ...\"Highest score:\" . to_string () , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" . to_string () , count_words (essay)) }...\n  |                                      --------  ^^^^^^^^^^^ no implementation for `Vec<i32> * Vec<i32>`\n  |                                      |\n  |                                      required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `Vec<i32>`\nnote: required by a bound in `find_max`\n --> /tmp/.tmpi3fHcZ/main.rs:1:391\n  |\n1 | ... :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T)...\n  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`\n\nerror[E0277]: `Vec<i32>` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpi3fHcZ/main.rs:1:1268\n  |\n1 | ...core:\" . to_string () , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" . to_string () , count_words (essay)) } } } }\n  |                            --------  ^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `Vec<i32>`\n  |                            |\n  |                            required by a bound introduced by this call\n  |\nnote: required by a bound in `find_max`\n --> /tmp/.tmpi3fHcZ/main.rs:1:426\n  |\n1 | ... + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (numbers : T) -> T { { let mut max_val = n...\n  |                                          ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `find_max`\n\nerror[E0277]: `Vec<i32>` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpi3fHcZ/main.rs:1:1258\n  |\n1 | ...! (\"{} {}\" , \"Highest score:\" . to_string () , find_max (test_scores)) ; println ! (\"{} {}\" , \"Word count:\" . to_string () , count_wor...\n  |           --                                      ^^^^^^^^^^^^^^^^^^^^^^ `Vec<i32>` cannot be formatted with the default formatter\n  |           |\n  |           required by this formatting parameter\n  |\n  = help: the trait `std::fmt::Display` is not implemented for `Vec<i32>`\n  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add `&str` to `&str`\n --> /tmp/.tmpi3fHcZ/main.rs:1:1349\n  |\n1 | ...} {}\" , \"Word count:\" . to_string () , count_words (essay)) } } } }\n  |                                           -----------  ^^^^^ no implementation for `&str + &str`\n  |                                           |\n  |                                           required by a bound introduced by this call\n  |\n  = help: the trait `Add<&str>` is not implemented for `&str`\n          but it is implemented for `String`\n  = help: for that trait implementation, expected `String`, found `&str`\nnote: required by a bound in `count_words`\n --> /tmp/.tmpi3fHcZ/main.rs:1:697\n  |\n1 | ...x_val } } fn count_words < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fm...\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_words`\n\nerror[E0277]: cannot multiply `&str` by `&str`\n --> /tmp/.tmpi3fHcZ/main.rs:1:1349\n  |\n1 | ...} {}\" , \"Word count:\" . to_string () , count_words (essay)) } } } }\n  |                                           -----------  ^^^^^ no implementation for `&str * &str`\n  |                                           |\n  |                                           required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `&str`\nnote: required by a bound in `count_words`\n --> /tmp/.tmpi3fHcZ/main.rs:1:732\n  |\n1 | ...:: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> ...\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `count_words`\n\nerror: aborting due to 18 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0599, E0608.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: len()"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 8,
          "line_number": 294,
          "code": "// Status: ✅ WORKING\n// ❌ This returns nothing (unit type)\nfun bad_add(a, b) {\n    a + b;\n    // The semicolon makes this a statement, returns ()\n}\n\n// ✅ This returns the sum\nfun good_add(a, b) {\n    a + b  // No semicolon - this is an expression\n}\n\nfun main() {\n    println(good_add(2, 3))\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 9,
          "line_number": 319,
          "code": "// Status: ❌ BROKEN\nfun greet(name, age) {\n    \"Hi \" + name + \", you're \" + age + \" years old\"\n}\n\nfun main() {\n    // ❌ This won't work\n    let msg = greet(\"Alice\")  // Missing age parameter\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpJykFf3/main.rs:1:374\n  |\n1 | ...t msg = greet (\"Alice\" . to_string ()) } }\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpJykFf3/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn greet < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Di...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpJykFf3/main.rs:1:204\n  |\n1 | ... T) -> T { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hi \" , name) , \", you're \") + age , \" years old\") } } fn main (...\n  |               ^^                                                                                                           ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn greet < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hi \" , name) , \", you're \") + age , \" years old\") } } fn main () { { let msg = greet (\"Alice\" . to_string ()) } }\n1 + use std :: collections :: HashMap ; fn greet < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hi \" , name) , \", you're \") + age , \" years old\") } fn main () { { let msg = greet (\"Alice\" . to_string ()) } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpJykFf3/main.rs:1:294\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hi \" , name) , \", you're \") + age , ...\n  |       - found this type parameter                                                                                                                                                                                                                           ^^^ expected `&str`, found type parameter `T`\n  |\n  = note:   expected reference `&str`\n          found type parameter `T`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpJykFf3/main.rs:1:206\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (name : T , age : T) -> T { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hi \" , name) , \", you're \") + age , \" years old\") } ...\n  |       -                                                                                                                                                       -     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `String`\n  |       |                                                                                                                                                       |\n  |       expected this type parameter                                                                                                                            expected `T` because of return type\n  |\n  = note: expected type parameter `T`\n                     found struct `String`\n  = note: the caller chooses a type for `T` which can be different from `String`\n  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 10,
          "line_number": 340,
          "code": "// Status: ❌ BROKEN\n// ❌ Parameters are read-only\nfun bad_function(x) {\n    x = x + 1  \n    x\n}\n\n// ✅ Create new variables inside functions\nfun good_function(x) {\n    let result = x + 1\n    result\n}\n\nfun main() {\n    println(good_function(5))\n}\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpfuU0nL/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fm...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpfuU0nL/main.rs:1:383\n  |\n1 | ... + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { { println ! (\"{}\" , good_functio...\n  |                                                    ^^                                  ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { { println ! (\"{}\" , good_function (5i32)) } }\n1 + use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { let result = x + 1i32 ; result } } fn main () { { println ! (\"{}\" , good_function (5i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpfuU0nL/main.rs:1:437\n  |\n1 | ...esult = x + 1i32 ; result } } } fn main () { { println ! (\"{}\" , good_function (5i32)) } }\n  |                                                 ^^                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { { println ! (\"{}\" , good_function (5i32)) } }\n1 + use std :: collections :: HashMap ; fn bad_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; x } } fn good_function < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; result } } } fn main () { println ! (\"{}\" , good_function (5i32)) }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpfuU0nL/main.rs:1:208\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { x = x + 1i32 ; ...\n  |       -                                                                                                                                                    -   ^^^^ expected type parameter `T`, found `i32`\n  |       |                                                                                                                                                    |\n  |       expected this type parameter                                                                                                                         expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                       found type `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpfuU0nL/main.rs:1:404\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (x : T) -> T { { { let result = x + 1i32 ; ...\n  |       -                                                                                                                                                               -   ^^^^ expected type parameter `T`, found `i32`\n  |       |                                                                                                                                                               |\n  |       expected this type parameter                                                                                                                                    expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                       found type `i32`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 11,
          "line_number": 373,
          "code": "// Status: ✅ WORKING\nfun add(a, b) {\n    a + b\n}\n\nfun main() {\n    let result = add(10, 20)\n    println(result)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 12,
          "line_number": 468,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n// Personal calculator\nfun celsius_to_fahrenheit(celsius) {\n    (celsius * 9 / 5) + 32\n}\n\nfun calculate_bmi(weight_kg, height_m) {\n    weight_kg / (height_m * height_m)\n}\n\nfun apply_discount(price, discount_percent) {\n    let discount = price * (discount_percent / 100)\n    price - discount\n}\n\n// Text tools\nfun word_count(text) {\n    let words = text.split(\" \")\n    words.len()\n}\n\nfun get_initials(full_name) {\n    let words = full_name.split(\" \")\n    let mut initials = \"\"\n    let mut i = 0\n    while i < words.len() {\n        let word = words[i]\n        initials = initials + word[0]\n        i = i + 1\n    }\n    initials\n}\n\n// Decision makers\nfun recommend_activity(energy_level, available_time) {\n    if energy_level > 7 && available_time > 60 {\n        \"Go for a run or hit the gym!\"\n    } else if energy_level > 5 && available_time > 30 {\n        \"Perfect time for a walk\"\n    } else {\n        \"Maybe just relax and read\"\n    }\n}\n\nfun main() {\n    // Test your functions!\n    println(celsius_to_fahrenheit(20))  // 68\n    println(calculate_bmi(70, 1.75))    // 22.86\n    println(get_initials(\"Alice Johnson\"))  // \"AJ\"\n    println(recommend_activity(8, 45))\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpTmUwAU/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTmUwAU/main.rs:1:213\n  |\n1 | ...td :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Outpu...\n  |                                                      ^^                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { celsius * 9i32 / 5i32 + 32i32 } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTmUwAU/main.rs:1:434\n  |\n1 | ... + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Out...\n  |                                                     ^^                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { weight_kg / height_m * height_m } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTmUwAU/main.rs:1:662\n  |\n1 | ...discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ...\n  |                                 ^^                                                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { let discount = price * discount_percent / 100i32 ; price - discount } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTmUwAU/main.rs:1:902\n  |\n1 | ...t :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: A...\n  |                                           ^^                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { let words = text . split (\" \") ; words . len () } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTmUwAU/main.rs:1:1129\n  |\n1 | ... { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } ...\n  |       ^^                                                                                                                                                                                                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTmUwAU/main.rs:1:1243\n  |\n1 | ...ile i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn r...\n  |                             ^^                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTmUwAU/main.rs:1:1547\n  |\n1 | ... { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } ...\n  |       ^^                                                                                                                                                                                                                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTmUwAU/main.rs:1:1600\n  |\n1 | ...f energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time...\n  |                                                      ^^                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { \"Go for a run or hit the gym!\" } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTmUwAU/main.rs:1:1695\n  |\n1 | ... if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn ...\n  |                                                        ^^                         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { \"Perfect time for a walk\" } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTmUwAU/main.rs:1:1734\n  |\n1 | ...e > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to...\n  |                                                       ^^                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { \"Maybe just relax and read\" } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpTmUwAU/main.rs:1:225\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / ...\n  |       -                                                                                                                                                      -------   ^^^^ expected type parameter `T`, found `i32`\n  |       |                                                                                                                                                      |\n  |       expected this type parameter                                                                                                                           expected because this is `T`\n  |\n  = note: expected type parameter `T`\n                       found type `i32`\n\nerror[E0369]: cannot divide `T` by `i32`\n --> /tmp/.tmpTmUwAU/main.rs:1:230\n  |\n1 | ... std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Out...\n  |                                                          -------------- ^ ---- i32\n  |                                                          |\n  |                                                          T\n  |\nhelp: consider further restricting type parameter `T` with trait `Div`\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div<i32> > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                              ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpTmUwAU/main.rs:1:239\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } ...\n  |       - expected this type parameter                                                                                                                                                 ^^^^^ expected type parameter `T`, found `i32`\n  |\n  = note: expected type parameter `T`\n                       found type `i32`\n\nerror[E0369]: cannot divide `T` by `T`\n --> /tmp/.tmpTmUwAU/main.rs:1:446\n  |\n1 | ...Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add ...\n  |                                                            --------- ^ -------- T\n  |                                                            |\n  |                                                            T\n  |\nhelp: consider further restricting type parameter `T` with trait `Div`\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++\n\nerror[E0369]: cannot divide `T` by `i32`\n --> /tmp/.tmpTmUwAU/main.rs:1:706\n  |\n1 | ...discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ...\n  |                                                    ------------------------ ^ ------ i32\n  |                                                    |\n  |                                                    T\n  |\nhelp: consider further restricting type parameter `T` with trait `Div`\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::ops::Div<i32> > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ++++++++++++++++++++\n\nerror[E0599]: no method named `split` found for type parameter `T` in the current scope\n --> /tmp/.tmpTmUwAU/main.rs:1:925\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\"...\n  |       - method `split` not found for this type parameter                                                                                                                       ^^^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `split`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + BufRead > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  +++++++++\n\nerror[E0599]: no method named `split` found for type parameter `T` in the current scope\n --> /tmp/.tmpTmUwAU/main.rs:1:1157\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\"...\n  |       - method `split` not found for this type parameter                                                                                                                                 ^^^^^ method not found in `T`\n  |\n  = help: items from traits can only be used if the type parameter is bounded by the trait\nhelp: the following trait defines an item `split`, perhaps you need to restrict type parameter `T` with it:\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + BufRead > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                +++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpTmUwAU/main.rs:1:1283\n  |\n1 | ...itials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1...\n  |             -- expected due to this value                                                              ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `str`\n  |\nhelp: consider borrowing here\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = &(initials + word [0i32]) ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ++                      +\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpTmUwAU/main.rs:1:1331\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } ...\n  |       - expected this type parameter                                                                                                                     - expected `T` because of return type                                                                                                                                                                         ^^^^^^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&str`\n  = note: the caller chooses a type for `T` which can be different from `&str`\n\nerror[E0369]: binary operation `>` cannot be applied to type `T`\n --> /tmp/.tmpTmUwAU/main.rs:1:1565\n  |\n1 | ... > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!...\n  |                                                           ------------ ^ ---- i32\n  |                                                           |\n  |                                                           T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++++++++++\n\nerror[E0369]: binary operation `>` cannot be applied to type `T`\n --> /tmp/.tmpTmUwAU/main.rs:1:1590\n  |\n1 | ...vailable_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_l...\n  |                                                          -------------- ^ ----- i32\n  |                                                          |\n  |                                                          T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpTmUwAU/main.rs:1:1602\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } ...\n  |       - expected this type parameter                                                                                                                                             - expected `T` because of return type                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n  = note: the caller chooses a type for `T` which can be different from `&'static str`\n\nerror[E0369]: binary operation `>` cannot be applied to type `T`\n --> /tmp/.tmpTmUwAU/main.rs:1:1660\n  |\n1 | ...60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } }...\n  |                                                           ------------ ^ ---- i32\n  |                                                           |\n  |                                                           T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++++++++++\n\nerror[E0369]: binary operation `>` cannot be applied to type `T`\n --> /tmp/.tmpTmUwAU/main.rs:1:1685\n  |\n1 | ...or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just re...\n  |                                                          -------------- ^ ----- i32\n  |                                                          |\n  |                                                          T\n  |\nhelp: consider further restricting type parameter `T` with trait `PartialOrd`\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone + std::cmp::PartialOrd<i32> > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpTmUwAU/main.rs:1:1697\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } ...\n  |       - expected this type parameter                                                                                                                                             - expected `T` because of return type                                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n  = note: the caller chooses a type for `T` which can be different from `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpTmUwAU/main.rs:1:1736\n  |\n1 | ... < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } ...\n  |       - expected this type parameter                                                                                                                                             - expected `T` because of return type                                                                                                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `&str`\n  |\n  = note: expected type parameter `T`\n                  found reference `&'static str`\n  = note: the caller chooses a type for `T` which can be different from `&'static str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpTmUwAU/main.rs:1:1881\n  |\n1 | ...\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recomme...\n  |           -------------  -----   ^^^^^^^ expected `i32`, found `f64`\n  |           |              |\n  |           |              expected all arguments to be this `i32` type because they need to match the type of this parameter\n  |           arguments to this function are incorrect\n  |\nhelp: the return type of this call is `f64` due to the type of the argument passed\n --> /tmp/.tmpTmUwAU/main.rs:1:1858\n  |\n1 | ...) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! ...\n  |                          ^^^^^^^^^^^^^^^^^^^^^^^-------^\n  |                                                 |\n  |                                                 this argument influences the return type of `calculate_bmi`\nnote: function defined here\n --> /tmp/.tmpTmUwAU/main.rs:1:252\n  |\n1 | ...fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -...\n  |       ^^^^^^^^^^^^^   -                                                                                                                                -------------   ------------ this parameter needs to match the `i32` type of `weight_kg`\n  |                       |                                                                                                                                |\n  |                       `weight_kg` and `height_m` both reference this parameter `T`                                                                     `height_m` needs to match the `i32` type of this parameter\nhelp: change the type of the numeric literal from `f64` to `i32`\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (celsius : T) -> T { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (weight_kg : T , height_m : T) -> T { { weight_kg / height_m * height_m } } fn apply_discount < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (price : T , discount_percent : T) -> T { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (text : T) -> T { { { let words = text . split (\" \") ; words . len () } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T) -> T { { { let words = full_name . split (\" \") ; { let mut initials = \"\" ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i] ; { initials = initials + word [0i32] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (energy_level : T , available_time : T) -> T { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{}\" , calculate_bmi (70i32 , 1i32)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nerror[E0277]: cannot add `String` to `String`\n --> /tmp/.tmpTmUwAU/main.rs:1:1925\n  |\n1 | ...64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                             ------------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String + String`\n  |                             |\n  |                             required by a bound introduced by this call\n  |\n  = help: the trait `Add<String>` is not implemented for `String`\n          but trait `Add<&str>` is implemented for it\n  = help: for that trait implementation, expected `&str`, found `String`\nnote: required by a bound in `get_initials`\n --> /tmp/.tmpTmUwAU/main.rs:1:982\n  |\n1 | ...) } } } fn get_initials < T : std :: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt...\n  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `get_initials`\n\nerror[E0277]: cannot multiply `String` by `String`\n --> /tmp/.tmpTmUwAU/main.rs:1:1925\n  |\n1 | ...64)) ; println ! (\"{}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{}\" , recommend_activity (8i32 , 45i32)) } }\n  |                             ------------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `String * String`\n  |                             |\n  |                             required by a bound introduced by this call\n  |\n  = help: the trait `Mul` is not implemented for `String`\nnote: required by a bound in `get_initials`\n --> /tmp/.tmpTmUwAU/main.rs:1:1017\n  |\n1 | ...: ops :: Add < Output = T > + std :: ops :: Mul < Output = T > + std :: fmt :: Display + std :: fmt :: Debug + Clone > (full_name : T)...\n  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `get_initials`\n\nerror: aborting due to 19 previous errors; 11 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: split()"
        }
      ]
    },
    "ch01-02-hello-world-tdd": {
      "chapter": "ch01-02-hello-world-tdd",
      "total_examples": 6,
      "working_examples": 2,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Hello, World!\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpFKj0KY/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                                               ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpFKj0KY/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                               ---------------   ^^^^^^^^^^^^ argument never used\n  |                                                               |\n  |                                                               formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpFKj0KY/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpFKj0KY/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                  ^^                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n1 + use std :: collections :: HashMap ; fn main () { println ! (\"Hello, World!\" . to_string ()) }\n  |\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpFKj0KY/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello, World!\" . to_string ()) } }\n  |                                                                                 ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 2,
          "line_number": 55,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Hello,\");\n    println(\"World!\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpzACjCY/main.rs:1:72\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello,\" . to_string ()) ; println ! (\"World!\" . to_string ()) } }\n  |                                                                        ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpzACjCY/main.rs:1:74\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello,\" . to_string ()) ; println ! (\"World!\" . to_string ()) } }\n  |                                                               --------   ^^^^^^^^^^^^ argument never used\n  |                                                               |\n  |                                                               formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpzACjCY/main.rs:1:110\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello,\" . to_string ()) ; println ! (\"World!\" . to_string ()) } }\n  |                                                                                                              ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpzACjCY/main.rs:1:112\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello,\" . to_string ()) ; println ! (\"World!\" . to_string ()) } }\n  |                                                                                                     --------   ^^^^^^^^^^^^ argument never used\n  |                                                                                                     |\n  |                                                                                                     formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpzACjCY/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello,\" . to_string ()) ; println ! (\"World!\" . to_string ()) } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpzACjCY/main.rs:1:74\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello,\" . to_string ()) ; println ! (\"World!\" . to_string ()) } }\n  |                                                                          ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpzACjCY/main.rs:1:112\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello,\" . to_string ()) ; println ! (\"World!\" . to_string ()) } }\n  |                                                                                                                ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 3,
          "line_number": 75,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let greeting = \"Hello, World!\";\n    println(greeting);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 4,
          "line_number": 124,
          "code": "// Status: ✅ WORKING\nprintln(\"Your message here\");",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpPIPMOV/main.rs:1:94\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = println ! (\"Your message here\" . to_string ()) ; if let Some (s) = (& resul...\n  |                                                                                              ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpPIPMOV/main.rs:1:96\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = println ! (\"Your message here\" . to_string ()) ; if let Some (s) = (& resul...\n  |                                                                          -------------------   ^^^^^^^^^^^^ argument never used\n  |                                                                          |\n  |                                                                          formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpPIPMOV/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = println ! (\"Your message here\" . to_string ()) ; if let Some (s) = (& resul...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpPIPMOV/main.rs:1:96\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = println ! (\"Your message here\" . to_string ()) ; if let Some (s) = (& resul...\n  |                                                                                                ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 5,
          "line_number": 132,
          "code": "// Status: ✅ WORKING\nlet message = \"Your message\";\nprintln(message);",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 6,
          "line_number": 141,
          "code": "// Status: ✅ WORKING\nprintln(\"First line\");\nprintln(\"Second line\");",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected `,`, found `.`\n --> /tmp/.tmpK5F8Za/main.rs:1:89\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"First line\" . to_string ()) ; println ! (\"Second line\" . to_s...\n  |                                                                                         ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpK5F8Za/main.rs:1:91\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"First line\" . to_string ()) ; println ! (\"Second line\" . to_s...\n  |                                                                            ------------   ^^^^^^^^^^^^ argument never used\n  |                                                                            |\n  |                                                                            formatting specifier missing\n\nerror: expected `,`, found `.`\n --> /tmp/.tmpK5F8Za/main.rs:1:132\n  |\n1 | ... ! (\"First line\" . to_string ()) ; println ! (\"Second line\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any...\n  |                                                                ^ expected `,`\n\nerror: argument never used\n --> /tmp/.tmpK5F8Za/main.rs:1:134\n  |\n1 | ...(\"First line\" . to_string ()) ; println ! (\"Second line\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) ....\n  |                                               -------------   ^^^^^^^^^^^^ argument never used\n  |                                               |\n  |                                               formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpK5F8Za/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"First line\" . to_string ()) ; println ! (\"Second line\" . to_s...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpK5F8Za/main.rs:1:91\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"First line\" . to_string ()) ; println ! (\"Second line\" . to_s...\n  |                                                                                           ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n --> /tmp/.tmpK5F8Za/main.rs:1:134\n  |\n1 | ...ine\" . to_string ()) ; println ! (\"Second line\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    }
  }
}