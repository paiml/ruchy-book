{
  "timestamp": "2025-08-26T13:48:40.739Z",
  "ruchy_version": "ruchy 1.18.1",
  "chapters_processed": 37,
  "examples_found": 375,
  "examples_working": 77,
  "examples_failing": 298,
  "success_rate": 21,
  "chapters": {
    "ch02-00-variables-types-tdd": {
      "chapter": "ch02-00-variables-types-tdd",
      "total_examples": 8,
      "working_examples": 5,
      "failing_examples": 3,
      "examples": [
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let x = 42;\n    println(x);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 2,
          "line_number": 51,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let name = \"Ruchy\";\n    println(name);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 3,
          "line_number": 70,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let x = 10;\n    let y = 20;\n    let sum = x + y;\n    println(sum);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 4,
          "line_number": 91,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let pi = 3.14159;\n    let radius = 5.0;\n    let area = pi * radius * radius;\n    println(area);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 5,
          "line_number": 136,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let outer = 100;\n    // outer is accessible here\n    println(outer);\n}\n// outer is NOT accessible here",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 6,
          "line_number": 163,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet result = value1 + value2;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found `let` statement\n --> /tmp/.tmp9zI1aI/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...\n  |                                                               ^^^\n  |\n  = note: only supported directly in conditions of `if` and `while` expressions\n\nerror[E0425]: cannot find value `value1` in this scope\n --> /tmp/.tmp9zI1aI/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...\n  |                                                                                ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `value2` in this scope\n --> /tmp/.tmp9zI1aI/main.rs:1:89\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...\n  |                                                                                         ^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp9zI1aI/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let mut result = value1 + value2 ; if let Some (s) = (& result as & dyn std...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 7,
          "line_number": 172,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet step1 = initial_value * factor;\nlet step2 = step1 + adjustment;\nlet final_result = step2 / divisor;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `}`\n --> /tmp/.tmpDK3oTN/main.rs:1:182\n  |\n1 | ...ustment ; let mut final_result = step2 / divisor } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < Strin...\n  |                                                     ^ expected one of 8 possible tokens\n\nerror[E0425]: cannot find value `initial_value` in this scope\n --> /tmp/.tmpDK3oTN/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut step1 = initial_value * factor ; let mut step2 = step1 + adjustme...\n  |                                                                                 ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `factor` in this scope\n --> /tmp/.tmpDK3oTN/main.rs:1:97\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut step1 = initial_value * factor ; let mut step2 = step1 + adjustme...\n  |                                                                                                 ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `adjustment` in this scope\n --> /tmp/.tmpDK3oTN/main.rs:1:130\n  |\n1 | ... initial_value * factor ; let mut step2 = step1 + adjustment ; let mut final_result = step2 / divisor } ; if let Some (s) = (& result ...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpDK3oTN/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut step1 = initial_value * factor ; let mut step2 = step1 + adjustme...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 8,
          "line_number": 183,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet PI = 3.14159;\nlet GRAVITY = 9.81;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpchxw0d/main.rs:1:117\n  |\n1 | ...3.14159f64 ; let mut GRAVITY = 9.81f64 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpchxw0d/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut PI = 3.14159f64 ; let mut GRAVITY = 9.81f64 } ; if let Some (s) =...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch10-00-performance-optimization": {
      "chapter": "ch10-00-performance-optimization",
      "total_examples": 11,
      "working_examples": 0,
      "failing_examples": 11,
      "examples": [
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 1,
          "line_number": 106,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// File: optimize_data_processing.ruchy\n// Before and after optimization\n\nuse std::perf;\nuse std::parallel;\n\n// Naive version - slow\nfun process_data_naive(data) {\n    let results = []\n    for item in data {\n        // Expensive computation\n        let processed = expensive_transform(item)\n        for existing in results {\n            if similar(processed, existing) {\n                processed.merge(existing)\n            }\n        }\n        results.push(processed)\n    }\n    return results\n}\n\n// Optimized version - fast\nfun process_data_optimized(data) {\n    // 1. Parallel processing\n    let results = parallel::map(data, |item| {\n        expensive_transform(item)\n    })\n    \n    // 2. Use hash map for lookups\n    let lookup = {}\n    for item in results {\n        let key = item.hash_key()\n        if lookup.has_key(key) {\n            lookup[key].merge(item)\n        } else {\n            lookup[key] = item\n        }\n    }\n    \n    return lookup.values()\n}\n\n// Benchmark both versions\nlet data = generate_test_data(10000)\n\nlet naive_time = perf::measure {\n    process_data_naive(data)\n}\n\nlet optimized_time = perf::measure {\n    process_data_optimized(data)\n}\n\nprintln(f\"Naive: {naive_time}ms\")\nprintln(f\"Optimized: {optimized_time}ms\")\nprintln(f\"Speedup: {naive_time / optimized_time:.1}x\")\n// Output: Speedup: 42.3x\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0432]: unresolved import `std::perf`\n --> /tmp/.tmpTzRM96/main.rs:1:739\n  |\n1 | ...eturn lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32)...\n  |                                                      ^^^^^^^^^^^ no `perf` in the root\n\nerror[E0432]: unresolved import `std::parallel`\n --> /tmp/.tmpTzRM96/main.rs:1:759\n  |\n1 | ... } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = ...\n  |                                                  ^^^^^^^^^^^^^^^ no `parallel` in the root\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpTzRM96/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTzRM96/main.rs:1:84\n  |\n1 | ... { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {:.1}x\" , naive_time / optimized_time) ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {:.1}x\" , naive_time / optimized_time) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTzRM96/main.rs:1:134\n  |\n1 | ... { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ...\n  |       ^^                                                                                                                                                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {:.1}x\" , naive_time / optimized_time) ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {:.1}x\" , naive_time / optimized_time) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTzRM96/main.rs:1:211\n  |\n1 | ...; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed...\n  |                                  ^^                                                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {:.1}x\" , naive_time / optimized_time) ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { if similar (processed , existing) { { processed . merge (existing) } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {:.1}x\" , naive_time / optimized_time) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTzRM96/main.rs:1:249\n  |\n1 | ...in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; retur...\n  |                                                       ^^                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {:.1}x\" , naive_time / optimized_time) ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { processed . merge (existing) } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {:.1}x\" , naive_time / optimized_time) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTzRM96/main.rs:1:401\n  |\n1 | ... { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                          ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {:.1}x\" , naive_time / optimized_time) ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {:.1}x\" , naive_time / optimized_time) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTzRM96/main.rs:1:532\n  |\n1 | ... { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ...\n  |       ^^                                                                                                                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {:.1}x\" , naive_time / optimized_time) ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {:.1}x\" , naive_time / optimized_time) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTzRM96/main.rs:1:595\n  |\n1 | ...em . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } ...\n  |                                                   ^^                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {:.1}x\" , naive_time / optimized_time) ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { lookup [key as usize] . merge (item) } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {:.1}x\" , naive_time / optimized_time) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTzRM96/main.rs:1:645\n  |\n1 | ... { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn mai...\n  |                                                       ^^                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {:.1}x\" , naive_time / optimized_time) ; }\n1 + use std :: collections :: HashMap ; fn process_data_naive (data : String) -> i32 { { { let results = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results . push (processed) } } } } ; return results } } } } fn process_data_optimized (data : String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { lookup [key as usize] = item } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_naive (data) } ; let mut optimized_time = perf :: measure ; { process_data_optimized (data) } ; println ! (\"Naive: {}ms\" , naive_time) ; println ! (\"Optimized: {}ms\" , optimized_time) ; println ! (\"Speedup: {:.1}x\" , naive_time / optimized_time) ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpTzRM96/main.rs:1:753\n  |\n1 | ... . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut n...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpTzRM96/main.rs:1:777\n  |\n1 | ...main () { use std :: perf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: meas...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0277]: `String` is not an iterator\n --> /tmp/.tmpTzRM96/main.rs:1:127\n  |\n1 | ...ults = vec ! [] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (proc...\n  |                                    ^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n  |\n  = help: the trait `Iterator` is not implemented for `String`\n  = note: required for `String` to implement `IntoIterator`\n\nerror[E0425]: cannot find function `expensive_transform` in this scope\n --> /tmp/.tmpTzRM96/main.rs:1:154\n  |\n1 | ...] ; { for item in data { { { let processed = expensive_transform (item) ; { for existing in results { { if similar (processed , existi...\n  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `similar` in this scope\n --> /tmp/.tmpTzRM96/main.rs:1:216\n  |\n1 | ...ransform (item) ; { for existing in results { { if similar (processed , existing) { { processed . merge (existing) } } } } ; results ....\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `parallel`\n --> /tmp/.tmpTzRM96/main.rs:1:419\n  |\n1 | ... String) -> i32 { { { let results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for ite...\n  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `parallel`\n  |\n  = help: you might be missing a crate named `parallel`\n\nerror[E0425]: cannot find function `expensive_transform` in this scope\n --> /tmp/.tmpTzRM96/main.rs:1:454\n  |\n1 | ...results = parallel :: map (data , | item | { expensive_transform (item) }) ; { let mut lookup = () ; for item in results { { { let key...\n  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `has_key` found for unit type `()` in the current scope\n --> /tmp/.tmpTzRM96/main.rs:1:579\n  |\n1 | ...s { { { let key = item . hash_key () ; if lookup . has_key (key) { { lookup [key as usize] . merge (item) } } else { { lookup [key as ...\n  |                                                       ^^^^^^^ method not found in `()`\n\nerror[E0599]: no method named `values` found for unit type `()` in the current scope\n --> /tmp/.tmpTzRM96/main.rs:1:704\n  |\n1 | ... [key as usize] = item } } } } } ; return lookup . values () } } } } fn main () { use std :: perf ; ; use std :: parallel ; ; let mut ...\n  |                                                       ^^^^^^ method not found in `()`\n\nerror[E0425]: cannot find function `generate_test_data` in this scope\n --> /tmp/.tmpTzRM96/main.rs:1:794\n  |\n1 | ...rf ; ; use std :: parallel ; ; let mut data = generate_test_data (10000i32) ; let mut naive_time = perf :: measure ; { process_data_na...\n  |                                                  ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 10 previous errors; 11 warnings emitted\n\nSome errors have detailed explanations: E0277, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: has_key()"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 2,
          "line_number": 185,
          "code": "// Status: ❌ BROKEN\n\n// CPU profiling\nlet profiler = perf::CpuProfiler::new()\nprofiler.start()\n\n// Your code here\ncomplex_operation()\n\nprofiler.stop()\nlet report = profiler.report()\n\nprintln(\"=== CPU Profile ===\")\nfor func in report.top_functions(10) {\n    println(f\"{func.name}: {func.self_time}ms ({func.percent}%)\")\n}\n\n// Memory profiling\nlet mem_profiler = perf::MemoryProfiler::new()\nmem_profiler.start()\n\n// Your code here\nmemory_intensive_operation()\n\nmem_profiler.stop()\nlet mem_report = mem_profiler.report()\n\nprintln(\"\\n=== Memory Profile ===\")\nprintln(\"Peak memory: \" + format_size(mem_report.peak_usage))\nprintln(\"Allocations: \" + mem_report.allocation_count.to_s())\nprintln(\"Largest allocation: \" + format_size(mem_report.largest_allocation))\n\n// Flame graph generation\nprofiler.generate_flamegraph(\"profile.svg\")\nprintln(\"Flame graph saved to profile.svg\")",
          "passed": false,
          "status": "broken",
          "error": "\nthread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:\n\"perf::CpuProfiler\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 3,
          "line_number": 233,
          "code": "// Status: ❌ BROKEN\n\n// Micro-benchmarks\nuse std::bench;\n\nbench::suite(\"String Operations\", {\n    \"concatenation\" => || {\n        let s = \"\"\n        for i in range(1000) {\n            s += i.to_s()\n        }\n    },\n    \n    \"string builder\" => || {\n        let builder = StringBuilder::new()\n        for i in range(1000) {\n            builder.append(i.to_s())\n        }\n        builder.to_string()\n    },\n    \n    \"join\" => || {\n        range(1000).map(|i| i.to_s()).join(\"\")\n    }\n})\n\n// Results:\n// String Operations\n//   concatenation:  2.3ms ± 0.1ms\n//   string builder: 0.4ms ± 0.02ms  [FASTEST]\n//   join:          0.6ms ± 0.03ms\n\n// Custom benchmarks\nfun benchmark_algorithm(name, func, data) {\n    let times = []\n    \n    // Warmup\n    for i in range(5) {\n        func(data)\n    }\n    \n    // Measure\n    for i in range(100) {\n        let time = perf::measure {\n            func(data)\n        }\n        times.push(time)\n    }\n    \n    let avg = times.mean()\n    let std = times.std_dev()\n    println(f\"{name}: {avg:.2}ms ± {std:.2}ms\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0432]: unresolved import `std::bench`\n --> /tmp/.tmp5pUKmn/main.rs:1:446\n  |\n1 | ...ms\" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite (\"String Operations\" . to_string () , { let mut map :...\n  |                                                     ^^^^^^^^^^^^ no `bench` in the root\n\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmp5pUKmn/main.rs:1:155\n  |\n1 | ...ing) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmp5pUKmn/main.rs:1:199\n  |\n1 | ...or i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmp5pUKmn/main.rs:1:718\n  |\n1 | ...g () , (|| { { let s = \"\" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert (\"str...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmp5pUKmn/main.rs:1:889\n  |\n1 | ... let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } ...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmp5pUKmn/main.rs:1:1038\n  |\n1 | ...g ()) ; map . insert (\"join\" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () ....\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp5pUKmn/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec !...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5pUKmn/main.rs:1:117\n  |\n1 | ... { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! (\"{}: {:.2}ms ± {:.2}ms\" , name , avg , std) } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! (\"{}: {:.2}ms ± {:.2}ms\" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite (\"String Operations\" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"concatenation\" . to_string () , (|| { { let s = \"\" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert (\"string builder\" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert (\"join\" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (\"\") }) . to_string ()) ; map }) ; }\n1 + use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! (\"{}: {:.2}ms ± {:.2}ms\" , name , avg , std) } } } fn main () { use std :: bench ; ; bench :: suite (\"String Operations\" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"concatenation\" . to_string () , (|| { { let s = \"\" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert (\"string builder\" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert (\"join\" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (\"\") }) . to_string ()) ; map }) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5pUKmn/main.rs:1:170\n  |\n1 | ...i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measur...\n  |                                                               ^^           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! (\"{}: {:.2}ms ± {:.2}ms\" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite (\"String Operations\" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"concatenation\" . to_string () , (|| { { let s = \"\" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert (\"string builder\" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert (\"join\" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (\"\") }) . to_string ()) ; map }) ; }\n1 + use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { func (data) } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! (\"{}: {:.2}ms ± {:.2}ms\" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite (\"String Operations\" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"concatenation\" . to_string () , (|| { { let s = \"\" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert (\"string builder\" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert (\"join\" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (\"\") }) . to_string ()) ; map }) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5pUKmn/main.rs:1:216\n  |\n1 | ...; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . m...\n  |                                ^^                                                                          ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! (\"{}: {:.2}ms ± {:.2}ms\" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite (\"String Operations\" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"concatenation\" . to_string () , (|| { { let s = \"\" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert (\"string builder\" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert (\"join\" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (\"\") }) . to_string ()) ; map }) ; }\n1 + use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! (\"{}: {:.2}ms ± {:.2}ms\" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite (\"String Operations\" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"concatenation\" . to_string () , (|| { { let s = \"\" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert (\"string builder\" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert (\"join\" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (\"\") }) . to_string ()) ; map }) ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp5pUKmn/main.rs:1:461\n  |\n1 | ... avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite (\"String Operations\" . to_string () , { let mut map : std :: coll...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5pUKmn/main.rs:1:736\n  |\n1 | ...{ let s = \"\" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert (\"string builder\" ...\n  |                                                             ^^                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! (\"{}: {:.2}ms ± {:.2}ms\" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite (\"String Operations\" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"concatenation\" . to_string () , (|| { { let s = \"\" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert (\"string builder\" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert (\"join\" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (\"\") }) . to_string ()) ; map }) ; }\n1 + use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! (\"{}: {:.2}ms ± {:.2}ms\" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite (\"String Operations\" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"concatenation\" . to_string () , (|| { { let s = \"\" . to_string () ; for i in range (1000i32) { s += i . to_s () } } }) . to_string ()) ; map . insert (\"string builder\" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert (\"join\" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (\"\") }) . to_string ()) ; map }) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5pUKmn/main.rs:1:907\n  |\n1 | ...gBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ())...\n  |                                                      ^^                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! (\"{}: {:.2}ms ± {:.2}ms\" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite (\"String Operations\" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"concatenation\" . to_string () , (|| { { let s = \"\" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert (\"string builder\" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ; builder . to_string () } } }) . to_string ()) ; map . insert (\"join\" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (\"\") }) . to_string ()) ; map }) ; }\n1 + use std :: collections :: HashMap ; fn benchmark_algorithm (name : String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean () ; let mut std = times . std_dev () ; println ! (\"{}: {:.2}ms ± {:.2}ms\" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: suite (\"String Operations\" . to_string () , { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"concatenation\" . to_string () , (|| { { let s = \"\" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert (\"string builder\" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { builder . append (i . to_s ()) } ; builder . to_string () } } }) . to_string ()) ; map . insert (\"join\" . to_string () , (|| { range (1000i32) . iter () . map (| i | i . to_s ()) . collect :: < Vec < _ >> () . join (\"\") }) . to_string ()) ; map }) ; }\n  |\n\nerror[E0618]: expected function, found `String`\n --> /tmp/.tmp5pUKmn/main.rs:1:172\n  |\n1 | ...: String , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in r...\n  |               ----                                                                                           ^^^^-------\n  |               |                                                                                              |\n  |               `func` has type `String`                                                                       call expression requires function\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `perf`\n --> /tmp/.tmp5pUKmn/main.rs:1:231\n  |\n1 | ...or i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ; times . push (time) } } } } ; let mut avg = times . mean...\n  |                                            ^^^^ use of unresolved module or unlinked crate `perf`\n  |\n  = help: you might be missing a crate named `perf`\n\nerror[E0618]: expected function, found `String`\n --> /tmp/.tmp5pUKmn/main.rs:1:253\n  |\n1 | ... , func : String , data : String) -> i32 { { { let times = vec ! [] ; { for i in range (5i32) { { func (data) } } ; for i in range (100i32) { { { let time = perf :: measure ; { { func (data) } ...\n  |       ----                                                                                                                                                                            ^^^^-------\n  |       |                                                                                                                                                                               |\n  |       `func` has type `String`                                                                                                                                                        call expression requires function\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp5pUKmn/main.rs:1:366\n  |\n1 | ...td = times . std_dev () ; println ! (\"{}: {:.2}ms ± {:.2}ms\" , name , avg , std) } } } } fn main () { use std :: bench ; ; bench :: su...\n  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: `{closure@/tmp/.tmp5pUKmn/main.rs:1:674: 1:676}` doesn't implement `std::fmt::Display`\n --> /tmp/.tmp5pUKmn/main.rs:1:766\n  |\n1 | ...string () , (|| { { let s = \"\" . to_string () ; for i in range (1000i32) { { s += i . to_s () } } } }) . to_string ()) ; map . insert ...\n  |                 -- doesn't satisfy `_: Display` or `_: ToString`                                            ^^^^^^^^^ method cannot be called on `{closure@/tmp/.tmp5pUKmn/main.rs:1:674: 1:676}` due to unsatisfied trait bounds\n  |\n  = note: the following trait bounds were not satisfied:\n          `{closure@/tmp/.tmp5pUKmn/main.rs:1:674: 1:676}: std::fmt::Display`\n          which is required by `{closure@/tmp/.tmp5pUKmn/main.rs:1:674: 1:676}: ToString`\n\nerror[E0433]: failed to resolve: use of undeclared type `StringBuilder`\n --> /tmp/.tmp5pUKmn/main.rs:1:852\n  |\n1 | ...\" . to_string () , (|| { { let builder = StringBuilder :: new () ; { for i in range (1000i32) { { builder . append (i . to_s ()) } } ;...\n  |                                             ^^^^^^^^^^^^^ use of undeclared type `StringBuilder`\n\nerror: aborting due to 12 previous errors; 7 warnings emitted\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433, E0599, E0618.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "IMPORT_ERROR",
          "rootCause": "Missing dependency or import path issue"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 4,
          "line_number": 300,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Parallel map\nlet data = range(1, 1000000)\nlet results = parallel::map(data, |n| {\n    expensive_computation(n)\n})\n\n// Parallel reduce\nlet sum = parallel::reduce(data, 0, |acc, n| {\n    acc + n\n})\n\n// Thread pool\nlet pool = parallel::ThreadPool::new(num_cpus())\n\nfor task in tasks {\n    pool.execute(|| {\n        process_task(task)\n    })\n}\n\npool.wait()\n\n// Parallel pipeline\nparallel::pipeline()\n    .stage(|item| fetch_data(item))      // I/O bound\n    .stage(|data| parse_data(data))      // CPU bound\n    .stage(|parsed| transform(parsed))   // CPU bound\n    .stage(|result| save_result(result)) // I/O bound\n    .process(items)\n\n// Async concurrency\nlet futures = []\nfor url in urls {\n    futures.push(async {\n        http::get(url).await()\n    })\n}\n\nlet responses = async::wait_all(futures)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 5,
          "line_number": 354,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// File: algorithm_optimization.ruchy\n// Common optimization patterns\n\n// 1. Cache computed values\nlet fibonacci_cache = {}\nfun fibonacci_memo(n) {\n    if fibonacci_cache.has_key(n) {\n        return fibonacci_cache[n]\n    }\n    \n    let result = if n <= 1 {\n        n\n    } else {\n        fibonacci_memo(n - 1) + fibonacci_memo(n - 2)\n    }\n    \n    fibonacci_cache[n] = result\n    return result\n}\n\n// 2. Use better data structures\nfun find_duplicates_naive(items) {\n    let duplicates = []\n    for i in range(items.len()) {\n        for j in range(i + 1, items.len()) {\n            if items[i] == items[j] {\n                duplicates.push(items[i])\n            }\n        }\n    }\n    return duplicates  // O(n²)\n}\n\nfun find_duplicates_optimized(items) {\n    let seen = Set::new()\n    let duplicates = Set::new()\n    \n    for item in items {\n        if seen.contains(item) {\n            duplicates.add(item)\n        }\n        seen.add(item)\n    }\n    return duplicates.to_array()  // O(n)\n}\n\n// 3. Batch operations\nfun save_records_naive(records) {\n    for record in records {\n        database.insert(record)  // N database calls\n    }\n}\n\nfun save_records_optimized(records) {\n    database.insert_batch(records)  // 1 database call\n}\n\n// 4. Early termination\nfun find_first_match(items, predicate) {\n    for item in items {\n        if predicate(item) {\n            return item  // Stop as soon as found\n        }\n    }\n    return null\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `fibonacci_cache` in this scope\n --> /tmp/.tmp5ISTsA/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n...\n  |                                                                               ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `fibonacci_cache` in this scope\n --> /tmp/.tmp5ISTsA/main.rs:1:120\n  |\n1 | ... { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibon...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `fibonacci_cache` in this scope\n --> /tmp/.tmp5ISTsA/main.rs:1:264\n  |\n1 | ...(n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive ...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmp5ISTsA/main.rs:1:420\n  |\n1 | ...-> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmp5ISTsA/main.rs:1:456\n  |\n1 | ...[] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] ...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmp5ISTsA/main.rs:1:970\n  |\n1 | ...rds : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> ...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmp5ISTsA/main.rs:1:1061\n  |\n1 | ...ve_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predica...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `null` in this scope\n --> /tmp/.tmp5ISTsA/main.rs:1:1243\n  |\n1 | ...if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::ptr::null;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp5ISTsA/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5ISTsA/main.rs:1:111\n  |\n1 | ... -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else ...\n  |                                                   ^^                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { return fibonacci_cache [n as usize] } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5ISTsA/main.rs:1:185\n  |\n1 | ...ibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32)...\n  |                                                                    ^^ ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { n } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5ISTsA/main.rs:1:200\n  |\n1 | ...esult = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = r...\n  |                                          ^^                                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5ISTsA/main.rs:1:377\n  |\n1 | ... { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } ...\n  |       ^^                                                                                                                                                                                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5ISTsA/main.rs:1:445\n  |\n1 | ... { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ...\n  |       ^^                                                                                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5ISTsA/main.rs:1:492\n  |\n1 | ..., items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return dupl...\n  |                        ^^                                                                                          ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5ISTsA/main.rs:1:540\n  |\n1 | ...if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find...\n  |                                                  ^^                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { duplicates . push (items [i as usize]) } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5ISTsA/main.rs:1:676\n  |\n1 | ... { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } ...\n  |       ^^                                                                                                                                                                                                                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5ISTsA/main.rs:1:796\n  |\n1 | ... ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_ar...\n  |                                                         ^^                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { duplicates . add (item) } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5ISTsA/main.rs:1:942\n  |\n1 | ...ds_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records...\n  |                                         ^^                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { for record in records { { database . insert (record) } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5ISTsA/main.rs:1:968\n  |\n1 | ...ecords : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) ...\n  |                                                        ^^                          ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { database . insert (record) } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5ISTsA/main.rs:1:1059\n  |\n1 | ...e_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicat...\n  |                                                    ^^                                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { database . insert_batch (records) } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5ISTsA/main.rs:1:1188\n  |\n1 | ...ate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibo...\n  |                                                 ^^                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { if predicate (item) { { return item } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp5ISTsA/main.rs:1:1212\n  |\n1 | ...ng) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cach...\n  |                                                               ^^           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n1 + use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { return item } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmp5ISTsA/main.rs:1:504\n  |\n1 | ... (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; ...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmp5ISTsA/main.rs:1:526\n  |\n1 | ...en ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } ...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmp5ISTsA/main.rs:1:568\n  |\n1 | ...[j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : ...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp5ISTsA/main.rs:1:602\n  |\n1 | ...-> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } ...\n  |       --- expected `i32` because of return type                                                                                                                                                                                              ^^^^^^^^^^ expected `i32`, found `Vec<_>`\n  |\n  = note: expected type `i32`\n           found struct `Vec<_>`\n\nerror[E0433]: failed to resolve: use of undeclared type `Set`\n --> /tmp/.tmp5ISTsA/main.rs:1:691\n  |\n1 | ...optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if see...\n  |                                                       ^^^ use of undeclared type `Set`\n\nerror[E0433]: failed to resolve: use of undeclared type `Set`\n --> /tmp/.tmp5ISTsA/main.rs:1:730\n  |\n1 | ... let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . ad...\n  |                                                       ^^^ use of undeclared type `Set`\n\nerror[E0277]: `String` is not an iterator\n --> /tmp/.tmp5ISTsA/main.rs:1:758\n  |\n1 | ... = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return du...\n  |                                   ^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n  |\n  = help: the trait `Iterator` is not implemented for `String`\n  = note: required for `String` to implement `IntoIterator`\n\nerror[E0277]: `String` is not an iterator\n --> /tmp/.tmp5ISTsA/main.rs:1:958\n  |\n1 | ...ing) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String) -> i32 { { d...\n  |                                  ^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n  |\n  = help: the trait `Iterator` is not implemented for `String`\n  = note: required for `String` to implement `IntoIterator`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp5ISTsA/main.rs:1:944\n  |\n1 | ...records : String) -> i32 { { for record in records { { database . insert (record) } } } } fn save_records_optimized (records : String)...\n  |                         ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |                         |\n  |                         expected `i32` because of return type\n  |\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_memo (n : i32) -> i32 { { if fibonacci_cache . has_key (n) { { return fibonacci_cache [n as usize] } } ; { let result = if n <= 1i32 { { n } } else { { fibonacci_memo (n - 1i32) + fibonacci_memo (n - 2i32) } } ; { fibonacci_cache [n as usize] = result ; return result } } } } fn find_duplicates_naive (items : String) -> i32 { { { let duplicates = vec ! [] ; { for i in range (items . len ()) { { for j in range (i + 1i32 , items . len ()) { { if items [i as usize] == items [j as usize] { { duplicates . push (items [i as usize]) } } } } } } ; return duplicates } } } } fn find_duplicates_optimized (items : String) -> i32 { { { let seen = Set :: new () ; { let mut duplicates = Set :: new () ; for item in items { { if seen . contains (item) { { duplicates . add (item) } } ; seen . add (item) } } ; return duplicates . to_array () } } } } fn save_records_naive (records : String) -> i32 { { for record in records { { database . insert (record) } } /* `i32` value */ } } fn save_records_optimized (records : String) -> i32 { { database . insert_batch (records) } } fn find_first_match (items : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         +++++++++++++++++\n\nerror[E0277]: `String` is not an iterator\n --> /tmp/.tmp5ISTsA/main.rs:1:1180\n  |\n1 | ...String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn main () { let mut fibonacci_...\n  |                                   ^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n  |\n  = help: the trait `Iterator` is not implemented for `String`\n  = note: required for `String` to implement `IntoIterator`\n\nerror[E0618]: expected function, found `String`\n --> /tmp/.tmp5ISTsA/main.rs:1:1193\n  |\n1 | ...ms : String , predicate : String) -> i32 { { for item in items { { if predicate (item) { { return item } } } } ; return null } } fn ma...\n  |                  ---------                                               ^^^^^^^^^-------\n  |                  |                                                       |\n  |                  `predicate` has type `String`                           call expression requires function\n\nwarning: unused variable: `fibonacci_cache`\n --> /tmp/.tmp5ISTsA/main.rs:1:1273\n  |\n1 | ...n main () { let mut fibonacci_cache = () ; }\n  |                        ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_fibonacci_cache`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmp5ISTsA/main.rs:1:1269\n  |\n1 | ...turn item } } } } ; return null } } fn main () { let mut fibonacci_cache = () ; }\n  |                                                         ----^^^^^^^^^^^^^^^\n  |                                                         |\n  |                                                         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror: aborting due to 19 previous errors; 17 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0433, E0618.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 6,
          "line_number": 435,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: memory_optimization.ruchy\n// Reduce memory usage\n\n// 1. Use generators for large datasets\nfun read_large_file_naive(path) {\n    return read_file(path).lines()  // Loads entire file\n}\n\nfun read_large_file_optimized(path) {\n    // Generator - yields lines one at a time\n    return generate {\n        let file = open(path)\n        while !file.eof() {\n            yield file.read_line()\n        }\n        file.close()\n    }\n}\n\n// 2. Object pooling\nlet connection_pool = Pool::new(\n    create: || Database::connect(),\n    reset: |conn| conn.clear()\n)\n\nfun handle_request(request) {\n    let conn = connection_pool.acquire()\n    let result = conn.query(request.sql)\n    connection_pool.release(conn)\n    return result\n}\n\n// 3. Weak references for caches\nlet cache = WeakMap::new()\n\nfun get_cached_data(key) {\n    if cache.has(key) {\n        return cache.get(key)\n    }\n    \n    let data = expensive_load(key)\n    cache.set(key, data)\n    return data\n}\n\n// 4. Compact data structures\nstruct CompactUser {\n    id: u32,        // 4 bytes instead of 8\n    flags: u8,      // Bit flags instead of booleans\n    name: String    // Single allocation\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 7,
          "line_number": 499,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: io_optimization.ruchy\n// Speed up I/O operations\n\n// 1. Buffered I/O\nfun process_file_naive(path) {\n    let file = open(path)\n    while !file.eof() {\n        let byte = file.read_byte()  // Syscall for each byte\n        process(byte)\n    }\n}\n\nfun process_file_optimized(path) {\n    let file = BufferedReader::new(open(path), 8192)\n    while !file.eof() {\n        let byte = file.read_byte()  // Reads from buffer\n        process(byte)\n    }\n}\n\n// 2. Async I/O\nasync fun fetch_all_naive(urls) {\n    let results = []\n    for url in urls {\n        let data = http::get(url).await()  // Sequential\n        results.push(data)\n    }\n    return results\n}\n\nasync fun fetch_all_optimized(urls) {\n    let futures = urls.map(|url| {\n        http::get(url)  // Concurrent\n    })\n    return async::wait_all(futures)\n}\n\n// 3. Memory-mapped files\nfun process_huge_file(path) {\n    let mmap = MemoryMap::open(path)\n    \n    // Process in parallel chunks\n    parallel::for_chunks(mmap, 1_000_000, |chunk| {\n        process_chunk(chunk)\n    })\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 8,
          "line_number": 560,
          "code": "// Status: ❌ BROKEN\n\n// File: query_optimizer.ruchy\n// Optimize database queries\n\nuse std::db;\nuse std::perf;\n\nlet database = db::connect(\"postgres://localhost/myapp\")\n\n// Enable query logging\ndatabase.log_queries(true)\n\n// Analyze slow queries\nfun analyze_query(sql) {\n    let plan = database.explain(sql)\n    println(\"Query: \" + sql)\n    println(\"Execution plan: \" + plan)\n    \n    // Find missing indexes\n    if plan.contains(\"Seq Scan\") {\n        println(\"⚠️  Sequential scan detected - consider adding index\")\n        \n        // Suggest index\n        let table = extract_table(sql)\n        let where_clause = extract_where(sql)\n        println(f\"Suggested: CREATE INDEX ON {table} ({where_clause.column})\")\n    }\n    \n    // Check for N+1 queries\n    let query_log = database.get_recent_queries(100)\n    let patterns = find_patterns(query_log)\n    \n    for pattern in patterns {\n        if pattern.count > 10 && pattern.similar {\n            println(\"⚠️  N+1 query pattern detected: \" + pattern.example)\n            println(\"Consider using JOIN or batch loading\")\n        }\n    }\n}\n\n// Optimize ORM queries\nfun get_users_with_posts_naive() {\n    let users = database.query(\"SELECT * FROM users\")\n    for user in users {\n        user.posts = database.query(\n            \"SELECT * FROM posts WHERE user_id = ?\", \n            [user.id]\n        )  // N+1 problem\n    }\n    return users\n}\n\nfun get_users_with_posts_optimized() {\n    // Single query with JOIN\n    return database.query(\"\n        SELECT u.*, p.*\n        FROM users u\n        LEFT JOIN posts p ON p.user_id = u.id\n        ORDER BY u.id, p.created_at\n    \").group_by(|row| row.user_id)\n}\n\n// Benchmark improvements\nlet naive_time = perf::measure {\n    get_users_with_posts_naive()\n}\n\nlet optimized_time = perf::measure {\n    get_users_with_posts_optimized()\n}\n\nprintln(f\"Improvement: {naive_time / optimized_time:.1}x faster\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0432]: unresolved import `std::db`\n --> /tmp/.tmpglQW3e/main.rs:1:1403\n  |\n1 | ... []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\"...\n  |                                          ^^^^^^^--\n  |                                          |      |\n  |                                          |      help: a similar name exists in the module: `dbg`\n  |                                          no `db` in the root\n\nerror[E0432]: unresolved import `std::perf`\n --> /tmp/.tmpglQW3e/main.rs:1:1421\n  |\n1 | ... unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_...\n  |                                                      ^^^^^^^^^^^ no `perf` in the root\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpglQW3e/main.rs:1:90\n  |\n1 | use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! (\"{:?}\" ,...\n  |                                                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpglQW3e/main.rs:1:553\n  |\n1 | ...ere_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_lo...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpglQW3e/main.rs:1:951\n  |\n1 | ...users_with_posts_naive () -> i32 { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = d...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpglQW3e/main.rs:1:1033\n  |\n1 | ...M users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `database` in this scope\n --> /tmp/.tmpglQW3e/main.rs:1:1194\n  |\n1 | ...et_users_with_posts_optimized () -> i32 { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JO...\n  |                                                       ^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpglQW3e/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! (\"{:?}\" ,...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpglQW3e/main.rs:1:75\n  |\n1 | ... { { { let plan = database . explain (sql) ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {:.1}x faster\" , naive_time / optimized_time) ; }\n1 + use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { let plan = database . explain (sql) ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {:.1}x faster\" , naive_time / optimized_time) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpglQW3e/main.rs:1:667\n  |\n1 | ... { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\") } } } } ...\n  |       ^^                                                                                                                                                                                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {:.1}x faster\" , naive_time / optimized_time) ; }\n1 + use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { if pattern . count > 10i32 && pattern . similar { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {:.1}x faster\" , naive_time / optimized_time) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpglQW3e/main.rs:1:935\n  |\n1 | ... { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } ...\n  |       ^^                                                                                                                                                                                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {:.1}x faster\" , naive_time / optimized_time) ; }\n1 + use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } fn get_users_with_posts_optimized () -> i32 { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {:.1}x faster\" , naive_time / optimized_time) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpglQW3e/main.rs:1:1016\n  |\n1 | ...r user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users }...\n  |                      ^^                                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {:.1}x faster\" , naive_time / optimized_time) ; }\n1 + use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {:.1}x faster\" , naive_time / optimized_time) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpglQW3e/main.rs:1:1185\n  |\n1 | ... { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } ...\n  |       ^^                                                                                                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {:.1}x faster\" , naive_time / optimized_time) ; }\n1 + use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\") } } } } } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {:.1}x faster\" , naive_time / optimized_time) ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpglQW3e/main.rs:1:1415\n  |\n1 | ...(& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myap...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpglQW3e/main.rs:1:1435\n  |\n1 | ... } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ;...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `extract_table` in this scope\n --> /tmp/.tmpglQW3e/main.rs:1:373\n  |\n1 | ...ected - consider adding index\") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Sugge...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `extract_where` in this scope\n --> /tmp/.tmpglQW3e/main.rs:1:420\n  |\n1 | ... extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `find_patterns` in this scope\n --> /tmp/.tmpglQW3e/main.rs:1:613\n  |\n1 | ...et_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && ...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpglQW3e/main.rs:1:641\n  |\n1 | ...-> i32 { { { let plan = database . explain (sql) ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\") } } } } } ...\n  |       --- expected `i32` because of return type                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn analyze_query (sql : i32) -> i32 { { { let plan = database . explain (sql) ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Query: \" , sql)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Execution plan: \" , plan)) ; if plan . contains (\"Seq Scan\") { { println ! (\"⚠\\u{fe0f}  Sequential scan detected - consider adding index\") ; { let table = extract_table (sql) ; { let mut where_clause = extract_where (sql) ; println ! (\"Suggested: CREATE INDEX ON {} ({})\" , table , where_clause . column) } } } } ; let mut query_log = database . get_recent_queries (100i32) ; let mut patterns = find_patterns (query_log) ; for pattern in patterns { { if pattern . count > 10i32 && pattern . similar { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"⚠\\u{fe0f}  N+1 query pattern detected: \" , pattern . example)) ; println ! (\"Consider using JOIN or batch loading\") } } } } /* `i32` value */ } } } } fn get_users_with_posts_naive () -> i32 { { { let users = database . query (\"SELECT * FROM users\") ; { for user in users { { user . posts = database . query (\"SELECT * FROM posts WHERE user_id = ?\" , vec ! [user . id]) } } ; return users } } } } fn get_users_with_posts_optimized () -> i32 { { return database . query (\"\\n        SELECT u.*, p.*\\n        FROM users u\\n        LEFT JOIN posts p ON p.user_id = u.id\\n        ORDER BY u.id, p.created_at\\n    \") . groupby (& []) . unwrap () } } fn main () { use std :: db ; ; use std :: perf ; ; let mut database = db :: connect (\"postgres://localhost/myapp\" . to_string ()) ; database . log_queries (true) ; let mut naive_time = perf :: measure ; { get_users_with_posts_naive () } ; let mut optimized_time = perf :: measure ; { get_users_with_posts_optimized () } ; println ! (\"Improvement: {:.1}x faster\" , naive_time / optimized_time) ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     +++++++++++++++++\n\nerror: aborting due to 11 previous errors; 8 warnings emitted\n\nSome errors have detailed explanations: E0308, E0425, E0432.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "IMPORT_ERROR",
          "rootCause": "Missing dependency or import path issue"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 9,
          "line_number": 646,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: web_server_optimization.ruchy\n// High-performance web server\n\nuse std::net::http;\nuse std::cache;\n\nlet app = http::Server::new(\"0.0.0.0:8080\")\n\n// Response caching\nlet response_cache = cache::LRU::new(1000)\n\napp.use(|req, res, next| {\n    let cache_key = req.method + \":\" + req.path + \":\" + req.query_string\n    \n    if req.method == \"GET\" && response_cache.has(cache_key) {\n        let cached = response_cache.get(cache_key)\n        return res\n            .status(200)\n            .header(\"X-Cache\", \"HIT\")\n            .send(cached)\n    }\n    \n    // Capture response for caching\n    let original_send = res.send\n    res.send = |body| {\n        if req.method == \"GET\" && res.status == 200 {\n            response_cache.set(cache_key, body, ttl: 60)\n        }\n        original_send(body)\n    }\n    \n    next()\n})\n\n// Static file serving with ETags\napp.static(\"/static\", \"./public\", {\n    maxAge: 86400,  // 1 day\n    etag: true,\n    gzip: true\n})\n\n// Database connection pooling\nlet db_pool = ConnectionPool::new(\n    url: \"postgres://localhost/myapp\",\n    min: 5,\n    max: 20\n)\n\n// Async request handling\napp.get(\"/api/data\", async |req, res| {\n    let conn = db_pool.acquire().await()\n    let data = conn.query(\"SELECT * FROM data\").await()\n    db_pool.release(conn)\n    \n    res.json(data)\n})\n\n// Enable HTTP/2\napp.enable_http2()\n\n// Compression middleware\napp.use(compression({\n    level: 6,\n    threshold: 1024,  // Only compress > 1KB\n    types: [\"text/*\", \"application/json\", \"application/javascript\"]\n}))\n\nprintln(\"🚀 Optimized server running with:\")\nprintln(\"  • Response caching\")\nprintln(\"  • Connection pooling\")  \nprintln(\"  • HTTP/2 support\")\nprintln(\"  • Gzip compression\")\n\napp.listen()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 10,
          "line_number": 733,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: data_pipeline_optimization.ruchy\n// Optimize large-scale data processing\n\nuse std::parallel;\nuse std::stream;\n\nfun process_dataset(input_file, output_file) {\n    let start = perf::Timer::start()\n    \n    // Stream processing to avoid loading all data\n    let input = stream::FileStream::new(input_file)\n    let output = stream::FileWriter::new(output_file)\n    \n    input\n        // Parse in parallel\n        .parallel_map(|line| {\n            parse_record(line)\n        }, workers: num_cpus())\n        \n        // Filter early to reduce data\n        .filter(|record| {\n            record.is_valid() && record.value > threshold\n        })\n        \n        // Batch for efficient processing\n        .batch(1000)\n        \n        // Process batches in parallel\n        .parallel_map(|batch| {\n            let enriched = enrich_batch(batch)\n            let transformed = transform_batch(enriched)\n            return transformed\n        })\n        \n        // Flatten batches\n        .flatten()\n        \n        // Write with buffering\n        .for_each(|record| {\n            output.write_line(to_json(record))\n        })\n    \n    let duration = start.elapsed()\n    let records = input.count()\n    let throughput = records / duration.seconds()\n    \n    println(\"Processed \" + records.to_s() + \" records in \" + duration.to_s())\n    println(f\"Throughput: {throughput:.0} records/second\")\n}\n\n// Monitor performance\nlet monitor = perf::Monitor::new()\n\nmonitor.track(\"cpu_usage\", || system::cpu_usage())\nmonitor.track(\"memory_usage\", || system::memory_usage())\nmonitor.track(\"disk_io\", || system::disk_io_rate())\n\nprocess_dataset(\"input.jsonl\", \"output.jsonl\")\n\nmonitor.report()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-performance-optimization.md",
          "example_number": 11,
          "line_number": 808,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// 1. Measure first\nperf::profile {\n    suspicious_function()\n}\n\n// 2. Optimize the right thing\n// Focus on the bottleneck, not random code\n\n// 3. Use the right algorithm\n// O(n) beats O(n²) even with overhead\n\n// 4. Batch operations\n// 1 operation on 1000 items > 1000 operations on 1 item\n\n// 5. Cache expensive computations\nlet cache = memoize(expensive_function)\n\n// 6. Parallelize independent work\nparallel::map(items, process)\n\n// 7. Use async for I/O\nasync::wait_all(io_operations)\n\n// 8. Profile in production\n// Dev performance ≠ Production performance",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch04-00-modules-tdd": {
      "chapter": "ch04-00-modules-tdd",
      "total_examples": 6,
      "working_examples": 2,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nmod math {\n    pub fun add(a: i32, b: i32) -> i32 {\n        a + b\n    }\n}\n\nfun main() {\n    let result = math::add(5, 3);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 2,
          "line_number": 57,
          "code": "// Status: ✅ WORKING\nmod utils {\n    pub fun greet() {\n        println(\"Hello from module!\");\n    }\n}\n\nfun main() {\n    utils::greet();\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 3,
          "line_number": 97,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nmod module_name {\n    pub fun public_function() {\n        // Accessible from outside\n    }\n    \n    fun private_function() {\n        // Only accessible within module\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found keyword `mod`\n --> /tmp/.tmpV0gckT/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...\n  |                                                               ^^^ expected expression\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpV0gckT/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod module_name { { pub fn public_function () { () } ; fn private_function ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 4,
          "line_number": 114,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfun main() {\n    module_name::public_function();  // Works\n    // module_name::private_function();  // Would fail - not public\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpIlyDWq/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpIlyDWq/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }\n  |                                                  ^^                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }\n1 + use std :: collections :: HashMap ; fn main () { module_name :: public_function () }\n  |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `module_name`\n --> /tmp/.tmpIlyDWq/main.rs:1:52\n  |\n1 | use std :: collections :: HashMap ; fn main () { { module_name :: public_function () } }\n  |                                                    ^^^^^^^^^^^ use of unresolved module or unlinked crate `module_name`\n  |\n  = help: you might be missing a crate named `module_name`\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 5,
          "line_number": 142,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nmod math {\n    pub fun add(a: i32, b: i32) -> i32 { a + b }\n    pub fun subtract(a: i32, b: i32) -> i32 { a - b }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found keyword `mod`\n --> /tmp/.tmp8I8HkZ/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...\n  |                                                               ^^^ expected expression\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp8I8HkZ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod math { { pub fn add (a : i32 , b : i32) -> i32 { { a + b } } ; pub fn s...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-modules-tdd.md",
          "example_number": 6,
          "line_number": 155,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nmod strings {\n    pub fun greet() { println(\"Hello!\"); }\n    pub fun farewell() { println(\"Goodbye!\"); }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found keyword `mod`\n --> /tmp/.tmpfg7ql9/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! (\"Hello!\") } } ; pub fn farew...\n  |                                                               ^^^ expected expression\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpfg7ql9/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = mod strings { { pub fn greet () { { println ! (\"Hello!\") } } ; pub fn farew...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch09-00-collections-tdd": {
      "chapter": "ch09-00-collections-tdd",
      "total_examples": 10,
      "working_examples": 4,
      "failing_examples": 6,
      "examples": [
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Counting to 5:\");\n    for i in 0..5 {\n        println(i);\n    }\n    println(\"Done counting\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 2,
          "line_number": 60,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let mut sum = 0;\n    let mut i = 1;\n    while i <= 5 {\n        sum = sum + i;\n        i = i + 1;\n    }\n    println(\"Sum of 1-5:\");\n    println(sum);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 3,
          "line_number": 86,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Pattern:\");\n    for row in 0..3 {\n        for col in 0..3 {\n            if (row + col) % 2 == 0 {\n                print(\"*\");\n            } else {\n                print(\" \");\n            }\n        }\n        println(\"\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 4,
          "line_number": 134,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfor variable in start..end {\n    // Process each value\n    println(variable);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `start` in this scope\n --> /tmp/.tmpRuy6Hb/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{:?}\" , variable) } } ; if let...\n  |                                                                               ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `end` in this scope\n --> /tmp/.tmpRuy6Hb/main.rs:1:88\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{:?}\" , variable) } } ; if let...\n  |                                                                                        ^^^ not found in this scope\n  |\nhelp: you might have meant to write `.` instead of `..`\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{:?}\" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start.end { { println ! (\"{:?}\" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpRuy6Hb/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{:?}\" , variable) } } ; if let...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpRuy6Hb/main.rs:1:94\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{:?}\" , variable) } } ; if let...\n  |                                                                                              ^^                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { { println ! (\"{:?}\" , variable) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for variable in start .. end { println ! (\"{:?}\" , variable) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 5,
          "line_number": 146,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet mut accumulator = initial_value;\nlet mut counter = start;\nwhile counter <= end {\n    accumulator = update(accumulator, counter);\n    counter = counter + 1;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `initial_value` in this scope\n --> /tmp/.tmpT71xzC/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut accumulator = initial_value ; let mut counter = start ; while cou...\n  |                                                                                       ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `start` in this scope\n --> /tmp/.tmpT71xzC/main.rs:1:121\n  |\n1 | ...mut accumulator = initial_value ; let mut counter = start ; while counter <= end { { accumulator = update (accumulator , counter) ; co...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `end` in this scope\n --> /tmp/.tmpT71xzC/main.rs:1:146\n  |\n1 | ...l_value ; let mut counter = start ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 }...\n  |                                                         ^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpT71xzC/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut accumulator = initial_value ; let mut counter = start ; while cou...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `update` in this scope\n --> /tmp/.tmpT71xzC/main.rs:1:168\n  |\n1 | ...er = start ; while counter <= end { { accumulator = update (accumulator , counter) ; counter = counter + 1i32 } } } ; if let Some (s) ...\n  |                                                        ^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 6,
          "line_number": 160,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfor outer in 0..height {\n    for inner in 0..width {\n        // Process (outer, inner) coordinate\n        process(outer, inner);\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `height` in this scope\n --> /tmp/.tmp7yGr36/main.rs:1:84\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...\n  |                                                                                    ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `width` in this scope\n --> /tmp/.tmp7yGr36/main.rs:1:116\n  |\n1 | ...or outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn s...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp7yGr36/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (out...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7yGr36/main.rs:1:93\n  |\n1 | ...ult = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as ...\n  |                                        ^^                                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { for inner in 0i32 .. width { { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7yGr36/main.rs:1:124\n  |\n1 | ...r in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: a...\n  |                                                         ^^                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for outer in 0i32 .. height { { for inner in 0i32 .. width { process (outer , inner) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `process` in this scope\n --> /tmp/.tmp7yGr36/main.rs:1:126\n  |\n1 | ... 0i32 .. height { { for inner in 0i32 .. width { { process (outer , inner) } } } } ; if let Some (s) = (& result as & dyn std :: any :...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 7,
          "line_number": 188,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfor i in 1..10 {\n    let result = process(i);\n    println(result);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpdRP94O/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! (\"{:?}\" ,...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpdRP94O/main.rs:1:88\n  |\n1 | ...t result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! (\"{:?}\" , result) } } } ; if let Some (s) = (& result as ...\n  |                                        ^^                                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! (\"{:?}\" , result) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for i in 1i32 .. 10i32 { { let result = process (i) ; println ! (\"{:?}\" , result) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `process` in this scope\n --> /tmp/.tmpdRP94O/main.rs:1:105\n  |\n1 | ...result = for i in 1i32 .. 10i32 { { { let result = process (i) ; println ! (\"{:?}\" , result) } } } ; if let Some (s) = (& result as & ...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 8,
          "line_number": 200,
          "code": "// Status: ✅ WORKING\nlet mut total = 0;\nfor value in 1..100 {\n    total = total + value;\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 9,
          "line_number": 211,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfor row in 0..height {\n    for col in 0..width {\n        let value = calculate(row, col);\n        display(value);\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `height` in this scope\n --> /tmp/.tmpLotV2r/main.rs:1:82\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...\n  |                                                                                  ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `width` in this scope\n --> /tmp/.tmpLotV2r/main.rs:1:112\n  |\n1 | ... = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpLotV2r/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = ca...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpLotV2r/main.rs:1:91\n  |\n1 | ... in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) ...\n  |                         ^^                                                                                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpLotV2r/main.rs:1:120\n  |\n1 | ...eight { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result a...\n  |                                         ^^                                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = for row in 0i32 .. height { { for col in 0i32 .. width { { let value = calculate (row , col) ; display (value) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `calculate` in this scope\n --> /tmp/.tmpLotV2r/main.rs:1:136\n  |\n1 | ...ht { { for col in 0i32 .. width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as &...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `display` in this scope\n --> /tmp/.tmpLotV2r/main.rs:1:160\n  |\n1 | ..... width { { { let value = calculate (row , col) ; display (value) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any)...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-collections-tdd.md",
          "example_number": 10,
          "line_number": 225,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet mut count = 0;\nfor i in 1..100 {\n    if condition(i) {\n        count = count + 1;\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmprdvMLI/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { c...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmprdvMLI/main.rs:1:114\n  |\n1 | ... count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn...\n  |                                              ^^                                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { if condition (i) { { count = count + 1i32 } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmprdvMLI/main.rs:1:135\n  |\n1 | ... 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: ...\n  |                                                           ^^                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { count = count + 1i32 } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `condition` in this scope\n --> /tmp/.tmprdvMLI/main.rs:1:119\n  |\n1 | ...mut count = 0i32 ; for i in 1i32 .. 100i32 { { if condition (i) { { count = count + 1i32 } } } } } ; if let Some (s) = (& result as & ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch19-00-real-world-projects": {
      "chapter": "ch19-00-real-world-projects",
      "total_examples": 4,
      "working_examples": 0,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch19-00-real-world-projects.md",
          "example_number": 1,
          "line_number": 48,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// taskmaster.ruchy - Complete task management system\nuse std::cli::{App, Arg, SubCommand};\nuse std::fs;\nuse std::chrono::{DateTime, Local};\n\n#[derive(Serialize, Deserialize, Clone)]\nstruct Task {\n    id: String,\n    title: String,\n    description: Option<String>,\n    status: TaskStatus,\n    priority: Priority,\n    due_date: Option<DateTime<Local>>,\n    tags: Vec<String>,\n    created_at: DateTime<Local>,\n    completed_at: Option<DateTime<Local>>,\n}\n\n#[derive(Serialize, Deserialize, Clone)]\nenum TaskStatus {\n    Todo,\n    InProgress,\n    Done,\n    Archived\n}\n\n#[derive(Serialize, Deserialize, Clone)]\nenum Priority {\n    Low,\n    Medium,\n    High,\n    Critical\n}\n\nstruct TaskStore {\n    path: PathBuf,\n    tasks: Vec<Task>,\n}\n\nimpl TaskStore {\n    fun load(path: PathBuf) -> Result<Self> {\n        let tasks = if path.exists() {\n            let content = fs::read_to_string(&path)?;\n            serde_json::from_str(&content)?\n        } else {\n            Vec::new()\n        };\n        \n        Ok(TaskStore { path, tasks })\n    }\n    \n    fun save(&self) -> Result<()> {\n        let json = serde_json::to_string_pretty(&self.tasks)?;\n        fs::write(&self.path, json)?;\n        Ok(())\n    }\n    \n    fun add(&mut self, task: Task) -> Result<()> {\n        self.tasks.push(task);\n        self.save()\n    }\n    \n    fun find(&self, id: &str) -> Option<&Task> {\n        self.tasks.iter().find(|t| t.id == id)\n    }\n    \n    fun update<F>(&mut self, id: &str, updater: F) -> Result<()>\n    where F: FnOnce(&mut Task)\n    {\n        if let Some(task) = self.tasks.iter_mut().find(|t| t.id == id) {\n            updater(task);\n            self.save()?;\n        }\n        Ok(())\n    }\n    \n    fun list(&self, filter: Option<TaskFilter>) -> Vec<&Task> {\n        self.tasks.iter()\n            .filter(|t| {\n                if let Some(ref f) = filter {\n                    f.matches(t)\n                } else {\n                    true\n                }\n            })\n            .collect()\n    }\n}\n\nstruct TaskFilter {\n    status: Option<TaskStatus>,\n    priority: Option<Priority>,\n    tags: Vec<String>,\n    search: Option<String>,\n}\n\nimpl TaskFilter {\n    fun matches(&self, task: &Task) -> bool {\n        if let Some(ref status) = self.status {\n            if task.status != *status {\n                return false;\n            }\n        }\n        \n        if let Some(ref priority) = self.priority {\n            if task.priority != *priority {\n                return false;\n            }\n        }\n        \n        if !self.tags.is_empty() {\n            if !self.tags.iter().any(|tag| task.tags.contains(tag)) {\n                return false;\n            }\n        }\n        \n        if let Some(ref search) = self.search {\n            let search_lower = search.to_lowercase();\n            if !task.title.to_lowercase().contains(&search_lower) &&\n               !task.description.as_ref()\n                   .map(|d| d.to_lowercase().contains(&search_lower))\n                   .unwrap_or(false) {\n                return false;\n            }\n        }\n        \n        true\n    }\n}\n\nfun main() -> Result<()> {\n    let app = App::new(\"taskmaster\")\n        .version(\"1.0.0\")\n        .author(\"Your Name\")\n        .about(\"Powerful task management from the command line\")\n        .subcommand(\n            SubCommand::with_name(\"add\")\n                .about(\"Add a new task\")\n                .arg(Arg::with_name(\"title\").required(true))\n                .arg(Arg::with_name(\"description\").short(\"d\").takes_value(true))\n                .arg(Arg::with_name(\"priority\").short(\"p\").takes_value(true))\n                .arg(Arg::with_name(\"due\").long(\"due\").takes_value(true))\n                .arg(Arg::with_name(\"tags\").short(\"t\").multiple(true))\n        )\n        .subcommand(\n            SubCommand::with_name(\"list\")\n                .about(\"List tasks\")\n                .arg(Arg::with_name(\"status\").short(\"s\").takes_value(true))\n                .arg(Arg::with_name(\"priority\").short(\"p\").takes_value(true))\n                .arg(Arg::with_name(\"tags\").short(\"t\").multiple(true))\n        )\n        .subcommand(\n            SubCommand::with_name(\"done\")\n                .about(\"Mark task as done\")\n                .arg(Arg::with_name(\"id\").required(true))\n        )\n        .get_matches();\n    \n    let store_path = dirs::home_dir()\n        .unwrap()\n        .join(\".taskmaster\")\n        .join(\"tasks.json\");\n    \n    let mut store = TaskStore::load(store_path)?;\n    \n    match app.subcommand() {\n        (\"add\", Some(matches)) => {\n            let task = Task {\n                id: generate_id(),\n                title: matches.value_of(\"title\").unwrap().to_string(),\n                description: matches.value_of(\"description\").map(String::from),\n                status: TaskStatus::Todo,\n                priority: matches.value_of(\"priority\")\n                    .and_then(|p| p.parse().ok())\n                    .unwrap_or(Priority::Medium),\n                due_date: matches.value_of(\"due\")\n                    .and_then(|d| parse_date(d).ok()),\n                tags: matches.values_of(\"tags\")\n                    .map(|tags| tags.map(String::from).collect())\n                    .unwrap_or_default(),\n                created_at: Local::now(),\n                completed_at: None,\n            };\n            \n            store.add(task)?;\n            println!(\"✅ Task added successfully!\");\n        }\n        \n        (\"list\", Some(matches)) => {\n            let filter = TaskFilter {\n                status: matches.value_of(\"status\").and_then(|s| s.parse().ok()),\n                priority: matches.value_of(\"priority\").and_then(|p| p.parse().ok()),\n                tags: matches.values_of(\"tags\")\n                    .map(|tags| tags.map(String::from).collect())\n                    .unwrap_or_default(),\n                search: None,\n            };\n            \n            let tasks = store.list(Some(filter));\n            \n            for task in tasks {\n                let status_emoji = match task.status {\n                    TaskStatus::Todo => \"⬜\",\n                    TaskStatus::InProgress => \"🔄\",\n                    TaskStatus::Done => \"✅\",\n                    TaskStatus::Archived => \"📦\",\n                };\n                \n                let priority_marker = match task.priority {\n                    Priority::Critical => \"🔴\",\n                    Priority::High => \"🟠\",\n                    Priority::Medium => \"🟡\",\n                    Priority::Low => \"🟢\",\n                };\n                \n                println!(\"{} {} {} {}\", \n                    status_emoji, \n                    priority_marker,\n                    task.id[..8].to_string(),\n                    task.title\n                );\n                \n                if let Some(ref desc) = task.description {\n                    println!(\"    {}\", desc);\n                }\n                \n                if !task.tags.is_empty() {\n                    println!(\"    Tags: {}\", task.tags.join(\", \"));\n                }\n            }\n        }\n        \n        (\"done\", Some(matches)) => {\n            let id = matches.value_of(\"id\").unwrap();\n            store.update(id, |task| {\n                task.status = TaskStatus::Done;\n                task.completed_at = Some(Local::now());\n            })?;\n            println!(\"✅ Task marked as done!\");\n        }\n        \n        _ => {\n            println!(\"Use --help for usage information\");\n        }\n    }\n    \n    Ok(())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch19-00-real-world-projects.md",
          "example_number": 2,
          "line_number": 311,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// api_server.ruchy - Complete web service\nuse warp::{Filter, Reply, Rejection};\nuse sqlx::{PgPool, FromRow};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize, FromRow)]\nstruct User {\n    id: i32,\n    username: String,\n    email: String,\n    created_at: chrono::DateTime<chrono::Utc>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct CreateUser {\n    username: String,\n    email: String,\n    password: String,\n}\n\n#[derive(Clone)]\nstruct AppState {\n    db: PgPool,\n    jwt_secret: String,\n}\n\nasync fun create_user(\n    user: CreateUser,\n    state: AppState,\n) -> Result<impl Reply, Rejection> {\n    let hashed_password = hash_password(&user.password)?;\n    \n    let result = sqlx::query_as!(\n        User,\n        r#\"\n        INSERT INTO users (username, email, password_hash)\n        VALUES ($1, $2, $3)\n        RETURNING id, username, email, created_at\n        \"#,\n        user.username,\n        user.email,\n        hashed_password\n    )\n    .fetch_one(&state.db)\n    .await\n    .map_err(|e| reject::custom(DatabaseError(e)))?;\n    \n    Ok(warp::reply::json(&result))\n}\n\nasync fun get_user(\n    id: i32,\n    state: AppState,\n) -> Result<impl Reply, Rejection> {\n    let user = sqlx::query_as!(\n        User,\n        \"SELECT id, username, email, created_at FROM users WHERE id = $1\",\n        id\n    )\n    .fetch_one(&state.db)\n    .await\n    .map_err(|e| reject::custom(DatabaseError(e)))?;\n    \n    Ok(warp::reply::json(&user))\n}\n\nasync fun list_users(\n    state: AppState,\n) -> Result<impl Reply, Rejection> {\n    let users = sqlx::query_as!(\n        User,\n        \"SELECT id, username, email, created_at FROM users ORDER BY created_at DESC\"\n    )\n    .fetch_all(&state.db)\n    .await\n    .map_err(|e| reject::custom(DatabaseError(e)))?;\n    \n    Ok(warp::reply::json(&users))\n}\n\nfun with_state(\n    state: AppState,\n) -> impl Filter<Extract = (AppState,), Error = Infallible> + Clone {\n    warp::any().map(move || state.clone())\n}\n\nfun routes(state: AppState) -> impl Filter<Extract = impl Reply> + Clone {\n    let users_create = warp::path(\"users\")\n        .and(warp::post())\n        .and(warp::body::json())\n        .and(with_state(state.clone()))\n        .and_then(create_user);\n    \n    let users_get = warp::path!(\"users\" / i32)\n        .and(warp::get())\n        .and(with_state(state.clone()))\n        .and_then(get_user);\n    \n    let users_list = warp::path(\"users\")\n        .and(warp::get())\n        .and(with_state(state.clone()))\n        .and_then(list_users);\n    \n    let health = warp::path(\"health\")\n        .and(warp::get())\n        .map(|| \"OK\");\n    \n    users_create\n        .or(users_get)\n        .or(users_list)\n        .or(health)\n        .with(warp::cors().allow_any_origin())\n        .with(warp::log(\"api\"))\n        .recover(handle_rejection)\n}\n\nasync fun handle_rejection(err: Rejection) -> Result<impl Reply, Infallible> {\n    let code;\n    let message;\n    \n    if err.is_not_found() {\n        code = StatusCode::NOT_FOUND;\n        message = \"Not Found\";\n    } else if let Some(DatabaseError(_)) = err.find() {\n        code = StatusCode::INTERNAL_SERVER_ERROR;\n        message = \"Database Error\";\n    } else {\n        code = StatusCode::INTERNAL_SERVER_ERROR;\n        message = \"Internal Server Error\";\n    }\n    \n    let json = warp::reply::json(&ErrorResponse {\n        message: message.to_string(),\n    });\n    \n    Ok(warp::reply::with_status(json, code))\n}\n\n#[tokio::main]\nasync fun main() -> Result<()> {\n    env_logger::init();\n    \n    let database_url = env::var(\"DATABASE_URL\")\n        .expect(\"DATABASE_URL must be set\");\n    \n    let pool = PgPool::connect(&database_url).await?;\n    \n    // Run migrations\n    sqlx::migrate!(\"./migrations\").run(&pool).await?;\n    \n    let state = AppState {\n        db: pool,\n        jwt_secret: env::var(\"JWT_SECRET\")\n            .expect(\"JWT_SECRET must be set\"),\n    };\n    \n    let routes = routes(state);\n    \n    println!(\"🚀 Server running on http://localhost:3030\");\n    \n    warp::serve(routes)\n        .run(([0, 0, 0, 0], 3030))\n        .await;\n    \n    Ok(())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch19-00-real-world-projects.md",
          "example_number": 3,
          "line_number": 492,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// sysmon.ruchy - System monitoring dashboard\nuse sysinfo::{System, SystemExt, ProcessExt, CpuExt};\nuse tui::{Terminal, Frame, backend::CrosstermBackend};\nuse crossterm::event::{self, Event, KeyCode};\n\nstruct App {\n    system: System,\n    cpu_history: Vec<f32>,\n    memory_history: Vec<f32>,\n    selected_process: Option<usize>,\n    processes: Vec<ProcessInfo>,\n}\n\n#[derive(Clone)]\nstruct ProcessInfo {\n    pid: u32,\n    name: String,\n    cpu_usage: f32,\n    memory: u64,\n    status: String,\n}\n\nimpl App {\n    fun new() -> Self {\n        let mut system = System::new_all();\n        system.refresh_all();\n        \n        App {\n            system,\n            cpu_history: Vec::with_capacity(60),\n            memory_history: Vec::with_capacity(60),\n            selected_process: None,\n            processes: Vec::new(),\n        }\n    }\n    \n    fun update(&mut self) {\n        self.system.refresh_all();\n        \n        // Update CPU history\n        let cpu_usage = self.system.global_cpu_info().cpu_usage();\n        self.cpu_history.push(cpu_usage);\n        if self.cpu_history.len() > 60 {\n            self.cpu_history.remove(0);\n        }\n        \n        // Update memory history\n        let used_memory = self.system.used_memory();\n        let total_memory = self.system.total_memory();\n        let memory_usage = (used_memory as f32 / total_memory as f32) * 100.0;\n        self.memory_history.push(memory_usage);\n        if self.memory_history.len() > 60 {\n            self.memory_history.remove(0);\n        }\n        \n        // Update process list\n        self.processes = self.system.processes()\n            .iter()\n            .map(|(pid, process)| ProcessInfo {\n                pid: pid.as_u32(),\n                name: process.name().to_string(),\n                cpu_usage: process.cpu_usage(),\n                memory: process.memory(),\n                status: format!(\"{:?}\", process.status()),\n            })\n            .collect();\n        \n        // Sort by CPU usage\n        self.processes.sort_by(|a, b| \n            b.cpu_usage.partial_cmp(&a.cpu_usage).unwrap()\n        );\n    }\n    \n    fun draw(&self, frame: &mut Frame<impl Backend>) {\n        let chunks = Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Length(3),\n                Constraint::Percentage(30),\n                Constraint::Percentage(30),\n                Constraint::Percentage(40),\n            ])\n            .split(frame.size());\n        \n        // Header\n        let header = Paragraph::new(\"System Monitor - Press 'q' to quit\")\n            .style(Style::default().fg(Color::Cyan))\n            .block(Block::default().borders(Borders::ALL));\n        frame.render_widget(header, chunks[0]);\n        \n        // CPU Chart\n        let cpu_data: Vec<(f64, f64)> = self.cpu_history\n            .iter()\n            .enumerate()\n            .map(|(i, &val)| (i as f64, val as f64))\n            .collect();\n        \n        let cpu_chart = Chart::new(vec![\n            Dataset::default()\n                .name(\"CPU\")\n                .marker(symbols::Marker::Dot)\n                .style(Style::default().fg(Color::Yellow))\n                .data(&cpu_data),\n        ])\n        .block(Block::default().title(\"CPU Usage\").borders(Borders::ALL))\n        .x_axis(Axis::default()\n            .bounds([0.0, 60.0])\n            .labels(vec![\"60s\", \"30s\", \"Now\"]))\n        .y_axis(Axis::default()\n            .bounds([0.0, 100.0])\n            .labels(vec![\"0%\", \"50%\", \"100%\"]));\n        \n        frame.render_widget(cpu_chart, chunks[1]);\n        \n        // Memory Chart\n        let memory_data: Vec<(f64, f64)> = self.memory_history\n            .iter()\n            .enumerate()\n            .map(|(i, &val)| (i as f64, val as f64))\n            .collect();\n        \n        let memory_chart = Chart::new(vec![\n            Dataset::default()\n                .name(\"Memory\")\n                .marker(symbols::Marker::Dot)\n                .style(Style::default().fg(Color::Blue))\n                .data(&memory_data),\n        ])\n        .block(Block::default().title(\"Memory Usage\").borders(Borders::ALL))\n        .x_axis(Axis::default()\n            .bounds([0.0, 60.0])\n            .labels(vec![\"60s\", \"30s\", \"Now\"]))\n        .y_axis(Axis::default()\n            .bounds([0.0, 100.0])\n            .labels(vec![\"0%\", \"50%\", \"100%\"]));\n        \n        frame.render_widget(memory_chart, chunks[2]);\n        \n        // Process List\n        let processes: Vec<ListItem> = self.processes\n            .iter()\n            .take(10)\n            .map(|p| {\n                let content = format!(\"{:5} {:20} {:6.1}% {:8}\",\n                    p.pid,\n                    p.name,\n                    p.cpu_usage,\n                    format_bytes(p.memory)\n                );\n                ListItem::new(content)\n            })\n            .collect();\n        \n        let process_list = List::new(processes)\n            .block(Block::default()\n                .title(\"Top Processes (PID | Name | CPU | Memory)\")\n                .borders(Borders::ALL))\n            .highlight_style(Style::default().bg(Color::DarkGray));\n        \n        frame.render_widget(process_list, chunks[3]);\n    }\n}\n\n#[tokio::main]\nasync fun main() -> Result<()> {\n    // Setup terminal\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen)?;\n    let backend = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backend)?;\n    \n    let mut app = App::new();\n    let mut last_update = Instant::now();\n    \n    loop {\n        // Update data every second\n        if last_update.elapsed() >= Duration::from_secs(1) {\n            app.update();\n            last_update = Instant::now();\n        }\n        \n        // Draw UI\n        terminal.draw(|f| app.draw(f))?;\n        \n        // Handle events\n        if event::poll(Duration::from_millis(100))? {\n            if let Event::Key(key) = event::read()? {\n                match key.code {\n                    KeyCode::Char('q') => break,\n                    KeyCode::Up => {\n                        if let Some(selected) = &mut app.selected_process {\n                            if *selected > 0 {\n                                *selected -= 1;\n                            }\n                        }\n                    }\n                    KeyCode::Down => {\n                        if let Some(selected) = &mut app.selected_process {\n                            if *selected < app.processes.len() - 1 {\n                                *selected += 1;\n                            }\n                        } else {\n                            app.selected_process = Some(0);\n                        }\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n    \n    // Restore terminal\n    disable_raw_mode()?;\n    execute!(terminal.backend_mut(), LeaveAlternateScreen)?;\n    terminal.show_cursor()?;\n    \n    Ok(())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch19-00-real-world-projects.md",
          "example_number": 4,
          "line_number": 760,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// 1. Project structure\nmy-project/\n├── src/\n│   ├── main.rs\n│   ├── lib.rs\n│   ├── models/\n│   ├── handlers/\n│   └── utils/\n├── tests/\n├── benches/\n├── docs/\n├── Cargo.toml\n├── README.md\n└── .github/\n    └── workflows/\n\n// 2. Error handling\ntype Result<T> = std::result::Result<T, Error>;\n\n#[derive(Debug, thiserror::Error)]\nenum Error {\n    #[error(\"Database error: {0}\")]\n    Database(#[from] sqlx::Error),\n    \n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n    \n    #[error(\"Invalid input: {0}\")]\n    InvalidInput(String),\n}\n\n// 3. Configuration\n#[derive(Debug, Deserialize)]\nstruct Config {\n    server: ServerConfig,\n    database: DatabaseConfig,\n    #[serde(default)]\n    features: Features,\n}\n\nimpl Config {\n    fun load() -> Result<Self> {\n        // Try multiple sources\n        let config = config::Config::builder()\n            .add_source(config::File::with_name(\"config\"))\n            .add_source(config::Environment::with_prefix(\"APP\"))\n            .build()?;\n        \n        Ok(config.try_deserialize()?)\n    }\n}\n\n// 4. Logging\nfun init_logging() {\n    tracing_subscriber::fmt()\n        .with_env_filter(EnvFilter::from_default_env())\n        .with_target(false)\n        .with_thread_ids(true)\n        .with_file(true)\n        .with_line_number(true)\n        .init();\n}\n\n// 5. Testing\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fun test_functionality() {\n        // Arrange\n        let input = prepare_test_data();\n        \n        // Act\n        let result = function_under_test(input);\n        \n        // Assert\n        assert_eq!(result, expected);\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch21-00-professional-tooling-tdd": {
      "chapter": "ch21-00-professional-tooling-tdd",
      "total_examples": 1,
      "working_examples": 1,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch21-00-professional-tooling-tdd.md",
          "example_number": 1,
          "line_number": 23,
          "code": "// Status: ✅ WORKING\n// test/tooling/simple_test.ruchy - ✓ VERIFIED WORKING\nfun add(a: i32, b: i32) -> i32 {\n    a + b\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "conclusion": {
      "chapter": "conclusion",
      "total_examples": 2,
      "working_examples": 1,
      "failing_examples": 1,
      "examples": [
        {
          "file": "src/conclusion.md",
          "example_number": 1,
          "line_number": 205,
          "code": "// Status: ✅ WORKING\nfun calculate(x: i32, y: i32) -> i32 {\n    return x + y;\n}\n\nfun main() {\n    let result = calculate(10, 20);\n    println(result);  // Output: 30\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/conclusion.md",
          "example_number": 2,
          "line_number": 220,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\n// Arrays - NOT YET\nlet arr = [1, 2, 3];\n\n// User Input - NOT YET  \nlet name = input(\"Enter name: \");\n\n// File I/O - NOT YET\nlet contents = fs::read_to_string(\"file.txt\");\n\n// Closures - NOT YET\nlet add_one = |x| x + 1;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmplphaDr/main.rs:1:562\n  |\n1 | ...()) ; let mut add_one = | x | x + 1i32 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n --> /tmp/.tmplphaDr/main.rs:1:478\n  |\n1 | ...pop () ; } } input } ; let mut contents = fs :: read_to_string (\"file.txt\" . to_string ()) ; let mut add_one = | x | x + 1i32 } ; if l...\n  |                                              ^^ use of unresolved module or unlinked crate `fs`\n  |\n  = help: you might be missing a crate named `fs`\nhelp: consider importing this module\n  |\n1 + use std::fs;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmplphaDr/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut arr = vec ! [1i32 , 2i32 , 3i32] ; let mut name = { print ! (\"{}\"...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch11-00-advanced-patterns": {
      "chapter": "ch11-00-advanced-patterns",
      "total_examples": 12,
      "working_examples": 0,
      "failing_examples": 12,
      "examples": [
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 1,
          "line_number": 48,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: event_system.ruchy\n// Event-driven architecture with multiple patterns\n\nuse std::patterns;\n\n// Observer pattern for events\nclass EventBus {\n    let subscribers = {}\n    \n    fun on(event, handler) {\n        if !subscribers.has_key(event) {\n            subscribers[event] = []\n        }\n        subscribers[event].push(handler)\n        \n        // Return unsubscribe function (closure pattern)\n        return || {\n            subscribers[event] = subscribers[event].filter(|h| h != handler)\n        }\n    }\n    \n    fun emit(event, data) {\n        if subscribers.has_key(event) {\n            for handler in subscribers[event] {\n                spawn { handler(data) }  // Async pattern\n            }\n        }\n    }\n}\n\n// Singleton pattern for global event bus\nlet events = EventBus::singleton()\n\n// Decorator pattern for logging\nfun with_logging(handler) {\n    return |data| {\n        println(\"[\" + current_datetime() + \"] Event triggered: \" + data)\n        let result = handler(data)\n        println(\"[\" + current_datetime() + \"] Event completed\")\n        return result\n    }\n}\n\n// Usage combining patterns\nlet unsubscribe = events.on(\"user.login\", with_logging(|user| {\n    println(\"User \" + user.name + \" logged in\")\n    update_last_login(user)\n}))\n\nevents.emit(\"user.login\", {name: \"Alice\", id: 123})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 2,
          "line_number": 117,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Fluent interface for configuration\nclass ServerBuilder {\n    let config = {\n        port: 8080,\n        host: \"localhost\",\n        threads: 4,\n        timeout: 30000,\n        middleware: [],\n        routes: {}\n    }\n    \n    fun port(p) {\n        config.port = p\n        return self  // Enable chaining\n    }\n    \n    fun host(h) {\n        config.host = h\n        return self\n    }\n    \n    fun threads(t) {\n        config.threads = t\n        return self\n    }\n    \n    fun use(middleware) {\n        config.middleware.push(middleware)\n        return self\n    }\n    \n    fun route(path, handler) {\n        config.routes[path] = handler\n        return self\n    }\n    \n    fun build() {\n        validate_config()\n        return Server::new(config)\n    }\n}\n\n// Clean, readable configuration\nlet server = ServerBuilder::new()\n    .port(3000)\n    .host(\"0.0.0.0\")\n    .threads(8)\n    .use(cors())\n    .use(auth())\n    .use(logging())\n    .route(\"/\", home_handler)\n    .route(\"/api\", api_handler)\n    .build()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 3,
          "line_number": 185,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Different compression strategies\nclass CompressionContext {\n    let strategy\n    \n    fun set_strategy(s) {\n        strategy = s\n    }\n    \n    fun compress(data) {\n        return strategy.compress(data)\n    }\n}\n\nclass GzipStrategy {\n    fun compress(data) {\n        return gzip::compress(data, level: 6)\n    }\n}\n\nclass BrotliStrategy {\n    fun compress(data) {\n        return brotli::compress(data, quality: 4)\n    }\n}\n\nclass NoCompressionStrategy {\n    fun compress(data) {\n        return data\n    }\n}\n\n// Choose strategy based on context\nlet compressor = CompressionContext::new()\n\nif file_size > mb(10) {\n    compressor.set_strategy(BrotliStrategy::new())  // Better for large files\n} else if client_supports_gzip {\n    compressor.set_strategy(GzipStrategy::new())\n} else {\n    compressor.set_strategy(NoCompressionStrategy::new())\n}\n\nlet compressed = compressor.compress(file_data)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 4,
          "line_number": 243,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Middleware chain for request processing\nclass MiddlewareChain {\n    let middlewares = []\n    \n    fun use(middleware) {\n        middlewares.push(middleware)\n    }\n    \n    fun execute(request, response) {\n        let index = 0\n        \n        fun next() {\n            if index < middlewares.len() {\n                let middleware = middlewares[index]\n                index += 1\n                middleware(request, response, next)\n            }\n        }\n        \n        next()\n    }\n}\n\n// Define middleware\nfun auth_middleware(req, res, next) {\n    let token = req.header(\"Authorization\")\n    if !token {\n        return res.status(401).json({error: \"Unauthorized\"})\n    }\n    \n    req.user = validate_token(token)\n    next()\n}\n\nfun rate_limit_middleware(req, res, next) {\n    let key = req.ip\n    if rate_limiter.exceeded(key) {\n        return res.status(429).json({error: \"Too many requests\"})\n    }\n    \n    rate_limiter.increment(key)\n    next()\n}\n\nfun cache_middleware(req, res, next) {\n    let cache_key = req.url\n    if cache.has(cache_key) {\n        return res.send(cache.get(cache_key))\n    }\n    \n    // Intercept response to cache it\n    let original_send = res.send\n    res.send = |data| {\n        cache.set(cache_key, data)\n        original_send(data)\n    }\n    \n    next()\n}\n\n// Build the chain\nlet chain = MiddlewareChain::new()\nchain.use(rate_limit_middleware)\nchain.use(auth_middleware)\nchain.use(cache_middleware)\nchain.use(route_handler)\n\nchain.execute(request, response)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 5,
          "line_number": 328,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Function composition\nfun compose(...functions) {\n    return |x| {\n        let result = x\n        for f in functions.reverse() {\n            result = f(result)\n        }\n        return result\n    }\n}\n\n// Pipeline operator\nfun pipeline(value, ...functions) {\n    let result = value\n    for f in functions {\n        result = f(result)\n    }\n    return result\n}\n\n// Example: Data transformation pipeline\nlet process_data = compose(\n    validate,\n    normalize,\n    enrich,\n    transform,\n    format\n)\n\nlet result = process_data(raw_data)\n\n// Or using pipeline\nlet result = pipeline(\n    raw_data,\n    validate,\n    normalize,\n    enrich,\n    transform,\n    format\n)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 6,
          "line_number": 383,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Result monad for error handling\nclass Result {\n    let value\n    let error\n    \n    static fun ok(val) {\n        return Result{value: val, error: null}\n    }\n    \n    static fun err(e) {\n        return Result{value: null, error: e}\n    }\n    \n    fun is_ok() {\n        return error == null\n    }\n    \n    fun map(f) {\n        if is_ok() {\n            return Result::ok(f(value))\n        }\n        return self\n    }\n    \n    fun flat_map(f) {\n        if is_ok() {\n            return f(value)\n        }\n        return self\n    }\n    \n    fun unwrap_or(default) {\n        if is_ok() {\n            return value\n        }\n        return default\n    }\n}\n\n// Chain operations safely\nfun process_user(id) {\n    return fetch_user(id)\n        .map(|user| validate_user(user))\n        .flat_map(|user| enrich_user_data(user))\n        .map(|user| format_user(user))\n        .unwrap_or({error: \"Processing failed\"})\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 7,
          "line_number": 445,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Lazy sequences\nclass LazySeq {\n    let generator\n    let cache = []\n    let index = 0\n    \n    fun next() {\n        if index >= cache.len() {\n            let value = generator()\n            if value != null {\n                cache.push(value)\n            }\n        }\n        \n        if index < cache.len() {\n            let value = cache[index]\n            index += 1\n            return value\n        }\n        \n        return null\n    }\n    \n    fun take(n) {\n        let result = []\n        for i in range(n) {\n            let value = next()\n            if value == null {\n                break\n            }\n            result.push(value)\n        }\n        return result\n    }\n    \n    fun map(f) {\n        return LazySeq::new(|| {\n            let value = next()\n            if value != null {\n                return f(value)\n            }\n            return null\n        })\n    }\n    \n    fun filter(predicate) {\n        return LazySeq::new(|| {\n            loop {\n                let value = next()\n                if value == null {\n                    return null\n                }\n                if predicate(value) {\n                    return value\n                }\n            }\n        })\n    }\n}\n\n// Infinite sequence\nlet fibonacci = LazySeq::new(|| {\n    static let a = 0\n    static let b = 1\n    let next = a\n    a = b\n    b = next + b\n    return next\n})\n\n// Only computes what's needed\nlet first_10_even = fibonacci\n    .filter(|n| n % 2 == 0)\n    .take(10)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 8,
          "line_number": 536,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Generic repository interface\nclass Repository {\n    fun find(id)\n    fun find_all()\n    fun find_where(conditions)\n    fun save(entity)\n    fun delete(id)\n}\n\n// Concrete implementation\nclass UserRepository < Repository {\n    let db\n    \n    fun find(id) {\n        let row = db.query_one(\"SELECT * FROM users WHERE id = ?\", [id])\n        return row ? User::from_row(row) : null\n    }\n    \n    fun find_where(conditions) {\n        let query = QueryBuilder::new(\"users\")\n            .where(conditions)\n            .build()\n        \n        return db.query(query).map(|row| User::from_row(row))\n    }\n    \n    fun save(user) {\n        if user.id {\n            db.execute(\"UPDATE users SET ... WHERE id = ?\", user.to_row())\n        } else {\n            user.id = db.execute(\"INSERT INTO users ... VALUES ...\", user.to_row())\n        }\n        return user\n    }\n}\n\n// Use repository in service layer\nclass UserService {\n    let repository\n    \n    fun get_active_users() {\n        return repository.find_where({active: true})\n    }\n    \n    fun create_user(data) {\n        let user = User::new(data)\n        user.validate()\n        return repository.save(user)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 9,
          "line_number": 601,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Event sourcing system\nclass EventStore {\n    let events = []\n    let snapshots = {}\n    let projections = {}\n    \n    fun append(event) {\n        event.id = generate_id()\n        event.timestamp = current_time()\n        event.version = events.len() + 1\n        \n        events.push(event)\n        update_projections(event)\n        \n        // Create snapshot every 100 events\n        if events.len() % 100 == 0 {\n            create_snapshot()\n        }\n    }\n    \n    fun replay(from_version = 0) {\n        let state = snapshots.get_latest_before(from_version) || {}\n        \n        for event in events.filter(|e| e.version > from_version) {\n            state = apply_event(state, event)\n        }\n        \n        return state\n    }\n    \n    fun get_projection(name) {\n        return projections[name]\n    }\n}\n\n// Domain events\nclass OrderPlaced {\n    let order_id\n    let customer_id\n    let items\n    let total\n}\n\nclass PaymentReceived {\n    let order_id\n    let amount\n    let method\n}\n\n// Event handlers update projections\nfun handle_order_placed(event) {\n    projections.orders[event.order_id] = {\n        status: \"pending\",\n        customer: event.customer_id,\n        total: event.total\n    }\n    \n    projections.customer_orders[event.customer_id].push(event.order_id)\n}\n\n// Rebuild state from events\nlet current_state = event_store.replay()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 10,
          "line_number": 678,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Command side - writes\nclass CommandBus {\n    let handlers = {}\n    \n    fun register(command_type, handler) {\n        handlers[command_type] = handler\n    }\n    \n    fun dispatch(command) {\n        let handler = handlers[command.type]\n        if !handler {\n            throw \"No handler for command: \" + command.type\n        }\n        \n        return handler(command)\n    }\n}\n\n// Query side - reads\nclass QueryBus {\n    let handlers = {}\n    \n    fun register(query_type, handler) {\n        handlers[query_type] = handler\n    }\n    \n    fun query(query) {\n        let handler = handlers[query.type]\n        if !handler {\n            throw \"No handler for query: \" + query.type\n        }\n        \n        return handler(query)\n    }\n}\n\n// Commands modify state\ncommand_bus.register(\"CreateOrder\", |cmd| {\n    let order = Order::new(cmd.data)\n    order.validate()\n    event_store.append(OrderPlaced::new(order))\n    return order.id\n})\n\n// Queries read projections\nquery_bus.register(\"GetOrdersByCustomer\", |query| {\n    return read_model.get_customer_orders(query.customer_id)\n})\n\n// Usage\nlet order_id = command_bus.dispatch({\n    type: \"CreateOrder\",\n    data: {customer: 123, items: [...]}\n})\n\nlet orders = query_bus.query({\n    type: \"GetOrdersByCustomer\",\n    customer_id: 123\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 11,
          "line_number": 754,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Actor system\nclass Actor {\n    let mailbox = Queue::new()\n    let running = true\n    \n    fun receive(message) {\n        mailbox.push(message)\n    }\n    \n    fun start() {\n        spawn {\n            while running {\n                let message = mailbox.pop()\n                if message {\n                    handle_message(message)\n                }\n                sleep(1)\n            }\n        }\n    }\n    \n    fun handle_message(message) {\n        // Override in subclass\n    }\n}\n\n// Concrete actor\nclass WorkerActor < Actor {\n    let state = {}\n    \n    fun handle_message(message) {\n        match message.type {\n            \"process\" => {\n                let result = process_work(message.data)\n                message.reply_to.receive({\n                    type: \"result\",\n                    data: result\n                })\n            }\n            \"get_state\" => {\n                message.reply_to.receive({\n                    type: \"state\",\n                    data: state\n                })\n            }\n            \"shutdown\" => {\n                running = false\n            }\n        }\n    }\n}\n\n// Actor system\nlet system = ActorSystem::new()\nlet worker = system.spawn(WorkerActor)\n\nworker.send({\n    type: \"process\",\n    data: work_item,\n    reply_to: self\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-advanced-patterns.md",
          "example_number": 12,
          "line_number": 830,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nclass CircuitBreaker {\n    let failure_threshold = 5\n    let timeout = 30000\n    let failure_count = 0\n    let last_failure_time = 0\n    let state = \"closed\"  // closed, open, half_open\n    \n    fun call(operation) {\n        if state == \"open\" {\n            if current_time() - last_failure_time > timeout {\n                state = \"half_open\"\n            } else {\n                throw \"Circuit breaker is open\"\n            }\n        }\n        \n        try {\n            let result = operation()\n            \n            if state == \"half_open\" {\n                state = \"closed\"\n                failure_count = 0\n            }\n            \n            return result\n        } catch error {\n            failure_count += 1\n            last_failure_time = current_time()\n            \n            if failure_count >= failure_threshold {\n                state = \"open\"\n                println(\"Circuit breaker opened after \" + failure_count.to_s() + \" failures\")\n            }\n            \n            throw error\n        }\n    }\n}\n\n// Use circuit breaker for external service\nlet api_breaker = CircuitBreaker::new()\n\nfun call_external_api(data) {\n    return api_breaker.call(|| {\n        http::post(\"https://api.external.com/endpoint\")\n            .json(data)\n            .timeout(5000)\n            .send()\n    })\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "appendix-b-syntax-reference": {
      "chapter": "appendix-b-syntax-reference",
      "total_examples": 35,
      "working_examples": 2,
      "failing_examples": 33,
      "examples": [
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 1,
          "line_number": 23,
          "code": "// Status: ✅ WORKING\n\n// Single line comment\n\n/* \n   Multi-line comment\n   Can span multiple lines\n*/\n\n/// Documentation comment for the following item\nfun documented_function() {}\n\n//! Inner documentation comment for containing item",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 2,
          "line_number": 47,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Valid identifiers\nvariable_name\ncamelCase\nPascalCase\n_private\n_internal\nsnake_case_123\nτ  // Unicode allowed\n\n// Keywords (reserved)\nlet mut fn if else match while for loop break continue\nreturn true false null struct enum trait impl use mod\nasync await type where const static pub super self",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 3,
          "line_number": 74,
          "code": "// Status: ❌ BROKEN\n\n// Integers\n42          // Decimal\n0xFF        // Hexadecimal  \n0o77        // Octal\n0b1010      // Binary\n1_000_000   // With separators\n\n// Floating point\n3.14\n2.0\n1e6         // Scientific notation\n1.5e-10\n\n// Type suffixes\n42i32       // 32-bit integer\n3.14f64     // 64-bit float\n100u8       // Unsigned 8-bit\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `xFF` in this scope\n --> /tmp/.tmpW6t13c/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...\n  |                                                                                ^^^ not found in this scope\n\nerror[E0425]: cannot find value `o77` in this scope\n --> /tmp/.tmpW6t13c/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...\n  |                                                                                             ^^^ not found in this scope\n\nerror[E0425]: cannot find value `b1010` in this scope\n --> /tmp/.tmpW6t13c/main.rs:1:106\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...\n  |                                                                                                          ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `_000_000` in this scope\n --> /tmp/.tmpW6t13c/main.rs:1:121\n  |\n1 | ... ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; 3.14f64 ; f64 ; ...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `e6` in this scope\n --> /tmp/.tmpW6t13c/main.rs:1:156\n  |\n1 | ...2 ; b1010 ; 1i32 ; _000_000 ; 3.14f64 ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; 3.14f64 ; f64 ; 100i32 } ; if let Some (s) = (& ...\n  |                                                          ^^ not found in this scope\n\nerror[E0423]: expected value, found builtin type `f64`\n --> /tmp/.tmpW6t13c/main.rs:1:198\n  |\n1 | ... ; 2f64 ; 1i32 ; e6 ; 0.00000000015f64 ; 42i32 ; 3.14f64 ; f64 ; 100i32 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...\n  |                                                               ^^^ not a value\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpW6t13c/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { 42i32 ; 0i32 ; xFF ; 0i32 ; o77 ; 0i32 ; b1010 ; 1i32 ; _000_000 ; 3.14f6...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 4,
          "line_number": 105,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// String literals\n\"hello world\"\n\"unicode: αβγ\"\n\"escapes: \\n \\t \\r \\\\ \\\" \\'\"\n\n// Raw strings (no escapes)\nr\"raw string with \\n literal backslashes\"\nr#\"can contain \"quotes\" with # delimiters\"#\nr##\"even more \"# nested # delimiters\"##\n\n// Multi-line strings\n\"line one\\\nline two\"\n\n// Format strings\n\"Hello, \" + name + \"!\"\n\"Result: \" + value.to_s()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 5,
          "line_number": 134,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n'a'         // ASCII character\n'\\n'        // Escape sequence\n'\\x41'      // Hex escape\n'\\u{1F600}' // Unicode escape",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 6,
          "line_number": 152,
          "code": "// Status: ❌ BROKEN\n\n// Boolean\nlet flag: bool = true\n\n// Integers\nlet small: i8 = -128           // 8-bit signed\nlet byte: u8 = 255             // 8-bit unsigned  \nlet short: i16 = -32768        // 16-bit signed\nlet word: u16 = 65535          // 16-bit unsigned\nlet int: i32 = -2147483648     // 32-bit signed\nlet uint: u32 = 4294967295     // 32-bit unsigned\nlet long: i64 = -9223372036854775808  // 64-bit signed\nlet ulong: u64 = 18446744073709551615 // 64-bit unsigned\nlet size: isize = -1           // Pointer-sized signed\nlet usize: usize = 1           // Pointer-sized unsigned\n\n// Floating point\nlet single: f32 = 3.14         // 32-bit float\nlet double: f64 = 2.718281828  // 64-bit float\n\n// Character\nlet ch: char = 'A'             // Unicode scalar value\n\n// String\nlet text: str = \"hello\"        // String slice\nlet owned: String = \"world\"    // Owned string\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found `let` statement\n --> /tmp/.tmpohst8j/main.rs:1:275\n  |\n1 | ...147483648i64 ; let mut uint = 4294967295i64 ; let mut long = - ! let mut ulong = ! let mut size = - 1i32 ; let mut usize = 1i32 ; let ...\n  |                                                                     ^^^\n  |\n  = note: only supported directly in conditions of `if` and `while` expressions\n\nerror: expected expression, found `let` statement\n --> /tmp/.tmpohst8j/main.rs:1:293\n  |\n1 | ... mut uint = 4294967295i64 ; let mut long = - ! let mut ulong = ! let mut size = - 1i32 ; let mut usize = 1i32 ; let mut single = 3.14f...\n  |                                                                     ^^^\n  |\n  = note: only supported directly in conditions of `if` and `while` expressions\n\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpohst8j/main.rs:1:499\n  |\n1 | ...let mut owned = \"world\" . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpohst8j/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut flag = true ; let mut small = - 128i32 ; let mut byte = 255i32 ; ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 7,
          "line_number": 191,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Arrays (fixed size)\nlet arr: [i32; 5] = [1, 2, 3, 4, 5]\nlet zeros: [i32; 100] = [0; 100]\n\n// Slices (dynamic size)\nlet slice: &[i32] = &arr[1..3]\n\n// Tuples\nlet tuple: (i32, str, bool) = (42, \"hello\", true)\nlet unit: () = ()  // Unit type\n\n// Vectors (dynamic arrays)\nlet vec: Vec<i32> = vec![1, 2, 3, 4, 5]\n\n// Hash maps\nlet map: HashMap<String, i32> = HashMap::new()\n\n// Options\nlet maybe: Option<i32> = Some(42)\nlet nothing: Option<i32> = None\n\n// Results  \nlet ok: Result<i32, String> = Ok(42)\nlet err: Result<i32, String> = Err(\"error message\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 8,
          "line_number": 229,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Immutable by default\nlet x = 42\nlet name = \"Alice\"\n\n// Explicit type annotation\nlet count: i32 = 100\nlet score: f64 = 95.5\n\n// Mutable variables\nlet mut counter = 0\ncounter += 1\n\n// Pattern destructuring\nlet (x, y) = (10, 20)\nlet [first, second, ..] = [1, 2, 3, 4, 5]\n\n// Shadowing\nlet x = 42\nlet x = \"now a string\"  // Shadows previous x",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmp5YgUaK/main.rs:1:384\n  |\n1 | ... mut x = \"now a string\" . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp5YgUaK/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut x = 42i32 ; let mut name = \"Alice\" . to_string () ; let mut count...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0529]: expected an array or slice, found `Vec<i32>`\n --> /tmp/.tmp5YgUaK/main.rs:1:255\n  |\n1 | ...(x , y) = (10i32 , 20i32) ; let [first , second , ..] = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32] ; let mut x = 42i32 ; let mut x = \"no...\n  |                                    ^^^^^^^^^^^^^^^^^^^^^ pattern cannot match with input type `Vec<i32>`\n  |\nhelp: consider slicing here\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut x = 42i32 ; let mut name = \"Alice\" . to_string () ; let mut count = 100i32 ; let mut score = 95.5f64 ; let mut counter = 0i32 ; counter += 1i32 ; let (x , y) = (10i32 , 20i32) ; let [first , second , ..] = vec ! [1i32 , 2i32 , 3i32 , 4i32 , 5i32][..] ; let mut x = 42i32 ; let mut x = \"now a string\" . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |                                                                                                                                                                                                                                                                                                                               ++++\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0529`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 9,
          "line_number": 260,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Compile-time constants\nconst MAX_SIZE: usize = 1024\nconst PI: f64 = 3.14159265359\n\n// Static variables\nstatic GLOBAL_COUNTER: AtomicUsize = AtomicUsize::new(0)\nstatic mut GLOBAL_STATE: i32 = 0  // Unsafe to mutate",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 10,
          "line_number": 281,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// If expressions\nlet result = if condition {\n    \"true branch\"\n} else {\n    \"false branch\"\n}\n\n// Multiple conditions\nif x > 0 {\n    \"positive\"\n} else if x < 0 {\n    \"negative\"  \n} else {\n    \"zero\"\n}\n\n// Let-else pattern\nlet Some(value) = optional else {\n    return Err(\"No value\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 11,
          "line_number": 313,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\n// Match expressions\nmatch value {\n    0 => \"zero\",\n    1 | 2 => \"one or two\",\n    3..=10 => \"three through ten\",\n    n if n > 100 => \"big number\",\n    _ => \"something else\"\n}\n\n// Destructuring patterns\nmatch point {\n    Point { x: 0, y: 0 } => \"origin\",\n    Point { x, y: 0 } => \"on x-axis at \" + x.to_s() + \",\",\n    Point { x: 0, y } => \"on y-axis at \" + y.to_s() + \",\",\n    Point { x, y } => \"point at (\" + x.to_s() + \", \" + y.to_s() + \")\"\n}\n\n// Guards\nmatch number {\n    n if n < 0 => \"negative\",\n    n if n > 0 => \"positive\", \n    _ => \"zero\"\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `value` in this scope\n --> /tmp/.tmpYlsrF9/main.rs:1:71\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { match value { 0i32 => \"zero\" , 1i32 | 2i32 => \"one or two\" , 3i32 ..= 10i...\n  |                                                                       ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `point` in this scope\n --> /tmp/.tmpYlsrF9/main.rs:1:234\n  |\n1 | ...=> \"big number\" , _ => \"something else\" , } ; match point { Point { x : 0i32 , y : 0i32 } => \"origin\" , Point { x , y : 0i32 } => form...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmpYlsrF9/main.rs:1:242\n  |\n1 | ...number\" , _ => \"something else\" , } ; match point { Point { x : 0i32 , y : 0i32 } => \"origin\" , Point { x , y : 0i32 } => format ! (\"{...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmpYlsrF9/main.rs:1:286\n  |\n1 | ...point { Point { x : 0i32 , y : 0i32 } => \"origin\" , Point { x , y : 0i32 } => format ! (\"{}{}\" , format ! (\"{}{}\" , \"on x-axis at \" , ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmpYlsrF9/main.rs:1:390\n  |\n1 | ...! (\"{}{}\" , \"on x-axis at \" , x . to_s ()) , \",\") , Point { x : 0i32 , y } => format ! (\"{}{}\" , format ! (\"{}{}\" , \"on y-axis at \" , ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Point` in this scope\n --> /tmp/.tmpYlsrF9/main.rs:1:494\n  |\n1 | ...! (\"{}{}\" , \"on y-axis at \" , y . to_s ()) , \",\") , Point { x , y } => format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"point...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `number` in this scope\n --> /tmp/.tmpYlsrF9/main.rs:1:639\n  |\n1 | .... to_s ()) , \", \") + y . to_s () , \")\") , } ; match number { n if n < 0i32 => \"negative\" , n if n > 0i32 => \"positive\" , _ => \"zero\" ,...\n  |                                                        ^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpYlsrF9/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { match value { 0i32 => \"zero\" , 1i32 | 2i32 => \"one or two\" , 3i32 ..= 10i...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: `match` arms have incompatible types\n --> /tmp/.tmpYlsrF9/main.rs:1:312\n  |\n1 | ... ; match point { Point { x : 0i32 , y : 0i32 } => \"origin\" , Point { x , y : 0i32 } => format ! (\"{}{}\" , format ! (\"{}{}\" , \"on x-axis at \" , x . to_s ()) , \",\") , ...\n  |       -----------                                    --------                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`\n  |       |                                              |\n  |       |                                              this is found to be of type `&str`\n  |       `match` arms have incompatible types\n  |\n  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 8 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0422, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 12,
          "line_number": 348,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Infinite loop\nloop {\n    // Code here\n    if condition {\n        break\n    }\n}\n\n// While loop\nwhile condition {\n    // Code here\n}\n\n// For loop with iterators\nfor item in collection {\n    // Process item\n}\n\n// For loop with range\nfor i in 0..10 {\n    println(\"Count: \" + i.to_s())\n}\n\n// For loop with enumerate\nfor (index, item) in collection.enumerate() {\n    println(index.to_s() + \": \" + item)\n}\n\n// Loop labels and break/continue\n'outer: loop {\n    loop {\n        if condition {\n            break 'outer  // Break outer loop\n        }\n        if other_condition {\n            continue 'outer  // Continue outer loop\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 13,
          "line_number": 403,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Basic function\nfun greet(name: String) -> String {\n    return \"Hello, \" + name + \"!\"\n}\n\n// Implicit return (no semicolon)\nfun add(a: i32, b: i32) -> i32 {\n    a + b  // Last expression is returned\n}\n\n// Unit return type (no return value)\nfun print_message(msg: String) {\n    println(msg)\n}\n\n// Multiple parameters\nfun calculate(x: f64, y: f64, operation: char) -> f64 {\n    match operation {\n        '+' => x + y,\n        '-' => x - y,\n        '*' => x * y,\n        '/' => x / y,\n        _ => panic(\"Invalid operation\")\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 14,
          "line_number": 440,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// By value (move)\nfun take_ownership(s: String) {\n    // s is moved here\n}\n\n// By reference (borrow)\nfun borrow_value(s: &String) -> usize {\n    s.len()  // s is borrowed\n}\n\n// Mutable reference\nfun modify_value(s: &mut String) {\n    s.push_str(\" modified\")\n}\n\n// Default parameters\nfun connect(host: String, port: u16 = 8080, timeout: u64 = 5000) {\n    // Implementation\n}\n\n// Variable arguments\nfun sum(numbers: &[i32]) -> i32 {\n    numbers.iter().sum()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 15,
          "line_number": 476,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Closure syntax\nlet add = |a, b| a + b\nlet result = add(5, 3)\n\n// Explicit types\nlet multiply: fn(i32, i32) -> i32 = |a, b| a * b\n\n// Capturing environment\nlet x = 10\nlet add_x = |y| x + y  // Captures x\nlet result = add_x(5)  // 15\n\n// Move capture\nlet name = String::from(\"Alice\")\nlet greeter = move |greeting| {\n    greeting + \", \" + name + \"!\"  // name is moved into closure\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 16,
          "line_number": 505,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Function as parameter\nfun apply_operation(x: i32, y: i32, op: fn(i32, i32) -> i32) -> i32 {\n    op(x, y)\n}\n\n// Function returning function\nfun make_adder(n: i32) -> impl Fn(i32) -> i32 {\n    move |x| x + n\n}\n\n// Generic function\nfun map_over<T, U, F>(items: Vec<T>, f: F) -> Vec<U>\nwhere F: Fn(T) -> U\n{\n    items.into_iter().map(f).collect()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 17,
          "line_number": 535,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Basic struct\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n// Tuple struct\nstruct Color(u8, u8, u8)\n\n// Unit struct\nstruct Marker\n\n// Generic struct\nstruct Container<T> {\n    value: T,\n}\n\n// Struct with lifetime\nstruct Excerpt<'a> {\n    text: &'a str,\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 18,
          "line_number": 568,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Creating instances\nlet origin = Point { x: 0.0, y: 0.0 }\nlet red = Color(255, 0, 0)\n\n// Field access\nlet x_coord = origin.x\n\n// Struct update syntax\nlet point2 = Point { x: 1.0, ..origin }\n\n// Destructuring\nlet Point { x, y } = origin\nlet Color(r, g, b) = red",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 19,
          "line_number": 593,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Basic enum\nenum Direction {\n    North,\n    South,\n    East,\n    West,\n}\n\n// Enum with data\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\n// Generic enum\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 20,
          "line_number": 626,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nimpl Point {\n    // Associated function (constructor)\n    fun new(x: f64, y: f64) -> Point {\n        Point { x, y }\n    }\n    \n    // Method (takes &self)\n    fun distance_from_origin(&self) -> f64 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n    \n    // Mutable method (takes &mut self)\n    fun translate(&mut self, dx: f64, dy: f64) {\n        self.x += dx\n        self.y += dy\n    }\n    \n    // Consuming method (takes self)\n    fun into_tuple(self) -> (f64, f64) {\n        (self.x, self.y)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 21,
          "line_number": 662,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Basic trait\ntrait Draw {\n    fun draw(&self)\n}\n\n// Trait with default implementation\ntrait Summary {\n    fun summarize_author(&self) -> String\n    \n    fun summarize(&self) -> String {\n        \"(Read more from \" + self.summarize_author() + \"...)\"\n    }\n}\n\n// Trait with associated types\ntrait Iterator {\n    type Item\n    \n    fun next(&mut self) -> Option<Self::Item>\n}\n\n// Trait with generic parameters\ntrait From<T> {\n    fun from(value: T) -> Self\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 22,
          "line_number": 699,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nimpl Draw for Point {\n    fun draw(&self) {\n        println(\"Drawing point at (\" + self.x.to_s() + \", \" + self.y.to_s() + \")\")\n    }\n}\n\n// Conditional implementation\nimpl<T: Display> ToString for T {\n    fun to_string(&self) -> String {\n        // Implementation\n    }\n}\n\n// Blanket implementation\nimpl<T: Clone> Clone for Box<T> {\n    fun clone(&self) -> Box<T> {\n        // Implementation  \n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 23,
          "line_number": 732,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun largest<T: PartialOrd>(list: &[T]) -> &T {\n    let mut largest = &list[0]\n    for item in list {\n        if item > largest {\n            largest = item\n        }\n    }\n    largest\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 24,
          "line_number": 753,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Point<T> {\n    fun new(x: T, y: T) -> Point<T> {\n        Point { x, y }\n    }\n}\n\nimpl Point<f64> {\n    fun distance_from_origin(&self) -> f64 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 25,
          "line_number": 781,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Single bound\nfun print_it<T: Display>(item: T) {\n    println(\"{}\", item)\n}\n\n// Multiple bounds\nfun compare_and_print<T: Display + PartialOrd>(a: T, b: T) {\n    if a > b {\n        println(\"a is greater\")\n    } else {\n        println(\"b is greater or equal\")\n    }\n}\n\n// Where clause\nfun some_function<T, U>(t: T, u: U) -> i32\nwhere\n    T: Display + Clone,\n    U: Clone + Debug,\n{\n    // Implementation\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 26,
          "line_number": 817,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Inline module\nmod network {\n    fun connect() {\n        // Implementation\n    }\n    \n    pub fun public_function() {\n        // Can be called from outside module\n    }\n}\n\n// File-based modules\nmod utils;  // Looks for utils.rs or utils/mod.rs\n\n// Nested modules\nmod graphics {\n    pub mod shapes {\n        pub fun draw_circle() {}\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 27,
          "line_number": 849,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\npub fun public_function() {}           // Public\nfun private_function() {}              // Private to module\n\npub struct PublicStruct {\n    pub public_field: i32,            // Public field\n    private_field: i32,               // Private field\n}\n\npub(crate) fun crate_visible() {}      // Visible within crate\npub(super) fun parent_visible() {}     // Visible to parent module\npub(in crate::utils) fun limited() {} // Visible within specific path",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 28,
          "line_number": 872,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nuse std::collections::HashMap         // Single import\nuse std::fs::{File, OpenOptions}      // Multiple imports\nuse std::io::*                        // Glob import\nuse std::collections::HashMap as Map  // Alias\n\n// Re-exports\npub use internal::public_api\n\n// Conditional compilation\n#[cfg(unix)]\nuse unix_specific::module\n\n#[cfg(windows)]  \nuse windows_specific::module",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 29,
          "line_number": 900,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Result type\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\n// Option type\nenum Option<T> {\n    Some(T),\n    None,\n}\n\n// Using ? operator\nfun read_file(path: &str) -> Result<String, std::io::Error> {\n    let content = std::fs::read_to_string(path)?\n    Ok(content.to_uppercase())\n}\n\n// Combining with match\nmatch result {\n    Ok(value) => println(\"Success: {}\", value),\n    Err(error) => eprintln(\"Error: {}\", error),\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 30,
          "line_number": 935,
          "code": "// Status: ❌ BROKEN\n\n// Unconditional panic\npanic!(\"Something went wrong!\")\n\n// Conditional panic\nassert!(condition, \"Condition must be true\")\nassert_eq!(left, right, \"Values must be equal\")\n\n// Debug assertions (only in debug builds)\ndebug_assert!(expensive_check())\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 31,
          "line_number": 960,
          "code": "// Status: ❌ BROKEN\n\n// Function-like macros\nprintln!(\"Hello, {}!\", name)\nvec![1, 2, 3, 4, 5]\nformat!(\"Value: {}\", x)\n\n// Attribute-like macros\n#[derive(Debug, Clone)]\nstruct MyStruct {}\n\n#[cfg(test)]\nmod tests {}\n\n// Derive macros\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\nstruct Point { x: i32, y: i32 }\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 32,
          "line_number": 989,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Declarative macro\nmacro_rules! say_hello {\n    () => {\n        println!(\"Hello!\")\n    };\n    ($name:expr) => {\n        println!(\"Hello, {}!\", $name)\n    };\n}\n\n// Usage\nsay_hello!()\nsay_hello!(\"World\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 33,
          "line_number": 1016,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Conditional compilation\n#[cfg(target_os = \"linux\")]\nfun linux_only() {}\n\n#[cfg(feature = \"network\")]\nmod networking {}\n\n// Testing\n#[test]\nfun test_function() {}\n\n#[ignore]\n#[test]\nfun expensive_test() {}\n\n// Documentation\n#[doc = \"This is a documented function\"]\nfun documented() {}\n\n// Deprecation\n#[deprecated(note = \"Use new_function instead\")]\nfun old_function() {}\n\n// Allow/deny lints\n#[allow(dead_code)]\nfun unused_function() {}\n\n#[deny(missing_docs)]\nmod well_documented {}\n\n// Inline hints\n#[inline]\nfun small_function() {}\n\n#[inline(always)]\nfun always_inline() {}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 34,
          "line_number": 1066,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Async function\nasync fun fetch_data(url: &str) -> Result<String, reqwest::Error> {\n    let response = reqwest::get(url).await?\n    let text = response.text().await?\n    Ok(text)\n}\n\n// Async blocks\nlet future = async {\n    let result = some_async_operation().await\n    process_result(result)\n}\n\n// Async closures\nlet async_closure = async |x| {\n    expensive_async_operation(x).await\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-b-syntax-reference.md",
          "example_number": 35,
          "line_number": 1095,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nuse futures::{Future, Stream}\n\n// Implementing Future\nimpl Future for MyFuture {\n    type Output = i32\n    \n    fun poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        // Implementation\n    }\n}\n\n// Working with streams\nlet stream = async_stream::stream! {\n    for i in 0..10 {\n        yield i\n        tokio::time::sleep(Duration::from_millis(100)).await\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch10-00-input-output-tdd": {
      "chapter": "ch10-00-input-output-tdd",
      "total_examples": 10,
      "working_examples": 7,
      "failing_examples": 3,
      "examples": [
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"=== Output Demo ===\");\n    println(\"Number: \");\n    println(42);\n    println(\"Boolean: \");\n    println(true);\n    println(\"=== End Demo ===\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 2,
          "line_number": 60,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let name = \"Alice\";\n    let age = 30;\n    let height = 5.6;\n    \n    println(\"=== User Profile ===\");\n    println(\"Name:\");\n    println(name);\n    println(\"Age:\");\n    println(age);\n    println(\"Height:\");\n    println(height);\n    println(\"================\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 3,
          "line_number": 96,
          "code": "// Status: ✅ WORKING\nfun display_menu() {\n    println(\"=== Main Menu ===\");\n    println(\"1. View Profile\");\n    println(\"2. Settings\");\n    println(\"3. Exit\");\n    println(\"=================\");\n}\n\nfun main() {\n    display_menu();\n    println(\"Menu displayed successfully\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 4,
          "line_number": 147,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nprintln(\"text message\");\nprintln(variable);\nprintln(42);\nprintln(true);",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `variable` in this scope\n --> /tmp/.tmpQS6ei8/main.rs:1:114\n  |\n1 | ...{ println ! (\"text message\") ; println ! (\"{:?}\" , variable) ; println ! (\"{:?}\" , 42i32) ; println ! (\"{:?}\" , true) } ; if let Some ...\n  |                                                       ^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpQS6ei8/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"text message\") ; println ! (\"{:?}\" , variable) ; println ! (\"...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 5,
          "line_number": 159,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet data = value;\nprintln(\"Label:\");\nprintln(data);",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `value` in this scope\n --> /tmp/.tmpj7IFuv/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut data = value ; println ! (\"Label:\") ; println ! (\"{:?}\" , data) }...\n  |                                                                                ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpj7IFuv/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut data = value ; println ! (\"Label:\") ; println ! (\"{:?}\" , data) }...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 6,
          "line_number": 170,
          "code": "// Status: ✅ WORKING\nfun display_options() {\n    println(\"=== Menu ===\");\n    println(\"1. Option One\");\n    println(\"2. Option Two\");\n    println(\"============\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 7,
          "line_number": 197,
          "code": "// Status: ✅ WORKING\nlet value = 100;\nprintln(\"Result:\");\nprintln(value);",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 8,
          "line_number": 207,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun display_report(title: &str, data: i32) {\n    println(\"=== Report ===\");\n    println(title);\n    println(data);\n    println(\"==============\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 9,
          "line_number": 221,
          "code": "// Status: ✅ WORKING\nprintln(\"Processing...\");\n// ... do work ...\nprintln(\"Complete!\");",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 10,
          "line_number": 231,
          "code": "// Status: ✅ WORKING\nfun show_options() {\n    println(\"Choose an option:\");\n    println(\"1. Start\");\n    println(\"2. Stop\");\n    println(\"3. Help\");\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch18-00-deployment-devops": {
      "chapter": "ch18-00-deployment-devops",
      "total_examples": 8,
      "working_examples": 0,
      "failing_examples": 8,
      "examples": [
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 1,
          "line_number": 48,
          "code": "// Status: ❌ BROKEN\n\n// deploy.ruchy - One-command deployment\nuse std::deploy;\n\nlet config = DeployConfig {\n    app: \"my-app\",\n    environment: env::var(\"DEPLOY_ENV\"),  // staging/production\n    strategy: BlueGreen,\n    health_check: \"/health\",\n    rollback_on_failure: true\n}\n\n// Build and test\ndeploy::build()\n    .test()\n    .security_scan()\n    .create_artifact()\n\n// Deploy with zero downtime\nlet deployment = deploy::start(config)\n    .provision_infrastructure()\n    .deploy_new_version()\n    .run_smoke_tests()\n    .switch_traffic()\n    .verify_metrics()\n\nif deployment.is_healthy() {\n    deployment.commit()\n    println(\"✅ Deployment successful!\")\n} else {\n    deployment.rollback()\n    println(\"⚠️  Rolled back to previous version\")\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0432]: unresolved import `std::deploy`\n --> /tmp/.tmp1R5RI4/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let mut config = DeployConfig { app : \"my-app\" . to...\n  |                                                                     ^^^^^^^^^^^^^ no `deploy` in the root\n\nerror[E0422]: cannot find struct, variant or union type `DeployConfig` in this scope\n --> /tmp/.tmp1R5RI4/main.rs:1:104\n  |\n1 | ...esult = { use std :: deploy ; ; let mut config = DeployConfig { app : \"my-app\" . to_string () , environment : env :: var (\"DEPLOY_ENV\"...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `env`\n --> /tmp/.tmp1R5RI4/main.rs:1:165\n  |\n1 | ... \"my-app\" . to_string () , environment : env :: var (\"DEPLOY_ENV\" . to_string ()) , strategy : BlueGreen , health_check : \"/health\" . ...\n  |                                             ^^^ use of unresolved module or unlinked crate `env`\n  |\n  = help: you might be missing a crate named `env`\nhelp: consider importing this module\n  |\n1 + use std::env;\n  |\n\nerror[E0425]: cannot find value `BlueGreen` in this scope\n --> /tmp/.tmp1R5RI4/main.rs:1:219\n  |\n1 | ...:: var (\"DEPLOY_ENV\" . to_string ()) , strategy : BlueGreen , health_check : \"/health\" . to_string () , rollback_on_failure : true , }...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp1R5RI4/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let mut config = DeployConfig { app : \"my-app\" . to...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp1R5RI4/main.rs:1:85\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: deploy ; ; let mut config = DeployConfig { app : \"my-app\" . to...\n  |                                                                                     ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror: aborting due to 4 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\n\n",
          "errorCategory": "IMPORT_ERROR",
          "rootCause": "Missing dependency or import path issue"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 2,
          "line_number": 299,
          "code": "// Status: ❌ BROKEN\n\n// blue_green.ruchy\nfun deploy_blue_green(new_version: String) {\n    // Current production is \"blue\"\n    let blue = Environment::current()\n    \n    // Provision identical \"green\" environment\n    let green = Environment::provision(new_version)\n    \n    // Deploy to green\n    green.deploy()\n    green.run_health_checks()\n    green.run_smoke_tests()\n    \n    // Verify green is healthy\n    if !green.is_healthy() {\n        green.destroy()\n        panic!(\"Green environment unhealthy\")\n    }\n    \n    // Switch traffic to green\n    LoadBalancer::switch_to(green)\n    \n    // Monitor for issues\n    sleep(Duration::from_mins(5))\n    \n    if green.error_rate() > 0.01 {\n        // Rollback\n        LoadBalancer::switch_to(blue)\n        green.destroy()\n        panic!(\"High error rate, rolled back\")\n    }\n    \n    // Success - green is now production\n    blue.destroy()\n    println!(\"✅ Deployed version {}\", new_version)\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: argument never used\n --> /tmp/.tmpOQxrdr/main.rs:1:653\n  |\n1 | ... ; blue . destroy () ; println ! (\"✅ Deployed version {}\" , \"{:?}\" , new_version) } } } } fn main () { }\n  |                                      ------------------------            ^^^^^^^^^^^ argument never used\n  |                                      |\n  |                                      formatting specifier missing\n\nerror[E0425]: cannot find function `sleep` in this scope\n --> /tmp/.tmpOQxrdr/main.rs:1:406\n  |\n1 | ...healthy\") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { Load...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::sleep;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Duration`\n --> /tmp/.tmpOQxrdr/main.rs:1:413\n  |\n1 | ... ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { LoadBalancer :: s...\n  |                                                  ^^^^^^^^ use of undeclared type `Duration`\n  |\nhelp: consider importing this struct\n  |\n1 + use std::time::Duration;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpOQxrdr/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn deploy_blue_green (new_version : String) -> i32 { { { let blue = Environment :: current () ; { let...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpOQxrdr/main.rs:1:90\n  |\n1 | ... { { { let blue = Environment :: current () ; { let mut green = Environment :: provision (new_version) ; green . deploy () ; green . run_health_checks () ; green . run_smoke_tests () ; if ! green . is_healthy () { { green . destroy () ; panic ! (\"Green environment unhealthy\") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { LoadBalancer :: switch_to (blue) ; green . destroy () ; panic ! (\"High error rate, rolled back\") } } ; blue . destroy () ; println ! (\"✅ Deployed version {}\" , \"{:?}\" , new_version) } } } } f...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn deploy_blue_green (new_version : String) -> i32 { { { let blue = Environment :: current () ; { let mut green = Environment :: provision (new_version) ; green . deploy () ; green . run_health_checks () ; green . run_smoke_tests () ; if ! green . is_healthy () { { green . destroy () ; panic ! (\"Green environment unhealthy\") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { LoadBalancer :: switch_to (blue) ; green . destroy () ; panic ! (\"High error rate, rolled back\") } } ; blue . destroy () ; println ! (\"✅ Deployed version {}\" , \"{:?}\" , new_version) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn deploy_blue_green (new_version : String) -> i32 { { let blue = Environment :: current () ; { let mut green = Environment :: provision (new_version) ; green . deploy () ; green . run_health_checks () ; green . run_smoke_tests () ; if ! green . is_healthy () { { green . destroy () ; panic ! (\"Green environment unhealthy\") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_rate () > 0.01f64 { { LoadBalancer :: switch_to (blue) ; green . destroy () ; panic ! (\"High error rate, rolled back\") } } ; blue . destroy () ; println ! (\"✅ Deployed version {}\" , \"{:?}\" , new_version) } } } fn main () { }\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Environment`\n --> /tmp/.tmpOQxrdr/main.rs:1:105\n  |\n1 | ..._version : String) -> i32 { { { let blue = Environment :: current () ; { let mut green = Environment :: provision (new_version) ; gree...\n  |                                               ^^^^^^^^^^^ use of undeclared type `Environment`\n\nerror[E0433]: failed to resolve: use of undeclared type `Environment`\n --> /tmp/.tmpOQxrdr/main.rs:1:151\n  |\n1 | ...ironment :: current () ; { let mut green = Environment :: provision (new_version) ; green . deploy () ; green . run_health_checks () ;...\n  |                                               ^^^^^^^^^^^ use of undeclared type `Environment`\n\nerror[E0433]: failed to resolve: use of undeclared type `LoadBalancer`\n --> /tmp/.tmpOQxrdr/main.rs:1:370\n  |\n1 | ...c ! (\"Green environment unhealthy\") } } ; LoadBalancer :: switch_to (green) ; sleep (Duration :: from_mins (5i32)) ; if green . error_...\n  |                                              ^^^^^^^^^^^^ use of undeclared type `LoadBalancer`\n\nerror[E0433]: failed to resolve: use of undeclared type `LoadBalancer`\n --> /tmp/.tmpOQxrdr/main.rs:1:484\n  |\n1 | ... ; if green . error_rate () > 0.01f64 { { LoadBalancer :: switch_to (blue) ; green . destroy () ; panic ! (\"High error rate, rolled ba...\n  |                                              ^^^^^^^^^^^^ use of undeclared type `LoadBalancer`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpOQxrdr/main.rs:1:607\n  |\n1 | ...} ; blue . destroy () ; println ! (\"✅ Deployed version {}\" , \"{:?}\" , new_version) } } } } fn main () { }\n  |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 8 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0308, E0425, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 3,
          "line_number": 352,
          "code": "// Status: ❌ BROKEN\n\n// canary.ruchy\nfun deploy_canary(new_version: String) {\n    let deployment = CanaryDeployment::new(new_version)\n    \n    // Start with 5% traffic\n    deployment.set_traffic_percentage(5)\n    deployment.deploy()\n    \n    // Monitor metrics\n    let baseline = Metrics::baseline()\n    \n    // Gradually increase traffic\n    for percentage in [5, 10, 25, 50, 100] {\n        deployment.set_traffic_percentage(percentage)\n        \n        sleep(Duration::from_mins(10))\n        \n        let current = Metrics::current()\n        if current.error_rate > baseline.error_rate * 1.1 {\n            deployment.rollback()\n            panic!(\"Error rate increased by >10%\")\n        }\n        \n        if current.p99_latency > baseline.p99_latency * 1.2 {\n            deployment.rollback()\n            panic!(\"Latency increased by >20%\")\n        }\n        \n        println!(\"✅ Canary at {}% - metrics healthy\", percentage)\n    }\n    \n    deployment.finalize()\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: argument never used\n --> /tmp/.tmp1PyeHs/main.rs:1:791\n  |\n1 | ... by >20%\") } } ; println ! (\"✅ Canary at {}% - metrics healthy\" , \"{:?}\" , percentage) } } } } ; deployment . finalize () } } } } fn ma...\n  |                                ------------------------------------            ^^^^^^^^^^ argument never used\n  |                                |\n  |                                formatting specifier missing\n\nerror[E0425]: cannot find function `sleep` in this scope\n --> /tmp/.tmp1PyeHs/main.rs:1:382\n  |\n1 | ... deployment . set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { ...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::sleep;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Duration`\n --> /tmp/.tmp1PyeHs/main.rs:1:389\n  |\n1 | ... set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . ...\n  |                                                  ^^^^^^^^ use of undeclared type `Duration`\n  |\nhelp: consider importing this struct\n  |\n1 + use std::time::Duration;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp1PyeHs/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn deploy_canary (new_version : String) -> i32 { { { let deployment = CanaryDeployment :: new (new_ve...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1PyeHs/main.rs:1:86\n  |\n1 | ... { { { let deployment = CanaryDeployment :: new (new_version) ; { deployment . set_traffic_percentage (5i32) ; deployment . deploy () ; let mut baseline = Metrics :: baseline () ; for percentage in vec ! [5i32 , 10i32 , 25i32 , 50i32 , 100i32] { { deployment . set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . error_rate > baseline . error_rate * 1.1f64 { { deployment . rollback () ; panic ! (\"Error rate increased by >10%\") } } ; if current . p99_latency > baseline . p99_latency * 1.2f64 { { deployment . rollback () ; panic ! (\"Latency increased by >20%\") } } ; println ! (\"✅ Canary at {}% - metrics healthy\" , \"{:?}\" , percentage) } } } } ; deployment . finalize () } } } } f...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn deploy_canary (new_version : String) -> i32 { { { let deployment = CanaryDeployment :: new (new_version) ; { deployment . set_traffic_percentage (5i32) ; deployment . deploy () ; let mut baseline = Metrics :: baseline () ; for percentage in vec ! [5i32 , 10i32 , 25i32 , 50i32 , 100i32] { { deployment . set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . error_rate > baseline . error_rate * 1.1f64 { { deployment . rollback () ; panic ! (\"Error rate increased by >10%\") } } ; if current . p99_latency > baseline . p99_latency * 1.2f64 { { deployment . rollback () ; panic ! (\"Latency increased by >20%\") } } ; println ! (\"✅ Canary at {}% - metrics healthy\" , \"{:?}\" , percentage) } } } } ; deployment . finalize () } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn deploy_canary (new_version : String) -> i32 { { let deployment = CanaryDeployment :: new (new_version) ; { deployment . set_traffic_percentage (5i32) ; deployment . deploy () ; let mut baseline = Metrics :: baseline () ; for percentage in vec ! [5i32 , 10i32 , 25i32 , 50i32 , 100i32] { { deployment . set_traffic_percentage (percentage) ; sleep (Duration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . error_rate > baseline . error_rate * 1.1f64 { { deployment . rollback () ; panic ! (\"Error rate increased by >10%\") } } ; if current . p99_latency > baseline . p99_latency * 1.2f64 { { deployment . rollback () ; panic ! (\"Latency increased by >20%\") } } ; println ! (\"✅ Canary at {}% - metrics healthy\" , \"{:?}\" , percentage) } } } } ; deployment . finalize () } } } fn main () { }\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `CanaryDeployment`\n --> /tmp/.tmp1PyeHs/main.rs:1:107\n  |\n1 | ...String) -> i32 { { { let deployment = CanaryDeployment :: new (new_version) ; { deployment . set_traffic_percentage (5i32) ; deploymen...\n  |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `CanaryDeployment`\n\nerror[E0433]: failed to resolve: use of undeclared type `Metrics`\n --> /tmp/.tmp1PyeHs/main.rs:1:238\n  |\n1 | ... ; deployment . deploy () ; let mut baseline = Metrics :: baseline () ; for percentage in vec ! [5i32 , 10i32 , 25i32 , 50i32 , 100i32...\n  |                                                   ^^^^^^^ use of undeclared type `Metrics`\n\nerror[E0433]: failed to resolve: use of undeclared type `Metrics`\n --> /tmp/.tmp1PyeHs/main.rs:1:438\n  |\n1 | ...ration :: from_mins (10i32)) ; { let current = Metrics :: current () ; { if current . error_rate > baseline . error_rate * 1.1f64 { { ...\n  |                                                   ^^^^^^^ use of undeclared type `Metrics`\n\nerror: aborting due to 6 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 4,
          "line_number": 402,
          "code": "// Status: ❌ BROKEN\n\n// feature_flags.ruchy\nuse feature_flags::{Client, Flag};\n\nlet flags = Client::new(\"api_key\")\n\n// Define feature flag\nlet new_algorithm = Flag::new(\"new-algorithm\")\n    .default(false)\n    .rollout_percentage(10)  // 10% of users\n    .targeting_rules([\n        Rule::new(\"beta_users\", true),\n        Rule::new(\"internal_users\", true)\n    ])\n\n// Use in code\nif flags.is_enabled(new_algorithm, user) {\n    use_new_algorithm()\n} else {\n    use_old_algorithm()\n}\n\n// Gradual rollout\nfor percentage in [10, 25, 50, 75, 100] {\n    flags.set_rollout(new_algorithm, percentage)\n    monitor_metrics()\n    \n    if metrics_degraded() {\n        flags.disable(new_algorithm)\n        break\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0432]: unresolved import `feature_flags`\n --> /tmp/.tmpqte5Ad/main.rs:1:69\n  |\n1 | ...n main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new (\"api_key\" . to_string ()) ; let m...\n  |                                   ^^^^^^^^^^^^^ use of unresolved module or unlinked crate `feature_flags`\n  |\nhelp: you might be missing a crate named `feature_flags`, add it to your project and import it in your code\n  |\n1 + extern crate feature_flags;\n  |\n\nerror[E0425]: cannot find value `user` in this scope\n --> /tmp/.tmpqte5Ad/main.rs:1:456\n  |\n1 | ...) , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percen...\n  |                                                         ^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpqte5Ad/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpqte5Ad/main.rs:1:106\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new ...\n  |                                                                                                          ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpqte5Ad/main.rs:1:464\n  |\n1 | ...ue)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage i...\n  |                                                           ^^                    ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new (\"api_key\" . to_string ()) ; let mut new_algorithm = Flag :: new (\"new-algorithm\" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new (\"beta_users\" . to_string () , true) , Rule :: new (\"internal_users\" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new (\"api_key\" . to_string ()) ; let mut new_algorithm = Flag :: new (\"new-algorithm\" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new (\"beta_users\" . to_string () , true) , Rule :: new (\"internal_users\" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { use_new_algorithm () } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpqte5Ad/main.rs:1:498\n  |\n1 | ..._algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 7...\n  |                                                           ^^                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new (\"api_key\" . to_string ()) ; let mut new_algorithm = Flag :: new (\"new-algorithm\" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new (\"beta_users\" . to_string () , true) , Rule :: new (\"internal_users\" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use feature_flags :: { Client , Flag } ; ; let mut flags = Client :: new (\"api_key\" . to_string ()) ; let mut new_algorithm = Flag :: new (\"new-algorithm\" . to_string ()) . default (false) . rollout_percentage (10i32) . targeting_rules (vec ! [Rule :: new (\"beta_users\" . to_string () , true) , Rule :: new (\"internal_users\" . to_string () , true)]) ; if flags . is_enabled (new_algorithm , user) { { use_new_algorithm () } } else { use_old_algorithm () } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i32] { { flags . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `Rule`\n --> /tmp/.tmpqte5Ad/main.rs:1:309\n  |\n1 | ...lout_percentage (10i32) . targeting_rules (vec ! [Rule :: new (\"beta_users\" . to_string () , true) , Rule :: new (\"internal_users\" . t...\n  |                                                      ^^^^ use of undeclared type `Rule`\n\nerror[E0433]: failed to resolve: use of undeclared type `Rule`\n --> /tmp/.tmpqte5Ad/main.rs:1:360\n  |\n1 | ...ule :: new (\"beta_users\" . to_string () , true) , Rule :: new (\"internal_users\" . to_string () , true)]) ; if flags . is_enabled (new_...\n  |                                                      ^^^^ use of undeclared type `Rule`\n\nerror[E0425]: cannot find function `use_new_algorithm` in this scope\n --> /tmp/.tmpqte5Ad/main.rs:1:466\n  |\n1 | ...ew_algorithm , user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 ,...\n  |                             ^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `new_algorithm`\n\nerror[E0425]: cannot find function `use_old_algorithm` in this scope\n --> /tmp/.tmpqte5Ad/main.rs:1:500\n  |\n1 | ..., user) { { use_new_algorithm () } } else { { use_old_algorithm () } } ; for percentage in vec ! [10i32 , 25i32 , 50i32 , 75i32 , 100i...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `monitor_metrics` in this scope\n --> /tmp/.tmpqte5Ad/main.rs:1:647\n  |\n1 | ...s . set_rollout (new_algorithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `metrics_degraded` in this scope\n --> /tmp/.tmpqte5Ad/main.rs:1:671\n  |\n1 | ...orithm , percentage) ; monitor_metrics () ; if metrics_degraded () { { flags . disable (new_algorithm) ; break } } } } } ; if let Some...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 8 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "IMPORT_ERROR",
          "rootCause": "Missing dependency or import path issue"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 5,
          "line_number": 509,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// metrics.ruchy\nuse metrics::{counter, gauge, histogram};\n\n// Application metrics\ncounter!(\"requests_total\", 1, \"endpoint\" => \"/api/users\")\nhistogram!(\"request_duration_seconds\", duration.as_secs_f64())\ngauge!(\"active_connections\", connections.len() as f64)\n\n// Prometheus endpoint\n#[get(\"/metrics\")]\nasync fun metrics_endpoint() -> String {\n    prometheus::gather()\n}\n\n// Grafana dashboard configuration\nlet dashboard = json!({\n    \"title\": \"Application Metrics\",\n    \"panels\": [\n        {\n            \"title\": \"Request Rate\",\n            \"targets\": [{\n                \"expr\": \"rate(requests_total[5m])\"\n            }]\n        },\n        {\n            \"title\": \"Error Rate\",\n            \"targets\": [{\n                \"expr\": \"rate(requests_total{status=~'5..'}[5m])\"\n            }]\n        },\n        {\n            \"title\": \"P99 Latency\",\n            \"targets\": [{\n                \"expr\": \"histogram_quantile(0.99, request_duration_seconds)\"\n            }]\n        }\n    ]\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 6,
          "line_number": 560,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// logging.ruchy\nuse tracing::{info, warn, error, debug, span, Level};\n\n// Structured logging\n#[instrument]\nasync fun process_request(req: Request) -> Result<Response, Error> {\n    let span = span!(Level::INFO, \"request\", \n        method = %req.method(),\n        path = %req.path(),\n        request_id = %generate_id()\n    );\n    \n    let _enter = span.enter();\n    \n    info!(\"Processing request\");\n    \n    let result = match handle_request(req).await {\n        Ok(response) => {\n            info!(status = response.status(), \"Request successful\");\n            Ok(response)\n        }\n        Err(e) => {\n            error!(error = ?e, \"Request failed\");\n            Err(e)\n        }\n    };\n    \n    result\n}\n\n// Log aggregation config\nlet config = json!({\n    \"sinks\": {\n        \"elasticsearch\": {\n            \"type\": \"elasticsearch\",\n            \"endpoints\": [\"http://elasticsearch:9200\"],\n            \"index\": \"logs-%Y.%m.%d\"\n        },\n        \"s3\": {\n            \"type\": \"aws_s3\",\n            \"bucket\": \"my-app-logs\",\n            \"compression\": \"gzip\"\n        }\n    }\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 7,
          "line_number": 618,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// tracing.ruchy\nuse opentelemetry::{global, sdk, trace::Tracer};\n\n// Initialize tracing\nlet tracer = global::tracer(\"my-app\")\n\n// Trace requests\n#[instrument(skip(db))]\nasync fun handle_request(req: Request, db: &Database) -> Result<Response> {\n    let span = tracer.start(\"handle_request\")\n    \n    // Trace database query\n    let user = db.with_span(\"fetch_user\", |db| {\n        db.query_one(\"SELECT * FROM users WHERE id = $1\", &[req.user_id()])\n    }).await?\n    \n    // Trace external API call\n    let data = http_client.with_span(\"fetch_external_data\", |client| {\n        client.get(\"https://api.example.com/data\").send()\n    }).await?\n    \n    span.end()\n    \n    Ok(Response::new(data))\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-deployment-devops.md",
          "example_number": 8,
          "line_number": 712,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to transpile to Rust\n// secrets.ruchy\nuse vault::Client;\n\n// Vault integration\nlet vault = Client::new(\"https://vault.example.com\")\n    .auth_kubernetes()  // Use K8s service account\n\n// Fetch secrets\nlet db_password = vault.read(\"secret/database/password\").await?\nlet api_key = vault.read(\"secret/external/api_key\").await?\n\n// Rotate secrets\nvault.rotate(\"secret/database/password\").await?\n\n// Environment injection\nenv::set_var(\"DATABASE_URL\", \n    format!(\"postgres://user:{}@host/db\", db_password))",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch01-03-interpreter-scripting": {
      "chapter": "ch01-03-interpreter-scripting",
      "total_examples": 15,
      "working_examples": 7,
      "failing_examples": 8,
      "examples": [
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 1,
          "line_number": 28,
          "code": "// Status: ❌ BROKEN\nruchy -e \"2 + 2\"\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `ruchy` in this scope\n --> /tmp/.tmp4n8GO5/main.rs:1:65\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"2 + 2\" } ; if let Some (s) = (& result as & dyn std :: any :...\n  |                                                                 ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `e` in this scope\n --> /tmp/.tmp4n8GO5/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"2 + 2\" } ; if let Some (s) = (& result as & dyn std :: any :...\n  |                                                                         ^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp4n8GO5/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"2 + 2\" } ; if let Some (s) = (& result as & dyn std :: any :...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 2,
          "line_number": 42,
          "code": "// Status: ❌ BROKEN\nruchy -e \"let name = \\\"World\\\"; \\\"Hello \\\" + name + \\\"!\\\"\"\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `ruchy` in this scope\n --> /tmp/.tmpzLx3IG/main.rs:1:65\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let name = \\\"World\\\"; \\\"Hello \\\" + name + \\\"!\\\"\" } ; if let ...\n  |                                                                 ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `e` in this scope\n --> /tmp/.tmpzLx3IG/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let name = \\\"World\\\"; \\\"Hello \\\" + name + \\\"!\\\"\" } ; if let ...\n  |                                                                         ^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpzLx3IG/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let name = \\\"World\\\"; \\\"Hello \\\" + name + \\\"!\\\"\" } ; if let ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 3,
          "line_number": 56,
          "code": "// Status: ❌ BROKEN\nruchy -e \"let nums = [1, 2, 3]; nums[1]\"\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `ruchy` in this scope\n --> /tmp/.tmpOMgayF/main.rs:1:65\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let nums = [1, 2, 3]; nums[1]\" } ; if let Some (s) = (& resu...\n  |                                                                 ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `e` in this scope\n --> /tmp/.tmpOMgayF/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let nums = [1, 2, 3]; nums[1]\" } ; if let Some (s) = (& resu...\n  |                                                                         ^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpOMgayF/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { ruchy - e ; \"let nums = [1, 2, 3]; nums[1]\" } ; if let Some (s) = (& resu...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 4,
          "line_number": 88,
          "code": "// Status: ❌ BROKEN\nfun main() {\n    // Integer values\n    let small_int = 42\n    let result = small_int * 2\n\n    // Floating point numbers  \n    let pi = 3.14159\n    let area = pi * 5.0 * 5.0\n\n    // String operations\n    let greeting = \"Hello\"\n    let name = \"Ruchy\"\n\n    // Arrays with indexing\n    let data = [1, 2, 3, 4, 5]\n    println(data[2])\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 5,
          "line_number": 137,
          "code": "// Status: ❌ BROKEN\n// calculator.ruchy - Basic calculator functionality\n\nfun add(a, b) {\n    a + b\n}\n\nfun subtract(a, b) {\n    a - b\n}\n\nfun multiply(a, b) {\n    a * b\n}\n\nfun divide(a, b) {\n    if b == 0 {\n        println(\"Error: Division by zero\")\n        0\n    } else {\n        a / b\n    }\n}\n\nfun main() {\n    // Test our calculator\n    let x = 10\n    let y = 3\n\n    println(\"Addition:\")\n    println(add(x, y))\n    println(\"Subtraction:\")\n    println(subtract(x, y))\n    println(\"Multiplication:\")\n    println(multiply(x, y))\n    println(\"Division:\")\n    println(divide(x, y))\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 6,
          "line_number": 192,
          "code": "// Status: ❌ BROKEN\n// data_processing.ruchy - Array manipulation examples\n\nfun main() {\n    let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    // Access elements\n    println(\"First:\")\n    println(numbers[0])\n    println(\"Last:\")\n    println(numbers[9])\n\n    // Simple iteration (manual)\n    let mut sum = 0\n    let mut i = 0\n    while i < 10 {\n        sum = sum + numbers[i]\n        i = i + 1\n    }\n    println(\"Sum:\")\n    println(sum)\n\n    // Calculate average\n    let average = sum / 10\n    println(\"Average:\")\n    println(average)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 7,
          "line_number": 233,
          "code": "// Status: ❌ BROKEN\n// scoping.ruchy - Variable scope examples\n\nlet global_var = \"I'm global\"\n\nfun demonstrate_scope() {\n    let local_var = \"I'm local\"\n    println(global_var)  // Can access global\n    println(local_var)   // Can access local\n    \n    // Nested function\n    fun nested() {\n        println(global_var)  // Can access global\n        println(local_var)   // Can access parent local\n        let nested_var = \"I'm nested\"\n        println(nested_var)\n    }\n    \n    nested()\n}\n\nfun main() {\n    demonstrate_scope()\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0434]: can't capture dynamic environment in a fn item\n --> /tmp/.tmpWHsHDe/main.rs:1:266\n  |\n1 | ...i32 { { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; { let nested_var = \"I'm nested\" . to_string () ; println ! ...\n  |                                                                  ^^^^^^^^^\n  |\n  = help: use the `|| { ... }` closure form instead\n\nerror[E0425]: cannot find value `global_var` in this scope\n --> /tmp/.tmpWHsHDe/main.rs:1:141\n  |\n1 | ...ng () ; { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; fn nested () -> i32 { { println ! (\"{:?}\" , global_var) ;...\n  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`\n\nerror[E0425]: cannot find value `global_var` in this scope\n --> /tmp/.tmpWHsHDe/main.rs:1:232\n  |\n1 | ...> i32 { { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; { let nested_var = \"I'm nested\" . to_string () ; println ...\n  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `local_var`\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpWHsHDe/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = \"I'm local\" . to_string () ; { println ! (\"{:?}\"...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpWHsHDe/main.rs:1:70\n  |\n1 | ... { { { let local_var = \"I'm local\" . to_string () ; { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; fn nested () -> i32 { { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; { let nested_var = \"I'm nested\" . to_string () ; println ! (\"{:?}\" , nested_var) } } } ; nested () } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = \"I'm local\" . to_string () ; { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; fn nested () -> i32 { { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; { let nested_var = \"I'm nested\" . to_string () ; println ! (\"{:?}\" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = \"I'm global\" . to_string () ; { demonstrate_scope () } }\n1 + use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { let local_var = \"I'm local\" . to_string () ; { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; fn nested () -> i32 { { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; { let nested_var = \"I'm nested\" . to_string () ; println ! (\"{:?}\" , nested_var) } } } ; nested () } } } fn main () { let mut global_var = \"I'm global\" . to_string () ; { demonstrate_scope () } }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpWHsHDe/main.rs:1:366\n  |\n1 | ...o_string () ; println ! (\"{:?}\" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = \"I'm global\" . to_string () ...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpWHsHDe/main.rs:1:450\n  |\n1 | ...) { let mut global_var = \"I'm global\" . to_string () ; { demonstrate_scope () } }\n  |                                                           ^^                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = \"I'm local\" . to_string () ; { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; fn nested () -> i32 { { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; { let nested_var = \"I'm nested\" . to_string () ; println ! (\"{:?}\" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = \"I'm global\" . to_string () ; { demonstrate_scope () } }\n1 + use std :: collections :: HashMap ; fn demonstrate_scope () -> i32 { { { let local_var = \"I'm local\" . to_string () ; { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; fn nested () -> i32 { { println ! (\"{:?}\" , global_var) ; println ! (\"{:?}\" , local_var) ; { let nested_var = \"I'm nested\" . to_string () ; println ! (\"{:?}\" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = \"I'm global\" . to_string () ; demonstrate_scope () }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpWHsHDe/main.rs:1:328\n  |\n1 | ...d_var = \"I'm nested\" . to_string () ; println ! (\"{:?}\" , nested_var) } } } ; nested () } } } } fn main () { let mut global_var = \"I'm...\n  |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpWHsHDe/main.rs:1:452\n  |\n1 | ...main () { let mut global_var = \"I'm global\" . to_string () ; { demonstrate_scope () } }\n  |           -                                                       ^^^^^^^^^^^^^^^^^^^^- help: consider using a semicolon here: `;`\n  |           |                                                       |\n  |           expected `()` because of default return type            expected `()`, found `i32`\n\nerror: aborting due to 5 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0308, E0425, E0434.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 8,
          "line_number": 273,
          "code": "// Status: ❌ BROKEN\nfun main() {\n    let arr = [1, 2, 3]\n\n    // Unsafe - may cause error if index is out of bounds\n    // println(arr[5])\n\n    // Better approach\n    if 5 < arr.len() {\n        println(arr[5])\n    } else {\n        println(\"Index out of bounds\")\n    }\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpa4lckL/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpa4lckL/main.rs:1:50\n  |\n1 | ... { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"Index out of bounds\") } } } } }\n  |       ^^                                                                                                                                                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"Index out of bounds\") } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"Index out of bounds\") } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpa4lckL/main.rs:1:118\n  |\n1 | ...32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"Index out of bounds\")...\n  |                                                 ^^                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"Index out of bounds\") } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { println ! (\"{:?}\" , arr [5i32 as usize]) } else { { println ! (\"Index out of bounds\") } } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpa4lckL/main.rs:1:172\n  |\n1 | ...tln ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"Index out of bounds\") } } } } }\n  |                                                    ^^                                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"Index out of bounds\") } } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { println ! (\"Index out of bounds\") } } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpa4lckL/main.rs:1:103\n  |\n1 | ...let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len () { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"In...\n  |                                              ----   ^^^^^^^^^^^^ expected `i32`, found `usize`\n  |                                              |\n  |                                              expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let arr = vec ! [1i32 , 2i32 , 3i32] ; if 5i32 < arr . len ().try_into().unwrap() { { println ! (\"{:?}\" , arr [5i32 as usize]) } } else { { println ! (\"Index out of bounds\") } } } } }\n  |                                                                                                                   ++++++++++++++++++++\n\nerror: aborting due to 1 previous error; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 9,
          "line_number": 301,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let x = 5\n    // x = 10  // Error! x is immutable\n\n    // Use mut for mutable variables\n    let mut y = 5\n    y = 10  // OK\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 10,
          "line_number": 323,
          "code": "// Status: ❌ BROKEN\nfun get_double(x) {\n    x * 2  // This is returned (no semicolon)\n}\n\nfun process_and_print(x) {\n    let doubled = x * 2\n    println(\"Doubled:\")\n    println(doubled)\n    // No explicit return - returns unit type ()\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpAOz7Jy/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn get_double (x : i32) -> i32 { { x * 2i32 } } fn process_and_print (x : i32) -> i32 { { { let doubl...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpAOz7Jy/main.rs:1:70\n  |\n1 | use std :: collections :: HashMap ; fn get_double (x : i32) -> i32 { { x * 2i32 } } fn process_and_print (x : i32) -> i32 { { { let doubl...\n  |                                                                      ^^        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn get_double (x : i32) -> i32 { { x * 2i32 } } fn process_and_print (x : i32) -> i32 { { { let doubled = x * 2i32 ; { println ! (\"Doubled:\") ; println ! (\"{:?}\" , doubled) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn get_double (x : i32) -> i32 { x * 2i32 } fn process_and_print (x : i32) -> i32 { { { let doubled = x * 2i32 ; { println ! (\"Doubled:\") ; println ! (\"{:?}\" , doubled) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpAOz7Jy/main.rs:1:125\n  |\n1 | ...nt (x : i32) -> i32 { { { let doubled = x * 2i32 ; { println ! (\"Doubled:\") ; println ! (\"{:?}\" , doubled) } } } } fn main () { }\n  |                          ^^                                                                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn get_double (x : i32) -> i32 { { x * 2i32 } } fn process_and_print (x : i32) -> i32 { { { let doubled = x * 2i32 ; { println ! (\"Doubled:\") ; println ! (\"{:?}\" , doubled) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn get_double (x : i32) -> i32 { { x * 2i32 } } fn process_and_print (x : i32) -> i32 { { let doubled = x * 2i32 ; { println ! (\"Doubled:\") ; println ! (\"{:?}\" , doubled) } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpAOz7Jy/main.rs:1:181\n  |\n1 | ... x * 2i32 ; { println ! (\"Doubled:\") ; println ! (\"{:?}\" , doubled) } } } } fn main () { }\n  |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 1 previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 11,
          "line_number": 390,
          "code": "// Status: ✅ WORKING\n// Good: Clear, functional style\nfun calculate_tax(income, rate) {\n    income * rate\n}\n\n// Avoid: Complex nested logic (for now)",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 12,
          "line_number": 407,
          "code": "// Status: ❌ BROKEN\n// Good\nlet user_count = 42\nlet total_price = calculate_price(items)\n\n// Avoid\nlet x = 42\nlet y = calc(z)\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmp07NDeE/main.rs:1:183\n  |\n1 | ...t mut x = 42i32 ; let mut y = calc (z) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]: cannot find value `items` in this scope\n --> /tmp/.tmp07NDeE/main.rs:1:133\n  |\n1 | ...nt = 42i32 ; let mut total_price = calculate_price (items) ; let mut x = 42i32 ; let mut y = calc (z) } ; if let Some (s) = (& result ...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp07NDeE/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut user_count = 42i32 ; let mut total_price = calculate_price (items...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `calculate_price` in this scope\n --> /tmp/.tmp07NDeE/main.rs:1:116\n  |\n1 | ...mut user_count = 42i32 ; let mut total_price = calculate_price (items) ; let mut x = 42i32 ; let mut y = calc (z) } ; if let Some (s) ...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 13,
          "line_number": 428,
          "code": "// Status: ❌ BROKEN\nfun main() {\n    let grades = [95, 87, 92, 78, 89]\n    let first_grade = grades[0]\n    let last_grade = grades[4]\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpqGbsMh/main.rs:1:208\n  |\n1 | ...ut last_grade = grades [4i32 as usize] } } } }\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpqGbsMh/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade =...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpqGbsMh/main.rs:1:50\n  |\n1 | ... { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade = grades [0i32 as usize] ; let mut last_grade = grades [4i32 as usize] } } } }\n  |       ^^                                                                                                                                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade = grades [0i32 as usize] ; let mut last_grade = grades [4i32 as usize] } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let grades = vec ! [95i32 , 87i32 , 92i32 , 78i32 , 89i32] ; { let mut first_grade = grades [0i32 as usize] ; let mut last_grade = grades [4i32 as usize] } } }\n  |\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 14,
          "line_number": 447,
          "code": "// Status: ❌ BROKEN\n// Add functions\nfun double(n) { n * 2 }\n\nfun main() {\n    // Start simple\n    let x = 5\n\n    // Combine\n    let result = double(x)\n    println(result)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-03-interpreter-scripting.md",
          "example_number": 15,
          "line_number": 473,
          "code": "// Status: ✅ WORKING\n// test_calculator.ruchy\nfun add(a, b) { a + b }\n\nfun main() {\n    // Test cases\n    let test1 = add(2, 3) == 5\n    let test2 = add(0, 0) == 0\n    let test3 = add(-1, 1) == 0\n\n    if test1 && test2 && test3 {\n        println(\"All tests passed!\")\n    } else {\n        println(\"Some tests failed\")\n    }\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch17-00-documentation": {
      "chapter": "ch17-00-documentation",
      "total_examples": 10,
      "working_examples": 0,
      "failing_examples": 10,
      "examples": [
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 1,
          "line_number": 48,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n/// A high-performance cache with automatic eviction.\n/// \n/// # Examples\n/// \n/// ```\n/// let cache = Cache::new(100)  // Max 100 items\n/// cache.insert(\"key\", \"value\")\n/// assert_eq!(cache.get(\"key\"), Some(\"value\"))\n/// ```\n/// \n/// # Performance\n/// \n/// - Insert: O(1) amortized\n/// - Get: O(1)\n/// - Memory: O(n) where n is cache size\n/// \n/// # Thread Safety\n/// \n/// This cache is thread-safe using internal locking.\n/// For better performance with multiple threads, consider\n/// using `ShardedCache` instead.\npub struct Cache<K, V> {\n    /// Maximum number of items before eviction starts\n    capacity: usize\n    \n    /// Current items in cache\n    items: HashMap<K, V>\n    \n    /// Access order for LRU eviction\n    order: LinkedList<K>\n}\n\nimpl<K, V> Cache<K, V> {\n    /// Creates a new cache with the specified capacity.\n    /// \n    /// # Arguments\n    /// \n    /// * `capacity` - Maximum items to store before eviction\n    /// \n    /// # Panics\n    /// \n    /// Panics if capacity is 0.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// let cache = Cache::new(1000)\n    /// ```\n    pub fn new(capacity: usize) -> Self {\n        assert!(capacity > 0, \"Capacity must be positive\")\n        // Implementation\n    }\n    \n    /// Inserts a key-value pair, evicting LRU item if at capacity.\n    /// \n    /// Returns the evicted value if any.\n    /// \n    /// # Complexity\n    /// \n    /// O(1) amortized time complexity.\n    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n        // Implementation with inline comments for complex parts\n        \n        // Update access order for LRU\n        self.update_access_order(&key)\n        \n        // Check capacity and evict if necessary\n        if self.items.len() >= self.capacity {\n            // Evict least recently used\n            let lru = self.order.pop_front()\n            // ...\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 2,
          "line_number": 141,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n/// Single line summary of what this does.\n/// \n/// More detailed explanation that provides context,\n/// use cases, and important information.\n/// \n/// # Arguments\n/// \n/// * `param1` - Description of first parameter\n/// * `param2` - Description of second parameter\n/// \n/// # Returns\n/// \n/// Description of return value and what it represents.\n/// \n/// # Errors\n/// \n/// * `ErrorType1` - When this error occurs\n/// * `ErrorType2` - When that error occurs\n/// \n/// # Examples\n/// \n/// ```\n/// let result = function(arg1, arg2)?\n/// assert_eq!(result, expected)\n/// ```\n/// \n/// # Safety\n/// \n/// This function is safe to call from multiple threads.\n/// \n/// # Performance\n/// \n/// Time: O(n log n)\n/// Space: O(n)\npub fn documented_function(param1: Type1, param2: Type2) -> Result<Return, Error> {\n    // Implementation\n}\n\n// Module-level documentation\n//! # Module Name\n//! \n//! This module provides functionality for...\n//! \n//! ## Overview\n//! \n//! Explain the module's purpose and main components.\n//! \n//! ## Usage\n//! \n//! ```\n//! use mylib::module\n//! \n//! let thing = module::Thing::new()\n//! thing.do_stuff()\n//! ```\n\n// Inner documentation\nimpl Struct {\n    fn method(&self) {\n        //! This method does...\n        \n        // Regular comment for implementation details\n        let temp = calculate_something()\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 3,
          "line_number": 221,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n/// Calculates the factorial of a number.\n/// \n/// # Examples\n/// \n/// ```\n/// assert_eq!(factorial(0), 1)\n/// assert_eq!(factorial(5), 120)\n/// assert_eq!(factorial(10), 3628800)\n/// ```\n/// \n/// ```should_panic\n/// factorial(-1)  // Panics on negative input\n/// ```\n/// \n/// ```no_run\n/// // Example that shouldn't be executed during tests\n/// let huge = factorial(1000000)\n/// ```\n/// \n/// ```ignore\n/// // Example that's temporarily broken\n/// let result = factorial(non_existent_var)\n/// ```\npub fn factorial(n: i32) -> i32 {\n    assert!(n >= 0, \"Factorial undefined for negative numbers\")\n    if n <= 1 { 1 } else { n * factorial(n - 1) }\n}\n\n// Run doc tests\n$ ruchy test --doc\n   Doc-tests mylib\nrunning 4 doc tests\ntest src/lib.rs - factorial (line 5) ... ok\ntest src/lib.rs - factorial (line 9) ... ok\ntest src/lib.rs - factorial (line 13) ... ok\ntest src/lib.rs - factorial (line 17) ... ignored\n\ntest result: ok. 3 passed; 0 failed; 1 ignored",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 4,
          "line_number": 274,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n/// Configuration for the application.\n/// \n/// This struct holds all configuration values needed to run\n/// the application. It can be loaded from files, environment\n/// variables, or command-line arguments.\n/// \n/// # Example Configuration File\n/// \n/// ```toml\n/// [server]\n/// host = \"localhost\"\n/// port = 8080\n/// \n/// [database]\n/// url = \"postgres://localhost/myapp\"\n/// pool_size = 20\n/// ```\n#[derive(Deserialize, Serialize, Debug)]\npub struct Config {\n    /// Server configuration\n    pub server: ServerConfig,\n    \n    /// Database configuration  \n    pub database: DatabaseConfig,\n    \n    /// Optional cache configuration\n    pub cache: Option<CacheConfig>,\n}\n\n/// Server configuration options.\n#[derive(Deserialize, Serialize, Debug)]\npub struct ServerConfig {\n    /// Host to bind to (default: \"127.0.0.1\")\n    #[serde(default = \"default_host\")]\n    pub host: String,\n    \n    /// Port to listen on (default: 8080)\n    #[serde(default = \"default_port\")]\n    pub port: u16,\n    \n    /// Number of worker threads (default: CPU cores)\n    #[serde(default = \"num_cpus\")]\n    pub workers: usize,\n}\n\n// Generate HTML documentation\n$ ruchy doc --open\nDocumenting mylib v1.10.0\n    Finished documentation\n    Opening docs/mylib/index.html",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 5,
          "line_number": 339,
          "code": "// Status: ❌ BROKEN\n\n//! # System Architecture\n//! \n//! ## Overview\n//! \n//! This application follows a layered architecture:\n//! \n//! ```text\n//! ┌─────────────────────────────────┐\n//! │          HTTP Layer             │\n//! │  (Handlers, Middleware, Routes) │\n//! └─────────────┬───────────────────┘\n//!               │\n//! ┌─────────────▼───────────────────┐\n//! │        Service Layer            │\n//! │   (Business Logic, Validation)  │\n//! └─────────────┬───────────────────┘\n//!               │\n//! ┌─────────────▼───────────────────┐\n//! │      Repository Layer           │\n//! │    (Database Access, Caching)   │\n//! └─────────────┬───────────────────┘\n//!               │\n//! ┌─────────────▼───────────────────┐\n//! │         Data Layer              │\n//! │    (PostgreSQL, Redis, S3)      │\n//! └─────────────────────────────────┘\n//! ```\n//! \n//! ## Data Flow\n//! \n//! 1. Request enters through HTTP handler\n//! 2. Handler validates input and calls service\n//! 3. Service applies business logic\n//! 4. Repository handles data persistence\n//! 5. Response flows back through layers\n//! \n//! ## Key Design Decisions\n//! \n//! ### Why Layered Architecture?\n//! \n//! - **Separation of Concerns**: Each layer has a single responsibility\n//! - **Testability**: Layers can be tested independently with mocks\n//! - **Flexibility**: Easy to swap implementations (e.g., database)\n//! \n//! ### Why Event Sourcing?\n//! \n//! - **Audit Trail**: Complete history of all changes\n//! - **Time Travel**: Can reconstruct state at any point\n//! - **Event Replay**: Easy to fix bugs in event processing\n\n/// Module containing HTTP handlers\npub mod handlers {\n    //! HTTP request handlers.\n    //! \n    //! Each handler is responsible for:\n    //! - Request validation\n    //! - Calling appropriate service\n    //! - Response formatting\n}\n\n/// Module containing business logic\npub mod services {\n    //! Business logic layer.\n    //! \n    //! Services contain all business rules and orchestrate\n    //! operations across multiple repositories.\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected item, found `{`\n --> /tmp/.tmp7RsVGb/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...\n  |                                                                                ^ expected item\n  |\n  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>\n\nerror: expected item, found `{`\n --> /tmp/.tmp7RsVGb/main.rs:1:103\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...\n  |                                                                                                       ^ expected item\n  |\n  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>\n\nerror: expected item, found `}`\n --> /tmp/.tmp7RsVGb/main.rs:1:109\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { mod handlers { { } } ; mod services { { } } } ; if let Some (s) = (& resu...\n  |                                                                                                             ^ expected item\n  |\n  = note: for a full list of items that can appear in modules, see <https://doc.rust-lang.org/reference/items.html>\n\nerror: aborting due to 3 previous errors\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 6,
          "line_number": 539,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n/// # Examples Section\n/// \n/// ## Basic Usage\n/// \n/// The simplest way to use this library:\n/// \n/// ```\n/// use mylib::Thing;\n/// \n/// let thing = Thing::default();\n/// thing.process()?;\n/// ```\n/// \n/// ## Advanced Usage\n/// \n/// For more control, configure manually:\n/// \n/// ```\n/// use mylib::{Thing, Config};\n/// \n/// let config = Config::builder()\n///     .timeout(5000)\n///     .retries(3)\n///     .build()?;\n/// \n/// let thing = Thing::with_config(config);\n/// ```\n/// \n/// ## Error Handling\n/// \n/// All operations return `Result`:\n/// \n/// ```\n/// match thing.risky_operation() {\n///     Ok(value) => println!(\"Success: {}\", value),\n///     Err(e) => eprintln!(\"Error: {}\", e),\n/// }\n/// ```\n/// \n/// ## Complete Example\n/// \n/// Here's a full working program:\n/// \n/// ```no_run\n/// use mylib::{Thing, Config, Error};\n/// \n/// fn main() -> Result<(), Error> {\n///     let config = Config::from_env()?;\n///     let thing = Thing::with_config(config);\n///     \n///     for item in thing.process_all()? {\n///         println!(\"Processed: {:?}\", item);\n///     }\n///     \n///     Ok(())\n/// }\n/// ```",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 7,
          "line_number": 611,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Generate interactive documentation site\n$ ruchy doc --format html --output docs/\n\n// With search, examples, and playground\n$ ruchy doc --features search,playground,examples\n\n// Serve documentation locally\n$ ruchy doc --serve --port 8080\nServing documentation at http://localhost:8080",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 8,
          "line_number": 633,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n/// Interactive API endpoint documentation\n/// \n/// <playground>\n/// {\n///   \"endpoint\": \"/api/users\",\n///   \"method\": \"POST\",\n///   \"body\": {\n///     \"name\": \"Alice\",\n///     \"email\": \"alice@example.com\"\n///   }\n/// }\n/// </playground>\n#[post(\"/api/users\")]\npub async fun create_user(user: Json<User>) -> Result<Json<User>, Error> {\n    // Implementation\n}\n\n// Generates interactive API tester in docs",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 9,
          "line_number": 666,
          "code": "// Status: ❌ BROKEN\n\n// Generate documentation from code\n#[doc_gen]\nimpl ConfigBuilder {\n    // Automatically documents builder pattern\n}\n\n// Generate diagrams from code\n#[diagram(sequence)]\nasync fun request_flow() {\n    client.send_request()\n    server.validate()\n    server.process()\n    server.respond()\n}\n\n// Generates:\n// Client -> Server: send_request()\n// Server -> Server: validate()\n// Server -> Server: process()\n// Server -> Client: respond()\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0670]: `async fn` is not permitted in Rust 2015\n --> /tmp/.tmpRSaA9a/main.rs:1:37\n  |\n1 | use std :: collections :: HashMap ; async fn request_flow () -> i32 { { client . send_request () ; server . validate () ; server . proces...\n  |                                     ^^^^^ to use `async fn`, switch to Rust 2018 or later\n  |\n  = help: pass `--edition 2024` to `rustc`\n  = note: for more on editions, read https://doc.rust-lang.org/edition-guide\n\nerror[E0425]: cannot find value `client` in this scope\n --> /tmp/.tmpRSaA9a/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; async fn request_flow () -> i32 { { client . send_request () ; server . validate () ; server . proces...\n  |                                                                         ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `server` in this scope\n --> /tmp/.tmpRSaA9a/main.rs:1:100\n  |\n1 | use std :: collections :: HashMap ; async fn request_flow () -> i32 { { client . send_request () ; server . validate () ; server . proces...\n  |                                                                                                    ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `server` in this scope\n --> /tmp/.tmpRSaA9a/main.rs:1:123\n  |\n1 | ...{ client . send_request () ; server . validate () ; server . process () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `server` in this scope\n --> /tmp/.tmpRSaA9a/main.rs:1:145\n  |\n1 | ...t () ; server . validate () ; server . process () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `ConfigBuilder` in this scope\n --> /tmp/.tmpRSaA9a/main.rs:1:187\n  |\n1 | ... () ; server . respond () } } fn main () { impl ConfigBuilder { } ; }\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpRSaA9a/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; async fn request_flow () -> i32 { { client . send_request () ; server . validate () ; server . proces...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpRSaA9a/main.rs:1:205\n  |\n1 | ... respond () } } fn main () { impl ConfigBuilder { } ; }\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror: aborting due to 6 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425, E0670.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-documentation.md",
          "example_number": 10,
          "line_number": 701,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Check documentation quality\n$ ruchy doc-lint\nChecking documentation...\n\n⚠️  Missing documentation: src/internal.rs:15 `fun process()`\n⚠️  Broken link: src/lib.rs:42 `[Config](../config.html)`\n⚠️  Outdated example: src/api.rs:88 (code changed)\n❌  Missing examples: src/client.rs `struct Client`\n\nDocumentation score: 87/100\n\n// Enforce in CI\n$ ruchy doc-lint --min-score 90",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch06-00-file-operations": {
      "chapter": "ch06-00-file-operations",
      "total_examples": 10,
      "working_examples": 0,
      "failing_examples": 10,
      "examples": [
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 1,
          "line_number": 48,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\n// File: desktop_organizer.ruchy\n// Organizes files by type into folders\n\nprintln(\"=== Desktop Organizer ===\")\n\n// Define organization rules\nlet file_categories = {\n    \"Documents\": [\".pdf\", \".doc\", \".docx\", \".txt\"],\n    \"Images\": [\".jpg\", \".jpeg\", \".png\", \".gif\", \".svg\"],\n    \"Videos\": [\".mp4\", \".avi\", \".mov\", \".mkv\"],\n    \"Code\": [\".py\", \".js\", \".rs\", \".ruchy\", \".cpp\"],\n    \"Data\": [\".csv\", \".json\", \".xml\", \".xlsx\"]\n}\n\nlet source_dir = \"~/Desktop\"\nlet files = list_files(source_dir)\n\nprintln(\"Found \" + files.len().to_s() + \" files to organize\")\n\n// Organize files\nfor file in files {\n    let extension = get_extension(file).lower()\n    \n    for category, extensions in file_categories.items() {\n        if extensions.contains(extension) {\n            let target_dir = join_path(source_dir, category)\n            \n            // Create category folder if needed\n            if !dir_exists(target_dir) {\n                create_dir(target_dir)\n                println(\"Created folder: \" + category)\n            }\n            \n            // Move file to appropriate folder\n            let source = join_path(source_dir, file)\n            let destination = join_path(target_dir, file)\n            \n            move_file(source, destination)\n            println(\"  Moved \" + file + \" -> \" + category + \"/\")\n            break\n        }\n    }\n}\n\nprintln(\"✅ Desktop organized!\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `create_dir` in this scope\n --> /tmp/.tmpfT6S3k/main.rs:1:1261\n  |\n1 | ... , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Created folder: \" ...\n  |                                                      ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::create_dir;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpfT6S3k/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\") ; let mut file_categories = { let...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpfT6S3k/main.rs:1:1015\n  |\n1 | ... { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\") ; let mut file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"Documents\" . to_string () , (vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"]) . to_string ()) ; map . insert (\"Images\" . to_string () , (vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"]) . to_string ()) ; map . insert (\"Videos\" . to_string () , (vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"]) . to_string ()) ; map . insert (\"Code\" . to_string () , (vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"]) . to_string ()) ; map . insert (\"Data\" . to_string () , (vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"]) . to_string ()) ; map } ; let mut source_dir = \"~/Desktop\" . to_string () ; let mut files = list_files (source_dir) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Found \" , files . len () . to_s ()) , \" files to organize\")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } } } } } } ; println ! (\"✅ Desktop organized!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\") ; let mut file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"Documents\" . to_string () , (vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"]) . to_string ()) ; map . insert (\"Images\" . to_string () , (vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"]) . to_string ()) ; map . insert (\"Videos\" . to_string () , (vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"]) . to_string ()) ; map . insert (\"Code\" . to_string () , (vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"]) . to_string ()) ; map . insert (\"Data\" . to_string () , (vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"]) . to_string ()) ; map } ; let mut source_dir = \"~/Desktop\" . to_string () ; let mut files = list_files (source_dir) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Found \" , files . len () . to_s ()) , \" files to organize\")) ; for file in files { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } } } } } ; println ! (\"✅ Desktop organized!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpfT6S3k/main.rs:1:1128\n  |\n1 | ... { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\") ; let mut file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"Documents\" . to_string () , (vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"]) . to_string ()) ; map . insert (\"Images\" . to_string () , (vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"]) . to_string ()) ; map . insert (\"Videos\" . to_string () , (vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"]) . to_string ()) ; map . insert (\"Code\" . to_string () , (vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"]) . to_string ()) ; map . insert (\"Data\" . to_string () , (vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"]) . to_string ()) ; map } ; let mut source_dir = \"~/Desktop\" . to_string () ; let mut files = list_files (source_dir) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Found \" , files . len () . to_s ()) , \" files to organize\")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } } } } } } ; println ! (\"✅ Desktop organized!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\") ; let mut file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"Documents\" . to_string () , (vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"]) . to_string ()) ; map . insert (\"Images\" . to_string () , (vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"]) . to_string ()) ; map . insert (\"Videos\" . to_string () , (vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"]) . to_string ()) ; map . insert (\"Code\" . to_string () , (vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"]) . to_string ()) ; map . insert (\"Data\" . to_string () , (vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"]) . to_string ()) ; map } ; let mut source_dir = \"~/Desktop\" . to_string () ; let mut files = list_files (source_dir) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Found \" , files . len () . to_s ()) , \" files to organize\")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } } } } } ; println ! (\"✅ Desktop organized!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpfT6S3k/main.rs:1:1169\n  |\n1 | ... { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\") ; let mut file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"Documents\" . to_string () , (vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"]) . to_string ()) ; map . insert (\"Images\" . to_string () , (vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"]) . to_string ()) ; map . insert (\"Videos\" . to_string () , (vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"]) . to_string ()) ; map . insert (\"Code\" . to_string () , (vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"]) . to_string ()) ; map . insert (\"Data\" . to_string () , (vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"]) . to_string ()) ; map } ; let mut source_dir = \"~/Desktop\" . to_string () ; let mut files = list_files (source_dir) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Found \" , files . len () . to_s ()) , \" files to organize\")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () { { if extensions . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } } } } } } ; println ! (\"✅ Desktop organized!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Desktop Organizer ===\") ; let mut file_categories = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"Documents\" . to_string () , (vec ! [\".pdf\" , \".doc\" , \".docx\" , \".txt\"]) . to_string ()) ; map . insert (\"Images\" . to_string () , (vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"]) . to_string ()) ; map . insert (\"Videos\" . to_string () , (vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"]) . to_string ()) ; map . insert (\"Code\" . to_string () , (vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"]) . to_string ()) ; map . insert (\"Data\" . to_string () , (vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"]) . to_string ()) ; map } ; let mut source_dir = \"~/Desktop\" . to_string () ; let mut files = list_files (source_dir) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Found \" , files . len () . to_s ()) , \" files to organize\")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . iter () { { if extensions . contains (extension) { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Created folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Moved \" , file) , \" -> \") + category , \"/\")) ; break } } } } } } } } ; println ! (\"✅ Desktop organized!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0599]: the method `to_string` exists for struct `Vec<&str>`, but its trait bounds were not satisfied\n   --> /tmp/.tmpfT6S3k/main.rs:1:333\n    |\n1   | ...oc\" , \".docx\" , \".txt\"]) . to_string ()) ; map . insert (\"Images\" . to_string () , (vec ! [\".jpg\" , \".jpeg\" , \".png\" , \".gif\" , \".svg\"...\n    |                               ^^^^^^^^^ method cannot be called on `Vec<&str>` due to unsatisfied trait bounds\n    |\n   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1\n    |\n414 | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<&str>: ToString` or `Vec<&str>: std::fmt::Display`\n    |\n    = note: the following trait bounds were not satisfied:\n            `Vec<&str>: std::fmt::Display`\n            which is required by `Vec<&str>: ToString`\n            `[&str]: std::fmt::Display`\n            which is required by `[&str]: ToString`\n\nerror[E0599]: the method `to_string` exists for struct `Vec<&str>`, but its trait bounds were not satisfied\n   --> /tmp/.tmpfT6S3k/main.rs:1:445\n    |\n1   | ...png\" , \".gif\" , \".svg\"]) . to_string ()) ; map . insert (\"Videos\" . to_string () , (vec ! [\".mp4\" , \".avi\" , \".mov\" , \".mkv\"]) . to_st...\n    |                               ^^^^^^^^^ method cannot be called on `Vec<&str>` due to unsatisfied trait bounds\n    |\n   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1\n    |\n414 | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<&str>: ToString` or `Vec<&str>: std::fmt::Display`\n    |\n    = note: the following trait bounds were not satisfied:\n            `Vec<&str>: std::fmt::Display`\n            which is required by `Vec<&str>: ToString`\n            `[&str]: std::fmt::Display`\n            which is required by `[&str]: ToString`\n\nerror[E0599]: the method `to_string` exists for struct `Vec<&str>`, but its trait bounds were not satisfied\n   --> /tmp/.tmpfT6S3k/main.rs:1:547\n    |\n1   | ...avi\" , \".mov\" , \".mkv\"]) . to_string ()) ; map . insert (\"Code\" . to_string () , (vec ! [\".py\" , \".js\" , \".rs\" , \".ruchy\" , \".cpp\"]) ....\n    |                               ^^^^^^^^^ method cannot be called on `Vec<&str>` due to unsatisfied trait bounds\n    |\n   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1\n    |\n414 | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<&str>: ToString` or `Vec<&str>: std::fmt::Display`\n    |\n    = note: the following trait bounds were not satisfied:\n            `Vec<&str>: std::fmt::Display`\n            which is required by `Vec<&str>: ToString`\n            `[&str]: std::fmt::Display`\n            which is required by `[&str]: ToString`\n\nerror[E0599]: the method `to_string` exists for struct `Vec<&str>`, but its trait bounds were not satisfied\n   --> /tmp/.tmpfT6S3k/main.rs:1:655\n    |\n1   | ...s\" , \".ruchy\" , \".cpp\"]) . to_string ()) ; map . insert (\"Data\" . to_string () , (vec ! [\".csv\" , \".json\" , \".xml\" , \".xlsx\"]) . to_st...\n    |                               ^^^^^^^^^ method cannot be called on `Vec<&str>` due to unsatisfied trait bounds\n    |\n   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1\n    |\n414 | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<&str>: ToString` or `Vec<&str>: std::fmt::Display`\n    |\n    = note: the following trait bounds were not satisfied:\n            `Vec<&str>: std::fmt::Display`\n            which is required by `Vec<&str>: ToString`\n            `[&str]: std::fmt::Display`\n            which is required by `[&str]: ToString`\n\nerror[E0599]: the method `to_string` exists for struct `Vec<&str>`, but its trait bounds were not satisfied\n   --> /tmp/.tmpfT6S3k/main.rs:1:757\n    |\n1   | ...on\" , \".xml\" , \".xlsx\"]) . to_string ()) ; map } ; let mut source_dir = \"~/Desktop\" . to_string () ; let mut files = list_files (sourc...\n    |                               ^^^^^^^^^ method cannot be called on `Vec<&str>` due to unsatisfied trait bounds\n    |\n   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1\n    |\n414 | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<&str>: ToString` or `Vec<&str>: std::fmt::Display`\n    |\n    = note: the following trait bounds were not satisfied:\n            `Vec<&str>: std::fmt::Display`\n            which is required by `Vec<&str>: ToString`\n            `[&str]: std::fmt::Display`\n            which is required by `[&str]: ToString`\n\nerror[E0425]: cannot find function `list_files` in this scope\n --> /tmp/.tmpfT6S3k/main.rs:1:847\n  |\n1 | ...ir = \"~/Desktop\" . to_string () ; let mut files = list_files (source_dir) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , ...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `get_extension` in this scope\n --> /tmp/.tmpfT6S3k/main.rs:1:1035\n  |\n1 | ...ze\")) ; for file in files { { { let extension = get_extension (file) . lower () ; for (category , extensions) in file_categories . ite...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpfT6S3k/main.rs:1:1190\n  |\n1 | ...ons . contains (extension) { { { let target_dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (t...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `dir_exists` in this scope\n --> /tmp/.tmpfT6S3k/main.rs:1:1233\n  |\n1 | ..._dir = join_path (source_dir , category) ; { if ! dir_exists (target_dir) { { create_dir (target_dir) ; println ! (\"{:?}\" , format ! (...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpfT6S3k/main.rs:1:1381\n  |\n1 | ...ted folder: \" , category)) } } ; let mut source = join_path (source_dir , file) ; let mut destination = join_path (target_dir , file) ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpfT6S3k/main.rs:1:1435\n  |\n1 | ..._path (source_dir , file) ; let mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{:?}\"...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `move_file` in this scope\n --> /tmp/.tmpfT6S3k/main.rs:1:1467\n  |\n1 | ...mut destination = join_path (target_dir , file) ; move_file (source , destination) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 13 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 2,
          "line_number": 111,
          "code": "// Status: ❌ BROKEN\n\n// Current directory operations\nlet current_dir = get_current_dir()\nset_current_dir(\"/home/user/projects\")\n\n// Path operations\nlet full_path = absolute_path(\"data.txt\")\nlet parent = parent_dir(full_path)\nlet filename = file_name(full_path)\nlet extension = file_extension(full_path)\n\n// Path joining and normalization\nlet project_path = join_path(home_dir(), \"projects\", \"my_app\")\nlet clean_path = normalize_path(\".././data//file.txt\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpsuQej5/main.rs:1:541\n  |\n1 | ...(\".././data//file.txt\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]: cannot find function `set_current_dir` in this scope\n --> /tmp/.tmpsuQej5/main.rs:1:108\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir (\"/home/user/p...\n  |                                                                                                            ^^^^^^^^^^^^^^^\n  |\nhelp: a local variable with a similar name exists\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir (\"/home/user/projects\" . to_string ()) ; let mut full_path = absolute_path (\"data.txt\" . to_string ()) ; let mut parent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut project_path = join_path (home_dir () , \"projects\" . to_string () , \"my_app\" . to_string ()) ; let mut clean_path = normalize_path (\".././data//file.txt\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; current_dir (\"/home/user/projects\" . to_string ()) ; let mut full_path = absolute_path (\"data.txt\" . to_string ()) ; let mut parent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut project_path = join_path (home_dir () , \"projects\" . to_string () , \"my_app\" . to_string ()) ; let mut clean_path = normalize_path (\".././data//file.txt\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\nhelp: consider importing this function\n  |\n1 + use std::env::set_current_dir;\n  |\n\nerror[E0425]: cannot find function `home_dir` in this scope\n --> /tmp/.tmpsuQej5/main.rs:1:397\n  |\n1 | ...on (full_path) ; let mut project_path = join_path (home_dir () , \"projects\" . to_string () , \"my_app\" . to_string ()) ; let mut clean_...\n  |                                                       ^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::env::home_dir;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpsuQej5/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir (\"/home/user/p...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `get_current_dir` in this scope\n --> /tmp/.tmpsuQej5/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut current_dir = get_current_dir () ; set_current_dir (\"/home/user/p...\n  |                                                                                       ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `absolute_path` in this scope\n --> /tmp/.tmpsuQej5/main.rs:1:185\n  |\n1 | ...projects\" . to_string ()) ; let mut full_path = absolute_path (\"data.txt\" . to_string ()) ; let mut parent = parent_dir (full_path) ; ...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `parent_dir` in this scope\n --> /tmp/.tmpsuQej5/main.rs:1:246\n  |\n1 | ...tring ()) ; let mut parent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (f...\n  |                                 ^^^^^^^^^^ help: a local variable with a similar name exists: `current_dir`\n\nerror[E0425]: cannot find function `file_name` in this scope\n --> /tmp/.tmpsuQej5/main.rs:1:290\n  |\n1 | ...ent = parent_dir (full_path) ; let mut filename = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut pro...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_extension` in this scope\n --> /tmp/.tmpsuQej5/main.rs:1:334\n  |\n1 | ...e = file_name (full_path) ; let mut extension = file_extension (full_path) ; let mut project_path = join_path (home_dir () , \"projects...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpsuQej5/main.rs:1:386\n  |\n1 | ...le_extension (full_path) ; let mut project_path = join_path (home_dir () , \"projects\" . to_string () , \"my_app\" . to_string ()) ; let ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 9 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 3,
          "line_number": 140,
          "code": "// Status: ❌ BROKEN\n\n// Check file properties\nlet exists = file_exists(\"config.json\")\nlet size = file_size(\"data.csv\")  // In bytes\nlet modified = file_modified_time(\"log.txt\")\nlet is_read_only = is_readonly(\"system.conf\")\n\n// File type checking\nlet is_file = is_file(path)\nlet is_dir = is_directory(path)\nlet is_symlink = is_symbolic_link(path)\n\n// Permissions (Unix-like systems)\nlet can_read = is_readable(path)\nlet can_write = is_writable(path)\nlet can_execute = is_executable(path)\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpnuqLMy/main.rs:1:562\n  |\n1 | ...mut can_execute = is_executable (path) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0423]: expected value, found built-in attribute `path`\n --> /tmp/.tmpnuqLMy/main.rs:1:344\n  |\n1 | ...\"system.conf\" . to_string ()) ; let mut is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_symb...\n  |                                                               ^^^^ not a value\n\nerror[E0423]: expected value, found built-in attribute `path`\n --> /tmp/.tmpnuqLMy/main.rs:1:383\n  |\n1 | ... is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read = i...\n  |                                                               ^^^^ not a value\n\nerror[E0423]: expected value, found built-in attribute `path`\n --> /tmp/.tmpnuqLMy/main.rs:1:430\n  |\n1 | ..._directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = is_writ...\n  |                                                               ^^^^ not a value\n\nerror[E0423]: expected value, found built-in attribute `path`\n --> /tmp/.tmpnuqLMy/main.rs:1:470\n  |\n1 | ... is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = is_e...\n  |                                                               ^^^^ not a value\n\nerror[E0423]: expected value, found built-in attribute `path`\n --> /tmp/.tmpnuqLMy/main.rs:1:511\n  |\n1 | ...ad = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = is_executable (path) } ; if let Some (s) = (&...\n  |                                                               ^^^^ not a value\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpnuqLMy/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut exists = file_exists (\"config.json\" . to_string ()) ; let mut siz...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpnuqLMy/main.rs:1:82\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut exists = file_exists (\"config.json\" . to_string ()) ; let mut siz...\n  |                                                                                  ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_size` in this scope\n --> /tmp/.tmpnuqLMy/main.rs:1:142\n  |\n1 | ...s (\"config.json\" . to_string ()) ; let mut size = file_size (\"data.csv\" . to_string ()) ; let mut modified = file_modified_time (\"log....\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_modified_time` in this scope\n --> /tmp/.tmpnuqLMy/main.rs:1:201\n  |\n1 | ...ata.csv\" . to_string ()) ; let mut modified = file_modified_time (\"log.txt\" . to_string ()) ; let mut is_read_only = is_readonly (\"sys...\n  |                                                  ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_readonly` in this scope\n --> /tmp/.tmpnuqLMy/main.rs:1:272\n  |\n1 | ...og.txt\" . to_string ()) ; let mut is_read_only = is_readonly (\"system.conf\" . to_string ()) ; let mut is_file = is_file (path) ; let m...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_file` in this scope\n --> /tmp/.tmpnuqLMy/main.rs:1:335\n  |\n1 | ...(\"system.conf\" . to_string ()) ; let mut is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_sym...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_directory` in this scope\n --> /tmp/.tmpnuqLMy/main.rs:1:369\n  |\n1 | ... mut is_file = is_file (path) ; let mut is_dir = is_directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_symbolic_link` in this scope\n --> /tmp/.tmpnuqLMy/main.rs:1:412\n  |\n1 | ...r = is_directory (path) ; let mut is_symlink = is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = i...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_readable` in this scope\n --> /tmp/.tmpnuqLMy/main.rs:1:457\n  |\n1 | ...k = is_symbolic_link (path) ; let mut can_read = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = i...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_writable` in this scope\n --> /tmp/.tmpnuqLMy/main.rs:1:498\n  |\n1 | ..._read = is_readable (path) ; let mut can_write = is_writable (path) ; let mut can_execute = is_executable (path) } ; if let Some (s) =...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 15 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0423, E0425.\nFor more information about an error, try `rustc --explain E0423`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 4,
          "line_number": 171,
          "code": "// Status: ❌ BROKEN\n\n// Create and remove directories\ncreate_dir(\"new_folder\")\ncreate_dir_all(\"path/to/nested/folder\")  // Creates parent dirs\nremove_dir(\"empty_folder\")\nremove_dir_all(\"folder_with_contents\")  // Recursive delete\n\n// List directory contents\nlet all_items = list_dir(\".\")\nlet files_only = list_files(\".\")\nlet dirs_only = list_directories(\".\")\n\n// Recursive directory walking\nfun walk_directory(dir) {\n    let items = list_dir(dir)\n    for item in items {\n        let path = join_path(dir, item)\n        if is_directory(path) {\n            walk_directory(path)  // Recurse into subdirectory\n        } else {\n            process_file(path)\n        }\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `create_dir` in this scope\n --> /tmp/.tmpq7G7Cx/main.rs:1:280\n  |\n1 | ... process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" ....\n  |                                                      ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::create_dir;\n  |\n\nerror[E0425]: cannot find function `create_dir_all` in this scope\n --> /tmp/.tmpq7G7Cx/main.rs:1:323\n  |\n1 | ...() { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" ....\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::create_dir_all;\n  |\n\nerror[E0425]: cannot find function `remove_dir` in this scope\n --> /tmp/.tmpq7G7Cx/main.rs:1:381\n  |\n1 | ...ir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" ...\n  |                                                      ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_dir;\n  |\n\nerror[E0425]: cannot find function `remove_dir_all` in this scope\n --> /tmp/.tmpq7G7Cx/main.rs:1:426\n  |\n1 | ... ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir ...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_dir_all;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpq7G7Cx/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let p...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpq7G7Cx/main.rs:1:76\n  |\n1 | ... { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } ...\n  |       ^^                                                                                                                                                                                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n1 + use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpq7G7Cx/main.rs:1:129\n  |\n1 | ... { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } ...\n  |       ^^                                                                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n1 + use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpq7G7Cx/main.rs:1:194\n  |\n1 | ...h = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main...\n  |                                                          ^^                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n1 + use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { walk_directory (path) } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpq7G7Cx/main.rs:1:229\n  |\n1 | ..._directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . t...\n  |                                                           ^^                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n1 + use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { process_file (path) } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n  |\n\nerror[E0425]: cannot find function `list_dir` in this scope\n --> /tmp/.tmpq7G7Cx/main.rs:1:92\n  |\n1 | use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let p...\n  |                                                                                            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpq7G7Cx/main.rs:1:144\n  |\n1 | ...st_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else {...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_directory` in this scope\n --> /tmp/.tmpq7G7Cx/main.rs:1:172\n  |\n1 | ...ems { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } ...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpq7G7Cx/main.rs:1:196\n  |\n1 | ...r , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir ...\n  |                ---------------------------^^^^^^^^^^^^^^^^^^^^^-------------------------------------\n  |                |                          |\n  |                |                          expected `()`, found `i32`\n  |                expected this to be `()`\n  |\nhelp: consider using a semicolon here\n  |\n1 | use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path); } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n  |                                                                                                                                                                                                                         +\nhelp: consider using a semicolon here\n  |\n1 | use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } }; } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n  |                                                                                                                                                                                                                                                              +\nhelp: you might have meant to return this value\n  |\n1 | use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { return walk_directory (path); } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n  |                                                                                                                                                                                                    ++++++                      +\n\nerror[E0425]: cannot find function `process_file` in this scope\n --> /tmp/.tmpq7G7Cx/main.rs:1:231\n  |\n1 | ...ry (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } } } fn main () { create_dir (\"new_folder\" . to_string...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpq7G7Cx/main.rs:1:109\n  |\n1 | ...-> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } } ...\n  |       ---                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |       |\n  |       expected `i32` because of return type\n  |\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn walk_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { walk_directory (path) } } else { { process_file (path) } } } } } /* `i32` value */ } } } fn main () { create_dir (\"new_folder\" . to_string ()) ; create_dir_all (\"path/to/nested/folder\" . to_string ()) ; remove_dir (\"empty_folder\" . to_string ()) ; remove_dir_all (\"folder_with_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n  |                                                                                                                                                                                                                                                                     +++++++++++++++++\n\nerror[E0425]: cannot find function `list_dir` in this scope\n --> /tmp/.tmpq7G7Cx/main.rs:1:503\n  |\n1 | ...th_contents\" . to_string ()) ; let mut all_items = list_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `list_files` in this scope\n --> /tmp/.tmpq7G7Cx/main.rs:1:556\n  |\n1 | ...t_dir (\".\" . to_string ()) ; let mut files_only = list_files (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_str...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `list_directories` in this scope\n --> /tmp/.tmpq7G7Cx/main.rs:1:610\n  |\n1 | ...les (\".\" . to_string ()) ; let mut dirs_only = list_directories (\".\" . to_string ()) ; }\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 13 previous errors; 5 warnings emitted\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 5,
          "line_number": 211,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: smart_backup.ruchy\n// Creates timestamped backups of important files\n\nprintln(\"=== Smart Backup System ===\")\n\nlet backup_config = {\n    \"documents\": [\"~/Documents\", \"*.doc\", \"*.pdf\", \"*.txt\"],\n    \"code\": [\"~/Projects\", \"*.py\", \"*.js\", \"*.rs\"],\n    \"config\": [\"~/.config\", \"*.conf\", \"*.json\", \"*.yaml\"]\n}\n\nlet backup_root = \"~/Backups\"\nlet timestamp = current_datetime().format(\"%Y%m%d_%H%M%S\")\nlet backup_dir = join_path(backup_root, \"backup_\" + timestamp)\n\ncreate_dir_all(backup_dir)\nprintln(\"Creating backup at: \" + backup_dir)\n\nlet total_files = 0\nlet total_size = 0\n\nfor category, config in backup_config.items() {\n    let source_dir = expand_home(config[0])\n    let patterns = config[1..]\n    \n    let category_dir = join_path(backup_dir, category)\n    create_dir(category_dir)\n    \n    println(\"\\n📁 Backing up \" + category + \"...\")\n    \n    for pattern in patterns {\n        let files = glob(join_path(source_dir, pattern))\n        \n        for file in files {\n            let size = file_size(file)\n            let relative_path = relative_to(file, source_dir)\n            let backup_path = join_path(category_dir, relative_path)\n            \n            // Create parent directories\n            let parent = parent_dir(backup_path)\n            if !dir_exists(parent) {\n                create_dir_all(parent)\n            }\n            \n            // Copy file to backup\n            copy_file(file, backup_path)\n            total_files += 1\n            total_size += size\n            \n            println(\"  ✓ \" + relative_path + \" (\" + format_size(size) + \")\")\n        }\n    }\n}\n\nprintln(\"\\n✅ Backup complete!\")\nprintln(\"Files backed up: \" + total_files.to_s())\nprintln(\"Total size: \" + format_size(total_size))\nprintln(\"Location: \" + backup_dir)\n\n// Create backup summary\nlet summary = \"Backup Summary\\n==============\\nDate: \" + timestamp + \"\\nFiles: \" + total_files.to_s() + \"\\nSize: \" + format_size(total_size) + \"\\nCategories: \" + backup_config.keys().join(\", \") + \"\\n\"\n\nwrite_file(join_path(backup_dir, \"summary.txt\"), summary)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 6,
          "line_number": 287,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// File: find_duplicates.ruchy\n// Finds duplicate files based on content hash\n\nprintln(\"=== Duplicate File Finder ===\")\n\nlet search_dir = input(\"Enter directory to search: \")\nlet min_size = input(\"Minimum file size (bytes, 0 for all): \").to_i()\n\nprintln(\"\\nScanning \" + search_dir + \"...\")\n\n// Build file hash map\nlet file_hashes = {}\nlet duplicates = []\n\nfun hash_file(path) {\n    let content = read_bytes(path)\n    return sha256(content)\n}\n\nfun scan_directory(dir) {\n    let items = list_dir(dir)\n    \n    for item in items {\n        let path = join_path(dir, item)\n        \n        if is_directory(path) {\n            scan_directory(path)  // Recurse\n        } else if is_file(path) {\n            let size = file_size(path)\n            \n            if size >= min_size {\n                let hash = hash_file(path)\n                \n                if file_hashes.has_key(hash) {\n                    // Found duplicate\n                    duplicates.push({\n                        \"original\": file_hashes[hash],\n                        \"duplicate\": path,\n                        \"size\": size,\n                        \"hash\": hash\n                    })\n                } else {\n                    file_hashes[hash] = path\n                }\n            }\n        }\n    }\n}\n\nscan_directory(search_dir)\n\nif duplicates.is_empty() {\n    println(\"\\n✅ No duplicate files found!\")\n} else {\n    println(\"\\n⚠️  Found \" + duplicates.len().to_s() + \" duplicate files:\")\n    \n    let total_wasted = 0\n    \n    for dup in duplicates {\n        println(\"\\nOriginal: \" + dup.original)\n        println(\"Duplicate: \" + dup.duplicate)\n        println(\"Size: \" + format_size(dup.size))\n        total_wasted += dup.size\n    }\n    \n    println(\"\\nTotal space wasted: \" + format_size(total_wasted))\n    \n    let action = input(\"\\nDelete duplicates? (y/n): \")\n    if action.lower() == \"y\" {\n        for dup in duplicates {\n            remove_file(dup.duplicate)\n            println(\"Deleted: \" + dup.duplicate)\n        }\n        println(\"\\n✅ Freed \" + format_size(total_wasted) + \" of space!\")\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `min_size` in this scope\n --> /tmp/.tmp3am531/main.rs:1:397\n  |\n1 | ...th) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { du...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `file_hashes` in this scope\n --> /tmp/.tmp3am531/main.rs:1:445\n  |\n1 | ... min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collection...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `duplicates` in this scope\n --> /tmp/.tmp3am531/main.rs:1:478\n  |\n1 | ...file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String >...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `file_hashes` in this scope\n --> /tmp/.tmp3am531/main.rs:1:650\n  |\n1 | ... () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `file_hashes` in this scope\n --> /tmp/.tmp3am531/main.rs:1:911\n  |\n1 | ...) , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `remove_file` in this scope\n --> /tmp/.tmp3am531/main.rs:1:3055\n  |\n1 | ... . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_file;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp3am531/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp3am531/main.rs:1:72\n  |\n1 | ...n hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) ->...\n  |                                      ^^                                                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { let content = read_bytes (path) ; return sha256 (content) } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp3am531/main.rs:1:179\n  |\n1 | ... { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp3am531/main.rs:1:232\n  |\n1 | ... { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp3am531/main.rs:1:297\n  |\n1 | ...h = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size ...\n  |                                                          ^^                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { scan_directory (path) } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp3am531/main.rs:1:352\n  |\n1 | ... { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp3am531/main.rs:1:408\n  |\n1 | ... { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp3am531/main.rs:1:476\n  |\n1 | ... { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp3am531/main.rs:1:909\n  |\n1 | ...() , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { printl...\n  |                                                    ^^                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { file_hashes [hash as usize] = path } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp3am531/main.rs:1:2015\n  |\n1 | ...earch_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}...\n  |                                               ^^                                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n1 + use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { println ! (\"\\n✅ No duplicate files found!\") } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |\n\nerror[E0425]: cannot find function `read_bytes` in this scope\n --> /tmp/.tmp3am531/main.rs:1:90\n  |\n1 | use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } ...\n  |                                                                                          ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `sha256` in this scope\n --> /tmp/.tmp3am531/main.rs:1:117\n  |\n1 | ... i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list...\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `list_dir` in this scope\n --> /tmp/.tmp3am531/main.rs:1:195\n  |\n1 | ...can_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmp3am531/main.rs:1:247\n  |\n1 | ...st_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else {...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_directory` in this scope\n --> /tmp/.tmp3am531/main.rs:1:275\n  |\n1 | ...ems { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let ...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp3am531/main.rs:1:299\n  |\n1 | ... ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } ...\n  |       ---------------------------^^^^^^^^^^^^^^^^^^^^^-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n  |       |                          |\n  |       |                          expected `()`, found `i32`\n  |       expected this to be `()`\n  |\nhelp: consider using a semicolon here\n  |\n1 | use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path); } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                +\nhelp: consider using a semicolon here\n  |\n1 | use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } }; } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   +\nhelp: you might have meant to return this value\n  |\n1 | use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { return scan_directory (path); } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |                                                                                                                                                                                                                                                                                                           ++++++                      +\n\nerror[E0425]: cannot find function `is_file` in this scope\n --> /tmp/.tmp3am531/main.rs:1:335\n  |\n1 | ...ory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let ha...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_size` in this scope\n --> /tmp/.tmp3am531/main.rs:1:367\n  |\n1 | ...th) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_h...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp3am531/main.rs:1:212\n  |\n1 | ...-> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } } ...\n  |       ---                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |       |\n  |       expected `i32` because of return type\n  |\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn hash_file (path : i32) -> i32 { { { let content = read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in items { { { let path = join_path (dir , item) ; if is_directory (path) { { scan_directory (path) } } else { if is_file (path) { { { let size = file_size (path) ; if size >= min_size { { { let hash = hash_file (path) ; if file_hashes . has_key (hash) { { duplicates . push ({ let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"original\" . to_string () , (file_hashes [hash as usize]) . to_string ()) ; map . insert (\"duplicate\" . to_string () , (path) . to_string ()) ; map . insert (\"size\" . to_string () , (size) . to_string ()) ; map . insert (\"hash\" . to_string () , (hash) . to_string ()) ; map }) } } else { { file_hashes [hash as usize] = path } } } } } } } } } } } } /* `i32` value */ } } } fn main () { println ! (\"=== Duplicate File Finder ===\") ; let mut search_dir = { print ! (\"{}\" , \"Enter directory to search: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut min_size = { print ! (\"{}\" , \"Minimum file size (bytes, 0 for all): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , search_dir) , \"...\")) ; let mut file_hashes = () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files found!\") } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplicates { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nOriginal: \" , dup . original)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Duplicate: \" , dup . duplicate)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicates? (y/n): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Deleted: \" , dup . duplicate)) } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          +++++++++++++++++\n\nerror[E0599]: no method named `to_i` found for struct `String` in the current scope\n --> /tmp/.tmp3am531/main.rs:1:1788\n  |\n1 | ...ends_with ('\\r') { input . pop () ; } } input } . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nScanning \" , ...\n  |                                                      ^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp3am531/main.rs:1:1971\n  |\n1 | ... () ; let mut duplicates = vec ! [] ; scan_directory (search_dir) ; if duplicates . is_empty () { { println ! (\"\\n✅ No duplicate files ...\n  |                                          --------------  ^^^^^^^^^^ expected `i32`, found `String`\n  |                                          |\n  |                                          arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmp3am531/main.rs:1:143\n  |\n1 | ... read_bytes (path) ; return sha256 (content) } } } fn scan_directory (dir : i32) -> i32 { { { let items = list_dir (dir) ; for item in...\n  |                                                          ^^^^^^^^^^^^^^  ---------\n\nerror[E0599]: no method named `to_s` found for type `usize` in the current scope\n --> /tmp/.tmp3am531/main.rs:1:2178\n  |\n1 | ...}\" , \"\\n⚠\\u{fe0f}  Found \" , duplicates . len () . to_s ()) , \" duplicate files:\")) ; { let total_wasted = 0i32 ; { for dup in duplica...\n  |                                                       ^^^^ method not found in `usize`\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmp3am531/main.rs:1:2469\n  |\n1 | ...rintln ! (\"{:?}\" , format ! (\"{}{}\" , \"Size: \" , format_size (dup . size))) ; total_wasted += dup . size } } ; println ! (\"{:?}\" , for...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmp3am531/main.rs:1:2597\n  |\n1 | ... , format ! (\"{}{}\" , \"\\nTotal space wasted: \" , format_size (total_wasted))) ; let mut action = { print ! (\"{}\" , \"\\nDelete duplicate...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `lower` found for struct `String` in the current scope\n --> /tmp/.tmp3am531/main.rs:1:3009\n  |\n1 | ...\\r') { input . pop () ; } } input } ; if action . lower () == \"y\" { { for dup in duplicates { { remove_file (dup . duplicate) ; printl...\n  |                                                      ^^^^^ method not found in `String`\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmp3am531/main.rs:1:3237\n  |\n1 | ...at ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n✅ Freed \" , format_size (total_wasted)) , \" of space!\")) } } } } } } ; }\n  |                                                      ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 22 previous errors; 10 warnings emitted\n\nSome errors have detailed explanations: E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_i()"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 7,
          "line_number": 378,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// File: log_rotator.ruchy\n// Manages log files with size-based rotation\n\nprintln(\"=== Log Rotation System ===\")\n\nlet log_config = {\n    \"max_size\": 10 * 1024 * 1024,  // 10MB\n    \"max_backups\": 5,\n    \"compress\": true\n}\n\nlet log_dir = \"/var/log/myapp\"\nlet log_files = glob(join_path(log_dir, \"*.log\"))\n\nfor log_file in log_files {\n    let size = file_size(log_file)\n    \n    if size > log_config.max_size {\n        println(\"Rotating \" + log_file + \" (\" + format_size(size) + \")...\")\n        \n        // Shift existing backups\n        for i in range(log_config.max_backups - 1, 0, -1) {\n            let old_backup = log_file + \".\" + i.to_s()\n            let new_backup = log_file + \".\" + (i + 1).to_s()\n            \n            if file_exists(old_backup) {\n                if i == log_config.max_backups - 1 {\n                    // Delete oldest backup\n                    remove_file(old_backup)\n                } else {\n                    // Rename to next number\n                    rename_file(old_backup, new_backup)\n                }\n            }\n        }\n        \n        // Move current log to .1\n        let backup_path = log_file + \".1\"\n        rename_file(log_file, backup_path)\n        \n        // Compress if configured\n        if log_config.compress {\n            compress_file(backup_path, backup_path + \".gz\")\n            remove_file(backup_path)\n            println(\"  Compressed to \" + backup_path + \".gz\")\n        }\n        \n        // Create new empty log file\n        write_file(log_file, \"\")\n        println(\"  Created new \" + log_file)\n    }\n}\n\nprintln(\"\\n✅ Log rotation complete!\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmpXxEF6Q/main.rs:1:853\n  |\n1 | ... , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = for...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nerror[E0425]: cannot find function `remove_file` in this scope\n --> /tmp/.tmpXxEF6Q/main.rs:1:1140\n  |\n1 | ... { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } }...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_file;\n  |\n\nerror[E0425]: cannot find function `remove_file` in this scope\n --> /tmp/.tmpXxEF6Q/main.rs:1:1434\n  |\n1 | ...ath , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" ,...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_file;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpXxEF6Q/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let mut log_config = { let mu...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXxEF6Q/main.rs:1:627\n  |\n1 | ... { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"max_size\" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert (\"max_backups\" . to_string () , (5i32) . to_string ()) ; map . insert (\"compress\" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = \"/var/log/myapp\" . to_string () ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"max_size\" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert (\"max_backups\" . to_string () , (5i32) . to_string ()) ; map . insert (\"compress\" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = \"/var/log/myapp\" . to_string () ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXxEF6Q/main.rs:1:911\n  |\n1 | ... { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                          ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"max_size\" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert (\"max_backups\" . to_string () , (5i32) . to_string ()) ; map . insert (\"compress\" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = \"/var/log/myapp\" . to_string () ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"max_size\" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert (\"max_backups\" . to_string () , (5i32) . to_string ()) ; map . insert (\"compress\" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = \"/var/log/myapp\" . to_string () ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXxEF6Q/main.rs:1:1094\n  |\n1 | ... { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } }...\n  |       ^^                                                                                                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"max_size\" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert (\"max_backups\" . to_string () , (5i32) . to_string ()) ; map . insert (\"compress\" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = \"/var/log/myapp\" . to_string () ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"max_size\" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert (\"max_backups\" . to_string () , (5i32) . to_string ()) ; map . insert (\"compress\" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = \"/var/log/myapp\" . to_string () ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXxEF6Q/main.rs:1:1138\n  |\n1 | ...ackup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } }...\n  |                                                         ^^                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"max_size\" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert (\"max_backups\" . to_string () , (5i32) . to_string ()) ; map . insert (\"compress\" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = \"/var/log/myapp\" . to_string () ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"max_size\" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert (\"max_backups\" . to_string () , (5i32) . to_string ()) ; map . insert (\"compress\" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = \"/var/log/myapp\" . to_string () ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { remove_file (old_backup) } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXxEF6Q/main.rs:1:1176\n  |\n1 | ... 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (...\n  |                                                  ^^                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"max_size\" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert (\"max_backups\" . to_string () , (5i32) . to_string ()) ; map . insert (\"compress\" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = \"/var/log/myapp\" . to_string () ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Rotation System ===\") ; let mut log_config = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"max_size\" . to_string () , (10i32 * 1024i32 * 1024i32) . to_string ()) ; map . insert (\"max_backups\" . to_string () , (5i32) . to_string ()) ; map . insert (\"compress\" . to_string () , (true) . to_string ()) ; map } ; let mut log_dir = \"/var/log/myapp\" . to_string () ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , log_file , \".\") + i . to_s () ; { let mut new_backup = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { rename_file (old_backup , new_backup) } } } } } } } ; { let backup_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (backup_path) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"  Created new \" , log_file)) } } } } } } } ; println ! (\"\\n✅ Log rotation complete!\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpXxEF6Q/main.rs:1:551\n  |\n1 | ...myapp\" . to_string () ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files { { { let ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `glob` in this scope\n --> /tmp/.tmpXxEF6Q/main.rs:1:545\n  |\n1 | .../var/log/myapp\" . to_string () ; let mut log_files = glob (join_path (log_dir , \"*.log\" . to_string ())) ; for log_file in log_files {...\n  |                                                         ^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_size` in this scope\n --> /tmp/.tmpXxEF6Q/main.rs:1:642\n  |\n1 | ...())) ; for log_file in log_files { { { let size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{:?}\" , forma...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0609]: no field `max_size` on type `HashMap<String, String>`\n --> /tmp/.tmpXxEF6Q/main.rs:1:688\n  |\n1 | ...et size = file_size (log_file) ; if size > log_config . max_size { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ...\n  |                                                            ^^^^^^^^ unknown field\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpXxEF6Q/main.rs:1:812\n  |\n1 | ...at ! (\"{}{}\" , \"Rotating \" , log_file) , \" (\") + format_size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i3...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0609]: no field `max_backups` on type `HashMap<String, String>`\n --> /tmp/.tmpXxEF6Q/main.rs:1:873\n  |\n1 | ...size (size) , \")...\")) ; for i in range (log_config . max_backups - 1i32 , 0i32 , - 1i32) { { { let old_backup = format ! (\"{}{}\" , lo...\n  |                                                          ^^^^^^^^^^^ unknown field\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpXxEF6Q/main.rs:1:1054\n  |\n1 | ...p = format ! (\"{}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpXxEF6Q/main.rs:1:1067\n  |\n1 | ...}{}\" , log_file , \".\") + i + 1i32 . to_s () ; if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0609]: no field `max_backups` on type `HashMap<String, String>`\n --> /tmp/.tmpXxEF6Q/main.rs:1:1117\n  |\n1 | ... if file_exists (old_backup) { { if i == log_config . max_backups - 1i32 { { remove_file (old_backup) } } else { { rename_file (old_ba...\n  |                                                          ^^^^^^^^^^^ unknown field\n\nerror[E0425]: cannot find function `rename_file` in this scope\n --> /tmp/.tmpXxEF6Q/main.rs:1:1178\n  |\n1 | ...- 1i32 { { remove_file (old_backup) } } else { { rename_file (old_backup , new_backup) } } } } } } } } ; { let backup_path = format ! ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `rename_file` in this scope\n --> /tmp/.tmpXxEF6Q/main.rs:1:1294\n  |\n1 | ...p_path = format ! (\"{}{}\" , log_file , \".1\") ; { rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (ba...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0609]: no field `compress` on type `HashMap<String, String>`\n --> /tmp/.tmpXxEF6Q/main.rs:1:1349\n  |\n1 | ... rename_file (log_file , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".g...\n  |                                                            ^^^^^^^^ unknown field\n\nerror[E0425]: cannot find function `compress_file` in this scope\n --> /tmp/.tmpXxEF6Q/main.rs:1:1362\n  |\n1 | ...e , backup_path) ; if log_config . compress { { compress_file (backup_path , format ! (\"{}{}\" , backup_path , \".gz\")) ; remove_file (b...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpXxEF6Q/main.rs:1:1570\n  |\n1 | ...\"  Compressed to \" , backup_path) , \".gz\")) } } ; write_file (log_file , \"\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 17 previous errors; 6 warnings emitted\n\nSome errors have detailed explanations: E0425, E0599, E0609.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 8,
          "line_number": 447,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: config_manager.ruchy\n// Manages application configuration files\n\nprintln(\"=== Configuration Manager ===\")\n\nlet config_dir = \"~/.config/myapp\"\nlet config_file = join_path(config_dir, \"config.json\")\n\n// Ensure config directory exists\nif !dir_exists(config_dir) {\n    create_dir_all(config_dir)\n    println(\"Created config directory: \" + config_dir)\n}\n\n// Load or create default configuration\nlet config = if file_exists(config_file) {\n    parse_json(read_file(config_file))\n} else {\n    // Default configuration\n    {\n        \"version\": \"1.0\",\n        \"theme\": \"dark\",\n        \"auto_save\": true,\n        \"backup_interval\": 3600,\n        \"recent_files\": [],\n        \"window\": {\n            \"width\": 1200,\n            \"height\": 800,\n            \"maximized\": false\n        }\n    }\n}\n\nfun save_config() {\n    let json = to_json_pretty(config)\n    write_file(config_file, json)\n    println(\"✅ Configuration saved\")\n}\n\nfun update_setting(key, value) {\n    config[key] = value\n    save_config()\n}\n\nfun add_recent_file(path) {\n    if !config.recent_files.contains(path) {\n        config.recent_files.insert(0, path)\n        // Keep only last 10 files\n        if config.recent_files.len() > 10 {\n            config.recent_files = config.recent_files[..10]\n        }\n        save_config()\n    }\n}\n\n// Interactive configuration editor\nloop {\n    println(\"\\n=== Current Configuration ===\")\n    for key, value in config.items() {\n        println(key + \": \" + value.to_s())\n    }\n    \n    println(\"\\nOptions:\")\n    println(\"1. Change theme\")\n    println(\"2. Toggle auto-save\")\n    println(\"3. Set backup interval\")\n    println(\"4. Clear recent files\")\n    println(\"5. Reset to defaults\")\n    println(\"6. Exit\")\n    \n    let choice = input(\"\\nChoice: \")\n    \n    match choice {\n        \"1\" => {\n            let theme = input(\"Theme (light/dark): \")\n            update_setting(\"theme\", theme)\n        }\n        \"2\" => {\n            config.auto_save = !config.auto_save\n            save_config()\n        }\n        \"3\" => {\n            let interval = input(\"Backup interval (seconds): \").to_i()\n            update_setting(\"backup_interval\", interval)\n        }\n        \"4\" => {\n            config.recent_files = []\n            save_config()\n        }\n        \"5\" => {\n            // Reset to defaults\n            remove_file(config_file)\n            println(\"Configuration reset!\")\n            break\n        }\n        \"6\" => break\n        _ => println(\"Invalid choice\")\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 9,
          "line_number": 561,
          "code": "// Status: ❌ BROKEN\n\nfun safe_file_operation(path) {\n    // Check permissions first\n    if !file_exists(path) {\n        println(\"Error: File not found: \" + path)\n        return false\n    }\n    \n    if !is_readable(path) {\n        println(\"Error: No read permission for: \" + path)\n        return false\n    }\n    \n    // Try operation with error handling\n    try {\n        let content = read_file(path)\n        process_content(content)\n        return true\n    } catch error {\n        println(\"Error processing file: \" + error.to_s())\n        \n        // Log error for debugging\n        let error_log = \"errors.log\"\n        let timestamp = current_datetime()\n        append_file(error_log, timestamp.to_s() + \": \" + path + \" - \" + error.to_s() + \"\\n\")\n        \n        return false\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0423]: expected value, found macro `try`\n --> /tmp/.tmpQN5Efe/main.rs:1:338\n  |\n1 | ...: No read permission for: \" , path)) ; return false } } ; r#try ; { { let content = read_file (path) ; { process_content (content) ; r...\n  |                                                              ^^^^^ not a value\n\nerror[E0425]: cannot find value `catch` in this scope\n --> /tmp/.tmpQN5Efe/main.rs:1:433\n  |\n1 | ...; { process_content (content) ; return true } } } ; catch ; error ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Error processing file: \"...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpQN5Efe/main.rs:1:441\n  |\n1 | ...ess_content (content) ; return true } } } ; catch ; error ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Error processing file: \" , error...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpQN5Efe/main.rs:1:518\n  |\n1 | ...}\" , format ! (\"{}{}\" , \"Error processing file: \" , error . to_s ())) ; { let error_log = \"errors.log\" . to_string () ; { let mut time...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpQN5Efe/main.rs:1:758\n  |\n1 | ...{}\" , timestamp . to_s () , \": \") + path , \" - \") + error . to_s () , \"\\n\")) ; return false } } } } } fn main () { }\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpQN5Efe/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn safe_file_operation (path : i32) -> i32 { { if ! file_exists (path) { { println ! (\"{:?}\" , format...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpQN5Efe/main.rs:1:89\n  |\n1 | use std :: collections :: HashMap ; fn safe_file_operation (path : i32) -> i32 { { if ! file_exists (path) { { println ! (\"{:?}\" , format...\n  |                                                                                         ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpQN5Efe/main.rs:1:195\n  |\n1 | ...-> i32 { { if ! file_exists (path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Error: File not found: \" , path)) ; return false } } ; ...\n  |       --- expected `i32` because of return type                                                                              ^^^^^ expected `i32`, found `bool`\n\nerror[E0425]: cannot find function `is_readable` in this scope\n --> /tmp/.tmpQN5Efe/main.rs:1:212\n  |\n1 | ... not found: \" , path)) ; return false } } ; if ! is_readable (path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Error: No read permiss...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpQN5Efe/main.rs:1:364\n  |\n1 | ...)) ; return false } } ; r#try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ;...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `process_content` in this scope\n --> /tmp/.tmpQN5Efe/main.rs:1:385\n  |\n1 | ...r#try ; { { let content = read_file (path) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! (\"{:?}\" , f...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unreachable statement\n --> /tmp/.tmpQN5Efe/main.rs:1:433\n  |\n1 | ...th) ; { process_content (content) ; return true } } } ; catch ; error ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Error processing fil...\n  |                                        -----------         ^^^^^^^ unreachable statement\n  |                                        |\n  |                                        any code following this expression is unreachable\n  |\n  = note: `#[warn(unreachable_code)]` on by default\n\nerror[E0425]: cannot find function `current_datetime` in this scope\n --> /tmp/.tmpQN5Efe/main.rs:1:608\n  |\n1 | ...rs.log\" . to_string () ; { let mut timestamp = current_datetime () ; append_file (error_log , format ! (\"{}{}\" , format ! (\"{}{}\" , fo...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpQN5Efe/main.rs:1:742\n  |\n1 | ... format ! (\"{}{}\" , timestamp . to_s () , \": \") + path , \" - \") + error . to_s () , \"\\n\")) ; return false } } } } } fn main () { }\n  |                                                      ^^^^ expected `&str`, found `i32`\n\nerror[E0425]: cannot find function `append_file` in this scope\n --> /tmp/.tmpQN5Efe/main.rs:1:630\n  |\n1 | ...() ; { let mut timestamp = current_datetime () ; append_file (error_log , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , tim...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 13 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0308, E0423, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-file-operations.md",
          "example_number": 10,
          "line_number": 610,
          "code": "// Status: ❌ BROKEN\n\nlet files = list_files(\"data\")\nfor file in files {\n    let size = file_size(file)\n    if size > 1000000 {\n        move_file(file, \"large_files/\" + file)\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpudkiAW/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files (\"data\" . to_string ()) ; for file in files { ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpudkiAW/main.rs:1:138\n  |\n1 | ... { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! (\"{}{}\" , \"large_files/\" , file)) } } } } } }...\n  |       ^^                                                                                                                           ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files (\"data\" . to_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! (\"{}{}\" , \"large_files/\" , file)) } } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files (\"data\" . to_string ()) ; for file in files { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! (\"{}{}\" , \"large_files/\" , file)) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpudkiAW/main.rs:1:195\n  |\n1 | ...ze (file) ; if size > 1000000i32 { { move_file (file , format ! (\"{}{}\" , \"large_files/\" , file)) } } } } } } ; if let Some (s) = (& r...\n  |                                       ^^                                                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files (\"data\" . to_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! (\"{}{}\" , \"large_files/\" , file)) } } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files (\"data\" . to_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { move_file (file , format ! (\"{}{}\" , \"large_files/\" , file)) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `list_files` in this scope\n --> /tmp/.tmpudkiAW/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut files = list_files (\"data\" . to_string ()) ; for file in files { ...\n  |                                                                                 ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_size` in this scope\n --> /tmp/.tmpudkiAW/main.rs:1:153\n  |\n1 | ...o_string ()) ; for file in files { { { let size = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! (\"{}{}\" , \"la...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `move_file` in this scope\n --> /tmp/.tmpudkiAW/main.rs:1:197\n  |\n1 | ...ize = file_size (file) ; if size > 1000000i32 { { move_file (file , format ! (\"{}{}\" , \"large_files/\" , file)) } } } } } } ; if let So...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch20-00-tooling": {
      "chapter": "ch20-00-tooling",
      "total_examples": 6,
      "working_examples": 0,
      "failing_examples": 6,
      "examples": [
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 1,
          "line_number": 168,
          "code": "// Status: ❌ BROKEN\n// bad_code.ruchy - Multiple issues for demonstration\nfun calculate_something(x: int) {\n    let unused_var = 42;\n    let y = x + 1;\n    return y;\n}\n\nfun main() {\n    let result=calculate_something(10);\n    println(result);\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp6BMxru/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; retur...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp6BMxru/main.rs:1:79\n  |\n1 | ...ate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = ...\n  |                                     ^^                                                                ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{:?}\" , result) } } }\n1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{:?}\" , result) } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp6BMxru/main.rs:1:163\n  |\n1 | ...turn y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{:?}\" , result) } } }\n  |                                ^^                                                                          ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{:?}\" , result) } } }\n1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { let result = calculate_something (10i32) ; println ! (\"{:?}\" , result) } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp6BMxru/main.rs:1:126\n  |\n1 | ...2 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ;...\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot add `i32` to `i64`\n --> /tmp/.tmp6BMxru/main.rs:1:124\n  |\n1 | ...2 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ;...\n  |                                                     ^ no implementation for `i64 + i32`\n  |\n  = help: the trait `Add<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Add<Rhs>`:\n            `&i64` implements `Add<i64>`\n            `&i64` implements `Add`\n            `i64` implements `Add<&i64>`\n            `i64` implements `Add`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp6BMxru/main.rs:1:140\n  |\n1 | ...thing (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculat...\n  |                       --- expected `i32` because of return type                          ^ expected `i32`, found `i64`\n  |\nhelp: you can convert an `i64` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y.try_into().unwrap() } } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{:?}\" , result) } } }\n  |                                                                                                                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp6BMxru/main.rs:1:201\n  |\n1 | ... } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{:?}\" , result) } } }\n  |                                         -------------------  ^^^^^ expected `i64`, found `i32`\n  |                                         |\n  |                                         arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmp6BMxru/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; retur...\n  |                                        ^^^^^^^^^^^^^^^^^^^  -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i32) ; println ! (\"{:?}\" , result) } } }\n1 + use std :: collections :: HashMap ; fn calculate_something (x : i64) -> i32 { { { let unused_var = 42i32 ; { let mut y = x + 1i32 ; return y } } } } fn main () { { { let result = calculate_something (10i64) ; println ! (\"{:?}\" , result) } } }\n  |\n\nerror: aborting due to 4 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 2,
          "line_number": 249,
          "code": "// Status: ❌ BROKEN\n// Before formatting (messy)\nfun fibonacci(n:int)->int{if n<=1{n}else{fibonacci(n-1)+fibonacci(n-2)}}\n\n// After running: ruchy fmt fibonacci.ruchy\nfun fibonacci(n: int) -> int {\n    if n <= 1 {\n        n\n    } else {\n        fibonacci(n - 1) + fibonacci(n - 2)\n    }\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0428]: the name `fibonacci` is defined multiple times\n --> /tmp/.tmpuFC7fX/main.rs:1:155\n  |\n1 | ... ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { ...\n  |       ----------------------------- previous definition of the value `fibonacci` here                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `fibonacci` redefined here\n  |\n  = note: `fibonacci` must be defined only once in the value namespace of this module\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpuFC7fX/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpuFC7fX/main.rs:1:69\n  |\n1 | ...nacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) ...\n  |                             ^^                                                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpuFC7fX/main.rs:1:86\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...\n  |                                                                                      ^^ ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpuFC7fX/main.rs:1:101\n  |\n1 | ...) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if ...\n  |                                               ^^                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpuFC7fX/main.rs:1:187\n  |\n1 | ...nacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                             ^^                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpuFC7fX/main.rs:1:204\n  |\n1 | ... 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } f...\n  |                                                                    ^^ ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpuFC7fX/main.rs:1:219\n  |\n1 | ...) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                                               ^^                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpuFC7fX/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n...\n  |                                                                          -    ^^^^ expected `i64`, found `i32`\n  |                                                                          |\n  |                                                                          expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpuFC7fX/main.rs:1:118\n  |\n1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32...\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmpuFC7fX/main.rs:1:116\n  |\n1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32...\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpuFC7fX/main.rs:1:141\n  |\n1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fib...\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmpuFC7fX/main.rs:1:139\n  |\n1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fib...\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpuFC7fX/main.rs:1:197\n  |\n1 | ...2) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn ma...\n  |                                                    -    ^^^^ expected `i64`, found `i32`\n  |                                                    |\n  |                                                    expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn fibonacci (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpuFC7fX/main.rs:1:236\n  |\n1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmpuFC7fX/main.rs:1:234\n  |\n1 | ...{ { if n <= 1i32 { { n } } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpuFC7fX/main.rs:1:259\n  |\n1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmpuFC7fX/main.rs:1:257\n  |\n1 | ...} } else { { fibonacci (n - 1i32) + fibonacci (n - 2i32) } } } } fn main () { }\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror: aborting due to 11 previous errors; 7 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0428.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 3,
          "line_number": 294,
          "code": "// Status: ❌ BROKEN\n// math_utils.ruchy\nfun add(a: int, b: int) -> int {\n    a + b\n}\n\nfun multiply(a: int, b: int) -> int {\n    a * b\n}\n\n// Tests can be in the same file or separate test files\nfun test_add() {\n    assert_eq(add(2, 3), 5);\n    assert_eq(add(-1, 1), 0);\n    assert_eq(add(0, 0), 0);\n}\n\nfun test_multiply() {\n    assert_eq(multiply(2, 3), 6);\n    assert_eq(multiply(-1, 5), -5);\n    assert_eq(multiply(0, 100), 0);\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpxm9qOS/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpxm9qOS/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                                                         ^^     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { a + b } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpxm9qOS/main.rs:1:126\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                                                                                                              ^^     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { a * b } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpxm9qOS/main.rs:1:177\n  |\n1 | ...b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (...\n  |                                                 ^^^  ----   ---- expected `i64`, found `i32`\n  |                                                      |\n  |                                                      expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpxm9qOS/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                        ^^^  -------   -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i64 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i64) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpxm9qOS/main.rs:1:197\n  |\n1 | ...add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) ,...\n  |                                                       ^^^^ expected `i64`, found `i32`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i64) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpxm9qOS/main.rs:1:218\n  |\n1 | ...! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply ...\n  |                                                ^^^  ------   ---- expected `i64`, found `i32`\n  |                                                     |\n  |                                                     expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpxm9qOS/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                        ^^^  -------   -------\nhelp: you can convert an `i32` to an `i64`\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add ((- 1i32).into() , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                                               +      ++++++++\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i64) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpxm9qOS/main.rs:1:240\n  |\n1 | ...3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { a...\n  |                                                       ^^^^ expected `i64`, found `i32`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i64) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpxm9qOS/main.rs:1:261\n  |\n1 | ... (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 ...\n  |                                                 ^^^  ----   ---- expected `i64`, found `i32`\n  |                                                      |\n  |                                                      expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpxm9qOS/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                        ^^^  -------   -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i64 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i64) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpxm9qOS/main.rs:1:281\n  |\n1 | ..., 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32...\n  |                                                       ^^^^ expected `i64`, found `i32`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i64) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpxm9qOS/main.rs:1:248\n  |\n1 | ... ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i3...\n  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpxm9qOS/main.rs:1:335\n  |\n1 | ... test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq...\n  |                                              ^^^^^^^^  ----   ---- expected `i64`, found `i32`\n  |                                                        |\n  |                                                        expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpxm9qOS/main.rs:1:88\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                                                                        ^^^^^^^^  -------   -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i64 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i64) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpxm9qOS/main.rs:1:360\n  |\n1 | ...) -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i...\n  |                                                       ^^^^ expected `i64`, found `i32`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i64) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpxm9qOS/main.rs:1:381\n  |\n1 | ...ply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn mai...\n  |                                             ^^^^^^^^  ------   ---- expected `i64`, found `i32`\n  |                                                       |\n  |                                                       expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpxm9qOS/main.rs:1:88\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                                                                        ^^^^^^^^  -------   -------\nhelp: you can convert an `i32` to an `i64`\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply ((- 1i32).into() , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                       +      ++++++++\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i64) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpxm9qOS/main.rs:1:408\n  |\n1 | ..., 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                      ^^^^^^ expected `i64`, found `i32`\n  |\nhelp: you can convert an `i32` to an `i64`\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , (- 5i32).into()) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                        +      ++++++++\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpxm9qOS/main.rs:1:431\n  |\n1 | ...(- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                             ^^^^^^^^  ----   ------ expected `i64`, found `i32`\n  |                                                       |\n  |                                                       expected `i64`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpxm9qOS/main.rs:1:88\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } ...\n  |                                                                                        ^^^^^^^^  -------   -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i64 , 100i32) , 0i32) } } fn main () { }\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i64) , 0i32) } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpxm9qOS/main.rs:1:458\n  |\n1 | ... - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                                       ^^^^ expected `i64`, found `i32`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i64 , b : i64) -> i64 { { a + b } } fn multiply (a : i64 , b : i64) -> i64 { { a * b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) } } fn test_multiply () -> i32 { { assert_eq ! (multiply (2i32 , 3i32) , 6i32) ; assert_eq ! (multiply (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i64) } } fn main () { }\n  |\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpxm9qOS/main.rs:1:418\n  |\n1 | ...ly (- 1i32 , 5i32) , - 5i32) ; assert_eq ! (multiply (0i32 , 100i32) , 0i32) } } fn main () { }\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 14 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0317.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 4,
          "line_number": 369,
          "code": "// Status: ❌ BROKEN\n// property_test.ruchy\nfun reverse_string(s: string) -> string {\n    // Implementation details...\n    s  // Placeholder\n}\n\nfun property_test_reverse_twice_is_identity() {\n    // Property: reverse(reverse(s)) == s\n    property_test(|s: string| {\n        assert_eq(reverse_string(reverse_string(s)), s);\n    });\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpjQMW5e/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () -> i...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpjQMW5e/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () -> i...\n  |                                                                                ^^ ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () -> i32 { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { s } fn property_test_reverse_twice_is_identity () -> i32 { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpjQMW5e/main.rs:1:143\n  |\n1 | ..._is_identity () -> i32 { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }\n  |                             ^^                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () -> i32 { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn reverse_string (s : String) -> String { { s } } fn property_test_reverse_twice_is_identity () -> i32 { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } fn main () { }\n  |\n\nerror[E0425]: cannot find function `property_test` in this scope\n --> /tmp/.tmpjQMW5e/main.rs:1:145\n  |\n1 | ...ty_test_reverse_twice_is_identity () -> i32 { { property_test (| s | { assert_eq ! (reverse_string (reverse_string (s)) , s) }) } } fn...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 5,
          "line_number": 458,
          "code": "// Status: ❌ BROKEN\n// documented_code.ruchy\n\n/// Calculates the factorial of a positive integer\n/// \n/// # Examples\n/// ```ruchy\n/// let result = factorial(5);\n/// assert_eq(result, 120);\n/// ```\n///\n/// # Panics\n/// Panics if n is negative\nfun factorial(n: int) -> int {\n    if n < 0 {\n        panic(\"Factorial not defined for negative numbers\");\n    }\n    \n    if n == 0 || n == 1 {\n        1\n    } else {\n        n * factorial(n - 1)\n    }\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpVPnyhw/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative number...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpVPnyhw/main.rs:1:85\n  |\n1 | ...al (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i3...\n  |                                          ^^                                                      ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { panic ! (\"Factorial not defined for negative numbers\") } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpVPnyhw/main.rs:1:176\n  |\n1 | ...fined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |                                                                   ^^    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { 1i32 } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpVPnyhw/main.rs:1:194\n  |\n1 | ... } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |                                                         ^^                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { n * factorial (n - 1i32) } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpVPnyhw/main.rs:1:78\n  |\n1 | use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative number...\n  |                                                                          -   ^^^^ expected `i64`, found `i32`\n  |                                                                          |\n  |                                                                          expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i64 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpVPnyhw/main.rs:1:156\n  |\n1 | ...ial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main ...\n  |                                                    -    ^^^^ expected `i64`, found `i32`\n  |                                                    |\n  |                                                    expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i64 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpVPnyhw/main.rs:1:169\n  |\n1 | ...ed for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |                                                    -    ^^^^ expected `i64`, found `i32`\n  |                                                    |\n  |                                                    expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i64 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpVPnyhw/main.rs:1:178\n  |\n1 | ...) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else ...\n  |         --- expected `i64` because of return type                                                                          ^^^^ expected `i64`, found `i32`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn factorial (n : i64) -> i64 { { if n < 0i32 { { panic ! (\"Factorial not defined for negative numbers\") } } ; if n == 0i32 || n == 1i32 { { 1i64 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpVPnyhw/main.rs:1:215\n  |\n1 | ...n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmpVPnyhw/main.rs:1:213\n  |\n1 | ...n == 1i32 { { 1i32 } } else { { n * factorial (n - 1i32) } } } } fn main () { }\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror: aborting due to 6 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch20-00-tooling.md",
          "example_number": 6,
          "line_number": 512,
          "code": "// Status: ❌ BROKEN\n// bench_test.ruchy\nfun fibonacci_recursive(n: int) -> int {\n    if n <= 1 { n } else { fibonacci_recursive(n-1) + fibonacci_recursive(n-2) }\n}\n\nfun fibonacci_iterative(n: int) -> int {\n    let mut a = 0;\n    let mut b = 1;\n    for i in range(n) {\n        let temp = a + b;\n        a = b;\n        b = temp;\n    }\n    a\n}\n\n// Benchmark functions\nfun bench_recursive_fib() {\n    bench(\"fibonacci_recursive_20\", || fibonacci_recursive(20));\n}\n\nfun bench_iterative_fib() {\n    bench(\"fibonacci_iterative_20\", || fibonacci_iterative(20));\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmp2dCTmB/main.rs:1:276\n  |\n1 | ... { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_rec...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp2dCTmB/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp2dCTmB/main.rs:1:79\n  |\n1 | ... i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_...\n  |                   ^^                                                                                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp2dCTmB/main.rs:1:96\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...\n  |                                                                                                ^^ ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { n } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp2dCTmB/main.rs:1:111\n  |\n1 | ... { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n :...\n  |                                     ^^                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp2dCTmB/main.rs:1:288\n  |\n1 | ... ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 ...\n  |                                               ^^                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { let temp = a + b ; { a = b ; b = temp } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp2dCTmB/main.rs:1:381\n  |\n1 | ...ecursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib...\n  |                             ^^                                                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp2dCTmB/main.rs:1:503\n  |\n1 | ...terative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |                             ^^                                                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp2dCTmB/main.rs:1:89\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...\n  |                                                                                    -    ^^^^ expected `i64`, found `i32`\n  |                                                                                    |\n  |                                                                                    expected because this is `i64`\n  |\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i64 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp2dCTmB/main.rs:1:138\n  |\n1 | ...= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> ...\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmp2dCTmB/main.rs:1:136\n  |\n1 | ...= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> ...\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp2dCTmB/main.rs:1:171\n  |\n1 | ...ci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mu...\n  |                                                       ^^^^ expected `i64`, found `i32`\n\nerror[E0277]: cannot subtract `i32` from `i64`\n --> /tmp/.tmp2dCTmB/main.rs:1:169\n  |\n1 | ...ci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mu...\n  |                                                     ^ no implementation for `i64 - i32`\n  |\n  = help: the trait `Sub<i32>` is not implemented for `i64`\n  = help: the following other types implement trait `Sub<Rhs>`:\n            `&i64` implements `Sub<i64>`\n            `&i64` implements `Sub`\n            `i64` implements `Sub<&i64>`\n            `i64` implements `Sub`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp2dCTmB/main.rs:1:340\n  |\n1 | ...) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn b...\n  |         --- expected `i64` because of return type                                                                              ^ expected `i64`, found `i32`\n  |\nhelp: you can convert an `i32` to an `i64`\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a.into() } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                     +++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp2dCTmB/main.rs:1:456\n  |\n1 | ...ci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative...\n  |                                         -------------------  ^^^^^ expected `i64`, found `i32`\n  |                                         |\n  |                                         arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmp2dCTmB/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - ...\n  |                                        ^^^^^^^^^^^^^^^^^^^  -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i64)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found attribute macro `bench`\n --> /tmp/.tmp2dCTmB/main.rs:1:383\n  |\n1 | ...emp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i3...\n  |                                                             ^^^^^ not a function\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp2dCTmB/main.rs:1:578\n  |\n1 | ...ci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n  |                                         -------------------  ^^^^^ expected `i64`, found `i32`\n  |                                         |\n  |                                         arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmp2dCTmB/main.rs:1:188\n  |\n1 | ...- 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for...\n  |                                                        ^^^^^^^^^^^^^^^^^^^  -------\nhelp: change the type of the numeric literal from `i32` to `i64`\n  |\n1 - use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn fibonacci_recursive (n : i64) -> i64 { { if n <= 1i32 { { n } } else { { fibonacci_recursive (n - 1i32) + fibonacci_recursive (n - 2i32) } } } } fn fibonacci_iterative (n : i64) -> i64 { { let mut a = 0i32 ; let mut b = 1i32 ; for i in range (n) { { { let temp = a + b ; { a = b ; b = temp } } } } ; a } } fn bench_recursive_fib () -> i32 { { bench (\"fibonacci_recursive_20\" . to_string () , || fibonacci_recursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i64)) } } fn main () { }\n  |\n\nerror[E0423]: expected function, found attribute macro `bench`\n --> /tmp/.tmp2dCTmB/main.rs:1:505\n  |\n1 | ...ursive (20i32)) } } fn bench_iterative_fib () -> i32 { { bench (\"fibonacci_iterative_20\" . to_string () , || fibonacci_iterative (20i3...\n  |                                                             ^^^^^ not a function\n\nerror: aborting due to 11 previous errors; 7 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0423, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch07-00-building-applications": {
      "chapter": "ch07-00-building-applications",
      "total_examples": 9,
      "working_examples": 0,
      "failing_examples": 9,
      "examples": [
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 1,
          "line_number": 48,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: note_keeper.ruchy\n// A complete note-taking application\n\nlet APP_NAME = \"NoteKeeper\"\nlet VERSION = \"1.0.0\"\nlet NOTES_DIR = expand_home(\"~/.notes\")\nlet NOTES_INDEX = join_path(NOTES_DIR, \"index.json\")\n\n// Initialize application\nfun init_app() {\n    if !dir_exists(NOTES_DIR) {\n        create_dir_all(NOTES_DIR)\n        println(\"Created notes directory: \" + NOTES_DIR)\n    }\n    \n    if !file_exists(NOTES_INDEX) {\n        let initial_index = {\n            \"version\": VERSION,\n            \"notes\": [],\n            \"tags\": [],\n            \"last_modified\": current_datetime()\n        }\n        save_index(initial_index)\n    }\n}\n\nfun load_index() {\n    let content = read_file(NOTES_INDEX)\n    return parse_json(content)\n}\n\nfun save_index(index) {\n    index.last_modified = current_datetime()\n    let json = to_json_pretty(index)\n    write_file(NOTES_INDEX, json)\n}\n\nfun create_note() {\n    println(\"\\n📝 Create New Note\")\n    let title = input(\"Title: \")\n    let content = input_multiline(\"Content (end with empty line):\\n\")\n    let tags = input(\"Tags (comma-separated): \").split(\",\").map(|t| t.trim())\n    \n    let note_id = generate_id()\n    let note_file = join_path(NOTES_DIR, note_id + \".md\")\n    \n    let note = {\n        \"id\": note_id,\n        \"title\": title,\n        \"created\": current_datetime(),\n        \"modified\": current_datetime(),\n        \"tags\": tags,\n        \"file\": note_file\n    }\n    \n    // Save note content\n    let markdown = \"# \" + title + \"\\n\\nCreated: \" + note.created + \"\\nTags: \" + tags.join(\", \") + \"\\n\\n---\\n\\n\" + content\n    \n    write_file(note_file, markdown)\n    \n    // Update index\n    let index = load_index()\n    index.notes.push(note)\n    index.tags = index.tags.union(tags)\n    save_index(index)\n    \n    println(\"✅ Note created: \" + title)\n}\n\nfun list_notes(filter_tag = null) {\n    let index = load_index()\n    let notes = index.notes\n    \n    if filter_tag {\n        notes = notes.filter(|n| n.tags.contains(filter_tag))\n        println(f\"\\n📋 Notes tagged '{filter_tag}':\")\n    } else {\n        println(f\"\\n📋 All Notes ({notes.len()} total):\")\n    }\n    \n    if notes.is_empty() {\n        println(\"  No notes found\")\n        return\n    }\n    \n    for i, note in notes.enumerate() {\n        let age = time_ago(note.created)\n        println((i+1).to_s() + \". \" + note.title)\n        println(\"     Tags: \" + note.tags.join(\", \") + \" | Created: \" + age)\n    }\n}\n\nfun search_notes(query) {\n    let index = load_index()\n    let results = []\n    \n    for note in index.notes {\n        // Search in title\n        if note.title.lower().contains(query.lower()) {\n            results.push(note)\n            continue\n        }\n        \n        // Search in content\n        let content = read_file(note.file)\n        if content.lower().contains(query.lower()) {\n            results.push(note)\n        }\n    }\n    \n    println(f\"\\n🔍 Search results for '{query}': {results.len()} matches\")\n    \n    for note in results {\n        println(\"  • \" + note.title)\n        \n        // Show context\n        let content = read_file(note.file)\n        let lines = content.lines()\n        for line in lines {\n            if line.lower().contains(query.lower()) {\n                println(f\"    ...{line.trim()}...\")\n                break\n            }\n        }\n    }\n}\n\nfun view_note(index_num) {\n    let index = load_index()\n    \n    if index_num < 1 || index_num > index.notes.len() {\n        println(\"❌ Invalid note number\")\n        return\n    }\n    \n    let note = index.notes[index_num - 1]\n    let content = read_file(note.file)\n    \n    println(\"\\n\" + \"=\"*50)\n    println(content)\n    println(\"=\"*50)\n}\n\nfun export_notes(format) {\n    let index = load_index()\n    let export_file = \"notes_export_\" + current_date() + \".\" + format\n    \n    match format {\n        \"json\" => {\n            let data = {\n                \"exported\": current_datetime(),\n                \"notes\": []\n            }\n            \n            for note in index.notes {\n                let content = read_file(note.file)\n                data.notes.push({\n                    \"title\": note.title,\n                    \"content\": content,\n                    \"tags\": note.tags,\n                    \"created\": note.created\n                })\n            }\n            \n            write_file(export_file, to_json_pretty(data))\n        }\n        \"markdown\" => {\n            let markdown = f\"# My Notes\nExported: {current_datetime()}\n\n\"\n            for note in index.notes {\n                let content = read_file(note.file)\n                markdown += f\"\n\n---\n\n{content}\n\"\n            }\n            \n            write_file(export_file, markdown)\n        }\n        _ => {\n            println(\"❌ Unsupported format: \" + format)\n            return\n        }\n    }\n    \n    println(\"✅ Exported \" + index.notes.len().to_s() + \" notes to \" + export_file)\n}\n\nfun show_menu() {\n    println(f\"\\n=== {APP_NAME} v{VERSION} ===\")\n    println(\"1. Create note\")\n    println(\"2. List all notes\")\n    println(\"3. Search notes\")\n    println(\"4. View note\")\n    println(\"5. List by tag\")\n    println(\"6. Export notes\")\n    println(\"7. Statistics\")\n    println(\"8. Quit\")\n}\n\nfun show_statistics() {\n    let index = load_index()\n    let total_notes = index.notes.len()\n    let total_tags = index.tags.len()\n    \n    // Calculate word count\n    let total_words = 0\n    for note in index.notes {\n        let content = read_file(note.file)\n        total_words += content.split_whitespace().len()\n    }\n    \n    // Find most used tags\n    let tag_counts = {}\n    for note in index.notes {\n        for tag in note.tags {\n            tag_counts[tag] = tag_counts.get(tag, 0) + 1\n        }\n    }\n    \n    println(f\"\\n📊 NoteKeeper Statistics\")\n    println(\"Total notes: \" + total_notes.to_s())\n    println(\"Total words: \" + total_words.to_s())\n    println(\"Average words per note: \" + (total_words / max(total_notes, 1)).to_s())\n    println(\"Unique tags: \" + total_tags.to_s())\n    \n    if !tag_counts.is_empty() {\n        println(\"\\nTop tags:\")\n        let sorted_tags = tag_counts.items().sort_by(|item| -item.value)\n        for tag, count in sorted_tags[..min(5, sorted_tags.len())] {\n            println(f\"  • {tag}: {count} notes\")\n        }\n    }\n}\n\n// Main application loop\nfun main() {\n    init_app()\n    \n    println(f\"Welcome to {APP_NAME}!\")\n    println(\"Your personal note-taking assistant\")\n    \n    loop {\n        show_menu()\n        let choice = input(\"\\nChoice: \")\n        \n        match choice {\n            \"1\" => create_note()\n            \"2\" => list_notes()\n            \"3\" => {\n                let query = input(\"Search for: \")\n                search_notes(query)\n            }\n            \"4\" => {\n                list_notes()\n                let num = input(\"\\nNote number to view: \").to_i()\n                view_note(num)\n            }\n            \"5\" => {\n                let index = load_index()\n                println(\"\\nAvailable tags:\")\n                for tag in index.tags {\n                    println(\"  • \" + tag)\n                }\n                let tag = input(\"\\nFilter by tag: \")\n                list_notes(tag)\n            }\n            \"6\" => {\n                let format = input(\"Export format (json/markdown): \")\n                export_notes(format)\n            }\n            \"7\" => show_statistics()\n            \"8\" => {\n                println(\"👋 Thanks for using NoteKeeper!\")\n                break\n            }\n            _ => println(\"❌ Invalid choice\")\n        }\n    }\n}\n\n// Run the application\nmain()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 2,
          "line_number": 354,
          "code": "// Status: ❌ BROKEN\n\n// Application structure\nlet APP = {\n    \"name\": \"MyApp\",\n    \"version\": \"1.0.0\",\n    \"config_dir\": \"~/.config/myapp\",\n    \"data_dir\": \"~/.local/share/myapp\",\n    \"cache_dir\": \"~/.cache/myapp\"\n}\n\n// Separate concerns into modules\n// models.ruchy - Data structures\nlet User = {\n    \"id\": null,\n    \"name\": \"\",\n    \"email\": \"\",\n    \"created\": null\n}\n\n// services.ruchy - Business logic\nfun create_user(name, email) {\n    let user = User.copy()\n    user.id = generate_uuid()\n    user.name = name\n    user.email = email\n    user.created = current_datetime()\n    return user\n}\n\n// ui.ruchy - User interface\nfun display_user(user) {\n    println(f\"User: {user.name} ({user.email})\")\n    println(\"Member since: \" + user.created)\n}\n\n// main.ruchy - Application entry point\nfun main() {\n    init_app()\n    load_config()\n    run_event_loop()\n    cleanup()\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `User` in this scope\n --> /tmp/.tmpisYQoV/main.rs:1:109\n  |\n1 | ...e : String , email : String) -> i32 { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . ema...\n  |                                                         ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `null` in this scope\n --> /tmp/.tmpisYQoV/main.rs:1:1125\n  |\n1 | ...Map :: new () ; map . insert (\"id\" . to_string () , (null) . to_string ()) ; map . insert (\"name\" . to_string () , (\"\") . to_string ()...\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::ptr::null;\n  |\n\nerror[E0425]: cannot find value `null` in this scope\n --> /tmp/.tmpisYQoV/main.rs:1:1314\n  |\n1 | ...ring ()) ; map . insert (\"created\" . to_string () , (null) . to_string ()) ; map } ; { init_app () ; load_config () ; run_event_loop (...\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::ptr::null;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpisYQoV/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn create_user (name : String , email : String) -> i32 { { { let user = User . copy () ; { user . id ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpisYQoV/main.rs:1:94\n  |\n1 | ... { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } ...\n  |       ^^                                                                                                                                                                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn create_user (name : String , email : String) -> i32 { { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user (user : String) { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Member since: \" , user . created)) } } fn main () { let mut APP = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"name\" . to_string () , (\"MyApp\") . to_string ()) ; map . insert (\"version\" . to_string () , (\"1.0.0\") . to_string ()) ; map . insert (\"config_dir\" . to_string () , (\"~/.config/myapp\") . to_string ()) ; map . insert (\"data_dir\" . to_string () , (\"~/.local/share/myapp\") . to_string ()) ; map . insert (\"cache_dir\" . to_string () , (\"~/.cache/myapp\") . to_string ()) ; map } ; let mut User = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"id\" . to_string () , (null) . to_string ()) ; map . insert (\"name\" . to_string () , (\"\") . to_string ()) ; map . insert (\"email\" . to_string () , (\"\") . to_string ()) ; map . insert (\"created\" . to_string () , (null) . to_string ()) ; map } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n1 + use std :: collections :: HashMap ; fn create_user (name : String , email : String) -> i32 { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = current_datetime () ; return user } } } fn display_user (user : String) { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Member since: \" , user . created)) } } fn main () { let mut APP = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"name\" . to_string () , (\"MyApp\") . to_string ()) ; map . insert (\"version\" . to_string () , (\"1.0.0\") . to_string ()) ; map . insert (\"config_dir\" . to_string () , (\"~/.config/myapp\") . to_string ()) ; map . insert (\"data_dir\" . to_string () , (\"~/.local/share/myapp\") . to_string ()) ; map . insert (\"cache_dir\" . to_string () , (\"~/.cache/myapp\") . to_string ()) ; map } ; let mut User = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"id\" . to_string () , (null) . to_string ()) ; map . insert (\"name\" . to_string () , (\"\") . to_string ()) ; map . insert (\"email\" . to_string () , (\"\") . to_string ()) ; map . insert (\"created\" . to_string () , (null) . to_string ()) ; map } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |\n\nerror[E0425]: cannot find function `generate_uuid` in this scope\n --> /tmp/.tmpisYQoV/main.rs:1:140\n  |\n1 | ...{ { { let user = User . copy () ; { user . id = generate_uuid () ; user . name = name ; user . email = email ; user . created = curren...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `current_datetime` in this scope\n --> /tmp/.tmpisYQoV/main.rs:1:220\n  |\n1 | ...name ; user . email = email ; user . created = current_datetime () ; return user } } } } fn display_user (user : String) { { println !...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0609]: no field `name` on type `String`\n --> /tmp/.tmpisYQoV/main.rs:1:334\n  |\n1 | ...r (user : String) { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Member since:...\n  |                                                              ^^^^ unknown field\n\nerror[E0609]: no field `email` on type `String`\n --> /tmp/.tmpisYQoV/main.rs:1:348\n  |\n1 | ...g) { { println ! (\"User: {} ({})\" , user . name , user . email) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Member since: \" , user . cre...\n  |                                                             ^^^^^ unknown field\n\nerror[E0609]: no field `created` on type `String`\n --> /tmp/.tmpisYQoV/main.rs:1:422\n  |\n1 | ... (\"{:?}\" , format ! (\"{}{}\" , \"Member since: \" , user . created)) } } fn main () { let mut APP = { let mut map : std :: collections ::...\n  |                                                            ^^^^^^^ unknown field\n\nerror[E0425]: cannot find function `init_app` in this scope\n --> /tmp/.tmpisYQoV/main.rs:1:1348\n  |\n1 | ... to_string () , (null) . to_string ()) ; map } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `load_config` in this scope\n --> /tmp/.tmpisYQoV/main.rs:1:1362\n  |\n1 | ...(null) . to_string ()) ; map } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `run_event_loop` in this scope\n --> /tmp/.tmpisYQoV/main.rs:1:1379\n  |\n1 | ... ()) ; map } ; { init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `cleanup` in this scope\n --> /tmp/.tmpisYQoV/main.rs:1:1399\n  |\n1 | ...init_app () ; load_config () ; run_event_loop () ; cleanup () } }\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 12 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0425, E0609.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 3,
          "line_number": 412,
          "code": "// Status: ❌ BROKEN\n\n// Global application state\nlet STATE = {\n    \"users\": [],\n    \"current_user\": null,\n    \"settings\": {},\n    \"cache\": {},\n    \"dirty\": false\n}\n\nfun update_state(key, value) {\n    STATE[key] = value\n    STATE.dirty = true\n    trigger_save()\n}\n\nfun save_state() {\n    if STATE.dirty {\n        let state_file = join_path(APP.data_dir, \"state.json\")\n        write_file(state_file, to_json(STATE))\n        STATE.dirty = false\n    }\n}\n\nfun load_state() {\n    let state_file = join_path(APP.data_dir, \"state.json\")\n    if file_exists(state_file) {\n        STATE = parse_json(read_file(state_file))\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpNUsUm2/main.rs:1:96\n  |\n1 | use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dir...\n  |                                                                                                ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpNUsUm2/main.rs:1:127\n  |\n1 | ...: String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpNUsUm2/main.rs:1:201\n  |\n1 | ... trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP` in this scope\n --> /tmp/.tmpNUsUm2/main.rs:1:249\n  |\n1 | ...{ if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_jso...\n  |                                                         ^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpNUsUm2/main.rs:1:333\n  |\n1 | ...to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { { let stat...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpNUsUm2/main.rs:1:343\n  |\n1 | ...()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { { let state_file = j...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP` in this scope\n --> /tmp/.tmpNUsUm2/main.rs:1:435\n  |\n1 | ...ad_state () -> i32 { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { S...\n  |                                                         ^^^ not found in this scope\n\nerror[E0425]: cannot find value `STATE` in this scope\n --> /tmp/.tmpNUsUm2/main.rs:1:515\n  |\n1 | ...\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE =...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `null` in this scope\n --> /tmp/.tmpNUsUm2/main.rs:1:823\n  |\n1 | ...()) ; map . insert (\"current_user\" . to_string () , (null) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_strin...\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::ptr::null;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpNUsUm2/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dir...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpNUsUm2/main.rs:1:196\n  |\n1 | ... { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } ...\n  |       ^^                                                                                                                                                                              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"users\" . to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (null) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; }\n1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () -> i32 { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"users\" . to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (null) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpNUsUm2/main.rs:1:217\n  |\n1 | ... { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } ...\n  |       ^^                                                                                                                                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"users\" . to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (null) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; }\n1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } fn load_state () -> i32 { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"users\" . to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (null) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpNUsUm2/main.rs:1:403\n  |\n1 | ... { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } ...\n  |       ^^                                                                                                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"users\" . to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (null) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; }\n1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } fn main () { let mut STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"users\" . to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (null) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpNUsUm2/main.rs:1:513\n  |\n1 | ...string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let ...\n  |                                               ^^                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"users\" . to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (null) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; }\n1 + use std :: collections :: HashMap ; fn update_state (key : String , value : String) -> i32 { { STATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { STATE = parse_json (read_file (state_file)) } } } } fn main () { let mut STATE = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"users\" . to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (null) . to_string ()) ; map . insert (\"settings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; }\n  |\n\nerror[E0425]: cannot find function `trigger_save` in this scope\n --> /tmp/.tmpNUsUm2/main.rs:1:150\n  |\n1 | ... [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_file...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0605]: non-primitive cast: `String` as `usize`\n --> /tmp/.tmpNUsUm2/main.rs:1:103\n  |\n1 | ...ATE [key as usize] = value ; STATE . dirty = true ; trigger_save () } } fn save_state () -> i32 { { if STATE . dirty { { { let state_f...\n  |         ^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpNUsUm2/main.rs:1:238\n  |\n1 | ...> i32 { { if STATE . dirty { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; { write_file (state_file ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_json` in this scope\n --> /tmp/.tmpNUsUm2/main.rs:1:324\n  |\n1 | ...json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { { { ...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpNUsUm2/main.rs:1:299\n  |\n1 | ...ate.json\" . to_string ()) ; { write_file (state_file , to_json (STATE)) ; STATE . dirty = false } } } } } } fn load_state () -> i32 { ...\n  |                                  ^^^^^^^^^^ help: a local variable with a similar name exists: `state_file`\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmpNUsUm2/main.rs:1:424\n  |\n1 | ... } fn load_state () -> i32 { { { let state_file = join_path (APP . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_fil...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpNUsUm2/main.rs:1:486\n  |\n1 | ...P . data_dir , \"state.json\" . to_string ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpNUsUm2/main.rs:1:535\n  |\n1 | ... file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let mut map : std :...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `parse_json` in this scope\n --> /tmp/.tmpNUsUm2/main.rs:1:523\n  |\n1 | ...ing ()) ; if file_exists (state_file) { { STATE = parse_json (read_file (state_file)) } } } } } fn main () { let mut STATE = { let mut...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0599]: the method `to_string` exists for struct `Vec<_>`, but its trait bounds were not satisfied\n   --> /tmp/.tmpNUsUm2/main.rs:1:760\n    |\n1   | ...to_string () , (vec ! []) . to_string ()) ; map . insert (\"current_user\" . to_string () , (null) . to_string ()) ; map . insert (\"sett...\n    |                                ^^^^^^^^^ method cannot be called on `Vec<_>` due to unsatisfied trait bounds\n    |\n   ::: /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1\n    |\n414 | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<_>: ToString` or `Vec<_>: std::fmt::Display`\n    |\n    = note: the following trait bounds were not satisfied:\n            `Vec<_>: std::fmt::Display`\n            which is required by `Vec<_>: ToString`\n            `[_]: std::fmt::Display`\n            which is required by `[_]: ToString`\n\nerror[E0599]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpNUsUm2/main.rs:1:896\n  |\n1 | ...ings\" . to_string () , (()) . to_string ()) ; map . insert (\"cache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to...\n  |                                  ^^^^^^^^^ method cannot be called on `()` due to unsatisfied trait bounds\n  |\n  = note: the following trait bounds were not satisfied:\n          `(): std::fmt::Display`\n          which is required by `(): ToString`\n\nerror[E0599]: `()` doesn't implement `std::fmt::Display`\n --> /tmp/.tmpNUsUm2/main.rs:1:958\n  |\n1 | ...ache\" . to_string () , (()) . to_string ()) ; map . insert (\"dirty\" . to_string () , (false) . to_string ()) ; map } ; }\n  |                                  ^^^^^^^^^ method cannot be called on `()` due to unsatisfied trait bounds\n  |\n  = note: the following trait bounds were not satisfied:\n          `(): std::fmt::Display`\n          which is required by `(): ToString`\n\nerror: aborting due to 21 previous errors; 5 warnings emitted\n\nSome errors have detailed explanations: E0425, E0599, E0605.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 4,
          "line_number": 458,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\nfun safe_operation(operation_fn, fallback_value) {\n    try {\n        return operation_fn()\n    } catch error {\n        log_error(error)\n        return fallback_value\n    }\n}\n\nfun with_retry(operation_fn, max_attempts = 3) {\n    for attempt in range(max_attempts) {\n        try {\n            return operation_fn()\n        } catch error {\n            if attempt == max_attempts - 1 {\n                println(\"❌ Failed after \" + max_attempts.to_s() + \" attempts: \" + error.to_s())\n                throw error\n            }\n            \n            let wait_time = 2 ** attempt  // Exponential backoff\n            println(f\"⚠️  Attempt {attempt + 1} failed, retrying in {wait_time}s...\")\n            sleep(wait_time * 1000)\n        }\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0423]: expected value, found macro `try`\n --> /tmp/.tmpbFSOMB/main.rs:1:116\n  |\n1 | use std :: collections :: HashMap ; fn safe_operation (operation_fn : String , fallback_value : String) -> i32 { { r#try ; { return opera...\n  |                                                                                                                    ^^^^^ not a value\n\nerror[E0425]: cannot find value `catch` in this scope\n --> /tmp/.tmpbFSOMB/main.rs:1:153\n  |\n1 | ...ng) -> i32 { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry (o...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpbFSOMB/main.rs:1:161\n  |\n1 | ...32 { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry (operation...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpbFSOMB/main.rs:1:182\n  |\n1 | ...rn operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry (operation_fn : String , max_at...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `range` in this scope\n --> /tmp/.tmpbFSOMB/main.rs:1:307\n  |\n1 | ... , max_attempts : String) -> i32 { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::slice::range;\n  |\n\nerror[E0423]: expected value, found macro `try`\n --> /tmp/.tmpbFSOMB/main.rs:1:332\n  |\n1 | ...tring) -> i32 { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_att...\n  |                                                              ^^^^^ not a value\n\nerror[E0425]: cannot find value `catch` in this scope\n --> /tmp/.tmpbFSOMB/main.rs:1:369\n  |\n1 | ..._attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{:?}\" , format...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpbFSOMB/main.rs:1:377\n  |\n1 | ...s) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{:?}\" , format ! (\"{}{...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpbFSOMB/main.rs:1:546\n  |\n1 | ...fter \" , max_attempts . to_s ()) , \" attempts: \") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; ...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpbFSOMB/main.rs:1:574\n  |\n1 | ... ()) , \" attempts: \") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Att...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `sleep` in this scope\n --> /tmp/.tmpbFSOMB/main.rs:1:724\n  |\n1 | ...retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::sleep;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpbFSOMB/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn safe_operation (operation_fn : String , fallback_value : String) -> i32 { { r#try ; { return opera...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpbFSOMB/main.rs:1:290\n  |\n1 | ... { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Failed after \" , max_attempts . to_s ()) , \" attempts: \") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } f...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn safe_operation (operation_fn : String , fallback_value : String) -> i32 { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry (operation_fn : String , max_attempts : String) -> i32 { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Failed after \" , max_attempts . to_s ()) , \" attempts: \") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn safe_operation (operation_fn : String , fallback_value : String) -> i32 { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry (operation_fn : String , max_attempts : String) -> i32 { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Failed after \" , max_attempts . to_s ()) , \" attempts: \") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } fn main () { }\n  |\n\nerror[E0618]: expected function, found `String`\n --> /tmp/.tmpbFSOMB/main.rs:1:133\n  |\n1 | ...on (operation_fn : String , fallback_value : String) -> i32 { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (erro...\n  |        ------------                                                                 ^^^^^^^^^^^^---\n  |        |                                                                            |\n  |        `operation_fn` has type `String`                                             call expression requires function\n\nwarning: unreachable statement\n --> /tmp/.tmpbFSOMB/main.rs:1:153\n  |\n1 | ...: String) -> i32 { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_re...\n  |                                   ----------------------     ^^^^^^^ unreachable statement\n  |                                   |\n  |                                   any code following this expression is unreachable\n  |\n  = note: `#[warn(unreachable_code)]` on by default\n\nerror[E0425]: cannot find function `log_error` in this scope\n --> /tmp/.tmpbFSOMB/main.rs:1:171\n  |\n1 | ... ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry (operation_fn : String...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0618]: expected function, found `String`\n --> /tmp/.tmpbFSOMB/main.rs:1:349\n  |\n1 | ...y (operation_fn : String , max_attempts : String) -> i32 { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ...\n  |       ------------                                                                                                       ^^^^^^^^^^^^---\n  |       |                                                                                                                  |\n  |       `operation_fn` has type `String`                                                                                   call expression requires function\n\nwarning: unreachable statement\n --> /tmp/.tmpbFSOMB/main.rs:1:369\n  |\n1 | ...e (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{:?}\" , ...\n  |                                   ----------------------     ^^^^^^^ unreachable statement\n  |                                   |\n  |                                   any code following this expression is unreachable\n\nerror[E0369]: cannot subtract `i32` from `String`\n   --> /tmp/.tmpbFSOMB/main.rs:1:414\n    |\n1   | ...rn operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\"...\n    |                                                           ------------ ^ ---- i32\n    |                                                           |\n    |                                                           String\n    |\nnote: the foreign item type `String` doesn't implement `Sub<i32>`\n   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:360:1\n    |\n360 | pub struct String {\n    | ^^^^^^^^^^^^^^^^^ not implement `Sub<i32>`\n\nerror[E0599]: no method named `to_s` found for struct `String` in the current scope\n --> /tmp/.tmpbFSOMB/main.rs:1:518\n  |\n1 | ...at ! (\"{}{}\" , \"❌ Failed after \" , max_attempts . to_s ()) , \" attempts: \") + error . to_s ()) ; panic ! (error) } } ; { let wait_time ...\n  |                                                       ^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpbFSOMB/main.rs:1:704\n  |\n1 | ...Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }\n  |                                                       ^^^^ expected `u32`, found `i32`\n\nerror[E0277]: cannot add `i32` to `u32`\n --> /tmp/.tmpbFSOMB/main.rs:1:702\n  |\n1 | ...Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } } fn main () { }\n  |                                                     ^ no implementation for `u32 + i32`\n  |\n  = help: the trait `Add<i32>` is not implemented for `u32`\n  = help: the following other types implement trait `Add<Rhs>`:\n            `&u32` implements `Add<u32>`\n            `&u32` implements `Add`\n            `u32` implements `Add<&u32>`\n            `u32` implements `Add`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpbFSOMB/main.rs:1:292\n  |\n1 | ...-> i32 { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Failed after \" , max_attempts . to_s ()) , \" attempts: \") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } } }...\n  |       ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |       |\n  |       expected `i32` because of return type\n  |\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn safe_operation (operation_fn : String , fallback_value : String) -> i32 { { r#try ; { return operation_fn () } ; catch ; error ; { log_error (error) ; return fallback_value } } } fn with_retry (operation_fn : String , max_attempts : String) -> i32 { { for attempt in range (max_attempts) { { r#try ; { return operation_fn () } ; catch ; error ; { if attempt == max_attempts - 1i32 { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Failed after \" , max_attempts . to_s ()) , \" attempts: \") + error . to_s ()) ; panic ! (error) } } ; { let wait_time = 2i32 . pow (attempt) ; { println ! (\"⚠\\u{fe0f}  Attempt {} failed, retrying in {}s...\" , attempt + 1i32 , wait_time) ; sleep (wait_time * 1000i32) } } } } } /* `i32` value */ } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           +++++++++++++++++\n\nerror: aborting due to 19 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0423, E0425, E0599, E0618.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 5,
          "line_number": 500,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n// Error: ✗ Compilation failed: Compilation failed:\n// Simple password manager with encryption\nlet MASTER_KEY = null\nlet PASSWORDS_FILE = \"~/.passwords.enc\"\n\nfun encrypt(text, key) {\n    // Simple XOR encryption (use real encryption in production!)\n    let encrypted = []\n    for i, char in text.chars().enumerate() {\n        let key_char = key[i % key.len()]\n        encrypted.push(char.code() ^ key_char.code())\n    }\n    return base64_encode(encrypted)\n}\n\nfun decrypt(encrypted, key) {\n    let bytes = base64_decode(encrypted)\n    let decrypted = []\n    for i, byte in bytes.enumerate() {\n        let key_char = key[i % key.len()]\n        decrypted.push(char_from_code(byte ^ key_char.code()))\n    }\n    return decrypted.join(\"\")\n}\n\nfun add_password(site, username, password) {\n    let passwords = load_passwords()\n    passwords[site] = {\n        \"username\": username,\n        \"password\": encrypt(password, MASTER_KEY),\n        \"created\": current_datetime()\n    }\n    save_passwords(passwords)\n}\n\nfun get_password(site) {\n    let passwords = load_passwords()\n    if passwords.has_key(site) {\n        let entry = passwords[site]\n        let password = decrypt(entry.password, MASTER_KEY)\n        copy_to_clipboard(password)\n        println(\"✅ Password copied to clipboard!\")\n        \n        // Clear clipboard after 30 seconds\n        spawn_after(30000, || clear_clipboard())\n    } else {\n        println(\"❌ No password found for \" + site)\n    }\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `MASTER_KEY` in this scope\n --> /tmp/.tmpStodPQ/main.rs:1:1055\n  |\n1 | ...(\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_dat...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `MASTER_KEY` in this scope\n --> /tmp/.tmpStodPQ/main.rs:1:1416\n  |\n1 | ... { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboa...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `null` in this scope\n --> /tmp/.tmpStodPQ/main.rs:1:1692\n  |\n1 | ..., site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; }\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::ptr::null;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpStodPQ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpStodPQ/main.rs:1:88\n  |\n1 | ... { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } ...\n  |       ^^                                                                                                                                                                                                                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; }\n1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpStodPQ/main.rs:1:172\n  |\n1 | ...erate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return ...\n  |               ^^                                                                                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; }\n1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpStodPQ/main.rs:1:382\n  |\n1 | ... { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; }\n1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpStodPQ/main.rs:1:500\n  |\n1 | ...te () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; ret...\n  |            ^^                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; }\n1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } ; return decrypted . join (\"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpStodPQ/main.rs:1:741\n  |\n1 | ... { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; }\n1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpStodPQ/main.rs:1:1251\n  |\n1 | ... { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; }\n1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpStodPQ/main.rs:1:1323\n  |\n1 | ... { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } e...\n  |       ^^                                                                                                                                                                                                                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; }\n1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpStodPQ/main.rs:1:1571\n  |\n1 | ...lipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut...\n  |                                ^^                                                                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; }\n1 + use std :: collections :: HashMap ; fn encrypt (text : String , key : String) -> i32 { { { let encrypted = vec ! [] ; { for (i , char) in text . chars () . enumerate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes . enumerate () { { { let key_char = key [i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } } } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords () ; if passwords . has_key (site) { { { let entry = passwords [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } fn main () { let mut MASTER_KEY = null ; let mut PASSWORDS_FILE = \"~/.passwords.enc\" . to_string () ; }\n  |\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmpStodPQ/main.rs:1:196\n  |\n1 | ...merate () { { { let key_char = key [i % key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return...\n  |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0599]: no method named `code` found for type `char` in the current scope\n --> /tmp/.tmpStodPQ/main.rs:1:250\n  |\n1 | ... key . len () as usize] ; encrypted . push (char . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn d...\n  |                                                       ^^^^ method not found in `char`\n\nerror[E0425]: cannot find function `base64_encode` in this scope\n --> /tmp/.tmpStodPQ/main.rs:1:295\n  |\n1 | ... . code () ^ key_char . code ()) } } } ; return base64_encode (encrypted) } } } } fn decrypt (encrypted : i32 , key : String) -> i32 {...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `base64_decode` in this scope\n --> /tmp/.tmpStodPQ/main.rs:1:398\n  |\n1 | ... : i32 , key : String) -> i32 { { { let bytes = base64_decode (encrypted) ; { let mut decrypted = vec ! [] ; for (i , byte) in bytes ....\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `char_from_code` in this scope\n --> /tmp/.tmpStodPQ/main.rs:1:571\n  |\n1 | ...[i % key . len () as usize] ; decrypted . push (char_from_code (byte ^ key_char . code ())) } } } ; return decrypted . join (\"\") } } }...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `load_passwords` in this scope\n --> /tmp/.tmpStodPQ/main.rs:1:761\n  |\n1 | ...password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `current_datetime` in this scope\n --> /tmp/.tmpStodPQ/main.rs:1:1128\n  |\n1 | ...)) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn ge...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `save_passwords` in this scope\n --> /tmp/.tmpStodPQ/main.rs:1:1175\n  |\n1 | ...(current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let pa...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0605]: non-primitive cast: `String` as `usize`\n --> /tmp/.tmpStodPQ/main.rs:1:794\n  |\n1 | ...rds [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; ma...\n  |         ^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0425]: cannot find function `load_passwords` in this scope\n --> /tmp/.tmpStodPQ/main.rs:1:1271\n  |\n1 | ... } fn add_password (site : String , username : String , password : String) -> i32 { { { let passwords = load_passwords () ; { passwords [site as usize] = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"username\" . to_string () , (username) . to_string ()) ; map . insert (\"password\" . to_string () , (encrypt (password , MASTER_KEY)) . to_string ()) ; map . insert (\"created\" . to_string () , (current_datetime ()) . to_string ()) ; map } ; save_passwords (passwords) } } } } fn get_password (site : String) -> i32 { { { let passwords = load_passwords ()...\n  |       ------------------------------------------------------------------------------ similarly named function `add_password` defined here                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_password`\n\nerror[E0425]: cannot find function `copy_to_clipboard` in this scope\n --> /tmp/.tmpStodPQ/main.rs:1:1430\n  |\n1 | ...d = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Password copied to clipboard!\") ; spawn_afte...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `clear_clipboard` in this scope\n --> /tmp/.tmpStodPQ/main.rs:1:1536\n  |\n1 | ...d to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No passwo...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `spawn_after` in this scope\n --> /tmp/.tmpStodPQ/main.rs:1:1509\n  |\n1 | ... println ! (\"✅ Password copied to clipboard!\") ; spawn_after (30000i32 , || clear_clipboard ()) } } } } else { { println ! (\"{:?}\" , fo...\n  |                                                      ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpStodPQ/main.rs:1:1573\n  |\n1 | ... } } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ No password found for \" , site)) } } } } } fn main () { let mut MASTER_KEY = ...\n  |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0605]: non-primitive cast: `String` as `usize`\n --> /tmp/.tmpStodPQ/main.rs:1:1350\n  |\n1 | ...rds [site as usize] ; { let mut password = decrypt (entry . password , MASTER_KEY) ; copy_to_clipboard (password) ; println ! (\"✅ Passw...\n  |         ^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror: aborting due to 18 previous errors; 9 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0599, E0605.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: code()"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 6,
          "line_number": 561,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n// Error: ✗ Compilation failed: Compilation failed:\n// Personal finance tracker\nlet TRANSACTIONS_FILE = \"~/.budget/transactions.csv\"\nlet CATEGORIES = [\"Food\", \"Transport\", \"Bills\", \"Entertainment\", \"Other\"]\n\nfun add_transaction(amount, category, description) {\n    let transaction = {\n        \"date\": current_date(),\n        \"amount\": amount,\n        \"category\": category,\n        \"description\": description\n    }\n    \n    append_csv(TRANSACTIONS_FILE, transaction)\n    \n    // Check budget alerts\n    let monthly_spent = get_monthly_total(category)\n    let budget_limit = get_budget_limit(category)\n    \n    if monthly_spent > budget_limit {\n        send_notification(f\"⚠️ Over budget for {category}!\")\n        println(\"Warning: \" + category + \" spending at $\" + monthly_spent.to_s() + \"/$\" + budget_limit.to_s())\n    }\n}\n\nfun generate_report(month) {\n    let transactions = load_transactions(month)\n    let by_category = group_by(transactions, \"category\")\n    \n    println(\"\\n📊 Budget Report for \" + month)\n    println(\"=\"*40)\n    \n    let total = 0\n    for category, items in by_category.items() {\n        let category_total = items.map(|t| t.amount).sum()\n        total += category_total\n        \n        let bar = \"█\" * (category_total / 50).to_i()\n        println(category + \" $\" + category_total.to_s() + \" \" + bar)\n    }\n    \n    println(\"=\"*40)\n    println(\"Total:          $\" + total.to_s())\n    \n    // Save report\n    let report_file = f\"budget_report_{month}.pdf\"\n    generate_pdf(report_file, report_data)\n    println(\"\\n📄 Report saved to \" + report_file)\n}",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `TRANSACTIONS_FILE` in this scope\n --> /tmp/.tmprVsgtJ/main.rs:1:566\n  |\n1 | ...tion) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `report_data` in this scope\n --> /tmp/.tmprVsgtJ/main.rs:1:1894\n  |\n1 | ...t_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmprVsgtJ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { { let transac...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmprVsgtJ/main.rs:1:123\n  |\n1 | ... { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) . to_string ()) ; map . insert (\"category\" . to_string () , (category) . to_string ()) ; map . insert (\"description\" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) . to_string ()) ; map . insert (\"category\" . to_string () , (category) . to_string ()) ; map . insert (\"description\" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } } fn generate_report (month : i32) -> i32 { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{:?}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . iter () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" . to_string () ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n1 + use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) . to_string ()) ; map . insert (\"category\" . to_string () , (category) . to_string ()) ; map . insert (\"description\" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } fn generate_report (month : i32) -> i32 { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{:?}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . iter () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" . to_string () ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmprVsgtJ/main.rs:1:1056\n  |\n1 | ... { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{:?}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . iter () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) . to_string ()) ; map . insert (\"category\" . to_string () , (category) . to_string ()) ; map . insert (\"description\" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } } fn generate_report (month : i32) -> i32 { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{:?}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . iter () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" . to_string () ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n1 + use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) . to_string ()) ; map . insert (\"category\" . to_string () , (category) . to_string ()) ; map . insert (\"description\" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } } fn generate_report (month : i32) -> i32 { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{:?}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . iter () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } fn main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" . to_string () ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmprVsgtJ/main.rs:1:1369\n  |\n1 | ... { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) . to_string ()) ; map . insert (\"category\" . to_string () , (category) . to_string ()) ; map . insert (\"description\" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } } fn generate_report (month : i32) -> i32 { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{:?}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . iter () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" . to_string () ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n1 + use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) . to_string ()) ; map . insert (\"category\" . to_string () , (category) . to_string ()) ; map . insert (\"description\" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } } fn generate_report (month : i32) -> i32 { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{:?}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . iter () { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + bar) } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" . to_string () ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n  |\n\nerror[E0425]: cannot find function `current_date` in this scope\n --> /tmp/.tmprVsgtJ/main.rs:1:294\n  |\n1 | ... new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) ....\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `append_csv` in this scope\n --> /tmp/.tmprVsgtJ/main.rs:1:554\n  |\n1 | ...ng () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_t...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `get_monthly_total` in this scope\n --> /tmp/.tmprVsgtJ/main.rs:1:625\n  |\n1 | ...FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if m...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `get_budget_limit` in this scope\n --> /tmp/.tmprVsgtJ/main.rs:1:679\n  |\n1 | ...thly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (fo...\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `send_notification` in this scope\n --> /tmp/.tmprVsgtJ/main.rs:1:745\n  |\n1 | ...tegory) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"...\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmprVsgtJ/main.rs:1:821\n  |\n1 | ... ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } ...\n  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `load_transactions` in this scope\n --> /tmp/.tmprVsgtJ/main.rs:1:1079\n  |\n1 | ... ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) . to_string ()) ; map . insert (\"category\" . to_string () , (category) . to_string ()) ; map . insert (\"description\" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } } fn generate_report (month : i32) -> i32 { { { let transactions = load_transactions (m...\n  |       ----------------------------------------------------------------------------------- similarly named function `add_transaction` defined here                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^^^^^^^^^^^^^^^^ help: a function with a similar name exists: `add_transaction`\n\nerror[E0425]: cannot find function `group_by` in this scope\n --> /tmp/.tmprVsgtJ/main.rs:1:1131\n  |\n1 | ...oad_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{:?}\" , format ! ...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot multiply `&str` by `i32`\n --> /tmp/.tmprVsgtJ/main.rs:1:1285\n  |\n1 | ..., \"\\n📊 Budget Report for \" , month)) ; println ! (\"{:?}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category ...\n  |                                                                --- ^ ----- i32\n  |                                                                |\n  |                                                                &str\n\nerror[E0599]: no method named `to_i` found for type `i32` in the current scope\n --> /tmp/.tmprVsgtJ/main.rs:1:1548\n  |\n1 | ...otal ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmprVsgtJ/main.rs:1:1507\n  |\n1 | ... sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , fo...\n  |                                              ^^^^^^^ doesn't have a size known at compile-time\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: all local variables must have a statically known size\n\nerror[E0308]: mismatched types\n --> /tmp/.tmprVsgtJ/main.rs:1:1669\n  |\n1 | ...tegory , \" $\") + category_total . to_s () , \" \") + bar) } } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}...\n  |                                                       ^^^ expected `&str`, found `str`\n  |\nhelp: consider borrowing here\n  |\n1 | use std :: collections :: HashMap ; fn add_transaction (amount : String , category : i32 , description : String) -> i32 { { { let transaction = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"date\" . to_string () , (current_date ()) . to_string ()) ; map . insert (\"amount\" . to_string () , (amount) . to_string ()) ; map . insert (\"category\" . to_string () , (category) . to_string ()) ; map . insert (\"description\" . to_string () , (description) . to_string ()) ; map } ; { append_csv (TRANSACTIONS_FILE , transaction) ; let mut monthly_spent = get_monthly_total (category) ; let mut budget_limit = get_budget_limit (category) ; if monthly_spent > budget_limit { { send_notification (format ! (\"⚠\\u{fe0f} Over budget for {}!\" , category)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Warning: \" , category) , \" spending at $\") + monthly_spent . to_s () , \"/$\") + budget_limit . to_s ()) } } } } } } fn generate_report (month : i32) -> i32 { { { let transactions = load_transactions (month) ; { let mut by_category = group_by (transactions , \"category\" . to_string ()) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📊 Budget Report for \" , month)) ; println ! (\"{:?}\" , \"=\" * 40i32) ; let mut total = 0i32 ; for (category , items) in by_category . iter () { { { let category_total = items . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () . sum () ; { total += category_total ; let mut bar = \"█\" * category_total / 50i32 . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , category , \" $\") + category_total . to_s () , \" \") + &bar) } } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" . to_string () ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      +\n\nerror[E0369]: cannot multiply `&str` by `i32`\n --> /tmp/.tmprVsgtJ/main.rs:1:1708\n  |\n1 | ...otal . to_s () , \" \") + bar) } } } } ; println ! (\"{:?}\" , \"=\" * 40i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total:          $\" ,...\n  |                                                               --- ^ ----- i32\n  |                                                               |\n  |                                                               &str\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmprVsgtJ/main.rs:1:1788\n  |\n1 | ... , format ! (\"{}{}\" , \"Total:          $\" , total . to_s ())) ; let mut report_file = format ! (\"budget_report_{}.pdf\" , month) ; gene...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0425]: cannot find function `generate_pdf` in this scope\n --> /tmp/.tmprVsgtJ/main.rs:1:1866\n  |\n1 | ...le = format ! (\"budget_report_{}.pdf\" , month) ; generate_pdf (report_file , report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmprVsgtJ/main.rs:1:1909\n  |\n1 | ...report_data) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n📄 Report saved to \" , report_file)) } } } } fn main () { let mut TRANSACTIONS_...\n  |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unused variable: `TRANSACTIONS_FILE`\n --> /tmp/.tmprVsgtJ/main.rs:1:2016\n  |\n1 | ...main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" . to_string () ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" ,...\n  |                      ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_TRANSACTIONS_FILE`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `CATEGORIES`\n --> /tmp/.tmprVsgtJ/main.rs:1:2090\n  |\n1 | .... to_string () ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other\"] ; }\n  |                             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_CATEGORIES`\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmprVsgtJ/main.rs:1:2012\n  |\n1 | ... saved to \" , report_file)) } } } } fn main () { let mut TRANSACTIONS_FILE = \"~/.budget/transactions.csv\" . to_string () ; let mut CAT...\n  |                                                         ----^^^^^^^^^^^^^^^^^\n  |                                                         |\n  |                                                         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmprVsgtJ/main.rs:1:2086\n  |\n1 | ... = \"~/.budget/transactions.csv\" . to_string () ; let mut CATEGORIES = vec ! [\"Food\" , \"Transport\" , \"Bills\" , \"Entertainment\" , \"Other...\n  |                                                         ----^^^^^^^^^^\n  |                                                         |\n  |                                                         help: remove this `mut`\n\nerror: aborting due to 18 previous errors; 8 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_i()"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 7,
          "line_number": 622,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Development project scaffolding tool\nlet TEMPLATES = {\n    \"python\": {\n        \"files\": [\"main.py\", \"requirements.txt\", \"README.md\", \".gitignore\"],\n        \"folders\": [\"src\", \"tests\", \"docs\"]\n    },\n    \"javascript\": {\n        \"files\": [\"index.js\", \"package.json\", \"README.md\", \".gitignore\"],\n        \"folders\": [\"src\", \"test\", \"public\"]\n    },\n    \"ruchy\": {\n        \"files\": [\"main.ruchy\", \"Cargo.toml\", \"README.md\", \".gitignore\"],\n        \"folders\": [\"src\", \"tests\", \"docs\"]\n    }\n}\n\nfun create_project(name, language) {\n    let project_dir = name\n    \n    if dir_exists(project_dir) {\n        println(f\"❌ Directory {project_dir} already exists\")\n        return\n    }\n    \n    create_dir(project_dir)\n    println(\"📁 Created project: \" + name)\n    \n    let template = TEMPLATES[language]\n    \n    // Create folder structure\n    for folder in template.folders {\n        create_dir(join_path(project_dir, folder))\n        println(f\"  📂 {folder}/\")\n    }\n    \n    // Create files from templates\n    for file in template.files {\n        let template_content = get_template_content(language, file)\n        let content = template_content\n            .replace(\"{{PROJECT_NAME}}\", name)\n            .replace(\"{{DATE}}\", current_date())\n            .replace(\"{{AUTHOR}}\", get_git_user())\n        \n        write_file(join_path(project_dir, file), content)\n        println(\"  📄 \" + file)\n    }\n    \n    // Initialize git\n    run_command(\"git init\", project_dir)\n    run_command(\"git add .\", project_dir)\n    run_command('git commit -m \"Initial commit\"', project_dir)\n    \n    println(f\"\\n✅ Project {name} created successfully!\")\n    println(f\"Next steps:\")\n    println(\"  cd \" + project_dir)\n    println(\"  \" + get_run_command(language))\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 8,
          "line_number": 694,
          "code": "// Status: ❌ BROKEN\n\n// test_app.ruchy - Application test suite\n\nfun test_user_creation() {\n    let user = create_user(\"Alice\", \"alice@example.com\")\n    \n    assert(user.name == \"Alice\", \"Name should be set\")\n    assert(user.email == \"alice@example.com\", \"Email should be set\")\n    assert(user.id != null, \"ID should be generated\")\n    \n    println(\"✅ test_user_creation passed\")\n}\n\nfun test_data_persistence() {\n    let test_data = {\"test\": \"value\"}\n    let test_file = \"test_data.json\"\n    \n    // Save data\n    save_json(test_file, test_data)\n    assert(file_exists(test_file), \"File should be created\")\n    \n    // Load data\n    let loaded = load_json(test_file)\n    assert(loaded.test == \"value\", \"Data should persist\")\n    \n    // Cleanup\n    remove_file(test_file)\n    \n    println(\"✅ test_data_persistence passed\")\n}\n\nfun run_all_tests() {\n    println(\"🧪 Running application tests...\")\n    \n    test_user_creation()\n    test_data_persistence()\n    test_error_handling()\n    test_performance()\n    \n    println(\"\\n✅ All tests passed!\")\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `null` in this scope\n --> /tmp/.tmpGk7lO7/main.rs:1:333\n  |\n1 | ...}\" , \"Email should be set\") ; assert ! (user . id != null , \"{}\" , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\"...\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::ptr::null;\n  |\n\nerror[E0425]: cannot find function `remove_file` in this scope\n --> /tmp/.tmpGk7lO7/main.rs:1:939\n  |\n1 | ...est == \"value\" , \"{}\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::remove_file;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpGk7lO7/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () -> i32 { { { let user = create_user (\"Alice\" . to_string () , \"alice@example...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpGk7lO7/main.rs:1:71\n  |\n1 | ... { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert ! (user . name == \"Alice\" , \"{}\" , \"Name should be set\") ; assert ! (user . email == \"alice@example.com\" , \"{}\" , \"Email should be set\") ; assert ! (user . id != null , \"{}\" , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } f...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                            ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test_user_creation () -> i32 { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert ! (user . name == \"Alice\" , \"{}\" , \"Name should be set\") ; assert ! (user . email == \"alice@example.com\" , \"{}\" , \"Email should be set\") ; assert ! (user . id != null , \"{}\" , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } fn test_data_persistence () -> i32 { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"test\" . to_string () , (\"value\") . to_string ()) ; map } ; { let mut test_file = \"test_data.json\" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , \"{}\" , \"File should be created\") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == \"value\" , \"{}\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test_user_creation () -> i32 { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert ! (user . name == \"Alice\" , \"{}\" , \"Name should be set\") ; assert ! (user . email == \"alice@example.com\" , \"{}\" , \"Email should be set\") ; assert ! (user . id != null , \"{}\" , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } fn test_data_persistence () -> i32 { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"test\" . to_string () , (\"value\") . to_string ()) ; map } ; { let mut test_file = \"test_data.json\" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , \"{}\" , \"File should be created\") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == \"value\" , \"{}\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpGk7lO7/main.rs:1:462\n  |\n1 | ... { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"test\" . to_string () , (\"value\") . to_string ()) ; map } ; { let mut test_file = \"test_data.json\" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , \"{}\" , \"File should be created\") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == \"value\" , \"{}\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } f...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test_user_creation () -> i32 { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert ! (user . name == \"Alice\" , \"{}\" , \"Name should be set\") ; assert ! (user . email == \"alice@example.com\" , \"{}\" , \"Email should be set\") ; assert ! (user . id != null , \"{}\" , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } fn test_data_persistence () -> i32 { { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"test\" . to_string () , (\"value\") . to_string ()) ; map } ; { let mut test_file = \"test_data.json\" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , \"{}\" , \"File should be created\") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == \"value\" , \"{}\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test_user_creation () -> i32 { { { let user = create_user (\"Alice\" . to_string () , \"alice@example.com\" . to_string ()) ; { assert ! (user . name == \"Alice\" , \"{}\" , \"Name should be set\") ; assert ! (user . email == \"alice@example.com\" , \"{}\" , \"Email should be set\") ; assert ! (user . id != null , \"{}\" , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } fn test_data_persistence () -> i32 { { let test_data = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"test\" . to_string () , (\"value\") . to_string ()) ; map } ; { let mut test_file = \"test_data.json\" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , \"{}\" , \"File should be created\") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == \"value\" , \"{}\" , \"Data should persist\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } fn run_all_tests () { { println ! (\"🧪 Running application tests...\") ; test_user_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n  |\n\nerror[E0425]: cannot find function `create_user` in this scope\n --> /tmp/.tmpGk7lO7/main.rs:1:86\n  |\n1 | use std :: collections :: HashMap ; fn test_user_creation () -> i32 { { { let user = create_user (\"Alice\" . to_string () , \"alice@example...\n  |                                                                                      ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpGk7lO7/main.rs:1:375\n  |\n1 | ...}\" , \"ID should be generated\") ; println ! (\"✅ test_user_creation passed\") } } } } fn test_data_persistence () -> i32 { { { let test_da...\n  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `save_json` in this scope\n --> /tmp/.tmpGk7lO7/main.rs:1:722\n  |\n1 | ...mut test_file = \"test_data.json\" . to_string () ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , \"{}\" , \"File...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpGk7lO7/main.rs:1:768\n  |\n1 | ... ; save_json (test_file , test_data) ; assert ! (file_exists (test_file) , \"{}\" , \"File should be created\") ; let mut loaded = load_js...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `load_json` in this scope\n --> /tmp/.tmpGk7lO7/main.rs:1:846\n  |\n1 | ...}\" , \"File should be created\") ; let mut loaded = load_json (test_file) ; assert ! (loaded . test == \"value\" , \"{}\" , \"Data should per...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpGk7lO7/main.rs:1:965\n  |\n1 | ...\") ; remove_file (test_file) ; println ! (\"✅ test_data_persistence passed\") } } } } fn run_all_tests () { { println ! (\"🧪 Running applic...\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `test_error_handling` in this scope\n --> /tmp/.tmpGk7lO7/main.rs:1:1140\n  |\n1 | ...ser_creation () ; test_data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn ...\n  |                                                 ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `test_performance` in this scope\n --> /tmp/.tmpGk7lO7/main.rs:1:1165\n  |\n1 | ...data_persistence () ; test_error_handling () ; test_performance () ; println ! (\"\\n✅ All tests passed!\") } } fn main () { }\n  |                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 10 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-building-applications.md",
          "example_number": 9,
          "line_number": 751,
          "code": "// Status: ❌ BROKEN\n\n// build.ruchy - Build and package script\n\nfun build_release() {\n    println(\"🔨 Building release version...\")\n    \n    // Run tests first\n    run_tests()\n    \n    // Create release directory\n    let release_dir = \"release_\" + VERSION\n    create_dir_all(release_dir)\n    \n    // Copy application files\n    copy_file(\"main.ruchy\", join_path(release_dir, APP_NAME))\n    copy_dir(\"resources\", join_path(release_dir, \"resources\"))\n    \n    // Generate documentation\n    generate_docs(join_path(release_dir, \"docs\"))\n    \n    // Create installer script\n    let installer = f\"#!/bin/bash\necho 'Installing {APP_NAME} v{VERSION}'\nmkdir -p ~/.local/bin\ncp {APP_NAME} ~/.local/bin/\nchmod +x ~/.local/bin/{APP_NAME}\necho 'Installation complete! Run {APP_NAME} to start.'\n\"\n    write_file(join_path(release_dir, \"install.sh\"), installer)\n    \n    // Package as archive\n    create_archive(f\"{APP_NAME}-{VERSION}.tar.gz\", release_dir)\n    \n    println(f\"✅ Release built: {APP_NAME}-{VERSION}.tar.gz\")\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `VERSION` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:181\n  |\n1 | ... let release_dir = format ! (\"{}{}\" , \"release_\" , VERSION) ; { create_dir_all (release_dir) ; copy_file (\"main.ruchy\" . to_string () ...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `create_dir_all` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:194\n  |\n1 | ... = format ! (\"{}{}\" , \"release_\" , VERSION) ; { create_dir_all (release_dir) ; copy_file (\"main.ruchy\" . to_string () , join_path (rel...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::fs::create_dir_all;\n  |\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:291\n  |\n1 | ...n.ruchy\" . to_string () , join_path (release_dir , APP_NAME)) ; copy_dir (\"resources\" . to_string () , join_path (release_dir , \"resou...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:657\n  |\n1 | ...cho 'Installation complete! Run {} to start.'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (relea...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `VERSION` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:668\n  |\n1 | ...lation complete! Run {} to start.'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"i...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:678\n  |\n1 | ...plete! Run {} to start.'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"install.sh\"...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:689\n  |\n1 | ...{} to start.'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"install.sh\" . to_strin...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:700\n  |\n1 | ....'\\n\" , APP_NAME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"install.sh\" . to_string ()) , ins...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:836\n  |\n1 | ...ller) ; create_archive (format ! (\"{}-{}.tar.gz\" , APP_NAME , VERSION) , release_dir) ; println ! (\"✅ Release built: {}-{}.tar.gz\" , AP...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `VERSION` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:847\n  |\n1 | ...ate_archive (format ! (\"{}-{}.tar.gz\" , APP_NAME , VERSION) , release_dir) ; println ! (\"✅ Release built: {}-{}.tar.gz\" , APP_NAME , VE...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `APP_NAME` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:918\n  |\n1 | ...ir) ; println ! (\"✅ Release built: {}-{}.tar.gz\" , APP_NAME , VERSION) } } } } fn main () { }\n  |                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `VERSION` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:929\n  |\n1 | ...ln ! (\"✅ Release built: {}-{}.tar.gz\" , APP_NAME , VERSION) } } } } fn main () { }\n  |                                                        ^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmperIdC9/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn build_release () -> i32 { { println ! (\"🔨 Building release version...\") ; run_tests () ; { let rele...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `run_tests` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:114\n  |\n1 | ...{ { println ! (\"🔨 Building release version...\") ; run_tests () ; { let release_dir = format ! (\"{}{}\" , \"release_\" , VERSION) ; { creat...\n  |                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:266\n  |\n1 | ...e_dir) ; copy_file (\"main.ruchy\" . to_string () , join_path (release_dir , APP_NAME)) ; copy_dir (\"resources\" . to_string () , join_pa...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `copy_file` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:225\n  |\n1 | ...e_\" , VERSION) ; { create_dir_all (release_dir) ; copy_file (\"main.ruchy\" . to_string () , join_path (release_dir , APP_NAME)) ; copy_...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:343\n  |\n1 | ...P_NAME)) ; copy_dir (\"resources\" . to_string () , join_path (release_dir , \"resources\" . to_string ())) ; generate_docs (join_path (re...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `copy_dir` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:304\n  |\n1 | ..._string () , join_path (release_dir , APP_NAME)) ; copy_dir (\"resources\" . to_string () , join_path (release_dir , \"resources\" . to_st...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:414\n  |\n1 | ...r , \"resources\" . to_string ())) ; generate_docs (join_path (release_dir , \"docs\" . to_string ())) ; let mut installer = format ! (\"#!...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `generate_docs` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:399\n  |\n1 | ...h (release_dir , \"resources\" . to_string ())) ; generate_docs (join_path (release_dir , \"docs\" . to_string ())) ; let mut installer = ...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:724\n  |\n1 | ...N , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"install.sh\" . to_string ()) , installer) ; create_archive ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:712\n  |\n1 | ...AME , VERSION , APP_NAME , APP_NAME , APP_NAME) ; write_file (join_path (release_dir , \"install.sh\" . to_string ()) , installer) ; cre...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `create_archive` in this scope\n --> /tmp/.tmperIdC9/main.rs:1:793\n  |\n1 | ...r , \"install.sh\" . to_string ()) , installer) ; create_archive (format ! (\"{}-{}.tar.gz\" , APP_NAME , VERSION) , release_dir) ; printl...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmperIdC9/main.rs:1:873\n  |\n1 | ...ON) , release_dir) ; println ! (\"✅ Release built: {}-{}.tar.gz\" , APP_NAME , VERSION) } } } } fn main () { }\n  |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 23 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch15-00-macros-metaprogramming": {
      "chapter": "ch15-00-macros-metaprogramming",
      "total_examples": 2,
      "working_examples": 0,
      "failing_examples": 2,
      "examples": [
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 1,
          "line_number": 50,
          "code": "// Instead of a macro, use a function\nfun create_user(name: String, age: i32) -> String {\n    \"User: \" + name + \", Age: \" + age.to_string()\n}\n\n// Works today!\nlet user = create_user(\"Alice\", 30)\nprintln(user)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp7oD1f7/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn create_user (name : String , age : i32) -> String { { format ! (\"{}{}\" , format ! (\"{}{}\" , \"User:...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7oD1f7/main.rs:1:92\n  |\n1 | ...e : i32) -> String { { format ! (\"{}{}\" , format ! (\"{}{}\" , \"User: \" , name) , \", Age: \") + age . to_string () } } fn main () { let m...\n  |                         ^^                                                                                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn create_user (name : String , age : i32) -> String { { format ! (\"{}{}\" , format ! (\"{}{}\" , \"User: \" , name) , \", Age: \") + age . to_string () } } fn main () { let mut user = create_user (\"Alice\" . to_string () , 30i32) ; println ! (\"{:?}\" , user) ; }\n1 + use std :: collections :: HashMap ; fn create_user (name : String , age : i32) -> String { format ! (\"{}{}\" , format ! (\"{}{}\" , \"User: \" , name) , \", Age: \") + age . to_string () } fn main () { let mut user = create_user (\"Alice\" . to_string () , 30i32) ; println ! (\"{:?}\" , user) ; }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7oD1f7/main.rs:1:164\n  |\n1 | ...(\"{}{}\" , \"User: \" , name) , \", Age: \") + age . to_string () } } fn main () { let mut user = create_user (\"Alice\" . to_string () , 30i...\n  |                                              ^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`\n  |\nhelp: consider borrowing here\n  |\n1 | use std :: collections :: HashMap ; fn create_user (name : String , age : i32) -> String { { format ! (\"{}{}\" , format ! (\"{}{}\" , \"User: \" , name) , \", Age: \") + &age . to_string () } } fn main () { let mut user = create_user (\"Alice\" . to_string () , 30i32) ; println ! (\"{:?}\" , user) ; }\n  |                                                                                                                                                                    +\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmp7oD1f7/main.rs:1:204\n  |\n1 | ...\", Age: \") + age . to_string () } } fn main () { let mut user = create_user (\"Alice\" . to_string () , 30i32) ; println ! (\"{:?}\" , use...\n  |                                                         ----^^^^\n  |                                                         |\n  |                                                         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror: aborting due to 1 previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-macros-metaprogramming.md",
          "example_number": 2,
          "line_number": 63,
          "code": "// Instead of #[derive(Debug)], implement manually\nstruct User {\n    name: String,\n    age: i32\n}\n\nfun debug_user(user: User) -> String {\n    \"User { name: \" + user.name + \", age: \" + user.age.to_string() + \" }\"\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `User` in this scope\n --> /tmp/.tmp18pYhh/main.rs:1:59\n  |\n1 | use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"U...\n  |                                                           ^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp18pYhh/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"U...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp18pYhh/main.rs:1:77\n  |\n1 | ... { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"User { name: \" , user . name) , \", age: \") + user . age . to_string () , \" }\") } } ...\n  |       ^^                                                                                                                                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn debug_user (user : User) -> String { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"User { name: \" , user . name) , \", age: \") + user . age . to_string () , \" }\") } } fn main () { struct User { name : String , age : i32 , } ; }\n1 + use std :: collections :: HashMap ; fn debug_user (user : User) -> String { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"User { name: \" , user . name) , \", age: \") + user . age . to_string () , \" }\") } fn main () { struct User { name : String , age : i32 , } ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp18pYhh/main.rs:1:277\n  |\n1 | ...in () { struct User { name : String , age : i32 , } ; }\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror: aborting due to 1 previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch09-00-network-programming": {
      "chapter": "ch09-00-network-programming",
      "total_examples": 10,
      "working_examples": 0,
      "failing_examples": 10,
      "examples": [
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 1,
          "line_number": 48,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: web_server.ruchy\n// HTTP server with routing and middleware\n\nuse std::net::http;\n\nlet server = http::Server::new(\"0.0.0.0:8080\")\n\n// Middleware for logging\nserver.use(|req, res, next| {\n    let start = current_time_ms()\n    next()\n    let duration = current_time_ms() - start\n    println(req.method + \" \" + req.path + \" - \" + res.status.to_s() + \" (\" + duration.to_s() + \"ms)\")\n})\n\n// Routes\nserver.get(\"/\", |req, res| {\n    res.html(\"<h1>Welcome to Ruchy Server!</h1>\")\n})\n\nserver.get(\"/api/users\", |req, res| {\n    let users = [\n        {id: 1, name: \"Alice\", email: \"alice@example.com\"},\n        {id: 2, name: \"Bob\", email: \"bob@example.com\"}\n    ]\n    res.json(users)\n})\n\nserver.post(\"/api/users\", |req, res| {\n    let user = req.json()\n    println(\"Creating user: \" + user.name)\n    user.id = generate_id()\n    user.created = current_datetime()\n    res.status(201).json(user)\n})\n\n// Static files\nserver.static(\"/public\", \"./static\")\n\n// Start server\nprintln(f\"🚀 Server running on http://localhost:8080\")\nserver.listen()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 2,
          "line_number": 109,
          "code": "// Status: ❌ BROKEN\n\n// TCP Server\nlet server = net::TcpListener::bind(\"127.0.0.1:9000\")\nprintln(\"Server listening on port 9000\")\n\nloop {\n    let client = server.accept()\n    \n    // Handle each client in a separate thread\n    spawn {\n        println(\"Client connected: \" + client.remote_addr())\n        \n        loop {\n            let message = client.read_line()\n            if message.is_empty() {\n                break\n            }\n            \n            println(\"Received: \" + message)\n            client.write(\"Echo: \" + message + \"\\n\")\n        }\n        \n        println(\"Client disconnected\")\n    }\n}\n\n// TCP Client\nlet client = net::TcpStream::connect(\"127.0.0.1:9000\")\nclient.write(\"Hello, server!\\n\")\nlet response = client.read_line()\nprintln(\"Server replied: \" + response)",
          "passed": false,
          "status": "broken",
          "error": "\nthread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:\n\"net::TcpListener\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 3,
          "line_number": 154,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Simple GET request\nlet response = http::get(\"https://api.example.com/data\")\nlet data = response.json()\nprintln(\"Got \" + data.items.len().to_s() + \" items\")\n\n// POST with JSON\nlet user = {\n    name: \"Alice\",\n    email: \"alice@example.com\"\n}\nlet response = http::post(\"https://api.example.com/users\")\n    .json(user)\n    .send()\n\n// Advanced requests\nlet response = http::request(\"https://api.example.com/data\")\n    .method(\"GET\")\n    .header(\"Authorization\", \"Bearer \" + token)\n    .header(\"User-Agent\", \"Ruchy/1.0\")\n    .query(\"page\", 1)\n    .query(\"limit\", 100)\n    .timeout(5000)\n    .send()\n\nif response.is_success() {\n    let data = response.json()\n    process_data(data)\n} else {\n    println(\"Error: \" + response.status.to_s() + \" - \" + response.text())\n}\n\n// Download file with progress\nhttp::download(\"https://example.com/big-file.zip\", \"downloads/file.zip\")\n    .on_progress(|downloaded, total| {\n        let percent = (downloaded / total) * 100\n        print(\"\\rDownloading: \" + percent.to_s() + \"%\")\n    })\n    .await()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 4,
          "line_number": 207,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// WebSocket Server\nlet ws_server = ws::Server::new(\"0.0.0.0:8081\")\n\nws_server.on_connection(|socket| {\n    println(\"WebSocket connected: \" + socket.id)\n    \n    socket.on(\"message\", |data| {\n        println(\"Received: \" + data)\n        \n        // Broadcast to all clients\n        ws_server.broadcast({\n            type: \"chat\",\n            user: socket.id,\n            message: data\n        })\n    })\n    \n    socket.on(\"close\", || {\n        println(\"WebSocket disconnected: \" + socket.id)\n    })\n})\n\nws_server.listen()\n\n// WebSocket Client\nlet ws = ws::connect(\"ws://localhost:8081\")\n\nws.on(\"open\", || {\n    println(\"Connected to server\")\n    ws.send(\"Hello, server!\")\n})\n\nws.on(\"message\", |data| {\n    println(\"Server says: \" + data)\n})\n\nws.on(\"error\", |err| {\n    println(\"WebSocket error: \" + err.to_s())\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 5,
          "line_number": 261,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: api_server.ruchy\n// RESTful API with database\n\nuse std::net::http;\nuse std::db;\n\nlet app = http::Server::new(\"0.0.0.0:3000\")\nlet database = db::connect(\"sqlite:data.db\")\n\n// CORS middleware\napp.use(|req, res, next| {\n    res.header(\"Access-Control-Allow-Origin\", \"*\")\n    res.header(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE\")\n    next()\n})\n\n// Authentication middleware\nfun require_auth(req, res, next) {\n    let token = req.header(\"Authorization\")\n    if !token || !validate_token(token) {\n        return res.status(401).json({error: \"Unauthorized\"})\n    }\n    req.user = decode_token(token)\n    next()\n}\n\n// Routes\napp.get(\"/api/posts\", |req, res| {\n    let page = req.query(\"page\", 1)\n    let limit = req.query(\"limit\", 10)\n    \n    let posts = database.query(\"\n        SELECT * FROM posts \n        ORDER BY created_at DESC \n        LIMIT ? OFFSET ?\n    \", [limit, (page - 1) * limit])\n    \n    res.json({\n        posts: posts,\n        page: page,\n        total: database.count(\"posts\")\n    })\n})\n\napp.get(\"/api/posts/:id\", |req, res| {\n    let id = req.params.id\n    let post = database.find(\"posts\", id)\n    \n    if post {\n        res.json(post)\n    } else {\n        res.status(404).json({error: \"Post not found\"})\n    }\n})\n\napp.post(\"/api/posts\", require_auth, |req, res| {\n    let post = req.json()\n    post.author_id = req.user.id\n    post.created_at = current_datetime()\n    \n    let id = database.insert(\"posts\", post)\n    let created = database.find(\"posts\", id)\n    \n    res.status(201).json(created)\n})\n\napp.put(\"/api/posts/:id\", require_auth, |req, res| {\n    let id = req.params.id\n    let updates = req.json()\n    \n    // Check ownership\n    let post = database.find(\"posts\", id)\n    if post.author_id != req.user.id {\n        return res.status(403).json({error: \"Forbidden\"})\n    }\n    \n    updates.updated_at = current_datetime()\n    database.update(\"posts\", id, updates)\n    \n    res.json(database.find(\"posts\", id))\n})\n\napp.delete(\"/api/posts/:id\", require_auth, |req, res| {\n    let id = req.params.id\n    \n    // Check ownership\n    let post = database.find(\"posts\", id)\n    if post.author_id != req.user.id {\n        return res.status(403).json({error: \"Forbidden\"})\n    }\n    \n    database.delete(\"posts\", id)\n    res.status(204).send()\n})\n\n// Error handling\napp.use(|err, req, res, next| {\n    console.error(\"Error: \" + err.to_s())\n    res.status(500).json({\n        error: \"Internal server error\",\n        message: err.message\n    })\n})\n\nprintln(\"🚀 API server running on http://localhost:3000\")\napp.listen()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 6,
          "line_number": 380,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: chat_server.ruchy\n// Multi-room chat server with history\n\nuse std::net::ws;\n\nlet server = ws::Server::new(\"0.0.0.0:8080\")\nlet rooms = {}\nlet users = {}\n\nfun broadcast_to_room(room_id, message, exclude_user = null) {\n    if rooms.has_key(room_id) {\n        for user_id in rooms[room_id] {\n            if user_id != exclude_user {\n                users[user_id].socket.send(message)\n            }\n        }\n    }\n}\n\nserver.on_connection(|socket| {\n    let user = {\n        id: generate_id(),\n        socket: socket,\n        name: null,\n        room: null,\n        joined_at: current_datetime()\n    }\n    \n    users[user.id] = user\n    \n    socket.send(json({\n        type: \"welcome\",\n        user_id: user.id,\n        message: \"Welcome to chat! Send /help for commands\"\n    }))\n    \n    socket.on(\"message\", |data| {\n        let msg = parse_json(data)\n        \n        match msg.type {\n            \"join\" => {\n                user.name = msg.name\n                user.room = msg.room\n                \n                // Add user to room\n                if !rooms.has_key(msg.room) {\n                    rooms[msg.room] = []\n                }\n                rooms[msg.room].push(user.id)\n                \n                // Notify room\n                broadcast_to_room(msg.room, json({\n                    type: \"user_joined\",\n                    user: user.name,\n                    time: current_datetime()\n                }))\n                \n                // Send room history\n                let history = get_room_history(msg.room)\n                socket.send(json({\n                    type: \"history\",\n                    messages: history\n                }))\n            }\n            \n            \"message\" => {\n                let chat_msg = {\n                    type: \"message\",\n                    user: user.name,\n                    text: msg.text,\n                    time: current_datetime()\n                }\n                \n                // Save to history\n                save_message(user.room, chat_msg)\n                \n                // Broadcast to room\n                broadcast_to_room(user.room, json(chat_msg))\n            }\n            \n            \"private\" => {\n                let target = find_user_by_name(msg.to)\n                if target {\n                    target.socket.send(json({\n                        type: \"private\",\n                        from: user.name,\n                        text: msg.text,\n                        time: current_datetime()\n                    }))\n                }\n            }\n            \n            \"typing\" => {\n                broadcast_to_room(user.room, json({\n                    type: \"typing\",\n                    user: user.name\n                }), user.id)\n            }\n        }\n    })\n    \n    socket.on(\"close\", || {\n        // Remove from room\n        if user.room && rooms.has_key(user.room) {\n            rooms[user.room] = rooms[user.room].filter(|id| id != user.id)\n            \n            broadcast_to_room(user.room, json({\n                type: \"user_left\",\n                user: user.name,\n                time: current_datetime()\n            }))\n        }\n        \n        users.remove(user.id)\n    })\n})\n\nprintln(\"💬 Chat server running on ws://localhost:8080\")\nserver.listen()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 7,
          "line_number": 512,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: network_scanner.ruchy\n// Scan network for open ports and services\n\nuse std::net;\nuse std::async;\n\nprintln(\"=== Network Scanner ===\")\n\nfun scan_port(host, port, timeout = 1000) {\n    try {\n        let socket = net::TcpStream::connect_timeout(\n            host + \":\" + port.to_s(), \n            timeout\n        )\n        socket.close()\n        return true\n    } catch {\n        return false\n    }\n}\n\nfun identify_service(port) {\n    let services = {\n        21: \"FTP\",\n        22: \"SSH\",\n        23: \"Telnet\",\n        25: \"SMTP\",\n        53: \"DNS\",\n        80: \"HTTP\",\n        110: \"POP3\",\n        143: \"IMAP\",\n        443: \"HTTPS\",\n        445: \"SMB\",\n        3306: \"MySQL\",\n        5432: \"PostgreSQL\",\n        6379: \"Redis\",\n        8080: \"HTTP-Alt\",\n        8443: \"HTTPS-Alt\",\n        27017: \"MongoDB\"\n    }\n    \n    return services.get(port, \"Unknown\")\n}\n\nfun scan_host(host, ports) {\n    println(\"\\nScanning \" + host + \"...\")\n    let open_ports = []\n    \n    // Parallel port scanning\n    let tasks = []\n    for port in ports {\n        tasks.push(async {\n            if scan_port(host, port) {\n                return port\n            }\n            return null\n        })\n    }\n    \n    let results = async::wait_all(tasks)\n    \n    for port in results {\n        if port {\n            let service = identify_service(port)\n            open_ports.push({port: port, service: service})\n            println(\"  ✓ Port \" + port.to_s() + \" open - \" + service)\n        }\n    }\n    \n    return open_ports\n}\n\n// Get scan parameters\nlet target = input(\"Target host (IP or domain): \")\nlet scan_type = input(\"Scan type (quick/full/custom): \")\n\nlet ports = match scan_type {\n    \"quick\" => [21, 22, 23, 25, 80, 443, 3306, 5432, 8080]\n    \"full\" => range(1, 65535)\n    \"custom\" => {\n        let range_str = input(\"Port range (e.g., 1-1000): \")\n        let parts = range_str.split(\"-\")\n        range(parts[0].to_i(), parts[1].to_i())\n    }\n    _ => [80, 443]\n}\n\nprintln(\"\\nScanning \" + ports.len().to_s() + \" ports on \" + target + \"...\")\nlet start_time = current_time_ms()\n\nlet results = scan_host(target, ports)\n\nlet duration = (current_time_ms() - start_time) / 1000\nprintln(\"\\nScan complete in \" + duration.to_s() + \"s\")\nprintln(\"Found \" + results.len().to_s() + \" open ports\")\n\n// Generate report\nif results.len() > 0 {\n    println(\"\\n=== Open Services ===\")\n    for item in results.sort_by(|r| r.port) {\n        println(item.port.to_s() + \" - \" + item.service)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 8,
          "line_number": 628,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: load_balancer.ruchy\n// HTTP load balancer with health checking\n\nuse std::net::http;\n\nlet backends = [\n    {url: \"http://server1:8080\", weight: 1, healthy: true},\n    {url: \"http://server2:8080\", weight: 2, healthy: true},\n    {url: \"http://server3:8080\", weight: 1, healthy: true}\n]\n\nlet current_backend = 0\n\nfun select_backend() {\n    // Weighted round-robin selection\n    let healthy_backends = backends.filter(|b| b.healthy)\n    \n    if healthy_backends.is_empty() {\n        throw \"No healthy backends available\"\n    }\n    \n    // Simple round-robin for now\n    current_backend = (current_backend + 1) % healthy_backends.len()\n    return healthy_backends[current_backend]\n}\n\nfun health_check() {\n    for backend in backends {\n        try {\n            let response = http::get(backend.url + \"/health\")\n                .timeout(2000)\n                .send()\n            \n            backend.healthy = response.status == 200\n        } catch {\n            backend.healthy = false\n        }\n        \n        let status = backend.healthy ? \"✓\" : \"✗\"\n        println(\"Health check \" + backend.url + \": \" + status)\n    }\n}\n\n// Start health check timer\nspawn {\n    loop {\n        health_check()\n        sleep(10000)  // Check every 10 seconds\n    }\n}\n\n// Create load balancer server\nlet balancer = http::Server::new(\"0.0.0.0:80\")\n\nbalancer.all(\"*\", |req, res| {\n    let backend = select_backend()\n    \n    println(\"Routing \" + req.method + \" \" + req.path + \" -> \" + backend.url)\n    \n    // Forward request\n    let backend_response = http::request(backend.url + req.path)\n        .method(req.method)\n        .headers(req.headers)\n        .body(req.body)\n        .send()\n    \n    // Return response\n    res.status(backend_response.status)\n        .headers(backend_response.headers)\n        .send(backend_response.body)\n})\n\nprintln(\"🔄 Load balancer running on port 80\")\nprintln(\"Backends: \" + backends.len().to_s())\nbalancer.listen()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 9,
          "line_number": 720,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Custom protocol over TCP\nfun send_packet(socket, type, data) {\n    let packet = {\n        version: 1,\n        type: type,\n        timestamp: current_time_ms(),\n        data: data\n    }\n    \n    let json = to_json(packet)\n    let length = json.len()\n    \n    // Send length-prefixed message\n    socket.write_u32(length)\n    socket.write(json)\n}\n\nfun receive_packet(socket) {\n    let length = socket.read_u32()\n    let json = socket.read(length)\n    return parse_json(json)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch09-00-network-programming.md",
          "example_number": 10,
          "line_number": 755,
          "code": "// Status: ❌ BROKEN\n\n// Monitor network traffic\nlet monitor = net::PacketCapture::new(\"eth0\")\n\nmonitor.on_packet(|packet| {\n    if packet.protocol == \"TCP\" {\n        println(\"TCP: \" + packet.src + \":\" + packet.src_port.to_s() + \" -> \" + packet.dst + \":\" + packet.dst_port.to_s())\n    } else if packet.protocol == \"UDP\" {\n        println(\"UDP: \" + packet.src + \" -> \" + packet.dst + \" (\" + packet.size.to_s() + \" bytes)\")\n    }\n})\n\nmonitor.start()",
          "passed": false,
          "status": "broken",
          "error": "\nthread 'main' panicked at /home/noah/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quote-1.0.40/src/runtime.rs:444:9:\n\"net::PacketCapture\" is not a valid Ident\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch07-00-error-handling-tdd": {
      "chapter": "ch07-00-error-handling-tdd",
      "total_examples": 9,
      "working_examples": 3,
      "failing_examples": 6,
      "examples": [
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Before operation\");\n    if true {\n        println(\"Operation successful\");\n    }\n    println(\"After operation\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 2,
          "line_number": 56,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let number = 5;\n    if number > 0 {\n        println(\"Valid number\");\n    } else {\n        println(\"Invalid number\");\n    }\n    \n    let zero = 0;\n    if zero == 0 {\n        println(\"Warning: Zero value detected\");\n    } else {\n        println(\"Non-zero value\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 3,
          "line_number": 87,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let age = 25;\n    match age {\n        0 => println(\"Error: Age cannot be zero\"),\n        1..=17 => println(\"Minor\"),\n        18..=65 => println(\"Adult\"),\n        _ => println(\"Senior\")\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 4,
          "line_number": 130,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nif value > 0 {\n    println(\"Valid\");\n} else {\n    println(\"Invalid\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `value` in this scope\n --> /tmp/.tmplKD3A6/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") ...\n  |                                                                  ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmplKD3A6/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmplKD3A6/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") ...\n  |                                                                                 ^^                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { println ! (\"Valid\") } else { { println ! (\"Invalid\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmplKD3A6/main.rs:1:114\n  |\n1 | ... = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") } } ; if let Some (s) = (& result as & dyn std :: any ::...\n  |                                                          ^^                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { { println ! (\"Invalid\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if value > 0i32 { { println ! (\"Valid\") } } else { println ! (\"Invalid\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror: aborting due to 1 previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 5,
          "line_number": 143,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nmatch status {\n    0 => println(\"Error\"),\n    1 => println(\"Warning\"),\n    2 => println(\"Success\"),\n    _ => println(\"Unknown\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `status` in this scope\n --> /tmp/.tmpidKIYH/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! (\"Error\") , 1i32 => println ! (\"Warning\") ...\n  |                                                                     ^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpidKIYH/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match status { 0i32 => println ! (\"Error\") , 1i32 => println ! (\"Warning\") ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 6,
          "line_number": 157,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nmatch age {\n    0 => println(\"Invalid age\"),\n    1..=17 => println(\"Minor\"),\n    18..=65 => println(\"Adult\"),\n    _ => println(\"Senior\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `age` in this scope\n --> /tmp/.tmpYRlgZ1/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! (\"Invalid age\") , 1i32 ..= 17i32 => println !...\n  |                                                                     ^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpYRlgZ1/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match age { 0i32 => println ! (\"Invalid age\") , 1i32 ..= 17i32 => println !...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 7,
          "line_number": 185,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nif input < 0 {\n    println(\"Error: Negative input not allowed\");\n} else {\n    process_input(input);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `input` in this scope\n --> /tmp/.tmpPZenlL/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } els...\n  |                                                                  ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `input` in this scope\n --> /tmp/.tmpPZenlL/main.rs:1:159\n  |\n1 | ...ive input not allowed\") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_re...\n  |                                                        ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpPZenlL/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } els...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpPZenlL/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } els...\n  |                                                                                 ^^                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { println ! (\"Error: Negative input not allowed\") } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpPZenlL/main.rs:1:142\n  |\n1 | ...ln ! (\"Error: Negative input not allowed\") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any ::...\n  |                                                          ^^                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if input < 0i32 { { println ! (\"Error: Negative input not allowed\") } } else { process_input (input) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `process_input` in this scope\n --> /tmp/.tmpPZenlL/main.rs:1:144\n  |\n1 | ...rror: Negative input not allowed\") } } else { { process_input (input) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . ...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 8,
          "line_number": 198,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nmatch score {\n    0..=59 => println(\"Fail\"),\n    60..=79 => println(\"Pass\"),\n    80..=100 => println(\"Excellent\"),\n    _ => println(\"Invalid score\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `score` in this scope\n --> /tmp/.tmpTaDmlb/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! (\"Fail\") , 60i32 ..= 79i32 => pri...\n  |                                                                     ^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpTaDmlb/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match score { 0i32 ..= 59i32 => println ! (\"Fail\") , 60i32 ..= 79i32 => pri...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch07-00-error-handling-tdd.md",
          "example_number": 9,
          "line_number": 212,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nif system_ready {\n    println(\"System operational\");\n} else {\n    println(\"System not ready\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `system_ready` in this scope\n --> /tmp/.tmpa3xbE2/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { { println !...\n  |                                                                  ^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpa3xbE2/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { { println !...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpa3xbE2/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { { println !...\n  |                                                                                 ^^                                ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { { println ! (\"System not ready\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { println ! (\"System operational\") } else { { println ! (\"System not ready\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpa3xbE2/main.rs:1:127\n  |\n1 | ...y { { println ! (\"System operational\") } } else { { println ! (\"System not ready\") } } ; if let Some (s) = (& result as & dyn std :: a...\n  |                                                      ^^                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { { println ! (\"System not ready\") } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if system_ready { { println ! (\"System operational\") } } else { println ! (\"System not ready\") } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror: aborting due to 1 previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch08-00-systems-programming": {
      "chapter": "ch08-00-systems-programming",
      "total_examples": 9,
      "working_examples": 0,
      "failing_examples": 9,
      "examples": [
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 1,
          "line_number": 48,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// File: system_monitor.ruchy\n// Real-time system resource monitoring\n\nuse std::system;\nuse std::process;\n\nprintln(\"=== System Monitor ===\")\n\n// Get system information\nlet cpu_count = system::cpu_count()\nlet total_memory = system::total_memory()\nlet hostname = system::hostname()\nlet os_info = system::os_info()\n\nprintln(\"Host: \" + hostname)\nprintln(\"OS: \" + os_info.name + \" \" + os_info.version)\nprintln(\"CPUs: \" + cpu_count.to_s())\nprintln(\"Memory: \" + format_size(total_memory))\nprintln(\"\")\n\n// Monitor resources in real-time\nloop {\n    let cpu_usage = system::cpu_usage()\n    let memory_info = system::memory_info()\n    let disk_io = system::disk_io_stats()\n    let network_stats = system::network_stats()\n    \n    // Clear screen and show header\n    clear_screen()\n    println(\"System Monitor - Press Ctrl+C to exit\")\n    println(\"=\" * 50)\n    \n    // CPU Usage\n    println(\"CPU: \" + cpu_usage.to_s() + \"% |\" + (\"█\" * (cpu_usage * 50).to_i()) + (\"░\" * (50 - cpu_usage * 50).to_i()) + \"|\")\n    \n    // Memory Usage\n    let mem_percent = memory_info.used / memory_info.total\n    println(\"MEM: \" + mem_percent.to_s() + \"% |\" + (\"█\" * (mem_percent * 50).to_i()) + (\"░\" * (50 - mem_percent * 50).to_i()) + \"|\")\n    println(\"     \" + format_size(memory_info.used) + \" / \" + format_size(memory_info.total))\n    \n    // Disk I/O\n    println(\"Disk Read:  \" + format_size(disk_io.read_bytes) + \"/s\")\n    println(\"Disk Write: \" + format_size(disk_io.write_bytes) + \"/s\")\n    \n    // Network\n    println(\"Net Down: \" + format_size(network_stats.download_speed) + \"/s\")\n    println(\"Net Up:   \" + format_size(network_stats.upload_speed) + \"/s\")\n    \n    // Top processes\n    println(\"\\nTop Processes by CPU:\")\n    let processes = process::list()\n        .sort_by(|p| -p.cpu_percent)\n        .take(5)\n    \n    for proc in processes {\n        println(\"  \" + proc.pid.to_s() + \" \" + proc.name + \" \" + proc.cpu_percent.to_s() + \"%\")\n    }\n    \n    sleep(1000)  // Update every second\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0432]: unresolved import `std::system`\n --> /tmp/.tmpBcVVyp/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monit...\n  |                                                                     ^^^^^^^^^^^^^ no `system` in the root\n\nerror[E0425]: cannot find function `list` in module `process`\n --> /tmp/.tmpBcVVyp/main.rs:1:2198\n  |\n1 | ...Processes by CPU:\") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes...\n  |                                                         ^^^^ not found in `process`\n\nerror[E0425]: cannot find function `sleep` in this scope\n --> /tmp/.tmpBcVVyp/main.rs:1:2482\n  |\n1 | ..., \" \") + proc . cpu_percent . to_s () , \"%\")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::sleep;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpBcVVyp/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monit...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpBcVVyp/main.rs:1:85\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monit...\n  |                                                                                     ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpBcVVyp/main.rs:1:108\n  |\n1 | ...sult = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\") ; let mut cpu_count = system :: cpu_count (...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpBcVVyp/main.rs:1:686\n  |\n1 | ... { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\") ; println ! (\"{:?}\" , \"=\" * 50i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"CPU: \" , cpu_usage . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"MEM: \" , mem_percent . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } } ; sleep (1000i32) } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Host: \" , hostname)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"OS: \" , os_info . name) , \" \") + os_info . version) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"CPUs: \" , cpu_count . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Memory: \" , format_size (total_memory))) ; println ! (\"\") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\") ; println ! (\"{:?}\" , \"=\" * 50i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"CPU: \" , cpu_usage . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"MEM: \" , mem_percent . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Host: \" , hostname)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"OS: \" , os_info . name) , \" \") + os_info . version) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"CPUs: \" , cpu_count . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Memory: \" , format_size (total_memory))) ; println ! (\"\") ; loop { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\") ; println ! (\"{:?}\" , \"=\" * 50i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"CPU: \" , cpu_usage . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"MEM: \" , mem_percent . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } } ; sleep (1000i32) } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpBcVVyp/main.rs:1:2282\n  |\n1 | ... { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } } ...\n  |       ^^                                                                                                                                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Host: \" , hostname)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"OS: \" , os_info . name) , \" \") + os_info . version) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"CPUs: \" , cpu_count . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Memory: \" , format_size (total_memory))) ; println ! (\"\") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\") ; println ! (\"{:?}\" , \"=\" * 50i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"CPU: \" , cpu_usage . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"MEM: \" , mem_percent . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Host: \" , hostname)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"OS: \" , os_info . name) , \" \") + os_info . version) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"CPUs: \" , cpu_count . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Memory: \" , format_size (total_memory))) ; println ! (\"\") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\") ; println ! (\"{:?}\" , \"=\" * 50i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"CPU: \" , cpu_usage . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"MEM: \" , mem_percent . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpBcVVyp/main.rs:1:631\n  |\n1 | ...ntln ! (\"{:?}\" , format ! (\"{}{}\" , \"Memory: \" , format_size (total_memory))) ; println ! (\"\") ; loop { { { let cpu_usage = system :: ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `clear_screen` in this scope\n --> /tmp/.tmpBcVVyp/main.rs:1:882\n  |\n1 | ...mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\") ; println ! (\"{...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot multiply `&str` by `i32`\n --> /tmp/.tmpBcVVyp/main.rs:1:978\n  |\n1 | ...tem Monitor - Press Ctrl+C to exit\") ; println ! (\"{:?}\" , \"=\" * 50i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , fo...\n  |                                                               --- ^ ----- i32\n  |                                                               |\n  |                                                               &str\n\nerror[E0599]: no method named `to_i` found for type `i32` in the current scope\n --> /tmp/.tmpBcVVyp/main.rs:1:1134\n  |\n1 | ...age . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpBcVVyp/main.rs:1:1108\n  |\n1 | ...\" , cpu_usage . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut me...\n  |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `str`\n  |\nhelp: consider borrowing here\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Host: \" , hostname)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"OS: \" , os_info . name) , \" \") + os_info . version) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"CPUs: \" , cpu_count . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Memory: \" , format_size (total_memory))) ; println ! (\"\") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\") ; println ! (\"{:?}\" , \"=\" * 50i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"CPU: \" , cpu_usage . to_s ()) , \"% |\") + &(\"█\" * cpu_usage * 50i32 . to_i ()) + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"MEM: \" , mem_percent . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ++                                 +\n\nerror[E0369]: cannot multiply `&str` by `i32`\n --> /tmp/.tmpBcVVyp/main.rs:1:1148\n  |\n1 | ... . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = m...\n  |                                                               --- ^ ----- i32\n  |                                                               |\n  |                                                               &str\n\nerror[E0599]: no method named `to_i` found for type `i32` in the current scope\n --> /tmp/.tmpBcVVyp/main.rs:1:1178\n  |\n1 | ...50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ;...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_i` found for type `i32` in the current scope\n --> /tmp/.tmpBcVVyp/main.rs:1:1410\n  |\n1 | ...t . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{:?}\" ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpBcVVyp/main.rs:1:1382\n  |\n1 | ... mem_percent . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println...\n  |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `str`\n  |\nhelp: consider borrowing here\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: system ; ; use std :: process ; ; println ! (\"=== System Monitor ===\") ; let mut cpu_count = system :: cpu_count () ; let mut total_memory = system :: total_memory () ; let mut hostname = system :: hostname () ; let mut os_info = system :: os_info () ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Host: \" , hostname)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"OS: \" , os_info . name) , \" \") + os_info . version) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"CPUs: \" , cpu_count . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Memory: \" , format_size (total_memory))) ; println ! (\"\") ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\") ; println ! (\"{:?}\" , \"=\" * 50i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"CPU: \" , cpu_usage . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"MEM: \" , mem_percent . to_s ()) , \"% |\") + &(\"█\" * mem_percent * 50i32 . to_i ()) + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ++                                   +\n\nerror[E0369]: cannot multiply `&str` by `i32`\n --> /tmp/.tmpBcVVyp/main.rs:1:1424\n  |\n1 | ... to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{:?}\" , f...\n  |                                                               --- ^ ----- i32\n  |                                                               |\n  |                                                               &str\n\nerror[E0599]: no method named `to_i` found for type `i32` in the current scope\n --> /tmp/.tmpBcVVyp/main.rs:1:1456\n  |\n1 | ...i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpBcVVyp/main.rs:1:1542\n  |\n1 | ... format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; pri...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpBcVVyp/main.rs:1:1587\n  |\n1 | ...\" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpBcVVyp/main.rs:1:1699\n  |\n1 | ... ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" ,...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpBcVVyp/main.rs:1:1821\n  |\n1 | ... ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpBcVVyp/main.rs:1:1942\n  |\n1 | ...at ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{:?}\" , format !...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `format_size` in this scope\n --> /tmp/.tmpBcVVyp/main.rs:1:2072\n  |\n1 | ...at ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nwarning: unreachable expression\n --> /tmp/.tmpBcVVyp/main.rs:1:2510\n  |\n1 | ... ; loop { { { let cpu_usage = system :: cpu_usage () ; { let mut memory_info = system :: memory_info () ; let mut disk_io = system :: disk_io_stats () ; let mut network_stats = system :: network_stats () ; clear_screen () ; println ! (\"System Monitor - Press Ctrl+C to exit\") ; println ! (\"{:?}\" , \"=\" * 50i32) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"CPU: \" , cpu_usage . to_s ()) , \"% |\") + \"█\" * cpu_usage * 50i32 . to_i () + \"░\" * 50i32 - cpu_usage * 50i32 . to_i () , \"|\")) ; let mut mem_percent = memory_info . used / memory_info . total ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"MEM: \" , mem_percent . to_s ()) , \"% |\") + \"█\" * mem_percent * 50i32 . to_i () + \"░\" * 50i32 - mem_percent * 50i32 . to_i () , \"|\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"     \" , format_size (memory_info . used)) , \" / \") + format_size (memory_info . total)) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Read:  \" , format_size (disk_io . read_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Disk Write: \" , format_size (disk_io . write_bytes)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Down: \" , format_size (network_stats . download_speed)) , \"/s\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Net Up:   \" , format_size (network_stats . upload_speed)) , \"/s\")) ; println ! (\"\\nTop Processes by CPU:\") ; let mut processes = process :: list () . sort_by (| p | - p . cpu_percent) . take (5i32) ; for proc in processes { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"  \" , proc . pid . to_s ()) , \" \") + proc . name , \" \") + proc . cpu_percent . to_s () , \"%\")) } } ; sleep (1000i32) } } } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |       --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression\n  |       |\n  |       any code following this expression is unreachable\n  |\n  = note: `#[warn(unreachable_code)]` on by default\n\nerror: aborting due to 20 previous errors; 6 warnings emitted\n\nSome errors have detailed explanations: E0308, E0369, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_i()"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 2,
          "line_number": 129,
          "code": "// Status: ❌ BROKEN\n\n// Current process information\nlet pid = process::current_pid()\nlet ppid = process::parent_pid()\nlet exe_path = process::executable_path()\nlet args = process::args()\nlet env = process::environment()\n\n// List all processes\nlet all_processes = process::list()\nfor proc in all_processes {\n    println(\"PID: \" + proc.pid.to_s() + \", Name: \" + proc.name + \", CPU: \" + proc.cpu_percent.to_s() + \"%\")\n}\n\n// Find specific process\nlet chrome_procs = process::find_by_name(\"chrome\")\nlet high_cpu_procs = process::list()\n    .filter(|p| p.cpu_percent > 50)\n\n// Process control\nlet proc = process::from_pid(1234)\nproc.suspend()  // Pause process\nproc.resume()   // Resume process\nproc.terminate() // Request termination\nproc.kill()     // Force kill\n\n// Launch new process\nlet child = process::spawn(\"ls\", [\"-la\"])\nlet output = child.wait_with_output()\nprintln(output.stdout)\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpqvtQe7/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: paren...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpqvtQe7/main.rs:1:351\n  |\n1 | ... { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"PID: \" , proc . pid . to_s ()) , \", Name: \") + proc . name , \", CPU: \") + proc . cpu_percent . to_s () , \"%\")) } } ...\n  |       ^^                                                                                                                                                                                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = process :: args () ; let mut env = process :: environment () ; let mut all_processes = process :: list () ; for proc in all_processes { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"PID: \" , proc . pid . to_s ()) , \", Name: \") + proc . name , \", CPU: \") + proc . cpu_percent . to_s () , \"%\")) } } ; let mut chrome_procs = process :: find_by_name (\"chrome\" . to_string ()) ; let mut high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect :: < Vec < _ >> () ; let mut proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc . kill () ; let mut child = process :: spawn (\"ls\" . to_string () , vec ! [\"-la\"]) ; let mut output = child . wait_with_output () ; println ! (\"{:?}\" , output . stdout) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = process :: args () ; let mut env = process :: environment () ; let mut all_processes = process :: list () ; for proc in all_processes { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"PID: \" , proc . pid . to_s ()) , \", Name: \") + proc . name , \", CPU: \") + proc . cpu_percent . to_s () , \"%\")) } ; let mut chrome_procs = process :: find_by_name (\"chrome\" . to_string ()) ; let mut high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect :: < Vec < _ >> () ; let mut proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc . kill () ; let mut child = process :: spawn (\"ls\" . to_string () , vec ! [\"-la\"]) ; let mut output = child . wait_with_output () ; println ! (\"{:?}\" , output . stdout) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpqvtQe7/main.rs:1:79\n  |\n1 | ...in () { let result = { let mut pid = process :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process ...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpqvtQe7/main.rs:1:122\n  |\n1 | ...s :: current_pid () ; let mut ppid = process :: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = proc...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpqvtQe7/main.rs:1:168\n  |\n1 | ...: parent_pid () ; let mut exe_path = process :: executable_path () ; let mut args = process :: args () ; let mut env = process :: envi...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpqvtQe7/main.rs:1:215\n  |\n1 | ... executable_path () ; let mut args = process :: args () ; let mut env = process :: environment () ; let mut all_processes = process ::...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpqvtQe7/main.rs:1:250\n  |\n1 | ...= process :: args () ; let mut env = process :: environment () ; let mut all_processes = process :: list () ; for proc in all_processe...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpqvtQe7/main.rs:1:302\n  |\n1 | ...ronment () ; let mut all_processes = process :: list () ; for proc in all_processes { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpqvtQe7/main.rs:1:590\n  |\n1 | ..., \"%\")) } } ; let mut chrome_procs = process :: find_by_name (\"chrome\" . to_string ()) ; let mut high_cpu_procs = process :: list () ....\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpqvtQe7/main.rs:1:667\n  |\n1 | ...tring ()) ; let mut high_cpu_procs = process :: list () . into_iter () . filter (| p | p . cpu_percent > 50i32) . collect :: < Vec < _...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpqvtQe7/main.rs:1:788\n  |\n1 | ... :: < Vec < _ >> () ; let mut proc = process :: from_pid (1234i32) ; proc . suspend () ; proc . resume () ; proc . terminate () ; proc...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `process`\n --> /tmp/.tmpqvtQe7/main.rs:1:914\n  |\n1 | ...) ; proc . kill () ; let mut child = process :: spawn (\"ls\" . to_string () , vec ! [\"-la\"]) ; let mut output = child . wait_with_outpu...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `process`\n  |\n  = help: you might be missing a crate named `process`\n\nerror: aborting due to 10 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 3,
          "line_number": 175,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Register signal handlers\nsignal::on(SIGINT, || {\n    println(\"\\nGracefully shutting down...\")\n    cleanup()\n    exit(0)\n})\n\nsignal::on(SIGTERM, || {\n    save_state()\n    exit(0)\n})\n\nsignal::on(SIGUSR1, || {\n    reload_config()\n})\n\n// Send signals to other processes\nlet target_pid = 1234\nsignal::send(target_pid, SIGUSR1)\n\n// Block/unblock signals\nsignal::block([SIGPIPE])\ncritical_operation()\nsignal::unblock([SIGPIPE])",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 4,
          "line_number": 214,
          "code": "// Status: ❌ BROKEN\n\n// Get memory information\nlet mem_info = system::memory_info()\nprintln(\"Total: \" + mem_info.total.to_s())\nprintln(\"Used: \" + mem_info.used.to_s())\nprintln(\"Free: \" + mem_info.free.to_s())\nprintln(\"Available: \" + mem_info.available.to_s())\nprintln(\"Swap Used: \" + mem_info.swap_used.to_s())\n\n// Monitor memory pressure\nif mem_info.available < 100_000_000 {  // Less than 100MB\n    println(\"WARNING: Low memory!\")\n    free_caches()\n}\n\n// Memory-mapped files for large data\nlet mmap = memory::map_file(\"huge_dataset.bin\", READ_ONLY)\nlet data = mmap.read_range(0, 1000000)  // Read 1MB\nmmap.close()\n\n// Shared memory between processes\nlet shared = memory::create_shared(\"my_buffer\", 1024 * 1024)\nshared.write(0, data)\n\n// In another process\nlet shared = memory::open_shared(\"my_buffer\")\nlet data = shared.read(0, 1024)\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpUNubNV/main.rs:1:1035\n  |\n1 | ... data = shared . read (0i32 , 1024i32) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]: cannot find value `_000_000` in this scope\n --> /tmp/.tmpUNubNV/main.rs:1:568\n  |\n1 | ...d . to_s ())) ; if mem_info . available < 100i32 { _000_000 } ; { println ! (\"WARNING: Low memory!\") ; free_caches () } ; let mut mmap...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `READ_ONLY` in this scope\n --> /tmp/.tmpUNubNV/main.rs:1:710\n  |\n1 | ... :: map_file (\"huge_dataset.bin\" . to_string () , READ_ONLY) ; let mut data = mmap . read_range (0i32 , 1000000i32) ; mmap . close () ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpUNubNV/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut mem_info = system :: memory_info () ; println ! (\"{:?}\" , format ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `system`\n --> /tmp/.tmpUNubNV/main.rs:1:84\n  |\n1 | ...) { let result = { let mut mem_info = system :: memory_info () ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total: \" , mem_info . total ....\n  |                                          ^^^^^^ use of unresolved module or unlinked crate `system`\n  |\n  = help: you might be missing a crate named `system`\n\nerror[E0425]: cannot find function `free_caches` in this scope\n --> /tmp/.tmpUNubNV/main.rs:1:620\n  |\n1 | ...0_000 } ; { println ! (\"WARNING: Low memory!\") ; free_caches () } ; let mut mmap = memory :: map_file (\"huge_dataset.bin\" . to_string ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`\n --> /tmp/.tmpUNubNV/main.rs:1:654\n  |\n1 | ...) ; free_caches () } ; let mut mmap = memory :: map_file (\"huge_dataset.bin\" . to_string () , READ_ONLY) ; let mut data = mmap . read_...\n  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`\n  |\n  = help: you might be missing a crate named `memory`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`\n --> /tmp/.tmpUNubNV/main.rs:1:813\n  |\n1 | ... ; mmap . close () ; let mut shared = memory :: create_shared (\"my_buffer\" . to_string () , 1024i32 * 1024i32) ; shared . write (0i32 ...\n  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`\n  |\n  = help: you might be missing a crate named `memory`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `memory`\n --> /tmp/.tmpUNubNV/main.rs:1:936\n  |\n1 | ...rite (0i32 , data) ; let mut shared = memory :: open_shared (\"my_buffer\" . to_string ()) ; let mut data = shared . read (0i32 , 1024i3...\n  |                                          ^^^^^^ use of unresolved module or unlinked crate `memory`\n  |\n  = help: you might be missing a crate named `memory`\n\nerror: aborting due to 8 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 5,
          "line_number": 257,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: service_manager.ruchy\n// Manage system services\n\nprintln(\"=== Service Manager ===\")\n\nlet services = [\n    {name: \"web_server\", command: \"./server\", port: 8080},\n    {name: \"worker\", command: \"./worker\", count: 4},\n    {name: \"scheduler\", command: \"./scheduler\", interval: 60}\n]\n\nlet running_services = {}\n\nfun start_service(service) {\n    println(\"Starting \" + service.name + \"...\")\n    \n    match service.name {\n        \"web_server\" => {\n            let proc = process::spawn(service.command, [\n                \"--port\", service.port.to_s()\n            ])\n            running_services[service.name] = proc\n            \n            // Wait for port to be available\n            while !network::port_is_open(\"localhost\", service.port) {\n                sleep(100)\n            }\n            println(\"✅ \" + service.name + \" listening on port \" + service.port.to_s())\n        }\n        \"worker\" => {\n            let workers = []\n            for i in range(service.count) {\n                let proc = process::spawn(service.command, [\n                    \"--id\", i.to_s()\n                ])\n                workers.push(proc)\n            }\n            running_services[service.name] = workers\n            println(\"✅ Started \" + service.count.to_s() + \" workers\")\n        }\n        \"scheduler\" => {\n            let proc = process::spawn(service.command, [\n                \"--interval\", service.interval.to_s()\n            ])\n            running_services[service.name] = proc\n            println(\"✅ Scheduler running every \" + service.interval.to_s() + \"s\")\n        }\n    }\n}\n\nfun stop_service(name) {\n    if running_services.has_key(name) {\n        println(\"Stopping \" + name + \"...\")\n        let proc = running_services[name]\n        \n        if proc.is_array() {\n            // Multiple processes (workers)\n            for p in proc {\n                p.terminate()\n                p.wait()\n            }\n        } else {\n            // Single process\n            proc.terminate()\n            proc.wait()\n        }\n        \n        running_services.remove(name)\n        println(\"✅ \" + name + \" stopped\")\n    }\n}\n\nfun service_status() {\n    println(\"\\n=== Service Status ===\")\n    for service in services {\n        let status = if running_services.has_key(service.name) {\n            \"🟢 Running\"\n        } else {\n            \"🔴 Stopped\"\n        }\n        println(service.name + \" \" + status)\n    }\n}\n\n// Handle shutdown gracefully\nsignal::on(SIGTERM, || {\n    println(\"\\nShutting down all services...\")\n    for name in running_services.keys() {\n        stop_service(name)\n    }\n    exit(0)\n})\n\n// Interactive management\nloop {\n    service_status()\n    println(\"\\nCommands: start <name>, stop <name>, restart <name>, quit\")\n    let command = input(\"> \").split(\" \")\n    \n    match command[0] {\n        \"start\" => start_service(services.find(|s| s.name == command[1]))\n        \"stop\" => stop_service(command[1])\n        \"restart\" => {\n            stop_service(command[1])\n            start_service(services.find(|s| s.name == command[1]))\n        }\n        \"quit\" => break\n        _ => println(\"Unknown command\")\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 6,
          "line_number": 380,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: health_check.ruchy\n// Monitor system health and alert on issues\n\nprintln(\"=== System Health Checker ===\")\n\nlet checks = {\n    cpu_threshold: 80,      // Alert if CPU > 80%\n    memory_threshold: 90,   // Alert if memory > 90%\n    disk_threshold: 95,     // Alert if disk > 95%\n    load_threshold: 4.0,    // Alert if load average > 4\n    temp_threshold: 80      // Alert if CPU temp > 80°C\n}\n\nlet alerts = []\n\nfun check_cpu() {\n    let usage = system::cpu_usage() * 100\n    if usage > checks.cpu_threshold {\n        alerts.push({\n            level: \"WARNING\",\n            message: \"CPU usage high: \" + usage.to_s() + \"%\",\n            time: current_datetime()\n        })\n        return false\n    }\n    return true\n}\n\nfun check_memory() {\n    let mem = system::memory_info()\n    let usage = (mem.used / mem.total) * 100\n    if usage > checks.memory_threshold {\n        alerts.push({\n            level: \"CRITICAL\",\n            message: \"Memory usage critical: \" + usage.to_s() + \"%\",\n            time: current_datetime()\n        })\n        return false\n    }\n    return true\n}\n\nfun check_disk() {\n    let disks = system::disk_usage()\n    for disk in disks {\n        let usage = (disk.used / disk.total) * 100\n        if usage > checks.disk_threshold {\n            alerts.push({\n                level: \"WARNING\",\n                message: \"Disk \" + disk.mount + \" almost full: \" + usage.to_s() + \"%\",\n                time: current_datetime()\n            })\n            return false\n        }\n    }\n    return true\n}\n\nfun check_load() {\n    let load = system::load_average()\n    let cpu_count = system::cpu_count()\n    let normalized_load = load.one_minute / cpu_count\n    \n    if normalized_load > checks.load_threshold {\n        alerts.push({\n            level: \"WARNING\",\n            message: \"System load high: \" + load.one_minute.to_s() + \",\",\n            time: current_datetime()\n        })\n        return false\n    }\n    return true\n}\n\nfun check_temperature() {\n    let temps = system::temperatures()\n    for sensor in temps {\n        if sensor.current > checks.temp_threshold {\n            alerts.push({\n                level: \"CRITICAL\",\n                message: \"Temperature critical: \" + sensor.name + \" at \" + sensor.current.to_s() + \"°C\",\n                time: current_datetime()\n            })\n            return false\n        }\n    }\n    return true\n}\n\nfun run_health_checks() {\n    let all_healthy = true\n    \n    all_healthy = check_cpu() && all_healthy\n    all_healthy = check_memory() && all_healthy\n    all_healthy = check_disk() && all_healthy\n    all_healthy = check_load() && all_healthy\n    all_healthy = check_temperature() && all_healthy\n    \n    return all_healthy\n}\n\n// Main monitoring loop\nloop {\n    clear_screen()\n    println(\"System Health Check - \" + current_datetime())\n    println(\"=\" * 50)\n    \n    let healthy = run_health_checks()\n    \n    if healthy {\n        println(\"✅ All systems healthy\")\n    } else {\n        println(\"⚠️  Issues detected:\")\n        for alert in alerts.last(5) {\n            let icon = alert.level == \"CRITICAL\" ? \"🔴\" : \"🟡\"\n            println(icon + \" [\" + alert.level + \"] \" + alert.message)\n        }\n    }\n    \n    // Show current stats\n    println(\"\\nCurrent Status:\")\n    let cpu = system::cpu_usage() * 100\n    let mem = system::memory_info()\n    let mem_percent = (mem.used / mem.total) * 100\n    let load = system::load_average()\n    \n    println(\"CPU:    \" + cpu.to_s() + \"% / \" + checks.cpu_threshold.to_s() + \"%\")\n    println(\"Memory: \" + mem_percent.to_s() + \"% / \" + checks.memory_threshold.to_s() + \"%\")\n    println(\"Load:   \" + load.one_minute.to_s() + \" / \" + checks.load_threshold.to_s())\n    \n    // Send notifications for critical alerts\n    for alert in alerts {\n        if alert.level == \"CRITICAL\" {\n            system::notify(alert.message, \"System Health Alert\")\n        }\n    }\n    \n    sleep(5000)  // Check every 5 seconds\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 7,
          "line_number": 532,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: process_tree.ruchy\n// Visualize process hierarchy\n\nfun build_process_tree() {\n    let processes = process::list()\n    let tree = {}\n    \n    // Build parent-child relationships\n    for proc in processes {\n        let ppid = proc.parent_pid\n        if !tree.has_key(ppid) {\n            tree[ppid] = []\n        }\n        tree[ppid].push(proc)\n    }\n    \n    return tree\n}\n\nfun print_tree(pid, tree, indent = \"\") {\n    if !tree.has_key(pid) {\n        return\n    }\n    \n    let children = tree[pid].sort_by(|p| p.pid)\n    for i, proc in children.enumerate() {\n        let is_last = (i == children.len() - 1)\n        let prefix = is_last ? \"└─\" : \"├─\"\n        let extension = is_last ? \"  \" : \"│ \"\n        \n        let memory = format_size(proc.memory_info.rss)\n        println(indent + prefix + \" [\" + proc.pid.to_s() + \"] \" + proc.name + \" (\" + memory + \", \" + proc.cpu_percent.to_s() + \"%)\")\n        \n        // Recursively print children\n        print_tree(proc.pid, tree, indent + extension)\n    }\n}\n\nprintln(\"=== Process Tree ===\")\nlet tree = build_process_tree()\n\n// Start from init (PID 1) or system idle (PID 0)\nlet root_pid = tree.has_key(0) ? 0 : 1\nprintln(\"[\" + root_pid.to_s() + \"] System Root\")\nprint_tree(root_pid, tree)\n\n// Show process statistics\nlet all_procs = process::list()\nlet total_memory = all_procs.map(|p| p.memory_info.rss).sum()\nlet total_cpu = all_procs.map(|p| p.cpu_percent).sum()\n\nprintln(\"\\nTotal Processes: \" + all_procs.len().to_s())\nprintln(\"Total Memory: \" + format_size(total_memory))\nprintln(\"Total CPU: \" + total_cpu.to_s() + \"%\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 8,
          "line_number": 603,
          "code": "// Status: ❌ BROKEN\n\n// Watch for file system events\nlet watcher = fs::watch(\"/path/to/watch\", RECURSIVE)\n\nwatcher.on(\"created\", |path| {\n    println(\"File created: \" + path)\n})\n\nwatcher.on(\"modified\", |path| {\n    println(\"File modified: \" + path)\n    process_change(path)\n})\n\nwatcher.on(\"deleted\", |path| {\n    println(\"File deleted: \" + path)\n})\n\nwatcher.start()\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `RECURSIVE` in this scope\n --> /tmp/.tmp4GkvUy/main.rs:1:130\n  |\n1 | ... = fs :: watch (\"/path/to/watch\" . to_string () , RECURSIVE) ; watcher . on (\"created\" , | path | { println ! (\"{:?}\" , format ! (\"{}{...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp4GkvUy/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut watcher = fs :: watch (\"/path/to/watch\" . to_string () , RECURSIV...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n --> /tmp/.tmp4GkvUy/main.rs:1:83\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut watcher = fs :: watch (\"/path/to/watch\" . to_string () , RECURSIV...\n  |                                                                                   ^^ use of unresolved module or unlinked crate `fs`\n  |\n  = help: you might be missing a crate named `fs`\n\nerror[E0425]: cannot find function `process_change` in this scope\n --> /tmp/.tmp4GkvUy/main.rs:1:356\n  |\n1 | ...format ! (\"{}{}\" , \"File modified: \" , path)) ; process_change (path) }) ; watcher . on (\"deleted\" , | path | { println ! (\"{:?}\" , fo...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-systems-programming.md",
          "example_number": 9,
          "line_number": 635,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Automated system maintenance\nfun auto_cleanup() {\n    // Clean temp files older than 7 days\n    let temp_dir = \"/tmp\"\n    let cutoff_time = current_time() - days(7)\n    \n    for file in fs::walk(temp_dir) {\n        if fs::modified_time(file) < cutoff_time {\n            fs::remove(file)\n            println(\"Cleaned: \" + file)\n        }\n    }\n    \n    // Clear package manager cache\n    if fs::dir_size(\"/var/cache/apt\") > gb(1) {\n        run_command(\"apt-get clean\")\n    }\n    \n    // Rotate logs\n    for log in fs::glob(\"/var/log/*.log\") {\n        if fs::size(log) > mb(100) {\n            fs::rotate_log(log, keep_count: 5)\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch08-00-advanced-functions-tdd": {
      "chapter": "ch08-00-advanced-functions-tdd",
      "total_examples": 9,
      "working_examples": 5,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun double(x: i32) -> i32 {\n    return x * 2;\n}\n\nfun add_ten(x: i32) -> i32 {\n    return x + 10;\n}\n\nfun main() {\n    let x = 5;\n    let doubled = double(x);\n    let result = add_ten(doubled);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 2,
          "line_number": 61,
          "code": "// Status: ✅ WORKING\nfun classify_number(x: i32) -> i32 {\n    if x < 0 {\n        return -1;\n    }\n    if x == 0 {\n        return 0;\n    }\n    return 1;\n}\n\nfun main() {\n    println(classify_number(-5));\n    println(classify_number(0));\n    println(classify_number(10));\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 3,
          "line_number": 93,
          "code": "// Status: ✅ WORKING\nfun factorial(n: i32) -> i32 {\n    if n <= 1 {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nfun main() {\n    println(factorial(1));\n    println(factorial(3));\n    println(factorial(5));\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 4,
          "line_number": 141,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun step_one(x: Type) -> Type { ... }\nfun step_two(x: Type) -> Type { ... }\n\n// Usage\nlet intermediate = step_one(input);\nlet result = step_two(intermediate);",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 5,
          "line_number": 155,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfun categorize(input: Type) -> ResultType {\n    if condition1 {\n        return result1;\n    }\n    if condition2 {\n        return result2;\n    }\n    return default_result;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `Type` in this scope\n --> /tmp/.tmpXMkkPT/main.rs:1:60\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |                                                            ^^^^ not found in this scope\n\nerror[E0412]: cannot find type `ResultType` in this scope\n --> /tmp/.tmpXMkkPT/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |                                                                     ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `condition1` in this scope\n --> /tmp/.tmpXMkkPT/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |                                                                                       ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `result1` in this scope\n --> /tmp/.tmpXMkkPT/main.rs:1:109\n  |\n1 | ...: Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn m...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `condition2` in this scope\n --> /tmp/.tmpXMkkPT/main.rs:1:126\n  |\n1 | ...ype { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `result2` in this scope\n --> /tmp/.tmpXMkkPT/main.rs:1:148\n  |\n1 | ... { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `default_result` in this scope\n --> /tmp/.tmpXMkkPT/main.rs:1:169\n  |\n1 | ...; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpXMkkPT/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXMkkPT/main.rs:1:100\n  |\n1 | use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 {...\n  |                                                                                                    ^^              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { return result1 } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXMkkPT/main.rs:1:139\n  |\n1 | ... { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n  |                                                              ^^              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { { return result2 } } ; return default_result } } fn main () { }\n1 + use std :: collections :: HashMap ; fn categorize (input : Type) -> ResultType { { if condition1 { { return result1 } } ; if condition2 { return result2 } ; return default_result } } fn main () { }\n  |\n\nerror: aborting due to 7 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 6,
          "line_number": 172,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfun recursive_func(n: Type) -> Type {\n    if base_condition {\n        return base_value;\n    }\n    return combine(n, recursive_func(reduce(n)));\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `Type` in this scope\n --> /tmp/.tmpLSiEzD/main.rs:1:60\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |                                                            ^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Type` in this scope\n --> /tmp/.tmpLSiEzD/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |                                                                     ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `base_condition` in this scope\n --> /tmp/.tmpLSiEzD/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |                                                                                 ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `base_value` in this scope\n --> /tmp/.tmpLSiEzD/main.rs:1:107\n  |\n1 | ... : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpLSiEzD/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpLSiEzD/main.rs:1:98\n  |\n1 | use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine...\n  |                                                                                                  ^^                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn recursive_func (n : Type) -> Type { { if base_condition { return base_value } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n  |\n\nerror[E0425]: cannot find function `reduce` in this scope\n --> /tmp/.tmpLSiEzD/main.rs:1:160\n  |\n1 | ...ase_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `combine` in this scope\n --> /tmp/.tmpLSiEzD/main.rs:1:131\n  |\n1 | ... base_condition { { return base_value } } ; return combine (n , recursive_func (reduce (n))) } } fn main () { }\n  |                                                       ^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 7,
          "line_number": 200,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun validate(input: i32) -> i32 { ... }\nfun normalize(input: i32) -> i32 { ... }\nfun process(input: i32) -> i32 { ... }\n\n// Usage\nlet clean_input = validate(raw_input);\nlet normal_input = normalize(clean_input);\nlet result = process(normal_input);",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 8,
          "line_number": 216,
          "code": "// Status: ✅ WORKING\nfun get_grade(score: i32) -> i32 {\n    if score >= 90 {\n        return 4; // A\n    }\n    if score >= 80 {\n        return 3; // B\n    }\n    if score >= 70 {\n        return 2; // C\n    }\n    return 1; // D/F\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch08-00-advanced-functions-tdd.md",
          "example_number": 9,
          "line_number": 235,
          "code": "// Status: ✅ WORKING\nfun countdown(n: i32) -> i32 {\n    if n <= 0 {\n        return 0;\n    }\n    println(n);\n    return countdown(n - 1);\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch13-00-error-handling": {
      "chapter": "ch13-00-error-handling",
      "total_examples": 12,
      "working_examples": 0,
      "failing_examples": 12,
      "examples": [
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 1,
          "line_number": 48,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Define error types\nenum AppError {\n    NetworkError(String)\n    ParseError(String)\n    NotFound(String)\n    Unauthorized\n}\n\n// Functions return Result\nfun fetch_user(id: i32) -> Result<User, AppError> {\n    // Note: In v1.10.0, the ? operator is removed. Use match for error handling:\n    let response = match http::get(\"/api/users/\" + id.to_s()) {\n        Ok(r) => r,\n        Err(e) => return Err(AppError::NetworkError(e))\n    }\n    \n    if response.status == 404 {\n        return Err(AppError::NotFound(\"User \" + id.to_s() + \" not found\"))\n    }\n    \n    if response.status == 401 {\n        return Err(AppError::Unauthorized)\n    }\n    \n    let user = match parse_json(response.body) {\n        Ok(u) => u,\n        Err(e) => return Err(AppError::ParseError(e.to_string()))\n    }\n    \n    return Ok(user)\n}\n\n// Handle errors explicitly\nmatch fetch_user(123) {\n    Ok(user) => {\n        println(\"Found user: \" + user.name)\n    }\n    Err(AppError::NotFound(msg)) => {\n        println(\"User not found: \" + msg)\n    }\n    Err(AppError::NetworkError(e)) => {\n        println(\"Network problem: \" + e.to_s())\n        retry_with_backoff()\n    }\n    Err(e) => {\n        log_error(e)\n        return_default_user()\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 2,
          "line_number": 116,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Result is an enum with two variants\nenum Result<T, E> {\n    Ok(T)    // Success with value\n    Err(E)   // Error with error value\n}\n\n// Functions that can fail return Result\nfun divide(a: f64, b: f64) -> Result<f64, String> {\n    if b == 0.0 {\n        return Err(\"Division by zero\")\n    }\n    return Ok(a / b)\n}\n\n// Check and handle results\nlet result = divide(10.0, 2.0)\nif result.is_ok() {\n    println(\"Result: \" + result.unwrap().to_s())\n} else {\n    println(\"Error: \" + result.unwrap_err().to_s())\n}\n\n// Pattern matching\nmatch divide(10.0, 0.0) {\n    Ok(value) => println(\"Success: \" + value.to_s())\n    Err(error) => println(\"Failed: \" + error.to_s())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 3,
          "line_number": 158,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Option represents nullable values\nenum Option<T> {\n    Some(T)  // Value present\n    None     // Value absent\n}\n\n// Functions that might not return a value\nfun find_user(name: String) -> Option<User> {\n    let users = load_users()\n    for user in users {\n        if user.name == name {\n            return Some(user)\n        }\n    }\n    return None\n}\n\n// Safe handling of missing values\nlet user = find_user(\"Alice\")\nif let Some(u) = user {\n    println(\"Found: \" + u.email)\n} else {\n    println(\"User not found\")\n}\n\n// Chain operations safely\nlet email = find_user(\"Bob\")\n    .map(|u| u.email)\n    .unwrap_or(\"no-email@example.com\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 4,
          "line_number": 202,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Without ? operator - verbose\nfun process_file_verbose(path: String) -> Result<String, Error> {\n    let file = match open_file(path) {\n        Ok(f) => f\n        Err(e) => return Err(e)\n    }\n    \n    let contents = match read_all(file) {\n        Ok(c) => c\n        Err(e) => return Err(e)\n    }\n    \n    let processed = match process(contents) {\n        Ok(p) => p\n        Err(e) => return Err(e)\n    }\n    \n    return Ok(processed)\n}\n\n// In v1.10.0 - use explicit error handling\nfun process_file(path: String) -> Result<String, Error> {\n    let file = match open_file(path) {\n        Ok(f) => f,\n        Err(e) => return Err(e)\n    }\n    let contents = match read_all(file) {\n        Ok(c) => c,\n        Err(e) => return Err(e)\n    }\n    let processed = match process(contents) {\n        Ok(p) => p,\n        Err(e) => return Err(e)\n    }\n    return Ok(processed)\n}\n\n// Chain multiple operations with explicit handling\nfun complex_operation() -> Result<Data, Error> {\n    let data = match fetch_data() {\n        Ok(d) => d,\n        Err(e) => return Err(e)\n    }\n    let validated = match data.validate() {\n        Ok(v) => v,\n        Err(e) => return Err(e)\n    }\n    let transformed = match validated.transform() {\n        Ok(t) => t,\n        Err(e) => return Err(e)\n    }\n    let optimized = match transformed.optimize() {\n        Ok(o) => o,\n        Err(e) => return Err(e)\n    }\n    \n    return Ok(optimized)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 5,
          "line_number": 275,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Detailed error enum\nenum DatabaseError {\n    ConnectionFailed { host: String, port: i32 }\n    QueryFailed { query: String, error: String }\n    Timeout { duration: i32 }\n    InvalidCredentials\n}\n\nimpl Display for DatabaseError {\n    fun fmt(self, f: Formatter) -> Result {\n        match self {\n            ConnectionFailed{host, port} => \n                write(f, \"Failed to connect to \" + host + \":\" + port.to_s())\n            QueryFailed{query, error} => \n                write(f, \"Query failed: \" + query + \"\\nError: \" + error)\n            Timeout{duration} => \n                write(f, \"Operation timed out after \" + duration.to_s() + \"ms\")\n            InvalidCredentials => \n                write(f, \"Invalid database credentials\")\n        }\n    }\n}\n\n// Error with context\nstruct Error {\n    kind: ErrorKind\n    message: String\n    source: Option<Box<Error>>\n    backtrace: Backtrace\n}\n\nimpl Error {\n    fun new(kind: ErrorKind, message: String) -> Error {\n        return Error{\n            kind,\n            message,\n            source: None,\n            backtrace: Backtrace::capture()\n        }\n    }\n    \n    fun with_source(mut self, source: Error) -> Error {\n        self.source = Some(Box::new(source))\n        return self\n    }\n    \n    fun chain(self) -> Vec<String> {\n        let mut messages = vec![self.message]\n        let mut current = self.source\n        \n        while let Some(error) = current {\n            messages.push(error.message)\n            current = error.source\n        }\n        \n        return messages\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 6,
          "line_number": 350,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun validate_user(user: User) -> Result<User, ValidationError> {\n    // Early return on validation failures\n    if user.name.is_empty() {\n        return Err(ValidationError::EmptyName)\n    }\n    \n    if !is_valid_email(user.email) {\n        return Err(ValidationError::InvalidEmail(user.email))\n    }\n    \n    if user.age < 0 || user.age > 150 {\n        return Err(ValidationError::InvalidAge(user.age))\n    }\n    \n    // All validations passed\n    return Ok(user)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 7,
          "line_number": 382,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Retry with exponential backoff\nfun fetch_with_retry<T>(\n    operation: Fn() -> Result<T, Error>,\n    max_attempts: i32\n) -> Result<T, Error> {\n    let mut attempt = 0\n    let mut delay = 1000  // Start with 1 second\n    \n    loop {\n        match operation() {\n            Ok(result) => return Ok(result)\n            Err(e) if attempt >= max_attempts => {\n                return Err(e)\n            }\n            Err(e) => {\n                println(\"Attempt \" + (attempt + 1).to_s() + \" failed: \" + e.to_s())\n                sleep(delay)\n                delay *= 2  // Exponential backoff\n                attempt += 1\n            }\n        }\n    }\n}\n\n// Fallback strategies\nfun get_config() -> Config {\n    load_config_file()\n        .or_else(|| load_env_config())\n        .or_else(|| fetch_remote_config())\n        .unwrap_or_else(|| Config::default())\n}\n\n// Circuit breaker pattern\nstruct CircuitBreaker {\n    failure_count: i32\n    last_failure: Option<Instant>\n    state: State\n}\n\nimpl CircuitBreaker {\n    fn call<T>(mut self, f: Fn() -> Result<T, Error>) -> Result<T, Error> {\n        match self.state {\n            State::Open => {\n                if self.should_attempt() {\n                    self.state = State::HalfOpen\n                } else {\n                    return Err(Error::CircuitOpen)\n                }\n            }\n            _ => {}\n        }\n        \n        match f() {\n            Ok(result) => {\n                self.reset()\n                Ok(result)\n            }\n            Err(e) => {\n                self.record_failure()\n                Err(e)\n            }\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 8,
          "line_number": 461,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Trait for adding context\ntrait Context<T> {\n    fun context(self, msg: String) -> Result<T, Error>\n    fun with_context<F>(self, f: F) -> Result<T, Error>\n        where F: FnOnce() -> String\n}\n\nimpl<T, E: Into<Error>> Context<T> for Result<T, E> {\n    fun context(self, msg: String) -> Result<T, Error> {\n        self.map_err(|e| {\n            Error::new(e.into())\n                .with_message(msg)\n        })\n    }\n    \n    fun with_context<F>(self, f: F) -> Result<T, Error>\n        where F: FnOnce() -> String\n    {\n        self.map_err(|e| {\n            Error::new(e.into())\n                .with_message(f())\n        })\n    }\n}\n\n// Use context for better errors\nfun process_order(order_id: i32) -> Result<Order, Error> {\n    let order = fetch_order(order_id)\n        .context(\"Failed to fetch order \" + order_id)??\n    \n    let validated = validate_order(order)\n        .context(\"Order validation failed\")?\n    \n    let processed = process_payment(validated)\n        .with_context(|| \"Payment processing failed for $\" + validated.total.to_s())??\n    \n    return Ok(processed)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 9,
          "line_number": 514,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Structured API errors\nstruct ApiError {\n    status: i32\n    code: String\n    message: String\n    details: Option<Map<String, Any>>\n}\n\nimpl ApiError {\n    fun bad_request(message: String) -> ApiError {\n        ApiError{\n            status: 400,\n            code: \"BAD_REQUEST\",\n            message,\n            details: None\n        }\n    }\n    \n    fun unauthorized() -> ApiError {\n        ApiError{\n            status: 401,\n            code: \"UNAUTHORIZED\",\n            message: \"Authentication required\",\n            details: None\n        }\n    }\n    \n    fun internal_error(error: Error) -> ApiError {\n        // Log full error internally\n        log::error(\"Internal error: \" + error.chain().join(\" -> \"))\n        \n        // Return sanitized error to client\n        ApiError{\n            status: 500,\n            code: \"INTERNAL_ERROR\",\n            message: \"An internal error occurred\",\n            details: None\n        }\n    }\n}\n\n// Convert to HTTP response\nimpl IntoResponse for ApiError {\n    fun into_response(self) -> Response {\n        Response::builder()\n            .status(self.status)\n            .json(self)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 10,
          "line_number": 576,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Composable validators\ntype Validator<T> = Fn(T) -> Result<T, ValidationError>\n\nfun validate_pipeline<T>(\n    value: T,\n    validators: Vec<Validator<T>>\n) -> Result<T, Vec<ValidationError>> {\n    let mut errors = Vec::new()\n    let mut current = value\n    \n    for validator in validators {\n        match validator(current) {\n            Ok(validated) => current = validated\n            Err(e) => errors.push(e)\n        }\n    }\n    \n    if errors.is_empty() {\n        Ok(current)\n    } else {\n        Err(errors)\n    }\n}\n\n// Use validation pipeline\nlet user_validators = vec![\n    validate_required_fields,\n    validate_email_format,\n    validate_age_range,\n    validate_unique_username\n]\n\nmatch validate_pipeline(user, user_validators) {\n    Ok(valid_user) => save_user(valid_user)\n    Err(errors) => {\n        for error in errors {\n            println(\"Validation error: \" + error.to_s())\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 11,
          "line_number": 629,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Async Result type\nasync fun fetch_data(url: String) -> Result<Data, Error> {\n    let response = http::get(url).await?\n    let parsed = parse_response(response).await?\n    return Ok(parsed)\n}\n\n// Try multiple sources\nasync fun get_data_with_fallback() -> Result<Data, Error> {\n    // Try primary source\n    if let Ok(data) = fetch_data(PRIMARY_URL).await {\n        return Ok(data)\n    }\n    \n    // Try backup source\n    if let Ok(data) = fetch_data(BACKUP_URL).await {\n        return Ok(data)\n    }\n    \n    // Try cache\n    if let Some(cached) = get_cached_data().await {\n        log::warn(\"Using stale cached data\")\n        return Ok(cached)\n    }\n    \n    return Err(Error::NoDataAvailable)\n}\n\n// Parallel error handling\nasync fun fetch_all(urls: Vec<String>) -> Vec<Result<Data, Error>> {\n    let futures = urls.map(|url| fetch_data(url))\n    return join_all(futures).await\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch13-00-error-handling.md",
          "example_number": 12,
          "line_number": 675,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n#[test]\nfun test_error_handling() {\n    // Test expected errors\n    let result = divide(10.0, 0.0)\n    assert!(result.is_err())\n    assert_eq!(result.unwrap_err(), \"Division by zero\")\n    \n    // Test error propagation\n    let result = process_invalid_file()\n    assert!(matches!(result, Err(FileError::NotFound(_))))\n    \n    // Test recovery\n    let config = get_config_with_fallback()\n    assert!(config.is_valid())  // Should always succeed\n}\n\n#[test]\n#[should_panic(expected = \"assertion failed\")]\nfun test_panic_condition() {\n    unsafe_operation()\n}\n\n// Property-based testing for error conditions\n#[property_test]\nfun never_panics(input: RandomInput) {\n    let _ = safe_process(input)  // Should never panic\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch03-01-testing-functions": {
      "chapter": "ch03-01-testing-functions",
      "total_examples": 12,
      "working_examples": 0,
      "failing_examples": 12,
      "examples": [
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n// Your function\nfun add(a, b) {\n    a + b\n}\n\n// Your test\n#[test]\nfun test_add() {\n    assert_eq!(add(2, 3), 5)\n    assert_eq!(add(0, 0), 0)\n    assert_eq!(add(-1, 1), 0)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpR9QF7Z/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i32 , b : i32) -> i32 { { a + b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpR9QF7Z/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn add (a : i32 , b : i32) -> i32 { { a + b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i...\n  |                                                                         ^^     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn add (a : i32 , b : i32) -> i32 { { a + b } } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn add (a : i32 , b : i32) -> i32 { a + b } fn test_add () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) ; assert_eq ! (add (0i32 , 0i32) , 0i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpR9QF7Z/main.rs:1:193\n  |\n1 | ...q ! (add (0i32 , 0i32) , 0i32) ; assert_eq ! (add (- 1i32 , 1i32) , 0i32) } } fn main () { }\n  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0317`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 2,
          "line_number": 68,
          "code": "// Status: ❌ BROKEN\n#[test]\nfun test_function_name() {\n    // Test code here\n    assert_eq!(actual, expected)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `actual` in this scope\n --> /tmp/.tmpQcQTRZ/main.rs:1:86\n  |\n1 | use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }\n  |                                                                                      ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `expected` in this scope\n --> /tmp/.tmpQcQTRZ/main.rs:1:95\n  |\n1 | use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }\n  |                                                                                               ^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpQcQTRZ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpQcQTRZ/main.rs:1:71\n  |\n1 | use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }\n  |                                                                       ^^                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test_function_name () -> i32 { assert_eq ! (actual , expected) } fn main () { }\n  |\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpQcQTRZ/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn test_function_name () -> i32 { { assert_eq ! (actual , expected) } } fn main () { }\n  |                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0317, E0425.\nFor more information about an error, try `rustc --explain E0317`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 3,
          "line_number": 98,
          "code": "// Status: ❌ BROKEN\n// tests/calculator_test.ruchy\n\nuse super::*;  // Import functions from main module\n\n#[test]\nfun test_addition() {\n    assert_eq!(add(2, 3), 5)\n}\n\n#[test]  \nfun test_subtraction() {\n    assert_eq!(subtract(10, 4), 6)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0433]: failed to resolve: there are too many leading `super` keywords\n --> /tmp/.tmpAkrA9B/main.rs:1:211\n  |\n1 | ...0i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }\n  |                                              ^^^^^ there are too many leading `super` keywords\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpAkrA9B/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () -> i...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpAkrA9B/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () -> i...\n  |                                                                  ^^                                      ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () -> i32 { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }\n1 + use std :: collections :: HashMap ; fn test_addition () -> i32 { assert_eq ! (add (2i32 , 3i32) , 5i32) } fn test_subtraction () -> i32 { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpAkrA9B/main.rs:1:143\n  |\n1 | ... 5i32) } } fn test_subtraction () -> i32 { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }\n  |                                               ^^                                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () -> i32 { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }\n1 + use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () -> i32 { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } fn main () { use super :: * ; ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpAkrA9B/main.rs:1:224\n  |\n1 | ...2 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror[E0425]: cannot find function `add` in this scope\n --> /tmp/.tmpAkrA9B/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () -> i...\n  |                                                                                 ^^^ not found in this scope\n  |\nhelp: use the `.` operator to call the method `Add::add` on `i32`\n  |\n1 - use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () -> i32 { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }\n1 + use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (2i32.add(3i32) , 5i32) } } fn test_subtraction () -> i32 { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }\n  |\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpAkrA9B/main.rs:1:68\n  |\n1 | use std :: collections :: HashMap ; fn test_addition () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn test_subtraction () -> i...\n  |                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `subtract` in this scope\n --> /tmp/.tmpAkrA9B/main.rs:1:158\n  |\n1 | ...} } fn test_subtraction () -> i32 { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpAkrA9B/main.rs:1:145\n  |\n1 | ...test_subtraction () -> i32 { { assert_eq ! (subtract (10i32 , 4i32) , 6i32) } } fn main () { use super :: * ; ; }\n  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 5 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0317, E0425, E0433.\nFor more information about an error, try `rustc --explain E0317`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 4,
          "line_number": 128,
          "code": "// Status: ❌ BROKEN\n// calculator.ruchy\nfun multiply(a, b) {\n    a * b\n}\n\nfun divide(a, b) {\n    if b == 0 {\n        0  // Simple handling for now\n    } else {\n        a / b\n    }\n}\n\nfun is_even(n) {\n    n % 2 == 0\n}\n\n// tests/calculator_test.ruchy  \n#[test]\nfun test_multiply() {\n    assert_eq!(multiply(3, 4), 12)\n    assert_eq!(multiply(0, 5), 0)\n    assert_eq!(multiply(-2, 3), -6)\n}\n\n#[test]\nfun test_divide() {\n    assert_eq!(divide(10, 2), 5)\n    assert_eq!(divide(7, 3), 2)  // Integer division\n    assert_eq!(divide(5, 0), 0)  // Division by zero handled\n}\n\n#[test]\nfun test_is_even() {\n    assert!(is_even(4))        // 4 is even\n    assert!(!is_even(3))       // 3 is not even  \n    assert!(is_even(0))        // 0 is even\n    assert!(!is_even(-1))      // -1 is not even\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpt7f1zx/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b ==...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpt7f1zx/main.rs:1:78\n  |\n1 | use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b ==...\n  |                                                                              ^^     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { a * b } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpt7f1zx/main.rs:1:129\n  |\n1 | ...} } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32...\n  |                                               ^^                                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { if b == 0i32 { { 0i32 } } else { { a / b } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpt7f1zx/main.rs:1:146\n  |\n1 | ... b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2...\n  |                                                                   ^^    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { 0i32 } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpt7f1zx/main.rs:1:164\n  |\n1 | ... : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn ...\n  |                                                                  ^^     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { a / b } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpt7f1zx/main.rs:1:210\n  |\n1 | ...} } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (...\n  |                                                             ^^                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn multiply (a : i32 , b : i32) -> i32 { { a * b } } fn divide (a : i32 , b : i32) -> i32 { { if b == 0i32 { { 0i32 } } else { { a / b } } } } fn is_even (n : i32) -> i32 { n % 2i32 == 0i32 } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32) , 12i32) ; assert_eq ! (multiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpt7f1zx/main.rs:1:212\n  |\n1 | ...{ a / b } } } } fn is_even (n : i32) -> i32 { { n % 2i32 == 0i32 } } fn test_multiply () -> i32 { { assert_eq ! (multiply (3i32 , 4i32...\n  |                                            ---     ^^^^^^^^^^^^^^^^ expected `i32`, found `bool`\n  |                                            |\n  |                                            expected `i32` because of return type\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpt7f1zx/main.rs:1:357\n  |\n1 | ...tiply (0i32 , 5i32) , 0i32) ; assert_eq ! (multiply (- 2i32 , 3i32) , - 6i32) } } fn test_divide () -> i32 { { assert_eq ! (divide (10...\n  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpt7f1zx/main.rs:1:527\n  |\n1 | ... (divide (7i32 , 3i32) , 2i32) ; assert_eq ! (divide (5i32 , 0i32) , 0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32))...\n  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpt7f1zx/main.rs:1:603\n  |\n1 | ...0i32) } } fn test_is_even () -> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert !...\n  |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpt7f1zx/main.rs:1:631\n  |\n1 | ...-> i32 { { assert ! (is_even (4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn ...\n  |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpt7f1zx/main.rs:1:661\n  |\n1 | ...(4i32)) ; assert ! (! is_even (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }\n  |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpt7f1zx/main.rs:1:689\n  |\n1 | ...(3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }\n  |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpt7f1zx/main.rs:1:689\n  |\n1 | ... (3i32)) ; assert ! (is_even (0i32)) ; assert ! (! is_even (- 1i32)) } } fn main () { }\n  |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |                                           |\n  |                                           expected `i32`, found `()`\n  |                                           found here\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n\nerror: aborting due to 8 previous errors; 6 warnings emitted\n\nSome errors have detailed explanations: E0308, E0317.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 5,
          "line_number": 182,
          "code": "// Status: ❌ BROKEN\nfun find_max(numbers) {\n    if numbers.len() == 0 {\n        -999999  // Sentinel value for empty\n    } else {\n        let mut max_val = numbers[0]\n        let mut i = 1\n        while i < numbers.len() {\n            if numbers[i] > max_val {\n                max_val = numbers[i]\n            }\n            i = i + 1\n        }\n        max_val\n    }\n}\n\n#[test]\nfun test_find_max() {\n    // Normal cases\n    assert_eq!(find_max([1, 5, 3, 9, 2]), 9)\n    assert_eq!(find_max([10]), 10)\n    \n    // Edge cases\n    assert_eq!(find_max([]), -999999)        // Empty list\n    assert_eq!(find_max([-5, -1, -10]), -1)  // All negative\n    assert_eq!(find_max([5, 5, 5]), 5)       // All same\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmprTczrd/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmprTczrd/main.rs:1:77\n  |\n1 | ... { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmprTczrd/main.rs:1:109\n  |\n1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...\n  |                                                                                                             ^^           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { - 999999i32 } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmprTczrd/main.rs:1:266\n  |\n1 | ... . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_fi...\n  |                                                      ^^                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { max_val = numbers [i as usize] } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmprTczrd/main.rs:1:102\n  |\n1 | ...nd_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize...\n  |                                            ----------------    ^^^^ expected `usize`, found `i32`\n  |                                            |\n  |                                            expected because this is `usize`\n  |\nhelp: change the type of the numeric literal from `i32` to `usize`\n  |\n1 - use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0usize { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }\n  |\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmprTczrd/main.rs:1:163\n  |\n1 | ...2 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] >...\n  |                                              ^^^^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmprTczrd/main.rs:1:209\n  |\n1 | ...0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize...\n  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`\n  |                                              |\n  |                                              expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { let mut max_val = numbers [0i32 as usize] ; let mut i = 1i32 ; while i < numbers . len ().try_into().unwrap() { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }\n  |                                                                                                                                                                                                                                 ++++++++++++++++++++\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmprTczrd/main.rs:1:242\n  |\n1 | ...while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val }...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmprTczrd/main.rs:1:287\n  |\n1 | ...as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } } } fn test_find_max () -> i32 { { assert_...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmprTczrd/main.rs:1:394\n  |\n1 | ...-> i32 { { assert_eq ! (find_max (vec ! [1i32 , 5i32 , 3i32 , 9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ;...\n  |                            --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `Vec<i32>`\n  |                            |\n  |                            arguments to this function are incorrect\n  |\n  = note: expected struct `String`\n             found struct `Vec<i32>`\nnote: function defined here\n --> /tmp/.tmprTczrd/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...\n  |                                        ^^^^^^^^  ----------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmprTczrd/main.rs:1:469\n  |\n1 | ...9i32 , 2i32]) , 9i32) ; assert_eq ! (find_max (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq !...\n  |                                         --------  ^^^^^^^^^^^^^ expected `String`, found `Vec<i32>`\n  |                                         |\n  |                                         arguments to this function are incorrect\n  |\n  = note: expected struct `String`\n             found struct `Vec<i32>`\nnote: function defined here\n --> /tmp/.tmprTczrd/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...\n  |                                        ^^^^^^^^  ----------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmprTczrd/main.rs:1:518\n  |\n1 | ... (vec ! [10i32]) , 10i32) ; assert_eq ! (find_max (vec ! []) , - 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]...\n  |                                             --------  ^^^^^^^^ expected `String`, found `Vec<_>`\n  |                                             |\n  |                                             arguments to this function are incorrect\n  |\n  = note: expected struct `String`\n             found struct `Vec<_>`\nnote: function defined here\n --> /tmp/.tmprTczrd/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...\n  |                                        ^^^^^^^^  ----------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmprTczrd/main.rs:1:568\n  |\n1 | ... 999999i32) ; assert_eq ! (find_max (vec ! [- 5i32 , - 1i32 , - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32])...\n  |                               --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `Vec<i32>`\n  |                               |\n  |                               arguments to this function are incorrect\n  |\n  = note: expected struct `String`\n             found struct `Vec<i32>`\nnote: function defined here\n --> /tmp/.tmprTczrd/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...\n  |                                        ^^^^^^^^  ----------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmprTczrd/main.rs:1:638\n  |\n1 | ...i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }\n  |                                   --------  ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `Vec<i32>`\n  |                                   |\n  |                                   arguments to this function are incorrect\n  |\n  = note: expected struct `String`\n             found struct `Vec<i32>`\nnote: function defined here\n --> /tmp/.tmprTczrd/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn find_max (numbers : String) -> i32 { { if numbers . len () == 0i32 { { - 999999i32 } } else { { le...\n  |                                        ^^^^^^^^  ----------------\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmprTczrd/main.rs:1:615\n  |\n1 | ..., - 10i32]) , - 1i32) ; assert_eq ! (find_max (vec ! [5i32 , 5i32 , 5i32]) , 5i32) } } fn main () { }\n  |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 11 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0317.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 6,
          "line_number": 222,
          "code": "// Status: ❌ BROKEN\nfun clean_username(raw_username) {\n    // Simple cleaning - replace spaces with underscores\n    raw_username.replace(\" \", \"_\")\n}\n\nfun count_vowels(text) {\n    let vowels = \"aeiouAEIOU\"\n    let mut count = 0\n    let mut i = 0\n    while i < text.len() {\n        if vowels.contains(text[i]) {\n            count = count + 1\n        }\n        i = i + 1\n    }\n    count\n}\n\n#[test]\nfun test_clean_username() {\n    assert_eq!(clean_username(\"Alice Johnson\"), \"Alice_Johnson\")\n    assert_eq!(clean_username(\"JOHN\"), \"JOHN\")\n    assert_eq!(clean_username(\"\"), \"\")\n}\n\n#[test]\nfun test_count_vowels() {\n    assert_eq!(count_vowels(\"hello\"), 2)      // e, o\n    assert_eq!(count_vowels(\"HELLO\"), 2)      // Case insensitive\n    assert_eq!(count_vowels(\"xyz\"), 0)        // No vowels\n    assert_eq!(count_vowels(\"aeiou\"), 5)      // All vowels\n    assert_eq!(count_vowels(\"\"), 0)           // Empty string\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmphbNaZR/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (\" \" , \"_\") } } fn count_...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmphbNaZR/main.rs:1:88\n  |\n1 | use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (\" \" , \"_\") } } fn count_...\n  |                                                                                        ^^                                  ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (\" \" , \"_\") } } fn count_vowels (text : String) -> i32 { { { let vowels = \"aeiouAEIOU\" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username (\"Alice Johnson\" . to_string ()) , \"Alice_Johnson\") ; assert_eq ! (clean_username (\"JOHN\" . to_string ()) , \"JOHN\") ; assert_eq ! (clean_username (\"\" . to_string ()) , \"\") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels (\"hello\" . to_string ()) , 2i32) ; assert_eq ! (count_vowels (\"HELLO\" . to_string ()) , 2i32) ; assert_eq ! (count_vowels (\"xyz\" . to_string ()) , 0i32) ; assert_eq ! (count_vowels (\"aeiou\" . to_string ()) , 5i32) ; assert_eq ! (count_vowels (\"\" . to_string ()) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { raw_username . replace (\" \" , \"_\") } fn count_vowels (text : String) -> i32 { { { let vowels = \"aeiouAEIOU\" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username (\"Alice Johnson\" . to_string ()) , \"Alice_Johnson\") ; assert_eq ! (clean_username (\"JOHN\" . to_string ()) , \"JOHN\") ; assert_eq ! (clean_username (\"\" . to_string ()) , \"\") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels (\"hello\" . to_string ()) , 2i32) ; assert_eq ! (count_vowels (\"HELLO\" . to_string ()) , 2i32) ; assert_eq ! (count_vowels (\"xyz\" . to_string ()) , 0i32) ; assert_eq ! (count_vowels (\"aeiou\" . to_string ()) , 5i32) ; assert_eq ! (count_vowels (\"\" . to_string ()) , 0i32) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmphbNaZR/main.rs:1:170\n  |\n1 | ... { { { let vowels = \"aeiouAEIOU\" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } ...\n  |       ^^                                                                                                                                                                                                                         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (\" \" , \"_\") } } fn count_vowels (text : String) -> i32 { { { let vowels = \"aeiouAEIOU\" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username (\"Alice Johnson\" . to_string ()) , \"Alice_Johnson\") ; assert_eq ! (clean_username (\"JOHN\" . to_string ()) , \"JOHN\") ; assert_eq ! (clean_username (\"\" . to_string ()) , \"\") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels (\"hello\" . to_string ()) , 2i32) ; assert_eq ! (count_vowels (\"HELLO\" . to_string ()) , 2i32) ; assert_eq ! (count_vowels (\"xyz\" . to_string ()) , 0i32) ; assert_eq ! (count_vowels (\"aeiou\" . to_string ()) , 5i32) ; assert_eq ! (count_vowels (\"\" . to_string ()) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (\" \" , \"_\") } } fn count_vowels (text : String) -> i32 { { let vowels = \"aeiouAEIOU\" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username (\"Alice Johnson\" . to_string ()) , \"Alice_Johnson\") ; assert_eq ! (clean_username (\"JOHN\" . to_string ()) , \"JOHN\") ; assert_eq ! (clean_username (\"\" . to_string ()) , \"\") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels (\"hello\" . to_string ()) , 2i32) ; assert_eq ! (count_vowels (\"HELLO\" . to_string ()) , 2i32) ; assert_eq ! (count_vowels (\"xyz\" . to_string ()) , 0i32) ; assert_eq ! (count_vowels (\"aeiou\" . to_string ()) , 5i32) ; assert_eq ! (count_vowels (\"\" . to_string ()) , 0i32) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmphbNaZR/main.rs:1:332\n  |\n1 | ... len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_use...\n  |                                                           ^^                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (\" \" , \"_\") } } fn count_vowels (text : String) -> i32 { { { let vowels = \"aeiouAEIOU\" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username (\"Alice Johnson\" . to_string ()) , \"Alice_Johnson\") ; assert_eq ! (clean_username (\"JOHN\" . to_string ()) , \"JOHN\") ; assert_eq ! (clean_username (\"\" . to_string ()) , \"\") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels (\"hello\" . to_string ()) , 2i32) ; assert_eq ! (count_vowels (\"HELLO\" . to_string ()) , 2i32) ; assert_eq ! (count_vowels (\"xyz\" . to_string ()) , 0i32) ; assert_eq ! (count_vowels (\"aeiou\" . to_string ()) , 5i32) ; assert_eq ! (count_vowels (\"\" . to_string ()) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (\" \" , \"_\") } } fn count_vowels (text : String) -> i32 { { { let vowels = \"aeiouAEIOU\" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { count = count + 1i32 } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username (\"Alice Johnson\" . to_string ()) , \"Alice_Johnson\") ; assert_eq ! (clean_username (\"JOHN\" . to_string ()) , \"JOHN\") ; assert_eq ! (clean_username (\"\" . to_string ()) , \"\") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels (\"hello\" . to_string ()) , 2i32) ; assert_eq ! (count_vowels (\"HELLO\" . to_string ()) , 2i32) ; assert_eq ! (count_vowels (\"xyz\" . to_string ()) , 0i32) ; assert_eq ! (count_vowels (\"aeiou\" . to_string ()) , 5i32) ; assert_eq ! (count_vowels (\"\" . to_string ()) , 0i32) } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmphbNaZR/main.rs:1:90\n  |\n1 | ...me (raw_username : String) -> i32 { { raw_username . replace (\" \" , \"_\") } } fn count_vowels (text : String) -> i32 { { { let vowels =...\n  |                                  ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`\n  |                                  |\n  |                                  expected `i32` because of return type\n\nerror[E0308]: mismatched types\n --> /tmp/.tmphbNaZR/main.rs:1:271\n  |\n1 | ...ut count = 0i32 ; let mut i = 0i32 ; while i < text . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } }...\n  |                                               -   ^^^^^^^^^^^^^ expected `i32`, found `usize`\n  |                                               |\n  |                                               expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn clean_username (raw_username : String) -> i32 { { raw_username . replace (\" \" , \"_\") } } fn count_vowels (text : String) -> i32 { { { let vowels = \"aeiouAEIOU\" . to_string () ; { let mut count = 0i32 ; let mut i = 0i32 ; while i < text . len ().try_into().unwrap() { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_username () -> i32 { { assert_eq ! (clean_username (\"Alice Johnson\" . to_string ()) , \"Alice_Johnson\") ; assert_eq ! (clean_username (\"JOHN\" . to_string ()) , \"JOHN\") ; assert_eq ! (clean_username (\"\" . to_string ()) , \"\") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels (\"hello\" . to_string ()) , 2i32) ; assert_eq ! (count_vowels (\"HELLO\" . to_string ()) , 2i32) ; assert_eq ! (count_vowels (\"xyz\" . to_string ()) , 0i32) ; assert_eq ! (count_vowels (\"aeiou\" . to_string ()) , 5i32) ; assert_eq ! (count_vowels (\"\" . to_string ()) , 0i32) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                            ++++++++++++++++++++\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmphbNaZR/main.rs:1:317\n  |\n1 | ...t . len () { { if vowels . contains (text [i as usize]) { { count = count + 1i32 } } ; i = i + 1i32 } } ; count } } } } fn test_clean_...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmphbNaZR/main.rs:1:494\n  |\n1 | ..._username (\"Alice Johnson\" . to_string ()) , \"Alice_Johnson\") ; assert_eq ! (clean_username (\"JOHN\" . to_string ()) , \"JOHN\") ; assert...\n  |                                                 ^^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmphbNaZR/main.rs:1:567\n  |\n1 | ...t_eq ! (clean_username (\"JOHN\" . to_string ()) , \"JOHN\") ; assert_eq ! (clean_username (\"\" . to_string ()) , \"\") } } fn test_count_vow...\n  |                                                     ^^^^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmphbNaZR/main.rs:1:627\n  |\n1 | ... assert_eq ! (clean_username (\"\" . to_string ()) , \"\") } } fn test_count_vowels () -> i32 { { assert_eq ! (count_vowels (\"hello\" . to_...\n  |                                                       ^^ expected `i32`, found `&str`\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmphbNaZR/main.rs:1:577\n  |\n1 | ... to_string ()) , \"JOHN\") ; assert_eq ! (clean_username (\"\" . to_string ()) , \"\") } } fn test_count_vowels () -> i32 { { assert_eq ! (c...\n  |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmphbNaZR/main.rs:1:912\n  |\n1 | ... . to_string ()) , 5i32) ; assert_eq ! (count_vowels (\"\" . to_string ()) , 0i32) } } fn main () { }\n  |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 8 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0317.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 7,
          "line_number": 268,
          "code": "// Status: ❌ BROKEN\nfun calculate_grade(score) {\n    if score >= 90 { \"A\" }\n    else if score >= 80 { \"B\" } \n    else if score >= 70 { \"C\" }\n    else if score >= 60 { \"D\" }\n    else { \"F\" }\n}\n\nfun can_vote(age, is_citizen) {\n    age >= 18 && is_citizen\n}\n\n#[test]\nfun test_calculate_grade() {\n    // Boundary testing\n    assert_eq!(calculate_grade(95), \"A\")\n    assert_eq!(calculate_grade(90), \"A\")  // Exactly 90\n    assert_eq!(calculate_grade(89), \"B\")  // Just below A\n    assert_eq!(calculate_grade(80), \"B\")  // Exactly 80\n    assert_eq!(calculate_grade(79), \"C\")  // Just below B\n    assert_eq!(calculate_grade(59), \"F\")  // Failing grade\n    assert_eq!(calculate_grade(0), \"F\")   // Very low\n}\n\n#[test]\nfun test_can_vote() {\n    // All combinations\n    assert!(can_vote(18, true))      // Minimum age, citizen\n    assert!(can_vote(25, true))      // Adult citizen\n    assert!(!can_vote(17, true))     // Too young\n    assert!(!can_vote(25, false))    // Not citizen\n    assert!(!can_vote(17, false))    // Too young AND not citizen\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpDYqqC5/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpDYqqC5/main.rs:1:82\n  |\n1 | ... { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } ...\n  |       ^^                                                                                                                                                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpDYqqC5/main.rs:1:104\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32...\n  |                                                                                                        ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { \"A\" } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpDYqqC5/main.rs:1:141\n  |\n1 | ...2 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { \"B\" } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpDYqqC5/main.rs:1:178\n  |\n1 | ...lse { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } }...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { \"C\" } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpDYqqC5/main.rs:1:215\n  |\n1 | ...lse { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_cit...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { \"D\" } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpDYqqC5/main.rs:1:232\n  |\n1 | ... 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) ->...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { \"F\" } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpDYqqC5/main.rs:1:310\n  |\n1 | ..._vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq !...\n  |                                                        ^^                          ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { age >= 18i32 && is_citizen } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:96\n  |\n1 | ...de (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } }...\n  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                      |        |\n  |                                      |        expected `String`, found `i32`\n  |                                      expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:106\n  |\n1 | ...calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i3...\n  |                                        ---                           ^^^ expected `i32`, found `&str`\n  |                                        |\n  |                                        expected `i32` because of return type\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:133\n  |\n1 | ...re >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } }...\n  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                      |        |\n  |                                      |        expected `String`, found `i32`\n  |                                      expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:143\n  |\n1 | ...ore : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else ...\n  |                     --- expected `i32` because of return type                          ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:170\n  |\n1 | ...re >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vo...\n  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                      |        |\n  |                                      |        expected `String`, found `i32`\n  |                                      expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:180\n  |\n1 | ...String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if s...\n  |               --- expected `i32` because of return type                                                               ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:207\n  |\n1 | ...re >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : Strin...\n  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                      |        |\n  |                                      |        expected `String`, found `i32`\n  |                                      expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:217\n  |\n1 | ...-> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } ...\n  |       --- expected `i32` because of return type                                                                                                    ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:234\n  |\n1 | ...-> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } ...\n  |       --- expected `i32` because of return type                                                                                                                     ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:319\n  |\n1 | ... , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (...\n  |                                       ---    ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                       |      |\n  |                                       |      expected `String`, found `i32`\n  |                                       expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:328\n  |\n1 | ...ing , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grad...\n  |                                          ------------    ^^^^^^^^^^ expected `bool`, found `String`\n  |                                          |\n  |                                          expected because this is `bool`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:312\n  |\n1 | ...: String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate...\n  |                                       ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `bool`\n  |                                       |\n  |                                       expected `i32` because of return type\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:411\n  |\n1 | ...de () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_gr...\n  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                  |                |\n  |                                  |                expected `String`, found `i32`\n  |                                  arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpDYqqC5/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32...\n  |                                        ^^^^^^^^^^^^^^^  --------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:420\n  |\n1 | ... -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (...\n  |                                                       ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:457\n  |\n1 | ...(95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_gr...\n  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                  |                |\n  |                                  |                expected `String`, found `i32`\n  |                                  arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpDYqqC5/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32...\n  |                                        ^^^^^^^^^^^^^^^  --------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:466\n  |\n1 | ...2) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (...\n  |                                                       ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:503\n  |\n1 | ...(90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_gr...\n  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                  |                |\n  |                                  |                expected `String`, found `i32`\n  |                                  arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpDYqqC5/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32...\n  |                                        ^^^^^^^^^^^^^^^  --------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:512\n  |\n1 | ...2) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (...\n  |                                                       ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:549\n  |\n1 | ...(89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_gr...\n  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                  |                |\n  |                                  |                expected `String`, found `i32`\n  |                                  arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpDYqqC5/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32...\n  |                                        ^^^^^^^^^^^^^^^  --------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:558\n  |\n1 | ...2) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (...\n  |                                                       ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:595\n  |\n1 | ...(80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_gr...\n  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                  |                |\n  |                                  |                expected `String`, found `i32`\n  |                                  arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpDYqqC5/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32...\n  |                                        ^^^^^^^^^^^^^^^  --------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:604\n  |\n1 | ...2) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (...\n  |                                                       ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:641\n  |\n1 | ...(79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i...\n  |                                  ---------------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                  |                |\n  |                                  |                expected `String`, found `i32`\n  |                                  arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpDYqqC5/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32...\n  |                                        ^^^^^^^^^^^^^^^  --------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:650\n  |\n1 | ...2) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { ...\n  |                                                       ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:687\n  |\n1 | ...(59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; as...\n  |                                  ---------------  ^^^^- help: try using a conversion method: `.to_string()`\n  |                                  |                |\n  |                                  |                expected `String`, found `i32`\n  |                                  arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpDYqqC5/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32...\n  |                                        ^^^^^^^^^^^^^^^  --------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:695\n  |\n1 | ...32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert...\n  |                                                       ^^^ expected `i32`, found `&str`\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpDYqqC5/main.rs:1:657\n  |\n1 | ...alculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i3...\n  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpDYqqC5/main.rs:1:745\n  |\n1 | ...n test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , ...\n  |                                            ^^^^^^^^  -----   ---- expected `String`, found `bool`\n  |                                                      |\n  |                                                      expected `String`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpDYqqC5/main.rs:1:255\n  |\n1 | ...2 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn...\n  |                                                ^^^^^^^^  ------------   -------------------\nhelp: try using a conversion method\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32.to_string() , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ++++++++++++\nhelp: try using a conversion method\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true.to_string())) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:735\n  |\n1 | ...} } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i...\n  |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpDYqqC5/main.rs:1:782\n  |\n1 | ...! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 ...\n  |                                            ^^^^^^^^  -----   ---- expected `String`, found `bool`\n  |                                                      |\n  |                                                      expected `String`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpDYqqC5/main.rs:1:255\n  |\n1 | ...2 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn...\n  |                                                ^^^^^^^^  ------------   -------------------\nhelp: try using a conversion method\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32.to_string() , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++++++++++++\nhelp: try using a conversion method\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true.to_string())) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:772\n  |\n1 | ...sert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (2...\n  |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpDYqqC5/main.rs:1:821\n  |\n1 | ...(can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32...\n  |                                            ^^^^^^^^  -----   ---- expected `String`, found `bool`\n  |                                                      |\n  |                                                      expected `String`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpDYqqC5/main.rs:1:255\n  |\n1 | ...2 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn...\n  |                                                ^^^^^^^^  ------------   -------------------\nhelp: try using a conversion method\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32.to_string() , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ++++++++++++\nhelp: try using a conversion method\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true.to_string())) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:809\n  |\n1 | ...ert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote ...\n  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpDYqqC5/main.rs:1:860\n  |\n1 | ...can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |                                           ^^^^^^^^  -----   ----- expected `String`, found `bool`\n  |                                                     |\n  |                                                     expected `String`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpDYqqC5/main.rs:1:255\n  |\n1 | ...2 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn...\n  |                                                ^^^^^^^^  ------------   -------------------\nhelp: try using a conversion method\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32.to_string() , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ++++++++++++\nhelp: try using a conversion method\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false.to_string())) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:848\n  |\n1 | ...t ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpDYqqC5/main.rs:1:900\n  |\n1 | ...an_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |                                           ^^^^^^^^  -----   ----- expected `String`, found `bool`\n  |                                                     |\n  |                                                     expected `String`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmpDYqqC5/main.rs:1:255\n  |\n1 | ...2 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn...\n  |                                                ^^^^^^^^  ------------   -------------------\nhelp: try using a conversion method\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32.to_string() , false)) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ++++++++++++\nhelp: try using a conversion method\n  |\n1 | use std :: collections :: HashMap ; fn calculate_grade (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn can_vote (age : String , is_citizen : String) -> i32 { { age >= 18i32 && is_citizen } } fn test_calculate_grade () -> i32 { { assert_eq ! (calculate_grade (95i32) , \"A\") ; assert_eq ! (calculate_grade (90i32) , \"A\") ; assert_eq ! (calculate_grade (89i32) , \"B\") ; assert_eq ! (calculate_grade (80i32) , \"B\") ; assert_eq ! (calculate_grade (79i32) , \"C\") ; assert_eq ! (calculate_grade (59i32) , \"F\") ; assert_eq ! (calculate_grade (0i32) , \"F\") } } fn test_can_vote () -> i32 { { assert ! (can_vote (18i32 , true)) ; assert ! (can_vote (25i32 , true)) ; assert ! (! can_vote (17i32 , true)) ; assert ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false.to_string())) } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDYqqC5/main.rs:1:888\n  |\n1 | ... ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpDYqqC5/main.rs:1:888\n  |\n1 | ...t ! (! can_vote (25i32 , false)) ; assert ! (! can_vote (17i32 , false)) } } fn main () { }\n  |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |                                       |\n  |                                       expected `i32`, found `()`\n  |                                       found here\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n\nerror: aborting due to 38 previous errors; 8 warnings emitted\n\nSome errors have detailed explanations: E0308, E0317.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 8,
          "line_number": 320,
          "code": "// Status: ❌ BROKEN\n\n// Step 1: Write the test first\n#[test]\nfun test_fahrenheit_to_celsius() {\n    assert_eq!(fahrenheit_to_celsius(32), 0)    // Freezing point\n    assert_eq!(fahrenheit_to_celsius(212), 100) // Boiling point\n    assert_eq!(fahrenheit_to_celsius(98.6), 37) // Body temperature\n}\n\n// Step 2: Write minimal code to pass\nfun fahrenheit_to_celsius(fahrenheit) {\n    return (fahrenheit - 32) * 5 / 9\n}\n\n// Step 3: Run tests, refactor if needed\n// All tests pass! Code is ready to use.\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpKn0oQp/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn test_fahrenheit_to_celsius () -> i32 { { assert_eq ! (fahrenheit_to_celsius (32i32) , 0i32) ; asse...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpKn0oQp/main.rs:1:304\n  |\n1 | ...it_to_celsius (fahrenheit : String) -> i32 { { return fahrenheit - 32i32 * 5i32 / 9i32 } } fn main () { }\n  |                                                 ^^                                       ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test_fahrenheit_to_celsius () -> i32 { { assert_eq ! (fahrenheit_to_celsius (32i32) , 0i32) ; assert_eq ! (fahrenheit_to_celsius (212i32) , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { { return fahrenheit - 32i32 * 5i32 / 9i32 } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test_fahrenheit_to_celsius () -> i32 { { assert_eq ! (fahrenheit_to_celsius (32i32) , 0i32) ; assert_eq ! (fahrenheit_to_celsius (212i32) , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { return fahrenheit - 32i32 * 5i32 / 9i32 } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpKn0oQp/main.rs:1:117\n  |\n1 | ...() -> i32 { { assert_eq ! (fahrenheit_to_celsius (32i32) , 0i32) ; assert_eq ! (fahrenheit_to_celsius (212i32) , 100i32) ; assert_eq !...\n  |                               ---------------------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                               |                      |\n  |                               |                      expected `String`, found `i32`\n  |                               arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpKn0oQp/main.rs:1:251\n  |\n1 | ...renheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { { return fahrenheit - 32i32 * 5i32 /...\n  |                                                 ^^^^^^^^^^^^^^^^^^^^^  -------------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpKn0oQp/main.rs:1:170\n  |\n1 | ...2) , 0i32) ; assert_eq ! (fahrenheit_to_celsius (212i32) , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahr...\n  |                              ---------------------  ^^^^^^- help: try using a conversion method: `.to_string()`\n  |                              |                      |\n  |                              |                      expected `String`, found `i32`\n  |                              arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpKn0oQp/main.rs:1:251\n  |\n1 | ...renheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { { return fahrenheit - 32i32 * 5i32 /...\n  |                                                 ^^^^^^^^^^^^^^^^^^^^^  -------------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpKn0oQp/main.rs:1:226\n  |\n1 | ... , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { { retur...\n  |                              ---------------------  ^^^^^^^- help: try using a conversion method: `.to_string()`\n  |                              |                      |\n  |                              |                      expected `String`, found `f64`\n  |                              arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpKn0oQp/main.rs:1:251\n  |\n1 | ...renheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) -> i32 { { return fahrenheit - 32i32 * 5i32 /...\n  |                                                 ^^^^^^^^^^^^^^^^^^^^^  -------------------\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpKn0oQp/main.rs:1:190\n  |\n1 | ...lsius (212i32) , 100i32) ; assert_eq ! (fahrenheit_to_celsius (98.6f64) , 37i32) } } fn fahrenheit_to_celsius (fahrenheit : String) ->...\n  |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0369]: cannot subtract `i32` from `String`\n   --> /tmp/.tmpKn0oQp/main.rs:1:324\n    |\n1   | ..._celsius (fahrenheit : String) -> i32 { { return fahrenheit - 32i32 * 5i32 / 9i32 } } fn main () { }\n    |                                                     ---------- ^ ------------------- i32\n    |                                                     |\n    |                                                     String\n    |\nnote: the foreign item type `String` doesn't implement `Sub<i32>`\n   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:360:1\n    |\n360 | pub struct String {\n    | ^^^^^^^^^^^^^^^^^ not implement `Sub<i32>`\n\nerror: aborting due to 5 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0308, E0317, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 9,
          "line_number": 351,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Only testing happy path\n#[test]\nfun test_divide_bad() {\n    assert_eq!(divide(10, 2), 5)  // What about divide by zero?\n}\n\n// ✅ Testing edge cases\n#[test]\nfun test_divide_good() {\n    assert_eq!(divide(10, 2), 5)      // Normal case\n    assert_eq!(divide(0, 5), 0)       // Zero dividend\n    // Should handle divide by zero gracefully\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpKi3RBT/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn test_divide_bad () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good (...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpKi3RBT/main.rs:1:68\n  |\n1 | use std :: collections :: HashMap ; fn test_divide_bad () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good (...\n  |                                                                    ^^                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test_divide_bad () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test_divide_bad () -> i32 { assert_eq ! (divide (10i32 , 2i32) , 5i32) } fn test_divide_good () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn main () { }\n  |\n\nerror[E0425]: cannot find function `divide` in this scope\n --> /tmp/.tmpKi3RBT/main.rs:1:83\n  |\n1 | use std :: collections :: HashMap ; fn test_divide_bad () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good (...\n  |                                                                                   ^^^^^^ not found in this scope\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpKi3RBT/main.rs:1:70\n  |\n1 | ...n test_divide_bad () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) } } fn test_divide_good () -> i32 { { assert_eq ! (divide (...\n  |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `divide` in this scope\n --> /tmp/.tmpKi3RBT/main.rs:1:164\n  |\n1 | ... } } fn test_divide_good () -> i32 { { assert_eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn m...\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `divide` in this scope\n --> /tmp/.tmpKi3RBT/main.rs:1:209\n  |\n1 | ..._eq ! (divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn main () { }\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpKi3RBT/main.rs:1:196\n  |\n1 | ...(divide (10i32 , 2i32) , 5i32) ; assert_eq ! (divide (0i32 , 5i32) , 0i32) } } fn main () { }\n  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 5 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0317, E0425.\nFor more information about an error, try `rustc --explain E0317`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 10,
          "line_number": 378,
          "code": "// Status: ❌ BROKEN\n\n// ❌ This test will always pass\n#[test]\nfun test_useless() {\n    let result = add(2, 3)\n    assert!(result > 0)  // Too vague!\n}\n\n// ✅ This test verifies exact behavior\n#[test]  \nfun test_useful() {\n    assert_eq!(add(2, 3), 5)  // Exact expectation\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpZmS2zM/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn te...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpZmS2zM/main.rs:1:65\n  |\n1 | use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn te...\n  |                                                                 ^^                                                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test_useless () -> i32 { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpZmS2zM/main.rs:1:160\n  |\n1 | ...sult > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }\n  |                                                  ^^                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { assert_eq ! (add (2i32 , 3i32) , 5i32) } fn main () { }\n  |\n\nerror[E0425]: cannot find function `add` in this scope\n --> /tmp/.tmpZmS2zM/main.rs:1:82\n  |\n1 | use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn te...\n  |                                                                                  ^^^ not found in this scope\n  |\nhelp: use the `.` operator to call the method `Add::add` on `i32`\n  |\n1 - use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = 2i32.add(3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }\n  |\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpZmS2zM/main.rs:1:102\n  |\n1 | ...2 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , ...\n  |                                             ^^^^^^^^^^^^^^^^^^^^^^^^\n  |                                             |\n  |                                             expected `i32`, found `()`\n  |                                             found here\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n\nerror[E0425]: cannot find function `add` in this scope\n --> /tmp/.tmpZmS2zM/main.rs:1:175\n  |\n1 | ...i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }\n  |                                                         ^^^ not found in this scope\n  |\nhelp: use the `.` operator to call the method `Add::add` on `i32`\n  |\n1 - use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test_useless () -> i32 { { { let result = add (2i32 , 3i32) ; assert ! (result > 0i32) } } } fn test_useful () -> i32 { { assert_eq ! (2i32.add(3i32) , 5i32) } } fn main () { }\n  |\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpZmS2zM/main.rs:1:162\n  |\n1 | ... } } fn test_useful () -> i32 { { assert_eq ! (add (2i32 , 3i32) , 5i32) } } fn main () { }\n  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 4 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0317, E0425.\nFor more information about an error, try `rustc --explain E0317`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 11,
          "line_number": 404,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Unclear what this tests\n#[test]\nfun test1() {\n    assert_eq!(is_valid(\"abc\"), false)\n}\n\n// ✅ Clear, descriptive name\n#[test]\nfun test_password_too_short() {\n    assert_eq!(is_valid_password(\"abc\"), false)\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpKGD3bN/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid (\"abc\" . to_string ()) , false) } } fn test_password_too...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpKGD3bN/main.rs:1:58\n  |\n1 | use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid (\"abc\" . to_string ()) , false) } } fn test_password_too...\n  |                                                          ^^                                                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid (\"abc\" . to_string ()) , false) } } fn test_password_too_short () -> i32 { { assert_eq ! (is_valid_password (\"abc\" . to_string ()) , false) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test1 () -> i32 { assert_eq ! (is_valid (\"abc\" . to_string ()) , false) } fn test_password_too_short () -> i32 { { assert_eq ! (is_valid_password (\"abc\" . to_string ()) , false) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpKGD3bN/main.rs:1:157\n  |\n1 | ...st_password_too_short () -> i32 { { assert_eq ! (is_valid_password (\"abc\" . to_string ()) , false) } } fn main () { }\n  |                                      ^^                                                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid (\"abc\" . to_string ()) , false) } } fn test_password_too_short () -> i32 { { assert_eq ! (is_valid_password (\"abc\" . to_string ()) , false) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid (\"abc\" . to_string ()) , false) } } fn test_password_too_short () -> i32 { assert_eq ! (is_valid_password (\"abc\" . to_string ()) , false) } fn main () { }\n  |\n\nerror[E0425]: cannot find function `is_valid` in this scope\n --> /tmp/.tmpKGD3bN/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn test1 () -> i32 { { assert_eq ! (is_valid (\"abc\" . to_string ()) , false) } } fn test_password_too...\n  |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpKGD3bN/main.rs:1:60\n  |\n1 | ...p ; fn test1 () -> i32 { { assert_eq ! (is_valid (\"abc\" . to_string ()) , false) } } fn test_password_too_short () -> i32 { { assert_e...\n  |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0425]: cannot find function `is_valid_password` in this scope\n --> /tmp/.tmpKGD3bN/main.rs:1:172\n  |\n1 | ...password_too_short () -> i32 { { assert_eq ! (is_valid_password (\"abc\" . to_string ()) , false) } } fn main () { }\n  |                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmpKGD3bN/main.rs:1:159\n  |\n1 | ...o_short () -> i32 { { assert_eq ! (is_valid_password (\"abc\" . to_string ()) , false) } } fn main () { }\n  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 4 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0317, E0425.\nFor more information about an error, try `rustc --explain E0317`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-01-testing-functions.md",
          "example_number": 12,
          "line_number": 467,
          "code": "// Status: ❌ BROKEN\n\n// 1. Write failing tests first\n#[test]\nfun test_is_strong_password() {\n    assert!(is_strong_password(\"MyPass123!\"))      // Valid\n    assert!(!is_strong_password(\"weak\"))           // Too short\n    assert!(!is_strong_password(\"NoNumbers!\"))     // No digits\n    assert!(!is_strong_password(\"nonumbers123\"))   // No special chars\n}\n\n// 2. Write minimal code to pass\nfun is_strong_password(password) {\n    if password.len() < 8 { return false }\n    \n    let has_digit = password.chars().any(|c| c.is_digit())\n    let has_special = password.chars().any(|c| \"!@#$%^&*\".contains(c))\n    \n    return has_digit && has_special\n}\n\n// 3. Run tests - they should all pass now!\n\n// 4. Add more edge case tests\n#[test]\nfun test_password_edge_cases() {\n    assert!(!is_strong_password(\"\"))              // Empty\n    assert!(!is_strong_password(\"12345678\"))      // Only digits\n    assert!(!is_strong_password(\"!!!!!!!!\"))      // Only special\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp7n7fzI/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password (\"MyPass123!\" . to_string ())) ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7n7fzI/main.rs:1:413\n  |\n1 | ...assword : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c | c ....\n  |                                                               ^^            ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password (\"MyPass123!\" . to_string ())) ; assert ! (! is_strong_password (\"weak\" . to_string ())) ; assert ! (! is_strong_password (\"NoNumbers!\" . to_string ())) ; assert ! (! is_strong_password (\"nonumbers123\" . to_string ())) } } fn is_strong_password (password : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c | c . is_digit ()) ; { let mut has_special = password . chars () . any (| c | \"!@#$%^&*\" . contains (c)) ; return has_digit && has_special } } } } fn test_password_edge_cases () -> i32 { { assert ! (! is_strong_password (\"\" . to_string ())) ; assert ! (! is_strong_password (\"12345678\" . to_string ())) ; assert ! (! is_strong_password (\"!!!!!!!!\" . to_string ())) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password (\"MyPass123!\" . to_string ())) ; assert ! (! is_strong_password (\"weak\" . to_string ())) ; assert ! (! is_strong_password (\"NoNumbers!\" . to_string ())) ; assert ! (! is_strong_password (\"nonumbers123\" . to_string ())) } } fn is_strong_password (password : String) -> i32 { { if password . len () < 8i32 { return false } ; { let has_digit = password . chars () . any (| c | c . is_digit ()) ; { let mut has_special = password . chars () . any (| c | \"!@#$%^&*\" . contains (c)) ; return has_digit && has_special } } } } fn test_password_edge_cases () -> i32 { { assert ! (! is_strong_password (\"\" . to_string ())) ; assert ! (! is_strong_password (\"12345678\" . to_string ())) ; assert ! (! is_strong_password (\"!!!!!!!!\" . to_string ())) } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7n7fzI/main.rs:1:78\n  |\n1 | ...password () -> i32 { { assert ! (is_strong_password (\"MyPass123!\" . to_string ())) ; assert ! (! is_strong_password (\"weak\" . to_strin...\n  |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7n7fzI/main.rs:1:140\n  |\n1 | ...123!\" . to_string ())) ; assert ! (! is_strong_password (\"weak\" . to_string ())) ; assert ! (! is_strong_password (\"NoNumbers!\" . to_s...\n  |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7n7fzI/main.rs:1:198\n  |\n1 | ...k\" . to_string ())) ; assert ! (! is_strong_password (\"NoNumbers!\" . to_string ())) ; assert ! (! is_strong_password (\"nonumbers123\" ....\n  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7n7fzI/main.rs:1:262\n  |\n1 | ...\" . to_string ())) ; assert ! (! is_strong_password (\"nonumbers123\" . to_string ())) } } fn is_strong_password (password : String) -> ...\n  |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmp7n7fzI/main.rs:1:262\n  |\n1 | ...!\" . to_string ())) ; assert ! (! is_strong_password (\"nonumbers123\" . to_string ())) } } fn is_strong_password (password : String) ->...\n  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |                          |\n  |                          expected `i32`, found `()`\n  |                          found here\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7n7fzI/main.rs:1:406\n  |\n1 | ...sword (password : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (|...\n  |                                            -----------------   ^^^^ expected `usize`, found `i32`\n  |                                            |\n  |                                            expected because this is `usize`\n  |\nhelp: change the type of the numeric literal from `i32` to `usize`\n  |\n1 - use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password (\"MyPass123!\" . to_string ())) ; assert ! (! is_strong_password (\"weak\" . to_string ())) ; assert ! (! is_strong_password (\"NoNumbers!\" . to_string ())) ; assert ! (! is_strong_password (\"nonumbers123\" . to_string ())) } } fn is_strong_password (password : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c | c . is_digit ()) ; { let mut has_special = password . chars () . any (| c | \"!@#$%^&*\" . contains (c)) ; return has_digit && has_special } } } } fn test_password_edge_cases () -> i32 { { assert ! (! is_strong_password (\"\" . to_string ())) ; assert ! (! is_strong_password (\"12345678\" . to_string ())) ; assert ! (! is_strong_password (\"!!!!!!!!\" . to_string ())) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password (\"MyPass123!\" . to_string ())) ; assert ! (! is_strong_password (\"weak\" . to_string ())) ; assert ! (! is_strong_password (\"NoNumbers!\" . to_string ())) ; assert ! (! is_strong_password (\"nonumbers123\" . to_string ())) } } fn is_strong_password (password : String) -> i32 { { if password . len () < 8usize { { return false } } ; { let has_digit = password . chars () . any (| c | c . is_digit ()) ; { let mut has_special = password . chars () . any (| c | \"!@#$%^&*\" . contains (c)) ; return has_digit && has_special } } } } fn test_password_edge_cases () -> i32 { { assert ! (! is_strong_password (\"\" . to_string ())) ; assert ! (! is_strong_password (\"12345678\" . to_string ())) ; assert ! (! is_strong_password (\"!!!!!!!!\" . to_string ())) } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7n7fzI/main.rs:1:422\n  |\n1 | ...rd (password : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c ...\n  |                              --- expected `i32` because of return type      ^^^^^ expected `i32`, found `bool`\n\nerror[E0061]: this method takes 1 argument but 0 arguments were supplied\n   --> /tmp/.tmp7n7fzI/main.rs:1:489\n    |\n1   | ...git = password . chars () . any (| c | c . is_digit ()) ; { let mut has_special = password . chars () . any (| c | \"!@#$%^&*\" . contai...\n    |                                               ^^^^^^^^--- argument #1 of type `u32` is missing\n    |\nnote: method defined here\n   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/methods.rs:343:18\n    |\n343 |     pub const fn is_digit(self, radix: u32) -> bool {\n    |                  ^^^^^^^^\nhelp: provide the argument\n    |\n1   | use std :: collections :: HashMap ; fn test_is_strong_password () -> i32 { { assert ! (is_strong_password (\"MyPass123!\" . to_string ())) ; assert ! (! is_strong_password (\"weak\" . to_string ())) ; assert ! (! is_strong_password (\"NoNumbers!\" . to_string ())) ; assert ! (! is_strong_password (\"nonumbers123\" . to_string ())) } } fn is_strong_password (password : String) -> i32 { { if password . len () < 8i32 { { return false } } ; { let has_digit = password . chars () . any (| c | c . is_digit(/* u32 */)) ; { let mut has_special = password . chars () . any (| c | \"!@#$%^&*\" . contains (c)) ; return has_digit && has_special } } } } fn test_password_edge_cases () -> i32 { { assert ! (! is_strong_password (\"\" . to_string ())) ; assert ! (! is_strong_password (\"12345678\" . to_string ())) ; assert ! (! is_strong_password (\"!!!!!!!!\" . to_string ())) } } fn main () { }\n    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7n7fzI/main.rs:1:672\n  |\n1 | ...d_edge_cases () -> i32 { { assert ! (! is_strong_password (\"\" . to_string ())) ; assert ! (! is_strong_password (\"12345678\" . to_strin...\n  |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7n7fzI/main.rs:1:726\n  |\n1 | ...(\"\" . to_string ())) ; assert ! (! is_strong_password (\"12345678\" . to_string ())) ; assert ! (! is_strong_password (\"!!!!!!!!\" . to_s...\n  |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7n7fzI/main.rs:1:788\n  |\n1 | ...78\" . to_string ())) ; assert ! (! is_strong_password (\"!!!!!!!!\" . to_string ())) } } fn main () { }\n  |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmp7n7fzI/main.rs:1:788\n  |\n1 | ...678\" . to_string ())) ; assert ! (! is_strong_password (\"!!!!!!!!\" . to_string ())) } } fn main () { }\n  |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |                            |\n  |                            expected `i32`, found `()`\n  |                            found here\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n\nerror: aborting due to 12 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0061, E0308, E0317.\nFor more information about an error, try `rustc --explain E0061`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch16-00-testing-quality": {
      "chapter": "ch16-00-testing-quality",
      "total_examples": 11,
      "working_examples": 0,
      "failing_examples": 11,
      "examples": [
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 1,
          "line_number": 48,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Unit test with multiple assertions\n#[test]\nfun test_user_validation() {\n    // Arrange\n    let valid_user = User {\n        name: \"Alice\",\n        email: \"alice@example.com\",\n        age: 25\n    }\n    \n    // Act\n    let result = validate_user(valid_user)\n    \n    // Assert\n    assert!(result.is_ok())\n    assert_eq!(result.unwrap().name, \"Alice\")\n}\n\n// Property-based testing\n#[proptest]\nfun test_serialization_roundtrip(user: User) {\n    let serialized = user.serialize()\n    let deserialized = User::deserialize(serialized)\n    assert_eq!(user, deserialized)\n}\n\n// Integration test\n#[integration_test]\nasync fun test_api_workflow() {\n    // Start test server\n    let server = TestServer::new()\n    \n    // Create user\n    let response = server.post(\"/users\")\n        .json(new_user)\n        .send()\n        .await\n    \n    assert_eq!(response.status(), 201)\n    let user: User = response.json().await\n    \n    // Verify user exists\n    let get_response = server.get(\"/users/\" + user.id.to_s())\n        .send()\n        .await\n    \n    assert_eq!(get_response.status(), 200)\n}\n\n// Benchmark\n#[bench]\nfun bench_data_processing(b: &mut Bencher) {\n    let data = generate_test_data(10000)\n    b.iter(|| {\n        process_data(data.clone())\n    })\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 2,
          "line_number": 124,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Basic test\n#[test]\nfun test_addition() {\n    assert_eq!(2 + 2, 4)\n}\n\n// Test with setup\n#[test]\nfun test_calculator() {\n    // Arrange\n    let calc = Calculator::new()\n    \n    // Act\n    let result = calc.add(5, 3)\n    \n    // Assert\n    assert_eq!(result, 8)\n}\n\n// Test expected failures\n#[test]\n#[should_panic(expected = \"Division by zero\")]\nfun test_divide_by_zero() {\n    divide(10, 0)\n}\n\n// Async tests\n#[async_test]\nasync fun test_async_operation() {\n    let result = fetch_data().await\n    assert!(result.is_ok())\n}\n\n// Parameterized tests\n#[test_case(0, 0, 0)]\n#[test_case(1, 1, 2)]\n#[test_case(-1, 1, 0)]\n#[test_case(100, 200, 300)]\nfun test_add_parameterized(a: i32, b: i32, expected: i32) {\n    assert_eq!(add(a, b), expected)\n}\n\n// Test groups\nmod calculator_tests {\n    use super::*\n    \n    #[test]\n    fun test_add() { /* ... */ }\n    \n    #[test]\n    fun test_subtract() { /* ... */ }\n    \n    #[test]\n    fun test_multiply() { /* ... */ }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 3,
          "line_number": 194,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Fixture trait\ntrait TestFixture {\n    fun setup() -> Self\n    fun teardown(self)\n}\n\n// Database fixture\nstruct DatabaseFixture {\n    db: Database\n    test_data: Vec<User>\n}\n\nimpl TestFixture for DatabaseFixture {\n    fun setup() -> Self {\n        let db = Database::connect(\":memory:\")\n        db.migrate()\n        \n        let test_data = vec![\n            User::new(\"Alice\", \"alice@example.com\"),\n            User::new(\"Bob\", \"bob@example.com\")\n        ]\n        \n        for user in &test_data {\n            db.insert(user)\n        }\n        \n        DatabaseFixture { db, test_data }\n    }\n    \n    fun teardown(self) {\n        self.db.drop_all_tables()\n        self.db.disconnect()\n    }\n}\n\n// Use fixture in tests\n#[test]\nfun test_user_query() {\n    let fixture = DatabaseFixture::setup()\n    \n    let users = fixture.db.query(\"SELECT * FROM users\")\n    assert_eq!(users.len(), 2)\n    \n    fixture.teardown()\n}\n\n// Fixture macro for automatic cleanup\n#[with_fixture(DatabaseFixture)]\nfun test_with_auto_cleanup(fixture: DatabaseFixture) {\n    // Fixture automatically cleaned up after test\n    let user = fixture.db.find_user(\"Alice\")\n    assert!(user.is_some())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 4,
          "line_number": 262,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Mock trait\ntrait EmailService {\n    fun send_email(to: String, subject: String, body: String) -> Result<(), Error>\n}\n\n// Mock implementation\n#[mockable]\nstruct MockEmailService {\n    sent_emails: RefCell<Vec<Email>>\n}\n\nimpl EmailService for MockEmailService {\n    fun send_email(to: String, subject: String, body: String) -> Result<(), Error> {\n        self.sent_emails.borrow_mut().push(Email { to, subject, body })\n        Ok(())\n    }\n}\n\n// Test with mock\n#[test]\nfun test_user_registration() {\n    let email_service = MockEmailService::new()\n    let user_service = UserService::new(email_service)\n    \n    user_service.register_user(\"alice@example.com\")\n    \n    // Verify email was sent\n    assert_eq!(email_service.sent_emails.borrow().len(), 1)\n    assert_eq!(email_service.sent_emails.borrow()[0].subject, \"Welcome!\")\n}\n\n// Spy to verify behavior\n#[test]\nfun test_with_spy() {\n    let spy = Spy::new(RealService::new())\n    \n    spy.method_call()\n    \n    assert!(spy.was_called(\"method_call\"))\n    assert_eq!(spy.call_count(\"method_call\"), 1)\n    assert_eq!(spy.last_args(\"method_call\"), expected_args)\n}\n\n// Stub for predetermined responses\n#[test]\nfun test_with_stub() {\n    let stub = Stub::new()\n        .with_response(\"get_user\", User::test_user())\n        .with_error(\"network_call\", NetworkError)\n    \n    let result = service_using_stub.process()\n    assert_eq!(result, expected)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 5,
          "line_number": 330,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nuse proptest::prelude::*\n\n// Generate arbitrary test data\n#[derive(Arbitrary)]\nstruct TestUser {\n    #[proptest(regex = \"[a-z]{3,10}\")]\n    name: String\n    \n    #[proptest(range = 0..150)]\n    age: u8\n    \n    #[proptest(strategy = \"email_strategy()\")]\n    email: String\n}\n\n// Property test\n#[proptest]\nfun test_user_serialization(user: TestUser) {\n    // Property: serialization round-trip preserves data\n    let json = to_json(user)\n    let restored: TestUser = from_json(json)\n    prop_assert_eq!(user, restored)\n}\n\n// Custom strategies\nfun email_strategy() -> impl Strategy<Value = String> {\n    \"[a-z]{3,10}@[a-z]{3,10}\\\\.(com|org|net)\"\n        .prop_map(|s| s.to_string())\n}\n\n// Shrinking for minimal failing case\n#[proptest]\nfun test_no_panic(input: Vec<u8>) {\n    // Proptest will find minimal input that causes panic\n    process_bytes(input)  // Should never panic\n}\n\n// Stateful property testing\n#[proptest]\nfun test_database_consistency(operations: Vec<DbOperation>) {\n    let db = Database::new()\n    \n    for op in operations {\n        op.apply(&db)\n    }\n    \n    // Properties that should always hold\n    prop_assert!(db.is_consistent())\n    prop_assert_eq!(db.total_balance(), INITIAL_BALANCE)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 6,
          "line_number": 395,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Integration test in tests/ directory\n#[integration_test]\nasync fun test_full_api_flow() {\n    // Start services\n    let db = TestDatabase::new()\n    let cache = TestCache::new()\n    let server = TestServer::with_services(db, cache)\n    \n    // Register user\n    let register_response = server\n        .post(\"/api/register\")\n        .json(json!({\n            \"email\": \"test@example.com\",\n            \"password\": \"secure123\"\n        }))\n        .send()\n        .await\n    \n    assert_eq!(register_response.status(), 201)\n    let user: User = register_response.json().await\n    \n    // Login\n    let login_response = server\n        .post(\"/api/login\")\n        .json(json!({\n            \"email\": \"test@example.com\",\n            \"password\": \"secure123\"\n        }))\n        .send()\n        .await\n    \n    assert_eq!(login_response.status(), 200)\n    let token = login_response.header(\"Authorization\")\n    \n    // Use authenticated endpoint\n    let profile_response = server\n        .get(\"/api/profile\")\n        .header(\"Authorization\", token)\n        .send()\n        .await\n    \n    assert_eq!(profile_response.status(), 200)\n    let profile: Profile = profile_response.json().await\n    assert_eq!(profile.email, \"test@example.com\")\n}\n\n// Database integration test\n#[test]\nfun test_database_transactions() {\n    let db = Database::connect(TEST_DATABASE_URL)\n    \n    db.transaction(|tx| {\n        tx.insert_user(user1)?\n        tx.insert_user(user2)?\n        \n        // Verify within transaction\n        let count = tx.count_users()?\n        assert_eq!(count, 2)\n        \n        // Rollback for test isolation\n        Err(TestRollback)\n    })\n    \n    // Verify rollback worked\n    assert_eq!(db.count_users(), 0)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 7,
          "line_number": 476,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Benchmarks\n#[bench]\nfun bench_sorting_algorithms(b: &mut Bencher) {\n    let data = generate_random_vec(10000)\n    \n    b.iter(|| {\n        let mut copy = data.clone()\n        copy.sort()\n    })\n}\n\n// Comparative benchmarks\n#[bench_group]\nmod sorting_benchmarks {\n    #[bench]\n    fun quick_sort(b: &mut Bencher) {\n        let data = generate_data()\n        b.iter(|| quick_sort(data.clone()))\n    }\n    \n    #[bench]\n    fun merge_sort(b: &mut Bencher) {\n        let data = generate_data()\n        b.iter(|| merge_sort(data.clone()))\n    }\n    \n    #[bench]\n    fun heap_sort(b: &mut Bencher) {\n        let data = generate_data()\n        b.iter(|| heap_sort(data.clone()))\n    }\n}\n\n// Load testing\n#[load_test]\nasync fun test_api_under_load() {\n    let config = LoadTestConfig {\n        concurrent_users: 1000,\n        requests_per_user: 100,\n        ramp_up_time: Duration::from_secs(10)\n    }\n    \n    let results = load_test(config, |client| async {\n        client.get(\"/api/endpoint\").send().await\n    }).await\n    \n    assert!(results.median_response_time < Duration::from_millis(100))\n    assert!(results.p99_response_time < Duration::from_millis(500))\n    assert!(results.error_rate < 0.01)\n}\n\n// Profiling in tests\n#[test]\n#[profile]\nfun test_with_profiling() {\n    let profiler = CpuProfiler::start()\n    \n    expensive_operation()\n    \n    let report = profiler.report()\n    assert!(report.total_time < Duration::from_secs(1))\n    \n    // Generate flame graph\n    report.save_flamegraph(\"profile.svg\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 8,
          "line_number": 556,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Run tests with coverage\n$ ruchy test --coverage\n\n// Coverage report\n================================\nFile            Lines  Covered  %\nsrc/lib.rs      245    238     97.1%\nsrc/parser.rs   512    487     95.1%\nsrc/executor.rs 380    360     94.7%\n================================\nTotal           1137   1085    95.4%\n\n// Coverage annotations\n#[test]\nfun test_all_branches() {\n    // Tool shows which branches are not covered\n    if condition {      // ✓ true branch covered\n        do_something()\n    } else {           // ✗ false branch not covered\n        do_other()\n    }\n}\n\n// Exclude from coverage\n#[cfg(not(tarpaulin_include))]\nfun debug_function() {\n    // Not included in coverage metrics\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 9,
          "line_number": 597,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Mutation testing finds gaps in tests\n$ ruchy mutate\n\n// Mutations that survived (tests didn't catch)\nsrc/calculator.rs:15\n- Original: x + y\n+ Mutation: x - y\nStatus: SURVIVED ❌\n\n// Add test to catch mutation\n#[test]\nfun test_addition_not_subtraction() {\n    assert_ne!(add(5, 3), subtract(5, 3))\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 10,
          "line_number": 624,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Fuzz testing for security\n#[fuzz_test]\nfun fuzz_parser(data: &[u8]) {\n    // Fuzzer generates random inputs\n    if let Ok(s) = std::str::from_utf8(data) {\n        // Should never panic or crash\n        let _ = parse_input(s)\n    }\n}\n\n// Run fuzzer\n$ ruchy fuzz parser_fuzz\n=== Fuzzing parser_fuzz ===\nIterations: 1000000\nCrashes found: 0\nHangs found: 0\nCoverage: 95%\n\n// Targeted fuzzing\n#[fuzz_target]\nfun fuzz_api_endpoint(input: FuzzInput) {\n    let request = Request::from_fuzz(input)\n    let response = handle_request(request)\n    \n    // Properties that should hold\n    assert!(response.status() < 600)\n    assert!(response.body().len() < 10_000_000)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality.md",
          "example_number": 11,
          "line_number": 699,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// quality.ruchy - Quality gate script\nfun main() {\n    let mut passed = true\n    \n    // Test coverage gate\n    let coverage = run_coverage_analysis()\n    if coverage.percentage < 80.0 {\n        println(\"❌ Coverage too low: \" + coverage.percentage.to_s() + \"%\")\n        passed = false\n    }\n    \n    // Performance gate\n    let benchmarks = run_benchmarks()\n    for (name, result) in benchmarks {\n        if result.regression > 0.1 {  // 10% regression\n            println(\"❌ Performance regression in \" + name + \": \" + (result.regression * 100).to_s() + \"%\")\n            passed = false\n        }\n    }\n    \n    // Complexity gate\n    let complexity = analyze_complexity()\n    if complexity.max_cyclomatic > 10 {\n        println(\"❌ Complexity too high: \" + complexity.max_cyclomatic.to_s())\n        passed = false\n    }\n    \n    // Security gate\n    let vulnerabilities = security_scan()\n    if !vulnerabilities.is_empty() {\n        println(\"❌ Security vulnerabilities found: \" + vulnerabilities.len().to_s())\n        passed = false\n    }\n    \n    if !passed {\n        exit(1)\n    }\n    \n    println(\"✅ All quality gates passed!\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch14-00-concurrency": {
      "chapter": "ch14-00-concurrency",
      "total_examples": 13,
      "working_examples": 0,
      "failing_examples": 13,
      "examples": [
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 1,
          "line_number": 31,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nuse std::sync;\nuse std::async;\n\n// Parallel processing with channels\nfun process_files(files: Vec<String>) -> Vec<Result> {\n    let (sender, receiver) = channel()\n    \n    // Spawn worker for each file\n    for file in files {\n        let tx = sender.clone()\n        spawn {\n            let result = process_file(file)\n            tx.send((file, result))\n        }\n    }\n    \n    // Collect results\n    let results = Vec::new()\n    for _ in files.len() {\n        let (file, result) = receiver.recv()\n        results.push(result)\n    }\n    \n    return results\n}\n\n// Async/await for I/O\nasync fun fetch_all_data(urls: Vec<String>) -> Vec<Data> {\n    let futures = urls.map(|url| async {\n        let response = http::get(url).await?\n        parse_response(response)\n    })\n    \n    return join_all(futures).await\n}\n\n// Thread pool for CPU-bound work\nlet pool = ThreadPool::new(num_cpus())\nlet results = pool.parallel_map(items, |item| {\n    expensive_computation(item)\n})",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 2,
          "line_number": 91,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// Spawn a thread\nlet handle = spawn {\n    println(\"Running in parallel!\")\n    compute_result()\n}\n\n// Wait for thread to complete\nlet result = handle.join()\n\n// Spawn with move semantics\nlet data = vec![1, 2, 3]\nlet handle = spawn move {\n    let sum = data.sum()  // data moved into thread\n    println(\"Sum: \" + sum.to_s())\n}\n\n// Thread builder for configuration\nlet handle = Thread::builder()\n    .name(\"worker\")\n    .stack_size(4 * 1024 * 1024)\n    .spawn(|| {\n        heavy_computation()\n    })\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpo1I6Sy/main.rs:1:500\n  |\n1 | ... . spawn (|| { heavy_computation () }) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]: cannot find value `spawn` in this scope\n --> /tmp/.tmpo1I6Sy/main.rs:1:82\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut handle = spawn ; { println ! (\"Running in parallel!\") ; compute_r...\n  |                                                                                  ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::spawn;\n  |\n\nerror[E0425]: cannot find value `spawn` in this scope\n --> /tmp/.tmpo1I6Sy/main.rs:1:248\n  |\n1 | ...ata = vec ! [1i32 , 2i32 , 3i32] ; let mut handle = spawn ; r#move ; { { let sum = data . sum () ; println ! (\"{:?}\" , format ! (\"{}{}...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::spawn;\n  |\n\nerror[E0425]: cannot find value `r#move` in this scope\n --> /tmp/.tmpo1I6Sy/main.rs:1:256\n  |\n1 | ...c ! [1i32 , 2i32 , 3i32] ; let mut handle = spawn ; r#move ; { { let sum = data . sum () ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Sum...\n  |                                                        ^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpo1I6Sy/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut handle = spawn ; { println ! (\"Running in parallel!\") ; compute_r...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `compute_result` in this scope\n --> /tmp/.tmpo1I6Sy/main.rs:1:129\n  |\n1 | ... spawn ; { println ! (\"Running in parallel!\") ; compute_result () } ; let mut result = handle . join () ; let mut data = vec ! [1i32 ,...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `sum` found for struct `Vec<i32>` in the current scope\n --> /tmp/.tmpo1I6Sy/main.rs:1:286\n  |\n1 | ...ut handle = spawn ; r#move ; { { let sum = data . sum () ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Sum: \" , sum . to_s ())) } } ; let ...\n  |                                                      ^^^ `Vec<i32>` is not an iterator\n  |\nhelp: call `.into_iter()` first\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut handle = spawn ; { println ! (\"Running in parallel!\") ; compute_result () } ; let mut result = handle . join () ; let mut data = vec ! [1i32 , 2i32 , 3i32] ; let mut handle = spawn ; r#move ; { { let sum = data . into_iter().sum () ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Sum: \" , sum . to_s ())) } } ; let mut handle = Thread :: builder () . name (\"worker\") . stack_size (4i32 * 1024i32 * 1024i32) . spawn (|| { heavy_computation () }) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |                                                                                                                                                                                                                                                                                              ++++++++++++\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: sum()"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 3,
          "line_number": 131,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Create a channel\nlet (sender, receiver) = channel()\n\n// Multiple producers\nfor i in range(10) {\n    let tx = sender.clone()\n    spawn move {\n        let result = process(i)\n        tx.send(result)\n    }\n}\n\n// Single consumer\nspawn move {\n    while let Ok(result) = receiver.recv() {\n        println(\"Got: \" + result.to_s())\n    }\n}\n\n// Bounded channels for backpressure\nlet (tx, rx) = sync_channel(100)  // Buffer size 100\n\n// Select from multiple channels\nloop {\n    select! {\n        msg = rx1.recv() => {\n            process_message(msg)\n        }\n        data = rx2.recv() => {\n            process_data(data)\n        }\n        _ = timeout(1000) => {\n            println(\"Timeout!\")\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 4,
          "line_number": 182,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Mutex for mutual exclusion\nlet counter = Arc::new(Mutex::new(0))\n\nlet handles = Vec::new()\nfor _ in range(10) {\n    let counter = counter.clone()\n    handles.push(spawn move {\n        let mut num = counter.lock()\n        *num += 1\n    })\n}\n\nfor handle in handles {\n    handle.join()\n}\n\nprintln(\"Result: \" + (*counter.lock()).to_s())\n\n// RwLock for multiple readers\nlet data = Arc::new(RwLock::new(HashMap::new()))\n\n// Multiple readers\nlet data_clone = data.clone()\nspawn move {\n    let map = data_clone.read()  // Shared read access\n    println(\"Value: \" + map.get(\"key\").to_s())\n}\n\n// Single writer\nlet data_clone = data.clone()\nspawn move {\n    let mut map = data_clone.write()  // Exclusive write access\n    map.insert(\"key\", \"value\")\n}\n\n// Atomic operations for lock-free programming\nlet counter = Arc::new(AtomicI32::new(0))\ncounter.fetch_add(1, Ordering::SeqCst)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 5,
          "line_number": 235,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Async function\nasync fun fetch_user(id: i32) -> Result<User, Error> {\n    let response = http::get(\"/api/users/\" + id.to_s()).await?\n    let user = parse_json(response.body).await?\n    return Ok(user)\n}\n\n// Await multiple futures\nasync fun fetch_all_users(ids: Vec<i32>) -> Vec<User> {\n    let futures = ids.map(|id| fetch_user(id))\n    let results = join_all(futures).await\n    \n    return results\n        .filter_map(|r| r.ok())\n        .collect()\n}\n\n// Select first to complete\nasync fun fetch_with_timeout(url: String) -> Result<Data, Error> {\n    select! {\n        result = fetch_data(url) => result,\n        _ = sleep(5000) => Err(Error::Timeout)\n    }\n}\n\n// Async streams\nasync fun process_stream(stream: AsyncStream<Item>) {\n    while let Some(item) = stream.next().await {\n        process_item(item).await\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 6,
          "line_number": 283,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nstruct ThreadPool {\n    workers: Vec<Worker>\n    sender: Sender<Job>\n}\n\nimpl ThreadPool {\n    fun new(size: usize) -> ThreadPool {\n        let (sender, receiver) = channel()\n        let receiver = Arc::new(Mutex::new(receiver))\n        \n        let workers = Vec::with_capacity(size)\n        for id in range(size) {\n            workers.push(Worker::new(id, receiver.clone()))\n        }\n        \n        ThreadPool { workers, sender }\n    }\n    \n    fn execute<F>(&self, f: F)\n    where F: FnOnce() + Send + 'static\n    {\n        self.sender.send(Box::new(f))\n    }\n    \n    fn parallel_map<T, R, F>(&self, items: Vec<T>, f: F) -> Vec<R>\n    where\n        F: Fn(T) -> R + Send + Clone + 'static,\n        T: Send + 'static,\n        R: Send + 'static\n    {\n        let (tx, rx) = channel()\n        \n        for item in items {\n            let tx = tx.clone()\n            let f = f.clone()\n            self.execute(move || {\n                let result = f(item)\n                tx.send(result)\n            })\n        }\n        \n        let results = Vec::new()\n        for _ in items.len() {\n            results.push(rx.recv())\n        }\n        \n        return results\n    }\n}\n\n// Use thread pool\nlet pool = ThreadPool::new(4)\n\nfor i in range(100) {\n    pool.execute(move || {\n        println(\"Task \" + i.to_s() + \" on thread \" + current_thread_id().to_s())\n        heavy_work()\n    })\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 7,
          "line_number": 357,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun producer_consumer_pipeline<T>() {\n    let (tx, rx) = channel()\n    \n    // Multiple producers\n    for i in range(4) {\n        let tx = tx.clone()\n        spawn move {\n            loop {\n                let work = generate_work(i)\n                if tx.send(work).is_err() {\n                    break  // Channel closed\n                }\n            }\n        }\n    }\n    \n    // Multiple consumers  \n    for i in range(2) {\n        let rx = rx.clone()\n        spawn move {\n            while let Ok(work) = rx.recv() {\n                process_work(work)\n            }\n        }\n    }\n}\n\n// With bounded queue for backpressure\nfun bounded_pipeline() {\n    let (tx, rx) = sync_channel(100)  // Max 100 items\n    \n    spawn move {\n        for item in generate_items() {\n            tx.send(item)  // Blocks if queue full\n        }\n    }\n    \n    spawn move {\n        while let Ok(item) = rx.recv() {\n            slow_process(item)\n        }\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 8,
          "line_number": 415,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun parallel_merge_sort<T: Ord + Send>(mut items: Vec<T>) -> Vec<T> {\n    if items.len() <= 1 {\n        return items\n    }\n    \n    let mid = items.len() / 2\n    let right = items.split_off(mid)\n    \n    // Fork: sort halves in parallel\n    let (left_sorted, right_sorted) = join(\n        || parallel_merge_sort(items),\n        || parallel_merge_sort(right)\n    )\n    \n    // Join: merge sorted halves\n    return merge(left_sorted, right_sorted)\n}\n\n// Parallel reduce\nfun parallel_sum(numbers: Vec<i32>) -> i32 {\n    if numbers.len() <= 1000 {\n        return numbers.sum()  // Sequential for small inputs\n    }\n    \n    let chunk_size = numbers.len() / num_cpus()\n    let chunks = numbers.chunks(chunk_size)\n    \n    let sums = chunks\n        .parallel_map(|chunk| chunk.sum())\n        .collect()\n    \n    return sums.sum()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 9,
          "line_number": 463,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Actor trait\ntrait Actor {\n    type Message\n    \n    fun handle(&mut self, msg: Self::Message)\n}\n\n// Example actor\nstruct CounterActor {\n    count: i32\n}\n\nenum CounterMessage {\n    Increment\n    Decrement\n    Get(Sender<i32>)\n}\n\nimpl Actor for CounterActor {\n    type Message = CounterMessage\n    \n    fun handle(&mut self, msg: CounterMessage) {\n        match msg {\n            Increment => self.count += 1\n            Decrement => self.count -= 1\n            Get(reply) => reply.send(self.count)\n        }\n    }\n}\n\n// Actor system\nstruct ActorSystem {\n    actors: HashMap<String, Box<dyn Actor>>\n}\n\nimpl ActorSystem {\n    fn spawn<A: Actor>(&mut self, name: String, actor: A) -> ActorRef<A> {\n        let (tx, rx) = channel()\n        \n        spawn move {\n            let mut actor = actor\n            while let Ok(msg) = rx.recv() {\n                actor.handle(msg)\n            }\n        }\n        \n        ActorRef { name, sender: tx }\n    }\n}\n\n// Use actors\nlet system = ActorSystem::new()\nlet counter = system.spawn(\"counter\", CounterActor { count: 0 })\n\ncounter.send(Increment)\ncounter.send(Increment)\n\nlet (tx, rx) = channel()\ncounter.send(Get(tx))\nlet count = rx.recv()\nprintln(\"Count: \" + count.to_s())  // 2",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 10,
          "line_number": 541,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nasync fun web_server() {\n    let listener = TcpListener::bind(\"0.0.0.0:8080\").await\n    \n    loop {\n        let (socket, addr) = listener.accept().await\n        \n        // Handle each connection concurrently\n        spawn async {\n            handle_connection(socket, addr).await\n        }\n    }\n}\n\nasync fun handle_connection(socket: TcpStream, addr: SocketAddr) {\n    let (reader, writer) = socket.split()\n    \n    let request = read_http_request(reader).await\n    let response = route_request(request).await\n    \n    write_http_response(writer, response).await\n}\n\n// Connection pool for database\nlet db_pool = ConnectionPool::new(20)\n\nasync fun handle_request(req: Request) -> Response {\n    let conn = db_pool.get().await\n    \n    let data = conn.query(\"SELECT * FROM users\").await\n    \n    db_pool.return(conn)\n    \n    Response::json(data)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 11,
          "line_number": 590,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun process_dataset(data: Vec<Record>) -> Vec<Result> {\n    // Partition data for parallel processing\n    let chunk_size = data.len() / num_cpus()\n    let chunks = data.chunks(chunk_size)\n    \n    // Process chunks in parallel\n    let handles = chunks.map(|chunk| {\n        spawn move {\n            chunk.iter()\n                .map(|record| process_record(record))\n                .collect()\n        }\n    })\n    \n    // Collect results\n    let mut results = Vec::new()\n    for handle in handles {\n        results.extend(handle.join())\n    }\n    \n    return results\n}\n\n// Pipeline with stages\nfun parallel_pipeline(input: Stream<Data>) -> Stream<Output> {\n    input\n        .parallel_map(stage1, workers: 4)\n        .parallel_filter(stage2, workers: 2)\n        .parallel_flat_map(stage3, workers: 4)\n        .collect()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 12,
          "line_number": 636,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n#[test]\nfun test_concurrent_access() {\n    let shared = Arc::new(Mutex::new(Vec::new()))\n    let handles = Vec::new()\n    \n    // Spawn concurrent writers\n    for i in range(100) {\n        let shared = shared.clone()\n        handles.push(spawn move {\n            let mut vec = shared.lock()\n            vec.push(i)\n        })\n    }\n    \n    // Wait for completion\n    for handle in handles {\n        handle.join()\n    }\n    \n    // Verify all writes succeeded\n    let vec = shared.lock()\n    assert_eq!(vec.len(), 100)\n}\n\n#[test]\nasync fun test_async_operations() {\n    let results = join_all(vec![\n        async_operation(1),\n        async_operation(2),\n        async_operation(3)\n    ]).await\n    \n    assert!(results.all(|r| r.is_ok()))\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch14-00-concurrency.md",
          "example_number": 13,
          "line_number": 683,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// 1. Choose the right abstraction\n// Threads: OS parallelism, CPU-bound work\n// Async: I/O-bound work, many concurrent tasks\n// Channels: Decoupled communication\n// Shared state: When necessary, with proper synchronization\n\n// 2. Avoid contention\nlet shards = (0..16).map(|_| Mutex::new(HashMap::new()))\nfun get_shard(key: &str) -> &Mutex<HashMap> {\n    let hash = hash(key)\n    return &shards[hash % 16]\n}\n\n// 3. Use work stealing\nlet queue = WorkStealingQueue::new()\n// Threads steal work from other threads when idle\n\n// 4. Batch operations\ninstead_of {\n    for item in items {\n        channel.send(item)  // Many small sends\n    }\n}\n\ndo {\n    channel.send(items)  // One batch send\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch04-00-command-line-tools": {
      "chapter": "ch04-00-command-line-tools",
      "total_examples": 14,
      "working_examples": 1,
      "failing_examples": 13,
      "examples": [
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\n\n// File: word_counter.ruchy\n// Simple word counter tool\n\n// Get filename from user\nprintln(\"Word Counter Tool\")\nprint(\"Enter filename: \")\nlet filename = input()\n\n// Read and process file\nlet content = read_file(filename)\nlet words = content.split_whitespace()\nlet word_count = words.len()\nlet char_count = content.len()\nlet line_count = content.lines().len()\n\n// Display results\nprintln(\"\\nFile Analysis: \" + filename)\nprintln(\"Characters: \" + char_count.to_s())\nprintln(\"Words: \" + word_count.to_s())  \nprintln(\"Lines: \" + line_count.to_s())\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpZCFISH/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"Word Counter Tool\") ; print ! (\"Enter filename: \") ; let mut ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpZCFISH/main.rs:1:396\n  |\n1 | ... input . pop () ; } } input } ; let mut content = read_file (filename) ; let mut words = content . split_whitespace () ; let mut word_...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 2,
          "line_number": 82,
          "code": "// Status: ❌ BROKEN\n\nlet name = input(\"What's your name? \")\nlet age = input(\"How old are you? \").to_i()\nlet is_student = input(\"Are you a student? (y/n) \") == \"y\"\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmp2sJQpW/main.rs:1:1162\n  |\n1 | ... { input . pop () ; } } input } == \"y\" } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp2sJQpW/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut name = { print ! (\"{}\" , \"What's your name? \") ; std :: io :: Wri...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0599]: no method named `to_i` found for struct `String` in the current scope\n --> /tmp/.tmp2sJQpW/main.rs:1:777\n  |\n1 | ...ends_with ('\\r') { input . pop () ; } } input } . to_i () ; let mut is_student = { print ! (\"{}\" , \"Are you a student? (y/n) \") ; std ...\n  |                                                      ^^^^ method not found in `String`\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_i()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 3,
          "line_number": 101,
          "code": "// Status: ❌ BROKEN\n\n// Reading files\nlet content = read_file(\"data.txt\")\nlet lines = read_lines(\"data.txt\")\n\n// Writing files\nwrite_file(\"output.txt\", \"Hello, World!\")\nappend_file(\"log.txt\", \"New entry: \" + timestamp())\n\n// File information\nlet exists = file_exists(\"config.txt\")\nlet size = file_size(\"data.txt\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpxFO0QP/main.rs:1:462\n  |\n1 | ... file_size (\"data.txt\" . to_string ()) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpxFO0QP/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut content = read_file (\"data.txt\" . to_string ()) ; let mut lines =...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpxFO0QP/main.rs:1:83\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut content = read_file (\"data.txt\" . to_string ()) ; let mut lines =...\n  |                                                                                   ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_lines` in this scope\n --> /tmp/.tmpxFO0QP/main.rs:1:139\n  |\n1 | ...ile (\"data.txt\" . to_string ()) ; let mut lines = read_lines (\"data.txt\" . to_string ()) ; write_file (\"output.txt\" . to_string () , \"...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpxFO0QP/main.rs:1:180\n  |\n1 | ... lines = read_lines (\"data.txt\" . to_string ()) ; write_file (\"output.txt\" . to_string () , \"Hello, World!\" . to_string ()) ; append_f...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `timestamp` in this scope\n --> /tmp/.tmpxFO0QP/main.rs:1:331\n  |\n1 | ...to_string () , format ! (\"{}{}\" , \"New entry: \" , timestamp ())) ; let mut exists = file_exists (\"config.txt\" . to_string ()) ; let mu...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `append_file` in this scope\n --> /tmp/.tmpxFO0QP/main.rs:1:256\n  |\n1 | ...to_string () , \"Hello, World!\" . to_string ()) ; append_file (\"log.txt\" . to_string () , format ! (\"{}{}\" , \"New entry: \" , timestamp ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpxFO0QP/main.rs:1:365\n  |\n1 | ...New entry: \" , timestamp ())) ; let mut exists = file_exists (\"config.txt\" . to_string ()) ; let mut size = file_size (\"data.txt\" . to...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 7 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 4,
          "line_number": 128,
          "code": "// Status: ❌ BROKEN\n\n// Usage: ruchy run script.ruchy file1.txt file2.txt\nlet args = command_args()\nlet program_name = args[0]\nlet first_file = args[1]\nlet second_file = args[2]\n\nprintln(\"Processing: \" + first_file + \" and \" + second_file)\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpZeuC3z/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut args = command_args () ; let mut program_name = args [0i32 as usi...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `command_args` in this scope\n --> /tmp/.tmpZeuC3z/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut args = command_args () ; let mut program_name = args [0i32 as usi...\n  |                                                                                ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 5,
          "line_number": 152,
          "code": "// Status: ❌ BROKEN\n\n// File: text_processor.ruchy\n// Processes text files with various operations\n\nprintln(\"=== Text Processor ===\")\nlet filename = input(\"Enter filename: \")\n\nif !file_exists(filename) {\n    println(\"Error: File '\" + filename + \"' not found!\")\n    exit(1)\n}\n\nlet content = read_file(filename)\nlet lines = content.lines()\n\nprintln(\"\\nChoose operation:\")\nprintln(\"1. Count lines\")\nprintln(\"2. Find and replace\")\nprintln(\"3. Convert to uppercase\") \nprintln(\"4. Remove empty lines\")\n\nlet choice = input(\"Enter choice (1-4): \").to_i()\n\nmatch choice {\n    1 => {\n        println(\"Total lines: \" + lines.len().to_s())\n    }\n    2 => {\n        let find = input(\"Find: \")\n        let replace = input(\"Replace with: \")\n        let new_content = content.replace(find, replace)\n        let output_file = filename.replace(\".txt\", \"_modified.txt\")\n        write_file(output_file, new_content)\n        println(\"Saved to: \" + output_file)\n    }\n    3 => {\n        let upper_content = content.to_uppercase()\n        let output_file = filename.replace(\".txt\", \"_upper.txt\")\n        write_file(output_file, upper_content)\n        println(\"Saved to: \" + output_file)\n    }\n    4 => {\n        let clean_lines = lines.filter(|line| !line.trim().is_empty())\n        let clean_content = clean_lines.join(\"\\n\")\n        let output_file = filename.replace(\".txt\", \"_clean.txt\")\n        write_file(output_file, clean_content)\n        println(\"Saved to: \" + output_file)\n    }\n    _ => {\n        println(\"Invalid choice!\")\n    }\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `exit` in this scope\n --> /tmp/.tmphA5B00/main.rs:1:602\n  |\n1 | ...\" , \"Error: File '\" , filename) , \"' not found!\")) ; exit (1i32) } } ; let mut content = read_file (filename) ; let mut lines = conten...\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::process::exit;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmphA5B00/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Text Processor ===\") ; let mut filename = { print ! (\"{}\"...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmphA5B00/main.rs:1:468\n  |\n1 | ...ith ('\\r') { input . pop () ; } } input } ; if ! file_exists (filename) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmphA5B00/main.rs:1:638\n  |\n1 | ...t found!\")) ; exit (1i32) } } ; let mut content = read_file (filename) ; let mut lines = content . lines () ; println ! (\"\\nChoose ope...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_i` found for struct `String` in the current scope\n --> /tmp/.tmphA5B00/main.rs:1:1240\n  |\n1 | ...ends_with ('\\r') { input . pop () ; } } input } . to_i () ; match choice { 1i32 => { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total lin...\n  |                                                      ^^^^ method not found in `String`\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmphA5B00/main.rs:1:2203\n  |\n1 | ...= filename . replace (\".txt\" , \"_modified.txt\") ; write_file (output_file , new_content) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Sav...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmphA5B00/main.rs:1:2449\n  |\n1 | ...le = filename . replace (\".txt\" , \"_upper.txt\") ; write_file (output_file , upper_content) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"S...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmphA5B00/main.rs:1:2822\n  |\n1 | ...le = filename . replace (\".txt\" , \"_clean.txt\") ; write_file (output_file , clean_content) ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"S...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 7 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_i()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 6,
          "line_number": 218,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// File: log_analyzer.ruchy\n// Analyzes server log files\n\nprintln(\"=== Log Analyzer ===\")\nlet log_file = input(\"Enter log file path: \")\n\nlet lines = read_lines(log_file)\nlet total_requests = lines.len()\n\n// Count different status codes\nlet success_count = 0\nlet error_count = 0\nlet not_found_count = 0\n\nfor line in lines {\n    if line.contains(\" 200 \") {\n        success_count += 1\n    } else if line.contains(\" 404 \") {\n        not_found_count += 1\n    } else if line.contains(\" 500 \") {\n        error_count += 1\n    }\n}\n\n// Calculate percentages\nlet success_percent = (success_count * 100) / total_requests\nlet error_percent = (error_count * 100) / total_requests\nlet not_found_percent = (not_found_count * 100) / total_requests\n\nprintln(\"\\n=== Analysis Results ===\")\nprintln(\"Total Requests: \" + total_requests.to_s())\nprintln(\"Success (200): \" + success_count.to_s() + \" (\" + success_percent.to_s() + \"%)\")\nprintln(\"Not Found (404): \" + not_found_count.to_s() + \" (\" + not_found_percent.to_s() + \"%)\")\nprintln(\"Server Error (500): \" + error_count.to_s() + \" (\" + error_percent.to_s() + \"%)\")\n\n// Find busiest hour\nlet hour_counts = {}\nfor line in lines {\n    let timestamp = extract_hour(line)  // Custom function\n    hour_counts[timestamp] = hour_counts.get(timestamp, 0) + 1\n}\n\nlet busiest_hour = hour_counts.max_by_value().key\nprintln(\"Busiest Hour: \" + busiest_hour.to_s() + \":00\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpiWeX87/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let mut log_file = { print ! (\"{}\" ,...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpiWeX87/main.rs:1:661\n  |\n1 | ... { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ...\n  |       ^^                                                                                                                                                                                                  ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let mut log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let mut log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpiWeX87/main.rs:1:694\n  |\n1 | ... for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_co...\n  |                                                          ^^                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let mut log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let mut log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { success_count += 1i32 } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpiWeX87/main.rs:1:760\n  |\n1 | ...nt += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count...\n  |                                                         ^^                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let mut log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let mut log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { not_found_count += 1i32 } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpiWeX87/main.rs:1:828\n  |\n1 | ...ount += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 1...\n  |                                                           ^^                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let mut log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let mut log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { error_count += 1i32 } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpiWeX87/main.rs:1:1761\n  |\n1 | ... { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ...\n  |       ^^                                                                                                                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let mut log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Log Analyzer ===\") ; let mut log_file = { print ! (\"{}\" , \"Enter log file path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_count = 0i32 ; let mut error_count = 0i32 ; let mut not_found_count = 0i32 ; for line in lines { { if line . contains (\" 200 \") { { success_count += 1i32 } } else { if line . contains (\" 404 \") { { not_found_count += 1i32 } } else { if line . contains (\" 500 \") { { error_count += 1i32 } } } } } } ; let mut success_percent = success_count * 100i32 / total_requests ; let mut error_percent = error_count * 100i32 / total_requests ; let mut not_found_percent = not_found_count * 100i32 / total_requests ; println ! (\"\\n=== Analysis Results ===\") ; println ! (\"{:?}\" , format ! (\"{}{}\" , \"Total Requests: \" , total_requests . to_s ())) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Busiest Hour: \" , busiest_hour . to_s ()) , \":00\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `read_lines` in this scope\n --> /tmp/.tmpiWeX87/main.rs:1:482\n  |\n1 | ... { input . pop () ; } } input } ; let mut lines = read_lines (log_file) ; let mut total_requests = lines . len () ; let mut success_co...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpiWeX87/main.rs:1:1313\n  |\n1 | ...mat ! (\"{}{}\" , \"Success (200): \" , success_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpiWeX87/main.rs:1:1350\n  |\n1 | ...uccess_count . to_s ()) , \" (\") + success_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , forma...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpiWeX87/main.rs:1:1486\n  |\n1 | ...! (\"{}{}\" , \"Not Found (404): \" , not_found_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , form...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpiWeX87/main.rs:1:1525\n  |\n1 | ...ound_count . to_s ()) , \" (\") + not_found_percent . to_s () , \"%)\")) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , forma...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpiWeX87/main.rs:1:1660\n  |\n1 | ... ! (\"{}{}\" , \"Server Error (500): \" , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; f...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpiWeX87/main.rs:1:1695\n  |\n1 | ... , error_count . to_s ()) , \" (\") + error_percent . to_s () , \"%)\")) ; let mut hour_counts = () ; for line in lines { { { let timestam...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0425]: cannot find function `extract_hour` in this scope\n --> /tmp/.tmpiWeX87/main.rs:1:1781\n  |\n1 | ...s = () ; for line in lines { { { let timestamp = extract_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `get` found for unit type `()` in the current scope\n    --> /tmp/.tmpiWeX87/main.rs:1:1852\n     |\n1    | ...t_hour (line) ; hour_counts [timestamp as usize] = hour_counts . get (timestamp , 0i32) . cloned () + 1i32 } } } ; let mut busiest_hou...\n     |                                                                     ^^^\n     |\nhelp: there is a method `ge` with a similar name, but with different arguments\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1438:5\n     |\n1438 |     fn ge(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `max_by_value` found for unit type `()` in the current scope\n --> /tmp/.tmpiWeX87/main.rs:1:1939\n  |\n1 | ...32 } } } ; let mut busiest_hour = hour_counts . max_by_value () . key ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Bus...\n  |                                                    ^^^^^^^^^^^^ method not found in `()`\n\nerror: aborting due to 10 previous errors; 6 warnings emitted\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 7,
          "line_number": 277,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// File: batch_renamer.ruchy  \n// Renames multiple files with patterns\n\nprintln(\"=== Batch File Renamer ===\")\nlet directory = input(\"Enter directory path: \")\nlet pattern = input(\"Enter pattern to find: \")\nlet replacement = input(\"Enter replacement: \")\n\nlet files = list_files(directory)\nlet renamed_count = 0\n\nfor file in files {\n    if file.contains(pattern) {\n        let new_name = file.replace(pattern, replacement)\n        let old_path = join_path(directory, file)\n        let new_path = join_path(directory, new_name)\n        \n        if rename_file(old_path, new_path) {\n            println(\"Renamed: \" + file + \" -> \" + new_name)\n            renamed_count += 1\n        } else {\n            println(\"Failed to rename: \" + file)\n        }\n    }\n}\n\nprintln(\"\\nRenamed \" + renamed_count.to_s() + \" files\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp1rLLk3/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\") ; let mut directory = { print ! ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1rLLk3/main.rs:1:1296\n  |\n1 | ... { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\") ; let mut directory = { print ! (\"{}\" , \"Enter directory path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut pattern = { print ! (\"{}\" , \"Enter pattern to find: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut replacement = { print ! (\"{}\" , \"Enter replacement: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\") ; let mut directory = { print ! (\"{}\" , \"Enter directory path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut pattern = { print ! (\"{}\" , \"Enter pattern to find: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut replacement = { print ! (\"{}\" , \"Enter replacement: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1rLLk3/main.rs:1:1329\n  |\n1 | ... { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\") ; let mut directory = { print ! (\"{}\" , \"Enter directory path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut pattern = { print ! (\"{}\" , \"Enter pattern to find: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut replacement = { print ! (\"{}\" , \"Enter replacement: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\") ; let mut directory = { print ! (\"{}\" , \"Enter directory path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut pattern = { print ! (\"{}\" , \"Enter pattern to find: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut replacement = { print ! (\"{}\" , \"Enter replacement: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp1rLLk3/main.rs:1:1671\n  |\n1 | ...named_count += 1i32 } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } } ; println ! (\"{:...\n  |                                   ^^                                                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\") ; let mut directory = { print ! (\"{}\" , \"Enter directory path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut pattern = { print ! (\"{}\" , \"Enter pattern to find: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut replacement = { print ! (\"{}\" , \"Enter replacement: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") + new_name) ; renamed_count += 1i32 } } else { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { println ! (\"=== Batch File Renamer ===\") ; let mut directory = { print ! (\"{}\" , \"Enter directory path: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut pattern = { print ! (\"{}\" , \"Enter pattern to find: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut replacement = { print ! (\"{}\" , \"Enter replacement: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if file . contains (pattern) { { { let new_name = file . replace (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Renamed: \" , file) , \" -> \") + new_name) ; renamed_count += 1i32 } } else { println ! (\"{:?}\" , format ! (\"{}{}\" , \"Failed to rename: \" , file)) } } } } } } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `list_files` in this scope\n --> /tmp/.tmp1rLLk3/main.rs:1:1220\n  |\n1 | ... { input . pop () ; } } input } ; let mut files = list_files (directory) ; let mut renamed_count = 0i32 ; for file in files { { if fil...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmp1rLLk3/main.rs:1:1410\n  |\n1 | ...ce (pattern , replacement) ; { let mut old_path = join_path (directory , file) ; let mut new_path = join_path (directory , new_name) ;...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `join_path` in this scope\n --> /tmp/.tmp1rLLk3/main.rs:1:1460\n  |\n1 | ...y , file) ; let mut new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ...\n  |                                   ^^^^^^^^^ help: a local variable with a similar name exists: `old_path`\n\nerror[E0425]: cannot find function `rename_file` in this scope\n --> /tmp/.tmp1rLLk3/main.rs:1:1498\n  |\n1 | ...new_path = join_path (directory , new_name) ; if rename_file (old_path , new_path) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format !...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmp1rLLk3/main.rs:1:1849\n  |\n1 | ..., format ! (\"{}{}\" , \"\\nRenamed \" , renamed_count . to_s ()) , \" files\")) } ; if let Some (s) = (& result as & dyn std :: any :: Any) ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror: aborting due to 5 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 8,
          "line_number": 321,
          "code": "// Status: ❌ BROKEN\n\n// Robust file processor with error handling\n\nfun process_file(filename) {\n    // Check if file exists\n    if !file_exists(filename) {\n        println(\"❌ Error: File '\" + filename + \"' does not exist\")\n        return false\n    }\n    \n    // Check if file is readable\n    if !file_readable(filename) {\n        println(\"❌ Error: Cannot read file '\" + filename + \"' (permission denied?)\")\n        return false\n    }\n    \n    // Try to read file\n    let content = try {\n        read_file(filename)\n    } catch error {\n        println(\"❌ Error reading file: \" + error.to_s())\n        return false\n    }\n    \n    // Process content\n    let word_count = content.split_whitespace().len()\n    println(\"✅ File processed: \" + word_count.to_s() + \" words\")\n    return true\n}\n\n// Main program\nlet filename = input(\"Enter filename: \")\nif process_file(filename) {\n    println(\"Processing completed successfully!\")\n} else {\n    println(\"Processing failed!\")\n    exit(1)\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0423]: expected value, found macro `try`\n --> /tmp/.tmpIgG7rk/main.rs:1:445\n  |\n1 | ...rmission denied?)\")) ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{:?}\" , f...\n  |                                                              ^^^^^ not a value\n\nerror[E0425]: cannot find value `catch` in this scope\n --> /tmp/.tmpIgG7rk/main.rs:1:482\n  |\n1 | ... let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ Error reading file: \" ,...\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpIgG7rk/main.rs:1:490\n  |\n1 | ...tent = r#try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ Error reading file: \" , error ....\n  |                                                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `error` in this scope\n --> /tmp/.tmpIgG7rk/main.rs:1:566\n  |\n1 | ...?}\" , format ! (\"{}{}\" , \"❌ Error reading file: \" , error . to_s ())) ; return false } ; let mut word_count = content . split_whitespac...\n  |                                                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `exit` in this scope\n --> /tmp/.tmpIgG7rk/main.rs:1:1303\n  |\n1 | ...y!\") } } else { { println ! (\"Processing failed!\") ; exit (1i32) } } ; }\n  |                                                         ^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::process::exit;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpIgG7rk/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn process_file (filename : i32) -> i32 { { if ! file_exists (filename) { { println ! (\"{:?}\" , forma...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpIgG7rk/main.rs:1:1204\n  |\n1 | ...} input } ; if process_file (filename) { { println ! (\"Processing completed successfully!\") } } else { { println ! (\"Processing failed...\n  |                                             ^^                                                ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn process_file (filename : i32) -> i32 { { if ! file_exists (filename) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Error: File '\" , filename) , \"' does not exist\")) ; return false } } ; if ! file_readable (filename) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Error: Cannot read file '\" , filename) , \"' (permission denied?)\")) ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ Error reading file: \" , error . to_s ())) ; return false } ; let mut word_count = content . split_whitespace () . len () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"✅ File processed: \" , word_count . to_s ()) , \" words\")) ; return true } } } } fn main () { let mut filename = { print ! (\"{}\" , \"Enter filename: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if process_file (filename) { { println ! (\"Processing completed successfully!\") } } else { { println ! (\"Processing failed!\") ; exit (1i32) } } ; }\n1 + use std :: collections :: HashMap ; fn process_file (filename : i32) -> i32 { { if ! file_exists (filename) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Error: File '\" , filename) , \"' does not exist\")) ; return false } } ; if ! file_readable (filename) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Error: Cannot read file '\" , filename) , \"' (permission denied?)\")) ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ Error reading file: \" , error . to_s ())) ; return false } ; let mut word_count = content . split_whitespace () . len () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"✅ File processed: \" , word_count . to_s ()) , \" words\")) ; return true } } } } fn main () { let mut filename = { print ! (\"{}\" , \"Enter filename: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; if process_file (filename) { println ! (\"Processing completed successfully!\") } else { { println ! (\"Processing failed!\") ; exit (1i32) } } ; }\n  |\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpIgG7rk/main.rs:1:86\n  |\n1 | use std :: collections :: HashMap ; fn process_file (filename : i32) -> i32 { { if ! file_exists (filename) { { println ! (\"{:?}\" , forma...\n  |                                                                                      ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpIgG7rk/main.rs:1:233\n  |\n1 | ...-> i32 { { if ! file_exists (filename) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"❌ Error: File '\" , filename) , \"' does not exist\")) ; return false } }...\n  |       --- expected `i32` because of return type                                                                                                                        ^^^^^ expected `i32`, found `bool`\n\nerror[E0425]: cannot find function `file_readable` in this scope\n --> /tmp/.tmpIgG7rk/main.rs:1:250\n  |\n1 | ... \"' does not exist\")) ; return false } } ; if ! file_readable (filename) { { println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , ...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpIgG7rk/main.rs:1:457\n  |\n1 | ... ; return false } } ; { let content = r#try ; { { read_file (filename) } ; catch ; error ; { println ! (\"{:?}\" , format ! (\"{}{}\" , \"❌ ...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nwarning: unreachable statement\n --> /tmp/.tmpIgG7rk/main.rs:1:603\n  |\n1 | ...or . to_s ())) ; return false } ; let mut word_count = content . split_whitespace () . len () ; println ! (\"{:?}\" , format ! (\"{}{}\" ,...\n  |                     ------------     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable statement\n  |                     |\n  |                     any code following this expression is unreachable\n  |\n  = note: `#[warn(unreachable_code)]` on by default\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpIgG7rk/main.rs:1:1192\n  |\n1 | ...r') { input . pop () ; } } input } ; if process_file (filename) { { println ! (\"Processing completed successfully!\") } } else { { prin...\n  |                                            ------------  ^^^^^^^^ expected `i32`, found `String`\n  |                                            |\n  |                                            arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpIgG7rk/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn process_file (filename : i32) -> i32 { { if ! file_exists (filename) { { println ! (\"{:?}\" , forma...\n  |                                        ^^^^^^^^^^^^  --------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpIgG7rk/main.rs:1:1178\n  |\n1 | ...\\r') { input . pop () ; } } input } ; if process_file (filename) { { println ! (\"Processing completed successfully!\") } } else { { pri...\n  |                                             ^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror: aborting due to 11 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0423, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 9,
          "line_number": 375,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// Good CLI tool practices\n\nfun show_help() {\n    println(\"File Statistics Tool v1.0\")\n    println(\"\")\n    println(\"Usage:\")\n    println(\"  ruchy run file_stats.ruchy <filename>\")\n    println(\"\")\n    println(\"Examples:\")\n    println(\"  ruchy run file_stats.ruchy document.txt\")\n    println(\"  ruchy run file_stats.ruchy data/*.csv\")\n    println(\"\")\n    println(\"Options:\")\n    println(\"  --help     Show this help message\")\n    println(\"  --verbose  Show detailed output\")\n}\n\nfun process_with_progress(files) {\n    let total = files.len()\n    let mut i = 0\n    \n    while i < total {\n        let file = files[i]\n        let progress = ((i + 1) * 100) / total\n        print(\"\\rProcessing... [\" + progress.to_s() + \"%] \" + file)\n        \n        // Do the actual work\n        process_file(file)\n        \n        // Small delay to show progress\n        sleep(100)  // 100ms\n        i = i + 1\n    }\n    \n    println(\"\\n✅ All files processed!\")\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `sleep` in this scope\n --> /tmp/.tmpgNjiUm/main.rs:1:845\n  |\n1 | .... to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } ...\n  |                                                        ^^^^^ not found in this scope\n  |\nhelp: consider importing this function\n  |\n1 + use std::thread::sleep;\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpgNjiUm/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ;...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpgNjiUm/main.rs:1:549\n  |\n1 | ... { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } } } f...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                         ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ; println ! (\"  ruchy run file_stats.ruchy <filename>\") ; println ! (\"\") ; println ! (\"Examples:\") ; println ! (\"  ruchy run file_stats.ruchy document.txt\") ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\") ; println ! (\"\") ; println ! (\"Options:\") ; println ! (\"  --help     Show this help message\") ; println ! (\"  --verbose  Show detailed output\") } } fn process_with_progress (files : String) -> i32 { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ; println ! (\"  ruchy run file_stats.ruchy <filename>\") ; println ! (\"\") ; println ! (\"Examples:\") ; println ! (\"  ruchy run file_stats.ruchy document.txt\") ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\") ; println ! (\"\") ; println ! (\"Options:\") ; println ! (\"  --help     Show this help message\") ; println ! (\"  --verbose  Show detailed output\") } } fn process_with_progress (files : String) -> i32 { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpgNjiUm/main.rs:1:621\n  |\n1 | ... { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ...\n  |       ^^                                                                                                                                                                                                                                                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ; println ! (\"  ruchy run file_stats.ruchy <filename>\") ; println ! (\"\") ; println ! (\"Examples:\") ; println ! (\"  ruchy run file_stats.ruchy document.txt\") ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\") ; println ! (\"\") ; println ! (\"Options:\") ; println ! (\"  --help     Show this help message\") ; println ! (\"  --verbose  Show detailed output\") } } fn process_with_progress (files : String) -> i32 { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } } } fn main () { }\n1 + use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ; println ! (\"  ruchy run file_stats.ruchy <filename>\") ; println ! (\"\") ; println ! (\"Examples:\") ; println ! (\"  ruchy run file_stats.ruchy document.txt\") ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\") ; println ! (\"\") ; println ! (\"Options:\") ; println ! (\"  --help     Show this help message\") ; println ! (\"  --verbose  Show detailed output\") } } fn process_with_progress (files : String) -> i32 { { { let total = files . len () ; { let mut i = 0i32 ; while i < total { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } ; println ! (\"\\n✅ All files processed!\") } } } } fn main () { }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpgNjiUm/main.rs:1:613\n  |\n1 | ... = files . len () ; { let mut i = 0i32 ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 ...\n  |                                                   -   ^^^^^ expected `i32`, found `usize`\n  |                                                   |\n  |                                                   expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn show_help () { { println ! (\"File Statistics Tool v1.0\") ; println ! (\"\") ; println ! (\"Usage:\") ; println ! (\"  ruchy run file_stats.ruchy <filename>\") ; println ! (\"\") ; println ! (\"Examples:\") ; println ! (\"  ruchy run file_stats.ruchy document.txt\") ; println ! (\"  ruchy run file_stats.ruchy data/*.csv\") ; println ! (\"\") ; println ! (\"Options:\") ; println ! (\"  --help     Show this help message\") ; println ! (\"  --verbose  Show detailed output\") } } fn process_with_progress (files : String) -> i32 { { { let total = files . len () ; { let mut i = 0i32 ; while i < total.try_into().unwrap() { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } } } fn main () { }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ++++++++++++++++++++\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmpgNjiUm/main.rs:1:643\n  |\n1 | ... ; while i < total { { { let file = files [i as usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{:?}\" , format ! (...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpgNjiUm/main.rs:1:698\n  |\n1 | ...size] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" ,...\n  |                                                     ^^^^^ expected `i32`, found `usize`\n\nerror[E0277]: cannot divide `i32` by `usize`\n --> /tmp/.tmpgNjiUm/main.rs:1:696\n  |\n1 | ...usize] ; { let mut progress = i + 1i32 * 100i32 / total ; print ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\rProcessing... [\" ...\n  |                                                    ^ no implementation for `i32 / usize`\n  |\n  = help: the trait `Div<usize>` is not implemented for `i32`\n  = help: the following other types implement trait `Div<Rhs>`:\n            `&i32` implements `Div<i32>`\n            `&i32` implements `Div`\n            `i32` implements `Div<&i32>`\n            `i32` implements `Div`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpgNjiUm/main.rs:1:795\n  |\n1 | ...format ! (\"{}{}\" , \"\\rProcessing... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } ...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0425]: cannot find function `process_file` in this scope\n --> /tmp/.tmpgNjiUm/main.rs:1:823\n  |\n1 | ...g... [\" , progress . to_s ()) , \"%] \") + file) ; process_file (file) ; sleep (100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All file...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpgNjiUm/main.rs:1:885\n  |\n1 | ...(100i32) ; i = i + 1i32 } } } } ; println ! (\"\\n✅ All files processed!\") } } } } fn main () { }\n  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 8 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: to_s()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 10,
          "line_number": 431,
          "code": "// Status: ❌ BROKEN\n// Example: Manual line counting implementation\n\nfun main() {\n    // Sample file content for demonstration\n    let content = \"line 1\\nline 2\\nline 3\";\n    \n    // Manual line counting implementation\n    let mut lines = 1;\n    let mut i = 0;\n    while i < content.len() {\n        if content[i] == '\\n' {\n            lines = lines + 1;\n        }\n        i = i + 1;\n    }\n    \n    println(\"File has\", lines, \"lines\");\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: multiple unused formatting arguments\n --> /tmp/.tmpQciyHN/main.rs:1:291\n  |\n1 | ... 1i32 } } ; i = i + 1i32 } } ; println ! (\"File has\" , lines , \"lines\") } } } }\n  |                                              ----------   ^^^^^   ^^^^^^^ argument never used\n  |                                              |            |\n  |                                              |            argument never used\n  |                                              multiple missing formatting specifiers\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpQciyHN/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" . to_string () ; { let mut lines = 1i32 ; let...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpQciyHN/main.rs:1:50\n  |\n1 | ... { { { let content = \"line 1\\nline 2\\nline 3\" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"File has\" , lines , \"lines\") } } } }\n  |       ^^                                                                                                                                                                                                                                                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"File has\" , lines , \"lines\") } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let content = \"line 1\\nline 2\\nline 3\" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"File has\" , lines , \"lines\") } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpQciyHN/main.rs:1:219\n  |\n1 | ...content . len () { { if content [i as usize] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"File has\" , lines ,...\n  |                                                           ^^                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"File has\" , lines , \"lines\") } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\\n' { lines = lines + 1i32 } ; i = i + 1i32 } } ; println ! (\"File has\" , lines , \"lines\") } } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpQciyHN/main.rs:1:164\n  |\n1 | ...t lines = 1i32 ; let mut i = 0i32 ; while i < content . len () { { if content [i as usize] == '\\n' { { lines = lines + 1i32 } } ; i = ...\n  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`\n  |                                              |\n  |                                              expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let content = \"line 1\\nline 2\\nline 3\" . to_string () ; { let mut lines = 1i32 ; let mut i = 0i32 ; while i < content . len ().try_into().unwrap() { { if content [i as usize] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"File has\" , lines , \"lines\") } } } }\n  |                                                                                                                                                                                    ++++++++++++++++++++\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmpQciyHN/main.rs:1:197\n  |\n1 | ...while i < content . len () { { if content [i as usize] == '\\n' { { lines = lines + 1i32 } } ; i = i + 1i32 } } ; println ! (\"File has\"...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 11,
          "line_number": 534,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// task_manager.ruchy - A simple but useful task management tool\n\nlet TASK_FILE = \"tasks.txt\"\n\nfun show_menu() {\n    println(\"\\n=== Task Manager ===\")\n    println(\"1. List tasks\")\n    println(\"2. Add task\")\n    println(\"3. Complete task\")\n    println(\"4. Delete task\")\n    println(\"5. Quit\")\n}\n\nfun load_tasks() {\n    if file_exists(TASK_FILE) {\n        return read_lines(TASK_FILE)\n    }\n    return []\n}\n\nfun save_tasks(tasks) {\n    let content = tasks.join(\"\\n\")\n    write_file(TASK_FILE, content)\n}\n\nfun list_tasks(tasks) {\n    if tasks.is_empty() {\n        println(\"\\n📝 No tasks yet!\")\n        return\n    }\n    \n    println(\"\\n📋 Your Tasks (\" + tasks.len().to_s() + \" items):\")\n    let mut i = 0\n    while i < tasks.len() {\n        let task = tasks[i]\n        let status = if task.starts_with(\"✅\") { \"DONE\" } else { \"PENDING\" }\n        println((i + 1).to_s() + \". \" + task)\n        i = i + 1\n    }\n}\n\nfun add_task(tasks) {\n    let new_task = input(\"\\nWhat do you want to add? \")\n    tasks.push(\"📌 \" + new_task)\n    save_tasks(tasks)\n    println(\"✅ Task added!\")\n}\n\nfun complete_task(tasks) {\n    list_tasks(tasks)\n    let index = input(\"\\nWhich task to complete? (number): \").to_i() - 1\n    \n    if index >= 0 && index < tasks.len() {\n        tasks[index] = tasks[index].replace(\"📌\", \"✅\")\n        save_tasks(tasks)\n        println(\"🎉 Task completed!\")\n    } else {\n        println(\"❌ Invalid task number\")\n    }\n}\n\n// Main program loop\nlet tasks = load_tasks()\n\nloop {\n    show_menu()\n    let choice = input(\"\\nChoose option: \")\n    \n    match choice {\n        \"1\" => list_tasks(tasks)\n        \"2\" => add_task(tasks)\n        \"3\" => complete_task(tasks)\n        \"4\" => {\n            list_tasks(tasks)\n            let index = input(\"Which task to delete? (number): \").to_i() - 1\n            if index >= 0 && index < tasks.len() {\n                tasks.remove(index)\n                save_tasks(tasks)\n                println(\"🗑️  Task deleted!\")\n            }\n        }\n        \"5\" => {\n            println(\"👋 Goodbye!\")\n            break\n        }\n        _ => println(\"❌ Invalid choice\")\n    }\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `TASK_FILE` in this scope\n --> /tmp/.tmpXuFVbn/main.rs:1:288\n  |\n1 | ...) } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `TASK_FILE` in this scope\n --> /tmp/.tmpXuFVbn/main.rs:1:322\n  |\n1 | ...if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `TASK_FILE` in this scope\n --> /tmp/.tmpXuFVbn/main.rs:1:451\n  |\n1 | ...{ let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_e...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpXuFVbn/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXuFVbn/main.rs:1:301\n  |\n1 | ..._tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : Str...\n  |                                                      ^^                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { return read_lines (TASK_FILE) } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXuFVbn/main.rs:1:399\n  |\n1 | ...ks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : Str...\n  |                                 ^^                                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXuFVbn/main.rs:1:762\n  |\n1 | ... { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } }...\n  |       ^^                                                                                                                                                                                                                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXuFVbn/main.rs:1:847\n  |\n1 | ... as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}...\n  |                                                                   ^^      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { \"DONE\" } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXuFVbn/main.rs:1:867\n  |\n1 | ... status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s ()...\n  |                                                                 ^^         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { \"PENDING\" } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXuFVbn/main.rs:1:1021\n  |\n1 | ... { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn...\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpXuFVbn/main.rs:1:2140\n  |\n1 | ...) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.t...\n  |                                                    ^^                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { println ! (\"❌ Invalid task number\") } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nerror[E0425]: cannot find function `file_exists` in this scope\n --> /tmp/.tmpXuFVbn/main.rs:1:275\n  |\n1 | ...! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } f...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `read_lines` in this scope\n --> /tmp/.tmpXuFVbn/main.rs:1:310\n  |\n1 | ... -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `join` found for struct `String` in the current scope\n --> /tmp/.tmpXuFVbn/main.rs:1:425\n  |\n1 | ...asks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) ...\n  |                                                      ^^^^ method not found in `String`\n\nerror[E0425]: cannot find function `write_file` in this scope\n --> /tmp/.tmpXuFVbn/main.rs:1:439\n  |\n1 | ... -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if ...\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nerror[E0069]: `return;` in a function whose return type is not `()`\n --> /tmp/.tmpXuFVbn/main.rs:1:581\n  |\n1 | ...sks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\"...\n  |                     --- expected `i32` because of this return type                        ^^^^^^ return type is not `()`\n  |\nhelp: give the `return` a value of the expected type\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return 42 } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ++\n\nerror[E0599]: no method named `to_s` found for type `usize` in the current scope\n --> /tmp/.tmpXuFVbn/main.rs:1:690\n  |\n1 | ... ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task...\n  |                                                        ^^^^ method not found in `usize`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXuFVbn/main.rs:1:745\n  |\n1 | ... , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . start...\n  |                                               -   ^^^^^^^^^^^^^^ expected `i32`, found `usize`\n  |                                               |\n  |                                               expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len ().try_into().unwrap() { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ++++++++++++++++++++\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmpXuFVbn/main.rs:1:784\n  |\n1 | ...i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDIN...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0599]: no method named `to_s` found for type `i32` in the current scope\n --> /tmp/.tmpXuFVbn/main.rs:1:935\n  |\n1 | ...; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i3...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXuFVbn/main.rs:1:735\n  |\n1 | ...-> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } f...\n  |       --- expected `i32` because of return type                                                                                                                                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `while` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } /* `i32` value */ } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         +++++++++++++++++\n\nerror[E0599]: no method named `push` found for type `i32` in the current scope\n --> /tmp/.tmpXuFVbn/main.rs:1:1401\n  |\n1 | ...h ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task...\n  |                                                        ^^^^ method not found in `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXuFVbn/main.rs:1:1458\n  |\n1 | ...! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_...\n  |                                     ----------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                     |           |\n  |                                     |           expected `String`, found `i32`\n  |                                     arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpXuFVbn/main.rs:1:362\n  |\n1 | ... read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; writ...\n  |                                                         ^^^^^^^^^^  --------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXuFVbn/main.rs:1:1467\n  |\n1 | ...📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks)...\n  |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXuFVbn/main.rs:1:1557\n  |\n1 | ...e_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: ...\n  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                    |           |\n  |                                    |           expected `String`, found `i32`\n  |                                    arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpXuFVbn/main.rs:1:481\n  |\n1 | ...n (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 ...\n  |                                                         ^^^^^^^^^^  --------------\n\nerror[E0599]: no method named `to_i` found for struct `String` in the current scope\n --> /tmp/.tmpXuFVbn/main.rs:1:1940\n  |\n1 | ...ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usiz...\n  |                                                      ^^^^ method not found in `String`\n\nerror[E0599]: no method named `len` found for type `i32` in the current scope\n    --> /tmp/.tmpXuFVbn/main.rs:1:1993\n     |\n1    | ...} input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (...\n     |                                                                     ^^^\n     |\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1402:5\n     |\n1402 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXuFVbn/main.rs:1:2088\n  |\n1 | ... usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } ...\n  |                                      ----------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                      |           |\n  |                                      |           expected `String`, found `i32`\n  |                                      arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpXuFVbn/main.rs:1:362\n  |\n1 | ... read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; writ...\n  |                                                         ^^^^^^^^^^  --------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXuFVbn/main.rs:1:2097\n  |\n1 | ...ce (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main  ...\n  |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXuFVbn/main.rs:1:2142\n  |\n1 | ... (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_stri...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXuFVbn/main.rs:1:2677\n  |\n1 | ...'\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (task...\n  |                                                 ------   ^^^ expected `String`, found `&str`\n  |                                                 |\n  |                                                 this expression has type `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXuFVbn/main.rs:1:2705\n  |\n1 | .... pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { ...\n  |                                   ------                               ^^^ expected `String`, found `&str`\n  |                                   |\n  |                                   this expression has type `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXuFVbn/main.rs:1:2731\n  |\n1 | ...} input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (t...\n  |                      ------ this expression has type `String`                       ^^^ expected `String`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXuFVbn/main.rs:1:2762\n  |\n1 | ...nput } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (task...\n  |                   ------ this expression has type `String`                                                      ^^^ expected `String`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXuFVbn/main.rs:1:3321\n  |\n1 | ...ch choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" =>...\n  |       ------ this expression has type `String`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^^ expected `String`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXuFVbn/main.rs:1:2696\n  |\n1 | ...input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tas...\n  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                    |           |\n  |                                    |           expected `String`, found `i32`\n  |                                    arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpXuFVbn/main.rs:1:481\n  |\n1 | ...n (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 ...\n  |                                                         ^^^^^^^^^^  --------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXuFVbn/main.rs:1:2783\n  |\n1 | ...omplete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :...\n  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                    |           |\n  |                                    |           expected `String`, found `i32`\n  |                                    arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpXuFVbn/main.rs:1:481\n  |\n1 | ...n (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 ...\n  |                                                         ^^^^^^^^^^  --------------\n\nerror[E0599]: no method named `to_i` found for struct `String` in the current scope\n --> /tmp/.tmpXuFVbn/main.rs:1:3162\n  |\n1 | ...ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (inde...\n  |                                                      ^^^^ method not found in `String`\n\nerror[E0599]: no method named `len` found for type `i32` in the current scope\n    --> /tmp/.tmpXuFVbn/main.rs:1:3215\n     |\n1    | ...} input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"...\n     |                                                                     ^^^\n     |\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1402:5\n     |\n1402 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `remove` found for type `i32` in the current scope\n --> /tmp/.tmpXuFVbn/main.rs:1:3234\n  |\n1 | ...- 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task dele...\n  |                                                                    ^^^^^^\n  |\nhelp: there is a method `rem` with a similar name\n  |\n1 - use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n1 + use std :: collections :: HashMap ; fn show_menu () { { println ! (\"\\n=== Task Manager ===\") ; println ! (\"1. List tasks\") ; println ! (\"2. Add task\") ; println ! (\"3. Complete task\") ; println ! (\"4. Delete task\") ; println ! (\"5. Quit\") } } fn load_tasks () -> i32 { { if file_exists (TASK_FILE) { { return read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; write_file (TASK_FILE , content) } } } fn list_tasks (tasks : String) -> i32 { { if tasks . is_empty () { { println ! (\"\\n📝 No tasks yet!\") ; return } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"\\n📋 Your Tasks (\" , tasks . len () . to_s ()) , \" items):\")) ; let mut i = 0i32 ; while i < tasks . len () { { { let task = tasks [i as usize] ; { let mut status = if task . starts_with (\"✅\") { { \"DONE\" } } else { { \"PENDING\" } } ; println ! (\"{:?}\" , format ! (\"{}{}\" , i + 1i32 . to_s () , \". \") + task) ; i = i + 1i32 } } } } } } fn add_task (tasks : i32) -> i32 { { { let new_task = { print ! (\"{}\" , \"\\nWhat do you want to add? \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; { tasks . push (format ! (\"{}{}\" , \"📌 \" , new_task)) ; save_tasks (tasks) ; println ! (\"✅ Task added!\") } } } } fn complete_task (tasks : i32) -> i32 { { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"\\nWhich task to complete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks [index as usize] = tasks [index as usize] . replace (\"📌\" , \"✅\") ; save_tasks (tasks) ; println ! (\"🎉 Task completed!\") } } else { { println ! (\"❌ Invalid task number\") } } } } } fn main () { let mut TASK_FILE = \"tasks.txt\" . to_string () ; let mut tasks = load_tasks () ; loop { { show_menu () ; { let choice = { print ! (\"{}\" , \"\\nChoose option: \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . rem (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\") ; break } , _ => println ! (\"❌ Invalid choice\") , } } } } ; }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpXuFVbn/main.rs:1:3263\n  |\n1 | ...() { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } } , \"5\" => { println ! (\"👋 Goodbye!\")...\n  |                                    ----------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                    |           |\n  |                                    |           expected `String`, found `i32`\n  |                                    arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmpXuFVbn/main.rs:1:362\n  |\n1 | ... read_lines (TASK_FILE) } } ; return vec ! [] } } fn save_tasks (tasks : String) -> i32 { { { let content = tasks . join (\"\\n\") ; writ...\n  |                                                         ^^^^^^^^^^  --------------\n\nerror[E0308]: `match` arms have incompatible types\n --> /tmp/.tmpXuFVbn/main.rs:1:3179\n  |\n1 | ... ; match choice { \"1\" => list_tasks (tasks) , \"2\" => add_task (tasks) , \"3\" => complete_task (tasks) , \"4\" => { list_tasks (tasks) ; { let index = { print ! (\"{}\" , \"Which task to delete? (number): \") ; std :: io :: Write :: flush (& mut std :: io :: stdout ()) . unwrap () ; let mut input = String :: new () ; std :: io :: stdin () . read_line (& mut input) . expect (\"Failed to read input\") ; if input . ends_with ('\\n') { input . pop () ; if input . ends_with ('\\r') { input . pop () ; } } input } . to_i () - 1i32 ; if index >= 0i32 && index < tasks . len () { { tasks . remove (index) ; save_tasks (tasks) ; println ! (\"🗑\\u{fe0f}  Task deleted!\") } } } ...\n  |       ------------          ------------------          ----------------          --------------------- this is found to be of type `i32`                                                                                                                                                                                                                                                                                                                                                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |       |                     |                           |\n  |       |                     |                           this is found to be of type `i32`\n  |       |                     this is found to be of type `i32`\n  |       `match` arms have incompatible types\n\nerror: aborting due to 34 previous errors; 8 warnings emitted\n\nSome errors have detailed explanations: E0069, E0277, E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain E0069`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: join()"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 12,
          "line_number": 655,
          "code": "// Status: ✅ WORKING\n// ❌ This demonstrates what NOT to do - no error handling\n\nfun main() {\n    // Example of code that would fail without proper error checking\n    println(\"Example: Unsafe file operations\");\n    println(\"This pattern would crash if file doesn't exist:\");\n    println(\"// let content = read_file(\\\"missing.txt\\\");\");\n    \n    // Better approach would include error checking\n    println(\"Always check if operations can fail before using them\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 13,
          "line_number": 677,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Confusing and unhelpful\nprintln(\"Enter thing:\")\nlet thing = input()\n// What thing? What format?\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpgogL09/main.rs:1:337\n  |\n1 | ... ('\\r') { input . pop () ; } } input } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpgogL09/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { println ! (\"Enter thing:\") ; let mut thing = { let mut input = String :: ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-command-line-tools.md",
          "example_number": 14,
          "line_number": 695,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Only works on your computer\nlet data = read_file(\"/Users/noah/Desktop/data.txt\")\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected expression, found `let` statement\n --> /tmp/.tmpUTKNci/main.rs:1:63\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let mut data = read_file (\"/Users/noah/Desktop/data.txt\" . to_string ()) ; ...\n  |                                                               ^^^\n  |\n  = note: only supported directly in conditions of `if` and `while` expressions\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpUTKNci/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let mut data = read_file (\"/Users/noah/Desktop/data.txt\" . to_string ()) ; ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `read_file` in this scope\n --> /tmp/.tmpUTKNci/main.rs:1:78\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = let mut data = read_file (\"/Users/noah/Desktop/data.txt\" . to_string ()) ; ...\n  |                                                                              ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch12-00-traits-generics": {
      "chapter": "ch12-00-traits-generics",
      "total_examples": 11,
      "working_examples": 0,
      "failing_examples": 11,
      "examples": [
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 1,
          "line_number": 48,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Define behavior with traits\ntrait Serializable {\n    fun serialize(self) -> String\n    fun deserialize(String) -> Self\n}\n\n// Generic function works with any Serializable type\nfun save_to_file<T: Serializable>(item: T, path: String) {\n    let serialized = item.serialize()\n    write_file(path, serialized)\n}\n\nfun load_from_file<T: Serializable>(path: String) -> T {\n    let content = read_file(path)\n    return T::deserialize(content)\n}\n\n// Implement trait for your types\nstruct User {\n    name: String\n    email: String\n    age: i32\n}\n\nimpl Serializable for User {\n    fun serialize(self) -> String {\n        return to_json(self)\n    }\n    \n    fun deserialize(data: String) -> User {\n        return parse_json(data)\n    }\n}\n\n// Now it just works!\nlet user = User{name: \"Alice\", email: \"alice@example.com\", age: 30}\nsave_to_file(user, \"user.json\")  // Generic function, specific type\nlet loaded: User = load_from_file(\"user.json\")  // Type safe!",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 2,
          "line_number": 105,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Simple trait\ntrait Drawable {\n    fun draw(self)\n}\n\n// Trait with multiple methods\ntrait Container {\n    fun len(self) -> i32\n    fun is_empty(self) -> bool {\n        return self.len() == 0  // Default implementation\n    }\n    fun clear(mut self)\n}\n\n// Traits with associated types\ntrait Iterator {\n    type Item\n    \n    fun next(mut self) -> Option<Item>\n    \n    fun collect(mut self) -> Vec<Item> {\n        let result = Vec::new()\n        while let Some(item) = self.next() {\n            result.push(item)\n        }\n        return result\n    }\n}\n\n// Traits with constraints\ntrait Comparable: Eq {\n    fun compare(self, other: Self) -> Ordering\n}\n\n// Trait inheritance\ntrait Animal {\n    fun speak(self)\n}\n\ntrait Dog: Animal {\n    fun wag_tail(self)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 3,
          "line_number": 162,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nstruct Point {\n    x: f64\n    y: f64\n}\n\nimpl Drawable for Point {\n    fun draw(self) {\n        println(\"Point at (\" + self.x.to_s() + \", \" + self.y.to_s() + \")\")\n    }\n}\n\nstruct Circle {\n    center: Point\n    radius: f64\n}\n\nimpl Drawable for Circle {\n    fun draw(self) {\n        println(\"Circle at (\" + self.center.x.to_s() + \", \" + self.center.y.to_s() + \") with radius \" + self.radius.to_s())\n    }\n}\n\n// Now both types can be drawn\nlet p = Point{x: 10, y: 20}\nlet c = Circle{center: p, radius: 5}\n\np.draw()  // Trait method\nc.draw()  // Same interface, different implementation\n\n// Implement traits for existing types\nimpl Drawable for String {\n    fun draw(self) {\n        println(\"Text: \" + self)\n    }\n}\n\n\"Hello\".draw()  // Extension methods!",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 4,
          "line_number": 214,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Simple generic function\nfun swap<T>(a: mut T, b: mut T) {\n    let temp = a\n    a = b\n    b = temp\n}\n\n// Multiple type parameters\nfun pair<K, V>(key: K, value: V) -> (K, V) {\n    return (key, value)\n}\n\n// Trait bounds\nfun print_all<T: Display>(items: Vec<T>) {\n    for item in items {\n        println(item)  // Works because T implements Display\n    }\n}\n\n// Multiple bounds\nfun process<T: Clone + Debug + Send>(item: T) {\n    let copy = item.clone()\n    debug(copy)\n    send_to_thread(item)\n}\n\n// Where clauses for complex bounds\nfun complex_function<T, U>(x: T, y: U) -> Vec<T>\nwhere\n    T: Clone + From<U>,\n    U: Display + Into<String>\n{\n    let converted: T = T::from(y)\n    return vec![x.clone(), converted]\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 5,
          "line_number": 264,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Generic struct\nstruct Pair<T> {\n    first: T\n    second: T\n}\n\nimpl<T> Pair<T> {\n    fun new(first: T, second: T) -> Pair<T> {\n        return Pair{first, second}\n    }\n    \n    fun swap(mut self) {\n        let temp = self.first\n        self.first = self.second\n        self.second = temp\n    }\n}\n\n// Generic enum\nenum Option<T> {\n    Some(T)\n    None\n}\n\nenum Result<T, E> {\n    Ok(T)\n    Err(E)\n}\n\n// Generic with constraints\nstruct SortedVec<T: Ord> {\n    items: Vec<T>\n}\n\nimpl<T: Ord> SortedVec<T> {\n    fun insert(mut self, item: T) {\n        let pos = self.items.binary_search(item)\n        self.items.insert(pos, item)\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 6,
          "line_number": 319,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Custom collection with traits\nstruct Cache<K: Hash + Eq, V> {\n    map: HashMap<K, V>\n    max_size: usize\n    access_order: Vec<K>\n}\n\nimpl<K: Hash + Eq + Clone, V: Clone> Cache<K, V> {\n    fun new(max_size: usize) -> Cache<K, V> {\n        return Cache{\n            map: HashMap::new(),\n            max_size,\n            access_order: Vec::new()\n        }\n    }\n    \n    fun get(mut self, key: K) -> Option<V> {\n        if let Some(value) = self.map.get(key) {\n            // Update access order\n            self.access_order.retain(|k| k != key)\n            self.access_order.push(key.clone())\n            return Some(value.clone())\n        }\n        return None\n    }\n    \n    fun put(mut self, key: K, value: V) {\n        if self.map.len() >= self.max_size && !self.map.contains_key(key) {\n            // Evict least recently used\n            let lru = self.access_order.remove(0)\n            self.map.remove(lru)\n        }\n        \n        self.map.insert(key.clone(), value)\n        self.access_order.push(key)\n    }\n}\n\n// Use with any hashable types\nlet cache: Cache<String, User> = Cache::new(100)\ncache.put(\"alice\", alice_user)\n\nlet cache2: Cache<i32, Vec<String>> = Cache::new(50)\ncache2.put(1, vec![\"data\"])",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 7,
          "line_number": 378,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Trait for plugins\ntrait Plugin {\n    fun name(self) -> String\n    fun execute(self, context: Context) -> Result<(), Error>\n}\n\nstruct LogPlugin {\n    level: String\n}\n\nimpl Plugin for LogPlugin {\n    fun name(self) -> String {\n        return \"Logger\"\n    }\n    \n    fun execute(self, context: Context) -> Result<(), Error> {\n        log(self.level, context.message)\n        return Ok(())\n    }\n}\n\n// Store different plugin types\nlet plugins: Vec<Box<dyn Plugin>> = vec![\n    Box::new(LogPlugin{level: \"INFO\"}),\n    Box::new(MetricsPlugin{...}),\n    Box::new(CachePlugin{...})\n]\n\n// Execute all plugins\nfor plugin in plugins {\n    plugin.execute(context)?\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 8,
          "line_number": 423,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Generic builder\nstruct Builder<T> {\n    value: T\n}\n\nimpl<T> Builder<T> {\n    fun new(initial: T) -> Builder<T> {\n        return Builder{value: initial}\n    }\n    \n    fun with<F>(mut self, f: F) -> Builder<T>\n    where F: FnOnce(mut T) -> T\n    {\n        self.value = f(self.value)\n        return self\n    }\n    \n    fun build(self) -> T {\n        return self.value\n    }\n}\n\n// Use with any type\nlet config = Builder::new(Config::default())\n    .with(|c| { c.port = 8080; c })\n    .with(|c| { c.host = \"localhost\"; c })\n    .with(|c| { c.workers = 4; c })\n    .build()\n\nlet user = Builder::new(User::new())\n    .with(|u| { u.name = \"Alice\"; u })\n    .with(|u| { u.role = Role::Admin; u })\n    .build()",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 9,
          "line_number": 469,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Associated types pattern\ntrait Graph {\n    type Node\n    type Edge\n    \n    fun nodes(self) -> Vec<Node>\n    fun edges(self) -> Vec<Edge>\n    fun neighbors(self, node: Node) -> Vec<Node>\n}\n\nstruct SocialNetwork {\n    users: Vec<User>\n    connections: Vec<Friendship>\n}\n\nimpl Graph for SocialNetwork {\n    type Node = User\n    type Edge = Friendship\n    \n    fun nodes(self) -> Vec<User> {\n        return self.users\n    }\n    \n    fun edges(self) -> Vec<Friendship> {\n        return self.connections\n    }\n    \n    fun neighbors(self, user: User) -> Vec<User> {\n        self.connections\n            .filter(|f| f.from == user.id || f.to == user.id)\n            .map(|f| self.get_user(f.other_id(user.id)))\n            .collect()\n    }\n}\n\n// Phantom types for compile-time guarantees\nstruct Id<T> {\n    value: String\n    _phantom: PhantomData<T>\n}\n\nimpl<T> Id<T> {\n    fun new(value: String) -> Id<T> {\n        return Id{value, _phantom: PhantomData}\n    }\n}\n\n// Type-safe IDs\nlet user_id: Id<User> = Id::new(\"user_123\")\nlet post_id: Id<Post> = Id::new(\"post_456\")\n\n// Won't compile - type safety!\n// let wrong = user_id == post_id",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 10,
          "line_number": 537,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Generics are monomorphized - no runtime cost\nfun generic_add<T: Add>(a: T, b: T) -> T {\n    return a + b  // Compiles to specific add instruction\n}\n\n// This generates two functions at compile time:\nlet int_result = generic_add(5, 10)      // Generates add_i32\nlet float_result = generic_add(5.0, 10.0) // Generates add_f64\n\n// Trait bounds are checked at compile time\nfun process<T: Send + Sync>(item: T) {\n    // Can safely send to another thread\n    spawn(|| {\n        use_item(item)\n    })\n}\n\n// Inline hints for performance\n#[inline]\nfun hot_path<T: Copy>(x: T) -> T {\n    return x  // Will be inlined\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch12-00-traits-generics.md",
          "example_number": 11,
          "line_number": 572,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// Static dispatch (faster)\nfun static_dispatch<T: Display>(item: T) {\n    println(item)  // Direct call, no indirection\n}\n\n// Dynamic dispatch (flexible)\nfun dynamic_dispatch(item: Box<dyn Display>) {\n    println(item)  // Virtual call through vtable\n}\n\n// Choose based on needs:\n// - Static: Known types, performance critical\n// - Dynamic: Plugin systems, heterogeneous collections",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch03-00-functions-tdd": {
      "chapter": "ch03-00-functions-tdd",
      "total_examples": 9,
      "working_examples": 8,
      "failing_examples": 1,
      "examples": [
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun greet() {\n    println(\"Hello from function!\");\n}\n\nfun main() {\n    greet();\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 2,
          "line_number": 54,
          "code": "// Status: ✅ WORKING\nfun add(a, b) {\n    a + b\n}\n\nfun main() {\n    let result = add(5, 3);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 3,
          "line_number": 77,
          "code": "// Status: ✅ WORKING\nfun multiply(x: i32, y: i32) -> i32 {\n    x * y\n}\n\nfun main() {\n    let product = multiply(6, 7);\n    println(product);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 4,
          "line_number": 100,
          "code": "// Status: ✅ WORKING\nfun square(n: i32) -> i32 {\n    n * n\n}\n\nfun sum_of_squares(a: i32, b: i32) -> i32 {\n    square(a) + square(b)\n}\n\nfun main() {\n    let result = sum_of_squares(3, 4);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 5,
          "line_number": 127,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfun function_name(parameters) -> return_type {\n    // function body\n    return_expression\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `return_type` in this scope\n --> /tmp/.tmpg81S1u/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }\n  |                                                                               ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `return_expression` in this scope\n --> /tmp/.tmpg81S1u/main.rs:1:95\n  |\n1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }\n  |                                                                                               ^^^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpg81S1u/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpg81S1u/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }\n  |                                                                                             ^^                 ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { { return_expression } } fn main () { }\n1 + use std :: collections :: HashMap ; fn function_name (parameters : String) -> return_type { return_expression } fn main () { }\n  |\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 6,
          "line_number": 166,
          "code": "// Status: ✅ WORKING\nfun calculate(x: i32, y: i32) -> i32 {\n    x * 2 + y * 3\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 7,
          "line_number": 195,
          "code": "// Status: ✅ WORKING\nfun calculate(input: i32) -> i32 {\n    input * 2\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 8,
          "line_number": 205,
          "code": "// Status: ✅ WORKING\nfun combine(a: i32, b: i32, c: i32) -> i32 {\n    a + b + c\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 9,
          "line_number": 215,
          "code": "// Status: ✅ WORKING\nfun helper(x: i32) -> i32 {\n    x * x\n}\n\nfun main_calculation(n: i32) -> i32 {\n    helper(n) + helper(n + 1)\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch11-00-file-operations-tdd": {
      "chapter": "ch11-00-file-operations-tdd",
      "total_examples": 10,
      "working_examples": 5,
      "failing_examples": 5,
      "examples": [
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun read_config() -> i32 {\n    // Simulate reading a config value\n    return 42;\n}\n\nfun write_status(value: i32) -> bool {\n    // Simulate writing status\n    if value > 0 {\n        return true;\n    }\n    return false;\n}\n\nfun main() {\n    let config = read_config();\n    println(\"Config value:\");\n    println(config);\n    \n    let success = write_status(config);\n    println(\"Write success:\");\n    println(success);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 2,
          "line_number": 72,
          "code": "// Status: ✅ WORKING\nfun save_game_state(level: i32, score: i32) {\n    println(\"Saving game state...\");\n    println(\"Level:\");\n    println(level);\n    println(\"Score:\");\n    println(score);\n    println(\"State saved successfully\");\n}\n\nfun load_game_state() {\n    println(\"Loading game state...\");\n    println(\"Level: 5\");\n    println(\"Score: 1000\");\n    println(\"State loaded successfully\");\n}\n\nfun main() {\n    save_game_state(5, 1000);\n    println(\"---\");\n    load_game_state();\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 3,
          "line_number": 118,
          "code": "// Status: ✅ WORKING\nfun get_default_config() -> i32 {\n    return 100;\n}\n\nfun validate_config(value: i32) -> bool {\n    if value > 0 && value <= 1000 {\n        return true;\n    }\n    return false;\n}\n\nfun apply_config(value: i32) {\n    println(\"Applying configuration...\");\n    println(\"Config value:\");\n    println(value);\n    if validate_config(value) {\n        println(\"Configuration applied successfully\");\n    } else {\n        println(\"Invalid configuration\");\n    }\n}\n\nfun main() {\n    let config = get_default_config();\n    apply_config(config);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp679z50/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp679z50/main.rs:1:71\n  |\n1 | use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if...\n  |                                                                       ^^             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! (\"Applying configuration...\") ; println ! (\"Config value:\") ; println ! (\"{:?}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\") } } else { { println ! (\"Invalid configuration\") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { return 100i32 } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! (\"Applying configuration...\") ; println ! (\"Config value:\") ; println ! (\"{:?}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\") } } else { { println ! (\"Invalid configuration\") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp679z50/main.rs:1:174\n  |\n1 | ...e : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 {...\n  |                                                               ^^           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! (\"Applying configuration...\") ; println ! (\"Config value:\") ; println ! (\"{:?}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\") } } else { { println ! (\"Invalid configuration\") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { return true } ; return false } } fn apply_config (value : i32) -> i32 { { println ! (\"Applying configuration...\") ; println ! (\"Config value:\") ; println ! (\"{:?}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\") } } else { { println ! (\"Invalid configuration\") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp679z50/main.rs:1:382\n  |\n1 | ... , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\") } } else { { println ! (\"Invalid configura...\n  |                                             ^^                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! (\"Applying configuration...\") ; println ! (\"Config value:\") ; println ! (\"{:?}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\") } } else { { println ! (\"Invalid configuration\") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! (\"Applying configuration...\") ; println ! (\"Config value:\") ; println ! (\"{:?}\" , value) ; if validate_config (value) { println ! (\"Configuration applied successfully\") } else { { println ! (\"Invalid configuration\") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp679z50/main.rs:1:444\n  |\n1 | ...onfiguration applied successfully\") } } else { { println ! (\"Invalid configuration\") } } } } fn main () { { { let config = get_default...\n  |                                                   ^^                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! (\"Applying configuration...\") ; println ! (\"Config value:\") ; println ! (\"{:?}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\") } } else { { println ! (\"Invalid configuration\") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! (\"Applying configuration...\") ; println ! (\"Config value:\") ; println ! (\"{:?}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\") } } else { println ! (\"Invalid configuration\") } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp679z50/main.rs:1:503\n  |\n1 | ...figuration\") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n  |                                      ^^                                                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! (\"Applying configuration...\") ; println ! (\"Config value:\") ; println ! (\"{:?}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\") } } else { { println ! (\"Invalid configuration\") } } } } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n1 + use std :: collections :: HashMap ; fn get_default_config () -> i32 { { return 100i32 } } fn validate_config (value : i32) -> bool { { if value > 0i32 && value <= 1000i32 { { return true } } ; return false } } fn apply_config (value : i32) -> i32 { { println ! (\"Applying configuration...\") ; println ! (\"Config value:\") ; println ! (\"{:?}\" , value) ; if validate_config (value) { { println ! (\"Configuration applied successfully\") } } else { { println ! (\"Invalid configuration\") } } } } fn main () { { let config = get_default_config () ; apply_config (config) } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp679z50/main.rs:1:384\n  |\n1 | ... validate_config (value) { { println ! (\"Configuration applied successfully\") } } else { { println ! (\"Invalid configuration\") } } } }...\n  |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp679z50/main.rs:1:446\n  |\n1 | ...applied successfully\") } } else { { println ! (\"Invalid configuration\") } } } } fn main () { { { let config = get_default_config () ; ...\n  |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp679z50/main.rs:1:544\n  |\n1 | ... } fn main () { { { let config = get_default_config () ; apply_config (config) } } }\n  |                 -                                           ^^^^^^^^^^^^^^^^^^^^^- help: consider using a semicolon here: `;`\n  |                 |                                           |\n  |                 |                                           expected `()`, found `i32`\n  |                 expected `()` because of default return type\n\nerror: aborting due to 3 previous errors; 6 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 4,
          "line_number": 181,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfun read_data() -> DataType {\n    // Return simulated data\n    return default_value;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `DataType` in this scope\n --> /tmp/.tmpTBDHxo/main.rs:1:56\n  |\n1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n  |                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `default_value` in this scope\n --> /tmp/.tmpTBDHxo/main.rs:1:76\n  |\n1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n  |                                                                            ^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpTBDHxo/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTBDHxo/main.rs:1:67\n  |\n1 | use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n  |                                                                   ^^                    ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn read_data () -> DataType { { return default_value } } fn main () { }\n1 + use std :: collections :: HashMap ; fn read_data () -> DataType { return default_value } fn main () { }\n  |\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 5,
          "line_number": 193,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfun write_data(value: DataType) -> bool {\n    // Validate and \"write\"\n    if valid(value) {\n        return true;\n    }\n    return false;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `DataType` in this scope\n --> /tmp/.tmpaWnTda/main.rs:1:60\n  |\n1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...\n  |                                                            ^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpaWnTda/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpaWnTda/main.rs:1:101\n  |\n1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...\n  |                                                                                                     ^^           ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } fn main () { }\n1 + use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { return true } ; return false } } fn main () { }\n  |\n\nerror[E0425]: cannot find function `valid` in this scope\n --> /tmp/.tmpaWnTda/main.rs:1:85\n  |\n1 | use std :: collections :: HashMap ; fn write_data (value : DataType) -> bool { { if valid (value) { { return true } } ; return false } } ...\n  |                                                                                     ^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 6,
          "line_number": 208,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nfun load_config() -> ConfigType {\n    return default_config;\n}\n\nfun save_config(config: ConfigType) -> bool {\n    return validate(config);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `ConfigType` in this scope\n --> /tmp/.tmpEeD1wP/main.rs:1:58\n  |\n1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...\n  |                                                          ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `default_config` in this scope\n --> /tmp/.tmpEeD1wP/main.rs:1:80\n  |\n1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...\n  |                                                                                ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `ConfigType` in this scope\n --> /tmp/.tmpEeD1wP/main.rs:1:124\n  |\n1 | ...eturn default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n  |                                                      ^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpEeD1wP/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEeD1wP/main.rs:1:71\n  |\n1 | use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) ->...\n  |                                                                       ^^                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { return default_config } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpEeD1wP/main.rs:1:146\n  |\n1 | ...g } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n  |                                                         ^^                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n1 + use std :: collections :: HashMap ; fn load_config () -> ConfigType { { return default_config } } fn save_config (config : ConfigType) -> bool { return validate (config) } fn main () { }\n  |\n\nerror[E0425]: cannot find function `validate` in this scope\n --> /tmp/.tmpEeD1wP/main.rs:1:155\n  |\n1 | ...ve_config (config : ConfigType) -> bool { { return validate (config) } } fn main () { }\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 7,
          "line_number": 237,
          "code": "// Status: ✅ WORKING\nfun load_settings() -> i32 {\n    return 50; // Default volume\n}\n\nfun save_settings(volume: i32) -> bool {\n    return volume >= 0 && volume <= 100;\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 8,
          "line_number": 251,
          "code": "// Status: ✅ WORKING\nfun save_progress(level: i32, score: i32) {\n    println(\"Saving progress...\");\n    println(level);\n    println(score);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 9,
          "line_number": 263,
          "code": "// Status: ✅ WORKING\nfun get_cached_value(key: i32) -> i32 {\n    // Simulate cache lookup\n    if key == 1 {\n        return 100;\n    }\n    return 0;\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch11-00-file-operations-tdd.md",
          "example_number": 10,
          "line_number": 277,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\nfun log_event(message: &str, severity: i32) {\n    println(\"LOG:\");\n    println(message);\n    println(\"Severity:\");\n    println(severity);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch05-00-control-flow-tdd": {
      "chapter": "ch05-00-control-flow-tdd",
      "total_examples": 14,
      "working_examples": 8,
      "failing_examples": 6,
      "examples": [
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let x = 10;\n    if x > 5 {\n        println(\"x is greater than 5\");\n    } else {\n        println(\"x is not greater than 5\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 2,
          "line_number": 55,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let score = 85;\n    if score >= 80 {\n        println(\"Great job!\");\n    }\n    println(\"Score processed\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 3,
          "line_number": 78,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let grade = 75;\n    if grade >= 90 {\n        println(\"A grade\");\n    } else if grade >= 80 {\n        println(\"B grade\");\n    } else if grade >= 70 {\n        println(\"C grade\");\n    } else {\n        println(\"Below C\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 4,
          "line_number": 105,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let mut i = 0;\n    while i < 3 {\n        println(i);\n        i = i + 1;\n    }\n    println(\"Done\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 5,
          "line_number": 131,
          "code": "// Status: ✅ WORKING\nfun main() {\n    for i in 0..3 {\n        println(i);\n    }\n    println(\"For loop done\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 6,
          "line_number": 155,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let number = 2;\n    match number {\n        1 => println(\"One\"),\n        2 => println(\"Two\"),\n        3 => println(\"Three\"),\n        _ => println(\"Other\")\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 7,
          "line_number": 179,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let mut i = 0;\n    while i < 10 {\n        i = i + 1;\n        if i == 3 {\n            continue;\n        }\n        if i == 6 {\n            break;\n        }\n        println(i);\n    }\n    println(\"Loop ended\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 8,
          "line_number": 236,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nif condition {\n    // true branch\n} else if other_condition {\n    // else if branch\n} else {\n    // false branch\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `condition` in this scope\n --> /tmp/.tmpJ5BSE6/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...\n  |                                                                  ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `other_condition` in this scope\n --> /tmp/.tmpJ5BSE6/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...\n  |                                                                                             ^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpJ5BSE6/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if condition { () } else { if other_condition { () } else { () } } ; if let...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 9,
          "line_number": 251,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\n// While loop\nwhile condition {\n    // loop body\n}\n\n// For loop with range\nfor variable in start..end {\n    // loop body\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `condition` in this scope\n --> /tmp/.tmpHV7hLn/main.rs:1:71\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...\n  |                                                                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `start` in this scope\n --> /tmp/.tmpHV7hLn/main.rs:1:106\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...\n  |                                                                                                          ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `end` in this scope\n --> /tmp/.tmpHV7hLn/main.rs:1:115\n  |\n1 | ... { while condition { () } ; for variable in start .. end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast...\n  |                                                         ^^^ not found in this scope\n  |\nhelp: you might have meant to write `.` instead of `..`\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start.end { () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpHV7hLn/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { while condition { () } ; for variable in start .. end { () } } ; if let S...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 10,
          "line_number": 268,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nmatch value {\n    pattern1 => action1,\n    pattern2 => action2,\n    _ => default_action\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `value` in this scope\n --> /tmp/.tmpQk1yFt/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...\n  |                                                                     ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `action1` in this scope\n --> /tmp/.tmpQk1yFt/main.rs:1:89\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...\n  |                                                                                         ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `action2` in this scope\n --> /tmp/.tmpQk1yFt/main.rs:1:111\n  |\n1 | ... = match value { pattern1 => action1 , pattern2 => action2 , _ => default_action , } ; if let Some (s) = (& result as & dyn std :: any...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `default_action` in this scope\n --> /tmp/.tmpQk1yFt/main.rs:1:126\n  |\n1 | ...attern1 => action1 , pattern2 => action2 , _ => default_action , } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcas...\n  |                                                    ^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpQk1yFt/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match value { pattern1 => action1 , pattern2 => action2 , _ => default_acti...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 11,
          "line_number": 295,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nif user_input > threshold {\n    process_high_value();\n} else {\n    process_normal_value();\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `user_input` in this scope\n --> /tmp/.tmpcBeyJm/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...\n  |                                                                  ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `threshold` in this scope\n --> /tmp/.tmpcBeyJm/main.rs:1:79\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...\n  |                                                                               ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpcBeyJm/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpcBeyJm/main.rs:1:91\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...\n  |                                                                                           ^^                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { process_high_value () } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpcBeyJm/main.rs:1:126\n  |\n1 | ...put > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :...\n  |                                                         ^^                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { process_normal_value () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0425]: cannot find function `process_high_value` in this scope\n --> /tmp/.tmpcBeyJm/main.rs:1:93\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = if user_input > threshold { { process_high_value () } } else { { process_no...\n  |                                                                                             ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `process_normal_value` in this scope\n --> /tmp/.tmpcBeyJm/main.rs:1:128\n  |\n1 | ...shold { { process_high_value () } } else { { process_normal_value () } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . d...\n  |                                                 ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 12,
          "line_number": 308,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet mut count = 0;\nwhile count < 10 {\n    do_something();\n    count = count + 1;\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp0l8g4M/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut count = 0i32 ; while count < 10i32 { { do_something () ; count = ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `do_something` in this scope\n --> /tmp/.tmp0l8g4M/main.rs:1:112\n  |\n1 | ...{ let mut count = 0i32 ; while count < 10i32 { { do_something () ; count = count + 1i32 } } } ; if let Some (s) = (& result as & dyn s...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 13,
          "line_number": 321,
          "code": "// Status: ✅ WORKING\nfor i in 1..5 {\n    println(\"Processing item \" + i);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 14,
          "line_number": 331,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nmatch status_code {\n    200 => println(\"Success\"),\n    404 => println(\"Not Found\"),\n    500 => println(\"Server Error\"),\n    _ => println(\"Unknown Status\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `status_code` in this scope\n --> /tmp/.tmp1Dzxll/main.rs:1:69\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match status_code { 200i32 => println ! (\"Success\") , 404i32 => println ! (...\n  |                                                                     ^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp1Dzxll/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = match status_code { 200i32 => println ! (\"Success\") , 404i32 => println ! (...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "appendix-c-troubleshooting": {
      "chapter": "appendix-c-troubleshooting",
      "total_examples": 20,
      "working_examples": 1,
      "failing_examples": 19,
      "examples": [
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 1,
          "line_number": 25,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Error\nlet x = 42\nlet y = 24\n\n// ✅ Fixed\nlet x = 42;\nlet y = 24;\n\n// Note: Semicolons needed for statements, not expressions\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpIa8ns9/main.rs:1:143\n  |\n1 | ... let mut x = 42i32 ; let mut y = 24i32 } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpIa8ns9/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut x = 42i32 ; let mut y = 24i32 ; let mut x = 42i32 ; let mut y = 2...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 2,
          "line_number": 48,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Error\nif condition {\n    do_something()\n// Missing closing brace\n\n// ✅ Fixed  \nif condition {\n    do_something()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 3,
          "line_number": 69,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Error\nlet 123invalid = \"nope\"\nlet my-var = \"no hyphens\"\nlet fn = \"keyword\"\n\n// ✅ Fixed\nlet invalid_123 = \"ok\"\nlet my_var = \"underscores ok\"\nlet function_name = \"not keyword\"",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 4,
          "line_number": 92,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Error\nlet x: i32 = \"string\"\n\n\n\n// ✅ Fixed\nlet x: i32 = 42\n// or\nlet x = \"string\"  // Let compiler infer type\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpR2OqOc/main.rs:1:159\n  |\n1 | ... ; let mut x = \"string\" . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpR2OqOc/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut x = \"string\" . to_string () ; let mut x = 42i32 ; let mut x = \"st...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 5,
          "line_number": 115,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Error\nlet s = String::from(\"hello\")\nlet r = &s\nlet moved = *r  // Cannot move out of borrowed content\n\n// ✅ Fixed\nlet s = String::from(\"hello\")\nlet r = &s\nlet copied = r.clone()  // Clone instead of move",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 6,
          "line_number": 136,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Error\nlet s = String::from(\"hello\")\ntakes_ownership(s)\nprintln(s)  \n\n// ✅ Fixed - Option 1: Clone\nlet s = String::from(\"hello\")\ntakes_ownership(s.clone())\nprintln(s)  // s still valid\n\n// ✅ Fixed - Option 2: Borrow\nlet s = String::from(\"hello\")\nborrows_value(&s)\nprintln(s)  // s still valid\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpwL53XJ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut s = String :: from (\"hello\" . to_string ()) ; takes_ownership (s)...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `takes_ownership` in this scope\n --> /tmp/.tmpwL53XJ/main.rs:1:119\n  |\n1 | ... s = String :: from (\"hello\" . to_string ()) ; takes_ownership (s) ; println ! (\"{:?}\" , s) ; let mut s = String :: from (\"hello\" . to...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `takes_ownership` in this scope\n --> /tmp/.tmpwL53XJ/main.rs:1:220\n  |\n1 | ... s = String :: from (\"hello\" . to_string ()) ; takes_ownership (s . clone ()) ; println ! (\"{:?}\" , s) ; let mut s = String :: from (\"...\n  |                                                   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `borrows_value` in this scope\n --> /tmp/.tmpwL53XJ/main.rs:1:332\n  |\n1 | ...t s = String :: from (\"hello\" . to_string ()) ; borrows_value (& s) ; println ! (\"{:?}\" , s) } ; if let Some (s) = (& result as & dyn ...\n  |                                                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 7,
          "line_number": 166,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Error\nfun dangle() -> &String {\n    let s = String::from(\"hello\")\n    &s  // s goes out of scope\n}\n\n// ✅ Fixed - Return owned value\nfun not_dangle() -> String {\n    let s = String::from(\"hello\")\n    s  // Move ownership\n}\n\n// ✅ Fixed - Use static lifetime\nfun static_str() -> &'static str {\n    \"hello\"  // String literals have static lifetime\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 8,
          "line_number": 194,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Error\nlet mut s = String::from(\"hello\")\nlet r1 = &mut s\nlet r2 = &mut s  // Error: ✗ Compilation failed: Failed to parse Ruchy source\nprintln(r1)\nprintln(r2)\n\n// ✅ Fixed - Use references sequentially\nlet mut s = String::from(\"hello\")\n{\n    let r1 = &mut s\n    // r1 scope ends here\n}\nlet r2 = &mut s  // Now ok",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 9,
          "line_number": 224,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Runtime panic\nlet v = vec![1, 2, 3]\nlet item = v[5]  // Panic: index out of bounds\n\n// ✅ Safe access\nlet v = vec![1, 2, 3]\nmatch v.get(5) {\n    Some(item) => println(\"Item: {}\", item),\n    None => println(\"Index out of bounds\"),\n}\n\n// ✅ Or use safe indexing\nif let Some(item) = v.get(5) {\n    println(\"Item: {}\", item)\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp9LRtQD/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut v = vec ! [1i32 , 2i32 , 3i32] ; let mut item = v [5i32 as usize]...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp9LRtQD/main.rs:1:362\n  |\n1 | ...if let Some (item) = v . get (5i32) . cloned () { { println ! (\"Item: {}\" , item) } } } ; if let Some (s) = (& result as & dyn std :: ...\n  |                                                      ^^                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { let mut v = vec ! [1i32 , 2i32 , 3i32] ; let mut item = v [5i32 as usize] ; let mut v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) . cloned () { Some (item) => println ! (\"Item: {}\" , item) , None => println ! (\"Index out of bounds\") , } ; if let Some (item) = v . get (5i32) . cloned () { { println ! (\"Item: {}\" , item) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { let mut v = vec ! [1i32 , 2i32 , 3i32] ; let mut item = v [5i32 as usize] ; let mut v = vec ! [1i32 , 2i32 , 3i32] ; match v . get (5i32) . cloned () { Some (item) => println ! (\"Item: {}\" , item) , None => println ! (\"Index out of bounds\") , } ; if let Some (item) = v . get (5i32) . cloned () { println ! (\"Item: {}\" , item) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n   --> /tmp/.tmp9LRtQD/main.rs:1:197\n    |\n1   | ...! [1i32 , 2i32 , 3i32] ; match v . get (5i32) . cloned () { Some (item) => println ! (\"Item: {}\" , item) , None => println ! (\"Index o...\n    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`\n    |                                       |\n    |                                       required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n    = help: the following other types implement trait `SliceIndex<T>`:\n              `usize` implements `SliceIndex<ByteStr>`\n              `usize` implements `SliceIndex<[T]>`\nnote: required by a bound in `core::slice::<impl [T]>::get`\n   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12\n    |\n571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>\n    |            --- required by a bound in this associated function\n572 |     where\n573 |         I: SliceIndex<Self>,\n    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`\n\nerror[E0277]: the type `[i32]` cannot be indexed by `i32`\n   --> /tmp/.tmp9LRtQD/main.rs:1:342\n    |\n1   | ...s\") , } ; if let Some (item) = v . get (5i32) . cloned () { { println ! (\"Item: {}\" , item) } } } ; if let Some (s) = (& result as & d...\n    |                                       ---  ^^^^ slice indices are of type `usize` or ranges of `usize`\n    |                                       |\n    |                                       required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n    = help: the following other types implement trait `SliceIndex<T>`:\n              `usize` implements `SliceIndex<ByteStr>`\n              `usize` implements `SliceIndex<[T]>`\nnote: required by a bound in `core::slice::<impl [T]>::get`\n   --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:573:12\n    |\n571 |     pub fn get<I>(&self, index: I) -> Option<&I::Output>\n    |            --- required by a bound in this associated function\n572 |     where\n573 |         I: SliceIndex<Self>,\n    |            ^^^^^^^^^^^^^^^^ required by this bound in `core::slice::<impl [T]>::get`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 10,
          "line_number": 253,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Runtime panic\nlet maybe_value: Option<i32> = None\nlet value = maybe_value.unwrap()  // Panic: called unwrap on None\n\n// ✅ Safe handling\nlet maybe_value: Option<i32> = None\nmatch maybe_value {\n    Some(value) => println(\"Value: {}\", value),\n    None => println(\"No value\"),\n}\n\n// ✅ Or provide default\nlet value = maybe_value.unwrap_or(0)",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 11,
          "line_number": 278,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Runtime panic\nfun divide(a: i32, b: i32) -> i32 {\n    a / b  // Panic if b is 0\n}\n\n// ✅ Safe division\nfun safe_divide(a: i32, b: i32) -> Option<i32> {\n    if b != 0 {\n        Some(a / b)\n    } else {\n        None\n    }\n}\n\n// ✅ Or return Result\nfun divide_result(a: i32, b: i32) -> Result<i32, String> {\n    if b != 0 {\n        Ok(a / b)\n    } else {\n        Err(\"Division by zero\".to_string())\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 12,
          "line_number": 314,
          "code": "// Status: ✅ WORKING\n\n// ❌ Infinite recursion causes stack overflow\nfun infinite_recursion(n: i32) -> i32 {\n    infinite_recursion(n + 1)  // No base case\n}\n\n// ✅ Proper recursion with base case\nfun factorial(n: i32) -> i32 {\n    if n <= 1 {\n        1  // Base case\n    } else {\n        n * factorial(n - 1)\n    }\n}\n\n// ✅ Or use iteration\nfun factorial_iterative(n: i32) -> i32 {\n    let mut result = 1\n    for i in 1..=n {\n        result *= i\n    }\n    result\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 13,
          "line_number": 349,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ May cause stack overflow\nfun large_array() {\n    let big_array: [i32; 1_000_000] = [0; 1_000_000]  // 4MB on stack\n}\n\n// ✅ Use heap allocation\nfun large_vector() {\n    let big_vector: Vec<i32> = vec![0; 1_000_000]  // Allocated on heap\n}\n\n// ✅ Or use Box for single large items\nfun boxed_array() {\n    let big_array: Box<[i32; 1_000_000]> = Box::new([0; 1_000_000])\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 14,
          "line_number": 377,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Inefficient - unnecessary clones\nfun process_strings(strings: Vec<String>) -> Vec<String> {\n    strings.iter()\n        .map(|s| s.clone().to_uppercase())  // Unnecessary clone\n        .collect()\n}\n\n// ✅ More efficient - work with references\nfun process_strings_efficient(strings: &[String]) -> Vec<String> {\n    strings.iter()\n        .map(|s| s.to_uppercase())  // to_uppercase() works on &str\n        .collect()\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 15,
          "line_number": 402,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// ❌ Inefficient - creates many temporary strings\nfun concat_inefficient(strings: &[&str]) -> String {\n    let mut result = String::new()\n    for s in strings {\n        result = result + s  // Creates new string each time\n    }\n    result\n}\n\n// ✅ Efficient - reuses buffer\nfun concat_efficient(strings: &[&str]) -> String {\n    let mut result = String::new()\n    for s in strings {\n        result.push_str(s)  // Appends to existing string\n    }\n    result\n}\n\n// ✅ Even better - pre-allocate capacity\nfun concat_with_capacity(strings: &[&str]) -> String {\n    let total_len: usize = strings.iter().map(|s| s.len()).sum()\n    let mut result = String::with_capacity(total_len)\n    for s in strings {\n        result.push_str(s)\n    }\n    result\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 16,
          "line_number": 441,
          "code": "// Status: ❌ BROKEN\n\n// ❌ Wrong collection for use case\nuse std::collections::VecDeque\n\nlet mut list = Vec::new()\n// Frequent insertions at beginning - O(n) for each insert\nfor i in 0..1000 {\n    list.insert(0, i)\n}\n\n// ✅ Better collection choice\nlet mut deque = VecDeque::new()\n// Efficient insertion at front - O(1)\nfor i in 0..1000 {\n    deque.push_front(i)\n}\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpbTrkIV/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpbTrkIV/main.rs:1:102\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for...\n  |                                                                                                      ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpbTrkIV/main.rs:1:162\n  |\n1 | ...ut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i...\n  |                                                         ^^                        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { list . insert (0i32 , i) } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpbTrkIV/main.rs:1:259\n  |\n1 | ...que = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any...\n  |                                                          ^^                      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1 + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { deque . push_front (i) } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n  |\n\nerror[E0308]: mismatched types\n    --> /tmp/.tmpbTrkIV/main.rs:1:179\n     |\n1    | ...ew () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { ...\n     |                                                ------  ^^^^ expected `usize`, found `i32`\n     |                                                |\n     |                                                arguments to this method are incorrect\n     |\nnote: method defined here\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2034:12\n     |\n2034 |     pub fn insert(&mut self, index: usize, element: T) {\n     |            ^^^^^^\nhelp: change the type of the numeric literal from `i32` to `usize`\n     |\n1    - use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0i32 , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n1    + use std :: collections :: HashMap ; fn main () { let result = { use std :: collections :: VecDeque ; ; let mut list = Vec :: new () ; for i in 0i32 .. 1000i32 { { list . insert (0usize , i) } } ; let mut deque = VecDeque :: new () ; for i in 0i32 .. 1000i32 { { deque . push_front (i) } } } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { println ! (\"{}\" , s) ; } else if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < & str > () { println ! (\"{}\" , s) ; } else { println ! (\"{:?}\" , result) ; } }\n     |\n\nerror: aborting due to 1 previous error; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 17,
          "line_number": 485,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\n// ❌ Error: no method named `json` found for type `Response`\nlet response = reqwest::get(url).await?\nlet data = response.json().await?  // Feature not enabled\n\n// ✅ Enable required features in Cargo.toml\n// [dependencies]\n// reqwest = { version = \"0.11\", features = [\"json\"] }",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmp36r4Uj/main.rs:1:161\n  |\n1 | ...ut data = response . json () . await ? } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]: cannot find value `url` in this scope\n --> /tmp/.tmp36r4Uj/main.rs:1:100\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut response = reqwest :: get (url) . await ? ; let mut data = respon...\n  |                                                                                                    ^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp36r4Uj/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut response = reqwest :: get (url) . await ? ; let mut data = respon...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`\n --> /tmp/.tmp36r4Uj/main.rs:1:84\n  |\n1 | ... { let result = { let mut response = reqwest :: get (url) . await ? ; let mut data = response . json () . await ? } ; if let Some (s) ...\n  |                                         ^^^^^^^ use of unresolved module or unlinked crate `reqwest`\n  |\n  = help: you might be missing a crate named `reqwest`\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 18,
          "line_number": 607,
          "code": "// Status: ❌ BROKEN\n\n// Simple debug prints\nprintln!(\"Debug: x = {}\", x)\nprintln!(\"Debug: {:?}\", complex_struct)  // Debug formatting\nprintln!(\"Debug: {:#?}\", nested_struct)  // Pretty debug formatting\n\n// Conditional debug prints\n#[cfg(debug_assertions)]\nprintln!(\"This only prints in debug builds\")\n\n// Debug macro\ndebug!(\"Variable state: x={}, y={}\", x, y)\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 19,
          "line_number": 647,
          "code": "// Status: ❌ BROKEN\n\nuse log::{debug, info, warn, error}\n\nfun main() {\n    env_logger::init()\n    \n    debug!(\"This is a debug message\")\n    info!(\"This is info\")\n    warn!(\"This is a warning\")\n    error!(\"This is an error\")\n}\n\n// Control log level with environment variable\n// RUST_LOG=debug cargo run\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Failed to transpile to Rust",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to transpile to Rust\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/appendix-c-troubleshooting.md",
          "example_number": 20,
          "line_number": 674,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n#[cfg(test)]\nmod tests {\n    use super::*\n    \n    #[test]\n    fun test_with_debug_output() {\n        let result = my_function(42)\n        \n        // Print for debugging (use -- --nocapture to see output)\n        println!(\"Result: {:?}\", result)\n        \n        assert_eq!(result, expected)\n    }\n    \n    // Run with: cargo test -- --nocapture\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch05-00-data-processing": {
      "chapter": "ch05-00-data-processing",
      "total_examples": 10,
      "working_examples": 0,
      "failing_examples": 10,
      "examples": [
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 1,
          "line_number": 48,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: sales_analyzer.ruchy\n// Analyzes sales data from CSV file\n\nprintln(\"=== Sales Data Analyzer ===\")\n\n// Read CSV data (simplified - in practice you'd use CSV parser)\nlet sales_data = [\n    [\"Date\", \"Product\", \"Amount\", \"Region\"],\n    [\"2024-01-15\", \"Laptop\", \"1299\", \"North\"],\n    [\"2024-01-16\", \"Mouse\", \"25\", \"South\"], \n    [\"2024-01-17\", \"Keyboard\", \"79\", \"North\"],\n    [\"2024-01-18\", \"Laptop\", \"1299\", \"East\"],\n    [\"2024-01-19\", \"Monitor\", \"399\", \"West\"]\n]\n\n// Process data\nlet total_sales = 0\nlet product_counts = {}\nlet region_sales = {}\n\nfor row in sales_data[1..] {  // Skip header\n    let product = row[1]\n    let amount = row[2].to_f()\n    let region = row[3]\n    \n    // Calculate totals\n    total_sales += amount\n    \n    // Count products\n    product_counts[product] = product_counts.get(product, 0) + 1\n    \n    // Sum by region\n    region_sales[region] = region_sales.get(region, 0) + amount\n}\n\n// Display results\nprintln(\"Total Sales: $\" + total_sales.to_s())\nprintln(\"Average Sale: $\" + (total_sales / (sales_data.len() - 1)).to_s())\n\nprintln(\"\\nTop Products:\")\nfor product, count in product_counts.items() {\n    println(\"  \" + product + \": \" + count.to_s() + \" sales\")\n}\n\nprintln(\"\\nSales by Region:\")\nfor region, amount in region_sales.items() {\n    println(\"  \" + region + \": $\" + amount.to_s())\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 2,
          "line_number": 133,
          "code": "// Status: ❌ BROKEN\n\n// Arrays for sequences\nlet sales_amounts = [1299, 25, 79, 1299, 399]\nlet monthly_revenue = [45000, 52000, 48000, 61000]\n\n// Dictionaries for key-value mapping  \nlet customer_orders = {\n    \"alice@email.com\": 5,\n    \"bob@email.com\": 2,\n    \"carol@email.com\": 8\n}\n\n// Arrays of dictionaries for structured records\nlet transactions = [\n    {\"id\": 1001, \"amount\": 1299, \"customer\": \"alice@email.com\"},\n    {\"id\": 1002, \"amount\": 25, \"customer\": \"bob@email.com\"},\n    {\"id\": 1003, \"amount\": 79, \"customer\": \"alice@email.com\"}\n]",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpYQqhGM/main.rs:1:1597\n  |\n1 | ...e@email.com\") . to_string ()) ; map }] } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpYQqhGM/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut sales_amounts = vec ! [1299i32 , 25i32 , 79i32 , 1299i32 , 399i32...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 3,
          "line_number": 165,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n\n// Sum and averages\nlet total = numbers.sum()\nlet average = numbers.sum() / numbers.len()\nlet maximum = numbers.max()\nlet minimum = numbers.min()\n\n// Grouping and counting\nfun group_by_field(records, field) {\n    let groups = {}\n    for record in records {\n        let key = record[field]\n        if !groups.has_key(key) {\n            groups[key] = []\n        }\n        groups[key].push(record)\n    }\n    return groups\n}\n\n// Filtering and transformation\nlet high_value = transactions.filter(|t| t.amount > 100)\nlet customer_ids = transactions.map(|t| t.customer)\nlet amounts_only = transactions.map(|t| t.amount)\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmpTqFGar/main.rs:1:360\n  |\n1 | ...return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut ...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmpTqFGar/main.rs:1:397\n  |\n1 | ...t mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut ...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmpTqFGar/main.rs:1:416\n  |\n1 | ...rs . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers ....\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmpTqFGar/main.rs:1:453\n  |\n1 | ...rs . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transa...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `numbers` in this scope\n --> /tmp/.tmpTqFGar/main.rs:1:490\n  |\n1 | ...mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t |...\n  |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `transactions` in this scope\n --> /tmp/.tmpTqFGar/main.rs:1:530\n  |\n1 | ...inimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec <...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `transactions` in this scope\n --> /tmp/.tmpTqFGar/main.rs:1:649\n  |\n1 | ...lect :: < Vec < _ >> () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let ...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `transactions` in this scope\n --> /tmp/.tmpTqFGar/main.rs:1:753\n  |\n1 | ...lect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpTqFGar/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTqFGar/main.rs:1:100\n  |\n1 | ... { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } ...\n  |       ^^                                                                                                                                                                                                                                ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n1 + use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTqFGar/main.rs:1:148\n  |\n1 | ... { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ...\n  |       ^^                                                                                                                                                        ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n1 + use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpTqFGar/main.rs:1:220\n  |\n1 | ...ield as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } ...\n  |                                                     ^^                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n1 + use std :: collections :: HashMap ; fn group_by_field (records : String , field : String) -> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { groups [key as usize] = vec ! [] } ; groups [key as usize] . push (record) } } } } ; return groups } } } } fn main () { let mut total = numbers . sum () ; let mut average = numbers . sum () / numbers . len () ; let mut maximum = numbers . max () ; let mut minimum = numbers . min () ; let mut high_value = transactions . into_iter () . filter (| t | t . amount > 100i32) . collect :: < Vec < _ >> () ; let mut customer_ids = transactions . iter () . map (| t | t . customer) . collect :: < Vec < _ >> () ; let mut amounts_only = transactions . iter () . map (| t | t . amount) . collect :: < Vec < _ >> () ; }\n  |\n\nerror[E0277]: `String` is not an iterator\n --> /tmp/.tmpTqFGar/main.rs:1:138\n  |\n1 | ...groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize...\n  |                                  ^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n  |\n  = help: the trait `Iterator` is not implemented for `String`\n  = note: required for `String` to implement `IntoIterator`\n\nerror[E0599]: no method named `has_key` found for unit type `()` in the current scope\n --> /tmp/.tmpTqFGar/main.rs:1:204\n  |\n1 | ...et key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . pu...\n  |                                                       ^^^^^^^ method not found in `()`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpTqFGar/main.rs:1:316\n  |\n1 | ...-> i32 { { { let groups = () ; { for record in records { { { let key = record [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) } } } } ; return groups } ...\n  |       --- expected `i32` because of return type                                                                                                                                                                                     ^^^^^^ expected `i32`, found `()`\n\nerror[E0605]: non-primitive cast: `String` as `usize`\n --> /tmp/.tmpTqFGar/main.rs:1:170\n  |\n1 | ...rd [field as usize] ; { if ! groups . has_key (key) { { groups [key as usize] = vec ! [] } } ; groups [key as usize] . push (record) }...\n  |        ^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror: aborting due to 12 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0599, E0605.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: has_key()"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 4,
          "line_number": 204,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// CSV-like processing (simplified)\nfun parse_csv_line(line) {\n    return line.split(\",\").map(|field| field.trim())\n}\n\nfun load_csv(filename) {\n    let lines = read_lines(filename)\n    let header = parse_csv_line(lines[0])\n    let data = []\n    \n    for line in lines[1..] {\n        let fields = parse_csv_line(line)\n        let record = {}\n        for i, field in fields.enumerate() {\n            record[header[i]] = field\n        }\n        data.push(record)\n    }\n    \n    return data\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 5,
          "line_number": 240,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: customer_analytics.ruchy\n// Analyzes customer purchase patterns\n\nprintln(\"=== Customer Analytics Tool ===\")\n\n// Sample customer data (in practice, load from file)\nlet customers = [\n    {\"name\": \"Alice\", \"email\": \"alice@email.com\", \"orders\": 5, \"total_spent\": 2500, \"signup_date\": \"2023-06-15\"},\n    {\"name\": \"Bob\", \"email\": \"bob@email.com\", \"orders\": 2, \"total_spent\": 150, \"signup_date\": \"2024-01-20\"},\n    {\"name\": \"Carol\", \"email\": \"carol@email.com\", \"orders\": 8, \"total_spent\": 4200, \"signup_date\": \"2023-03-10\"},\n    {\"name\": \"David\", \"email\": \"david@email.com\", \"orders\": 1, \"total_spent\": 75, \"signup_date\": \"2024-02-01\"}\n]\n\n// Calculate key metrics\nlet total_customers = customers.len()\nlet total_revenue = customers.map(|c| c.total_spent).sum()\nlet average_order_value = total_revenue / customers.map(|c| c.orders).sum()\nlet average_customer_value = total_revenue / total_customers\n\nprintln(\"Customer Base: \" + total_customers.to_s() + \" customers\")\nprintln(\"Total Revenue: $\" + total_revenue.to_s())\nprintln(\"Average Order Value: $\" + average_order_value.to_s())\nprintln(\"Average Customer Value: $\" + average_customer_value.to_s())\n\n// Segment customers\nlet vip_customers = customers.filter(|c| c.total_spent > 1000)\nlet new_customers = customers.filter(|c| c.signup_date.starts_with(\"2024\"))\nlet frequent_buyers = customers.filter(|c| c.orders > 5)\n\nprintln(f\"\\nCustomer Segments:\")\nprintln(\"VIP Customers (>$1000): \" + vip_customers.len().to_s())\nprintln(\"New Customers (2024): \" + new_customers.len().to_s())\nprintln(\"Frequent Buyers (>5 orders): \" + frequent_buyers.len().to_s())\n\n// Top customers by spending\nlet top_spenders = customers.sort_by(|c| -c.total_spent)[..3]\nprintln(f\"\\nTop Spenders:\")\nfor i, customer in top_spenders.enumerate() {\n    println(\"  \" + (i+1).to_s() + \". \" + customer.name + \": $\" + customer.total_spent.to_s() + \" (\" + customer.orders.to_s() + \" orders)\")\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 6,
          "line_number": 293,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: advanced_log_analyzer.ruchy\n// Comprehensive log file analysis\n\nprintln(\"=== Advanced Log Analyzer ===\")\n\n// Sample log entries (in practice, read from file)\nlet log_entries = [\n    \"2024-08-19 10:15:32 INFO User login: alice@email.com\",\n    \"2024-08-19 10:16:45 ERROR Database connection failed\", \n    \"2024-08-19 10:17:12 INFO User login: bob@email.com\",\n    \"2024-08-19 10:18:33 WARN Slow query detected: 2.5s\",\n    \"2024-08-19 10:19:44 ERROR 404 Not Found: /api/users/999\",\n    \"2024-08-19 10:20:15 INFO User logout: alice@email.com\"\n]\n\n// Parse log entries\nfun parse_log_entry(entry) {\n    let parts = entry.split(\" \")\n    return {\n        \"date\": parts[0],\n        \"time\": parts[1], \n        \"level\": parts[2],\n        \"message\": parts[3..].join(\" \")\n    }\n}\n\nlet parsed_logs = log_entries.map(parse_log_entry)\n\n// Analyze by level\nlet level_counts = {}\nfor log in parsed_logs {\n    let level = log.level\n    level_counts[level] = level_counts.get(level, 0) + 1\n}\n\nprintln(\"Log Level Summary:\")\nfor level, count in level_counts.items() {\n    let emoji = match level {\n        \"INFO\" => \"ℹ️\",\n        \"WARN\" => \"⚠️\", \n        \"ERROR\" => \"❌\",\n        _ => \"📝\"\n    }\n    println(\"  \" + emoji + \" \" + level + \": \" + count.to_s() + \" entries\")\n}\n\n// Find errors and warnings\nlet issues = parsed_logs.filter(|log| log.level == \"ERROR\" || log.level == \"WARN\")\nprintln(\"\\nIssues Found (\" + issues.len().to_s() + \"):\")\nfor issue in issues {\n    println(\"  \" + issue.time + \" \" + issue.level + \": \" + issue.message)\n}\n\n// Extract user activity\nlet user_actions = parsed_logs.filter(|log| log.message.contains(\"User\"))\nprintln(\"\\nUser Activity (\" + user_actions.len().to_s() + \" actions):\")\nfor action in user_actions {\n    println(\"  \" + action.time + \": \" + action.message)\n}\n\n// Time-based analysis\nlet hours = parsed_logs.map(|log| log.time.split(\":\")[0])\nlet hour_counts = {}\nfor hour in hours {\n    hour_counts[hour] = hour_counts.get(hour, 0) + 1\n}\n\nlet busiest_hour = hour_counts.max_by_value()\nprintln(\"\\nBusiest Hour: \" + busiest_hour.key + \":xx (\" + busiest_hour.value.to_s() + \" entries)\")",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 7,
          "line_number": 375,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// File: finance_processor.ruchy\n// Processes financial transactions and generates reports\n\nprintln(\"=== Financial Data Processor ===\")\n\n// Transaction data structure\nlet transactions = [\n    {\"date\": \"2024-01-15\", \"type\": \"income\", \"category\": \"salary\", \"amount\": 5000, \"description\": \"Monthly salary\"},\n    {\"date\": \"2024-01-16\", \"type\": \"expense\", \"category\": \"rent\", \"amount\": 1200, \"description\": \"Apartment rent\"},\n    {\"date\": \"2024-01-17\", \"type\": \"expense\", \"category\": \"groceries\", \"amount\": 85, \"description\": \"Weekly shopping\"},\n    {\"date\": \"2024-01-18\", \"type\": \"expense\", \"category\": \"utilities\", \"amount\": 150, \"description\": \"Electricity bill\"},\n    {\"date\": \"2024-01-20\", \"type\": \"income\", \"category\": \"freelance\", \"amount\": 800, \"description\": \"Web design project\"}\n]\n\n// Calculate totals\nlet total_income = transactions.filter(|t| t.type == \"income\").map(|t| t.amount).sum()\nlet total_expenses = transactions.filter(|t| t.type == \"expense\").map(|t| t.amount).sum()\nlet net_income = total_income - total_expenses\n\nprintln(f\"Financial Summary:\")\nprintln(\"Total Income: $\" + total_income.to_s())\nprintln(\"Total Expenses: $\" + total_expenses.to_s())\nprintln(\"Net Income: $\" + net_income.to_s())\nprintln(\"Savings Rate: \" + (net_income * 100 / total_income).to_s() + \"%\")\n\n// Expense breakdown by category\nlet expense_categories = {}\nfor transaction in transactions.filter(|t| t.type == \"expense\") {\n    let category = transaction.category\n    expense_categories[category] = expense_categories.get(category, 0) + transaction.amount\n}\n\nprintln(f\"\\nExpense Breakdown:\")\nfor category, amount in expense_categories.items() {\n    let percentage = (amount * 100) / total_expenses\n    println(\"  \" + category.capitalize() + \": $\" + amount.to_s() + \" (\" + percentage.to_s() + \"%)\")\n}\n\n// Budget analysis\nlet budget_limits = {\n    \"rent\": 1500,\n    \"groceries\": 400, \n    \"utilities\": 200,\n    \"entertainment\": 300\n}\n\nprintln(f\"\\nBudget Analysis:\")\nfor category, limit in budget_limits.items() {\n    let spent = expense_categories.get(category, 0)\n    let remaining = limit - spent\n    let status = if remaining >= 0 { \"✅ Under budget\" } else { \"❌ Over budget\" }\n    println(\"  \" + category.capitalize() + \": $\" + spent.to_s() + \"/$\" + limit.to_s() + \" - \" + status)\n}\n\n// Monthly trend (if we had multiple months of data)\nprintln(\"\\nTransaction History (\" + transactions.len().to_s() + \" transactions):\")\nfor transaction in transactions.sort_by(|t| t.date) {\n    let emoji = if transaction.type == \"income\" { \"💰\" } else { \"💸\" }\n    println(\"  \" + transaction.date + \" \" + emoji + \" $\" + transaction.amount.to_s() + \" - \" + transaction.description)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 8,
          "line_number": 450,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n// Error: ✗ Compilation failed: Compilation failed:\n// Simple bar chart function\nfun draw_bar_chart(data, title) {\n    println(\"\\n\" + title)\n    println(\"=\" * title.len())\n    \n    let max_value = data.values().max()\n    let max_bar_width = 50\n    \n    for key, value in data.items() {\n        let bar_width = (value * max_bar_width) / max_value\n        let bar = \"█\" * bar_width.to_i()\n        println(key + \" │\" + bar + \" \" + value.to_s())\n    }\n}\n\n// Usage example\nlet monthly_sales = {\n    \"January\": 45000,\n    \"February\": 52000,\n    \"March\": 48000,\n    \"April\": 61000,\n    \"May\": 58000\n}\n\ndraw_bar_chart(monthly_sales, \"Monthly Sales Report\")",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpDrS9QS/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) -> i32 { { println ! (\"{:?}\" , format ! (\"{}{}\" , ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpDrS9QS/main.rs:1:317\n  |\n1 | ... { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + bar , \" \") + value . to_s ()) } } } } ...\n  |       ^^                                                                                                                                                                                                           ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) -> i32 { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{:?}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . iter () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + bar , \" \") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"January\" . to_string () , (45000i32) . to_string ()) ; map . insert (\"February\" . to_string () , (52000i32) . to_string ()) ; map . insert (\"March\" . to_string () , (48000i32) . to_string ()) ; map . insert (\"April\" . to_string () , (61000i32) . to_string ()) ; map . insert (\"May\" . to_string () , (58000i32) . to_string ()) ; map } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n1 + use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) -> i32 { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{:?}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . iter () { { let bar_width = value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + bar , \" \") + value . to_s ()) } } } } } } } fn main () { let mut monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"January\" . to_string () , (45000i32) . to_string ()) ; map . insert (\"February\" . to_string () , (52000i32) . to_string ()) ; map . insert (\"March\" . to_string () , (48000i32) . to_string ()) ; map . insert (\"April\" . to_string () , (61000i32) . to_string ()) ; map . insert (\"May\" . to_string () , (58000i32) . to_string ()) ; map } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n  |\n\nerror[E0369]: cannot multiply `&str` by `usize`\n --> /tmp/.tmpDrS9QS/main.rs:1:179\n  |\n1 | ...rmat ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{:?}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut ...\n  |                                                          --- ^ -------------- usize\n  |                                                          |\n  |                                                          &str\n\nerror[E0599]: no method named `values` found for struct `String` in the current scope\n --> /tmp/.tmpDrS9QS/main.rs:1:224\n  |\n1 | ...\"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . it...\n  |                                                     ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n --> /tmp/.tmpDrS9QS/main.rs:1:307\n  |\n1 | ...x_bar_width = 50i32 ; for (key , value) in data . iter () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = \"█...\n  |                                                      ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n  |\n1 - use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) -> i32 { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{:?}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . iter () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + bar , \" \") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"January\" . to_string () , (45000i32) . to_string ()) ; map . insert (\"February\" . to_string () , (52000i32) . to_string ()) ; map . insert (\"March\" . to_string () , (48000i32) . to_string ()) ; map . insert (\"April\" . to_string () , (61000i32) . to_string ()) ; map . insert (\"May\" . to_string () , (58000i32) . to_string ()) ; map } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n1 + use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) -> i32 { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{:?}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . chars () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + bar , \" \") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"January\" . to_string () , (45000i32) . to_string ()) ; map . insert (\"February\" . to_string () , (52000i32) . to_string ()) ; map . insert (\"March\" . to_string () , (48000i32) . to_string ()) ; map . insert (\"April\" . to_string () , (61000i32) . to_string ()) ; map . insert (\"May\" . to_string () , (58000i32) . to_string ()) ; map } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n  |\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n --> /tmp/.tmpDrS9QS/main.rs:1:379\n  |\n1 | ...value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}...\n  |                                              ^^^^^^^ doesn't have a size known at compile-time\n  |\n  = help: the trait `Sized` is not implemented for `str`\n  = note: all local variables must have a statically known size\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDrS9QS/main.rs:1:489\n  |\n1 | ...ormat ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + bar , \" \") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = ...\n  |                                                       ^^^ expected `&str`, found `str`\n  |\nhelp: consider borrowing here\n  |\n1 | use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) -> i32 { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{:?}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . iter () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + &bar , \" \") + value . to_s ()) } } } } } } } } fn main () { let mut monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"January\" . to_string () , (45000i32) . to_string ()) ; map . insert (\"February\" . to_string () , (52000i32) . to_string ()) ; map . insert (\"March\" . to_string () , (48000i32) . to_string ()) ; map . insert (\"April\" . to_string () , (61000i32) . to_string ()) ; map . insert (\"May\" . to_string () , (58000i32) . to_string ()) ; map } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         +\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDrS9QS/main.rs:1:279\n  |\n1 | ...-> i32 { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{:?}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . iter () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + bar , \" \") + value . to_s ()) } } } } } ...\n  |       --- expected `i32` because of return type                                                                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n  |\n  = note: `for` loops evaluate to unit type `()`\nhelp: consider returning a value here\n  |\n1 | use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) -> i32 { { println ! (\"{:?}\" , format ! (\"{}{}\" , \"\\n\" , title)) ; println ! (\"{:?}\" , \"=\" * title . len ()) ; { let max_value = data . values () . max () ; { let mut max_bar_width = 50i32 ; for (key , value) in data . iter () { { { let bar_width = value * max_bar_width / max_value ; { let mut bar = \"█\" * bar_width . to_i () ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , key , \" │\") + bar , \" \") + value . to_s ()) } } } } /* `i32` value */ } } } } fn main () { let mut monthly_sales = { let mut map : std :: collections :: HashMap < String , String > = std :: collections :: HashMap :: new () ; map . insert (\"January\" . to_string () , (45000i32) . to_string ()) ; map . insert (\"February\" . to_string () , (52000i32) . to_string ()) ; map . insert (\"March\" . to_string () , (48000i32) . to_string ()) ; map . insert (\"April\" . to_string () , (61000i32) . to_string ()) ; map . insert (\"May\" . to_string () , (58000i32) . to_string ()) ; map } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               +++++++++++++++++\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpDrS9QS/main.rs:1:1049\n  |\n1 | ... . to_string ()) ; map } ; draw_bar_chart (monthly_sales , \"Monthly Sales Report\" . to_string ()) ; }\n  |                               --------------  ^^^^^^^^^^^^^ expected `String`, found `HashMap<String, String>`\n  |                               |\n  |                               arguments to this function are incorrect\n  |\n  = note: expected struct `String`\n             found struct `HashMap<String, String>`\nnote: function defined here\n --> /tmp/.tmpDrS9QS/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn draw_bar_chart (data : String , title : String) -> i32 { { println ! (\"{:?}\" , format ! (\"{}{}\" , ...\n  |                                        ^^^^^^^^^^^^^^  -------------\n\nerror: aborting due to 7 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0369, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: values()"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 9,
          "line_number": 505,
          "code": "// Status: ❌ BROKEN\n\nlet sales_data = load_csv(\"sales.csv\")\nlet total = sales_data.map(|row| row.amount.to_f()).sum()\nlet average = total / sales_data.len()\nprintln(\"Average sale: $\" + average.to_s())\n\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpVPuI4M/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut sales_data = load_csv (\"sales.csv\" . to_string ()) ; let mut tota...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0425]: cannot find function `load_csv` in this scope\n --> /tmp/.tmpVPuI4M/main.rs:1:86\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut sales_data = load_csv (\"sales.csv\" . to_string ()) ; let mut tota...\n  |                                                                                      ^^^^^^^^ not found in this scope\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-data-processing.md",
          "example_number": 10,
          "line_number": 602,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Failed to parse Ruchy source\n// expense_tracker.ruchy - Track and analyze personal expenses\n\nlet EXPENSES_FILE = \"expenses.csv\"\n\nfun save_expense(date, category, amount, description) {\n    let entry = date + \",\" + category + \",\" + amount.to_s() + \",\" + description + \"\\n\"\n    append_file(EXPENSES_FILE, entry)\n}\n\nfun load_expenses() {\n    if !file_exists(EXPENSES_FILE) {\n        // Create header if file doesn't exist\n        write_file(EXPENSES_FILE, \"Date,Category,Amount,Description\\n\")\n        return []\n    }\n    \n    let lines = read_lines(EXPENSES_FILE)[1..]  // Skip header\n    let expenses = []\n    \n    for line in lines {\n        let parts = line.split(\",\")\n        expenses.push({\n            \"date\": parts[0],\n            \"category\": parts[1], \n            \"amount\": parts[2].to_f(),\n            \"description\": parts[3]\n        })\n    }\n    \n    return expenses\n}\n\nfun analyze_expenses(expenses) {\n    let total = expenses.map(|e| e.amount).sum()\n    let average = total / expenses.len()\n    \n    // Category breakdown\n    let categories = {}\n    for expense in expenses {\n        categories[expense.category] = categories.get(expense.category, 0) + expense.amount\n    }\n    \n    println(\"\\n💰 Expense Analysis (\" + expenses.len().to_s() + \" transactions)\")\n    println(\"Total Spent: $\" + total.to_s())\n    println(\"Average Transaction: $\" + average.to_s())\n    \n    println(f\"\\n📊 Spending by Category:\")\n    for category, amount in categories.items().sort_by(|item| -item.value) {\n        let percentage = (amount * 100) / total\n        println(\"  \" + category + \": $\" + amount.to_s() + \" (\" + percentage.to_s() + \"%)\")\n    }\n    \n    // Recent transactions\n    let recent = expenses.sort_by(|e| -e.date)[..5]  // Last 5\n    println(f\"\\n🕒 Recent Transactions:\")\n    for expense in recent {\n        println(\"  \" + expense.date + \" $\" + expense.amount.to_s() + \" \" + expense.category + \" \" + expense.description)\n    }\n}\n\nfun main_menu() {\n    println(\"\\n=== Personal Expense Tracker ===\")\n    println(\"1. Add expense\")\n    println(\"2. View analysis\") \n    println(\"3. Export data\")\n    println(\"4. Quit\")\n    \n    let choice = input(\"\\nChoose option: \")\n    \n    match choice {\n        \"1\" => {\n            let date = input(\"Date (YYYY-MM-DD): \")\n            let category = input(\"Category: \")\n            let amount = input(\"Amount: $\").to_f()\n            let description = input(\"Description: \")\n            \n            save_expense(date, category, amount, description)\n            println(\"✅ Expense added!\")\n        }\n        \"2\" => {\n            let expenses = load_expenses()\n            if expenses.is_empty() {\n                println(\"📝 No expenses recorded yet\")\n            } else {\n                analyze_expenses(expenses)\n            }\n        }\n        \"3\" => {\n            println(\"📁 Data exported to: \" + EXPENSES_FILE)\n            println(\"Open in spreadsheet application for advanced analysis\")\n        }\n        \"4\" => {\n            println(\"💸 Happy budgeting!\")\n            return false\n        }\n        _ => {\n            println(\"❌ Invalid choice\")\n        }\n    }\n    \n    return true\n}\n\n// Main program loop\nwhile main_menu() {\n    // Continue until user quits\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Failed to parse Ruchy source\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch01-02-hello-world": {
      "chapter": "ch01-02-hello-world",
      "total_examples": 8,
      "working_examples": 5,
      "failing_examples": 3,
      "examples": [
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 2,
          "line_number": 86,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Hello\", \"World\", \"from\", \"Ruchy\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: multiple unused formatting arguments\n --> /tmp/.tmpiUej8P/main.rs:1:73\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello\" , \"World\" , \"from\" , \"Ruchy\") } }\n  |                                                               -------   ^^^^^^^   ^^^^^^   ^^^^^^^ argument never used\n  |                                                               |         |         |\n  |                                                               |         |         argument never used\n  |                                                               |         argument never used\n  |                                                               multiple missing formatting specifiers\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpiUej8P/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello\" , \"World\" , \"from\" , \"Ruchy\") } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpiUej8P/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"Hello\" , \"World\" , \"from\" , \"Ruchy\") } }\n  |                                                  ^^                                                ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { println ! (\"Hello\" , \"World\" , \"from\" , \"Ruchy\") } }\n1 + use std :: collections :: HashMap ; fn main () { println ! (\"Hello\" , \"World\" , \"from\" , \"Ruchy\") }\n  |\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 3,
          "line_number": 106,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let name = \"Alice\";\n    println(\"Hello,\", name);\n    \n    // String concatenation (interpolation coming in future versions)\n    println(\"Hello, \" + name + \"!\");\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: argument never used\n --> /tmp/.tmpsPHXEe/main.rs:1:114\n  |\n1 | ...et name = \"Alice\" . to_string () ; { println ! (\"Hello,\" , name) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hello, \"...\n  |                                                    --------   ^^^^ argument never used\n  |                                                    |\n  |                                                    formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpsPHXEe/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" . to_string () ; { println ! (\"Hello,\" , name) ; println ! (\"{:?}...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpsPHXEe/main.rs:1:50\n  |\n1 | ... { { { let name = \"Alice\" . to_string () ; { println ! (\"Hello,\" , name) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hello, \" , name) , \"!\")) } } } }\n  |       ^^                                                                                                                                                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" . to_string () ; { println ! (\"Hello,\" , name) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hello, \" , name) , \"!\")) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let name = \"Alice\" . to_string () ; { println ! (\"Hello,\" , name) ; println ! (\"{:?}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hello, \" , name) , \"!\")) } } }\n  |\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 4,
          "line_number": 131,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"The answer is\", 42);\n    println(\"Pi is approximately\", 3.14159);\n    println(\"Is Ruchy awesome?\", true);\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: argument never used\n --> /tmp/.tmpM3OVfg/main.rs:1:81\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"The answer is\" , 42i32) ; println ! (\"Pi is approximately\" , 3.14159f64) ;...\n  |                                                               ---------------   ^^^^^ argument never used\n  |                                                               |\n  |                                                               formatting specifier missing\n\nerror: argument never used\n --> /tmp/.tmpM3OVfg/main.rs:1:125\n  |\n1 | ... (\"The answer is\" , 42i32) ; println ! (\"Pi is approximately\" , 3.14159f64) ; println ! (\"Is Ruchy awesome?\" , true) } }\n  |                                            ---------------------   ^^^^^^^^^^ argument never used\n  |                                            |\n  |                                            formatting specifier missing\n\nerror: argument never used\n --> /tmp/.tmpM3OVfg/main.rs:1:172\n  |\n1 | ... approximately\" , 3.14159f64) ; println ! (\"Is Ruchy awesome?\" , true) } }\n  |                                               -------------------   ^^^^ argument never used\n  |                                               |\n  |                                               formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpM3OVfg/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { println ! (\"The answer is\" , 42i32) ; println ! (\"Pi is approximately\" , 3.14159f64) ;...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 5,
          "line_number": 156,
          "code": "// Status: ✅ WORKING\n// ❌ This won't work - intentional error example\n// println(Hello, World!);\n//\n\n// Always use quotes for literal text.\n\nfun main() {\n    // ✅ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 6,
          "line_number": 176,
          "code": "// Status: ✅ WORKING\n// ❌ Quotes don't match - intentional error example\n// println(\"Hello, World!');\n//\n\n// Use either \"...\" or '...' but be consistent.\n\nfun main() {\n    // ✅ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 7,
          "line_number": 196,
          "code": "// Status: ✅ WORKING\n// ❌ Wrong capitalization - intentional error example\n// PrintLn(\"Hello, World!\");\n//\n\n\nfun main() {\n    // ✅ Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 8,
          "line_number": 222,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch02-00-variables-types": {
      "chapter": "ch02-00-variables-types",
      "total_examples": 9,
      "working_examples": 1,
      "failing_examples": 8,
      "examples": [
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let name = \"Alice\"\n    let age = 25\n    let is_learning = true\n\n    println(\"Hi\", name, \", you're\", age, \"years old!\")\n    println(\"Currently learning Ruchy:\", is_learning)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: multiple unused formatting arguments\n --> /tmp/.tmpz0mH2J/main.rs:1:161\n  |\n1 | ...t is_learning = true ; println ! (\"Hi\" , name , \", you're\" , age , \"years old!\") ; println ! (\"Currently learning Ruchy:\" , is_learnin...\n  |                                      ----   ^^^^   ^^^^^^^^^^   ^^^   ^^^^^^^^^^^^ argument never used\n  |                                      |      |      |            |\n  |                                      |      |      |            argument never used\n  |                                      |      |      argument never used\n  |                                      |      argument never used\n  |                                      multiple missing formatting specifiers\n\nerror: argument never used\n --> /tmp/.tmpz0mH2J/main.rs:1:244\n  |\n1 | ... , age , \"years old!\") ; println ! (\"Currently learning Ruchy:\" , is_learning) } } } }\n  |                                        ---------------------------   ^^^^^^^^^^^ argument never used\n  |                                        |\n  |                                        formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpz0mH2J/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" . to_string () ; { let mut age = 25i32 ; let mut is_learning = tr...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpz0mH2J/main.rs:1:50\n  |\n1 | ... { { { let name = \"Alice\" . to_string () ; { let mut age = 25i32 ; let mut is_learning = true ; println ! (\"Hi\" , name , \", you're\" , age , \"years old!\") ; println ! (\"Currently learning Ruchy:\" , is_learning) } } } }\n  |       ^^                                                                                                                                                                                                                ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" . to_string () ; { let mut age = 25i32 ; let mut is_learning = true ; println ! (\"Hi\" , name , \", you're\" , age , \"years old!\") ; println ! (\"Currently learning Ruchy:\" , is_learning) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let name = \"Alice\" . to_string () ; { let mut age = 25i32 ; let mut is_learning = true ; println ! (\"Hi\" , name , \", you're\" , age , \"years old!\") ; println ! (\"Currently learning Ruchy:\" , is_learning) } } }\n  |\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmpz0mH2J/main.rs:1:96\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" . to_string () ; { let mut age = 25i32 ; let mut is_learning = tr...\n  |                                                                                                ----^^^\n  |                                                                                                |\n  |                                                                                                help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmpz0mH2J/main.rs:1:118\n  |\n1 | ...\"Alice\" . to_string () ; { let mut age = 25i32 ; let mut is_learning = true ; println ! (\"Hi\" , name , \", you're\" , age , \"years old!\"...\n  |                                                         ----^^^^^^^^^^^\n  |                                                         |\n  |                                                         help: remove this `mut`\n\nerror: aborting due to 2 previous errors; 4 warnings emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 2,
          "line_number": 86,
          "code": "// Status: ✅ WORKING\nfun main() {\n    // Text data\n    let first_name = \"John\"\n    let last_name = \"Doe\"\n    let full_name = first_name + \" \" + last_name\n\n    // Numeric data\n    let score = 95\n    let percentage = 95.5\n    let temperature = -10\n\n    // Boolean (true/false) data\n    let is_student = true\n    let has_graduated = false\n    let is_enrolled = !has_graduated\n\n    println(\"Student:\", full_name)\n    println(\"Score:\", score, \"(\", percentage, \"%)\")\n    println(\"Temperature:\", temperature, \"°C\")\n    println(\"Status: student=\", is_student, \", graduated=\", has_graduated)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: argument never used\n --> /tmp/.tmpGEI5Yt/main.rs:1:422\n  |\n1 | ...ut is_enrolled = ! has_graduated ; println ! (\"Student:\" , full_name) ; println ! (\"Score:\" , score , \"(\" , percentage , \"%)\") ; print...\n  |                                                  ----------   ^^^^^^^^^ argument never used\n  |                                                  |\n  |                                                  formatting specifier missing\n\nerror: multiple unused formatting arguments\n --> /tmp/.tmpGEI5Yt/main.rs:1:457\n  |\n1 | ...Student:\" , full_name) ; println ! (\"Score:\" , score , \"(\" , percentage , \"%)\") ; println ! (\"Temperature:\" , temperature , \"°C\") ; pr...\n  |                                        --------   ^^^^^   ^^^   ^^^^^^^^^^   ^^^^ argument never used\n  |                                        |          |       |     |\n  |                                        |          |       |     argument never used\n  |                                        |          |       argument never used\n  |                                        |          argument never used\n  |                                        multiple missing formatting specifiers\n\nerror: multiple unused formatting arguments\n --> /tmp/.tmpGEI5Yt/main.rs:1:520\n  |\n1 | ... \"(\" , percentage , \"%)\") ; println ! (\"Temperature:\" , temperature , \"°C\") ; println ! (\"Status: student=\" , is_student , \", graduate...\n  |                                           --------------   ^^^^^^^^^^^   ^^^^ argument never used\n  |                                           |                |\n  |                                           |                argument never used\n  |                                           multiple missing formatting specifiers\n\nerror: multiple unused formatting arguments\n --> /tmp/.tmpGEI5Yt/main.rs:1:574\n  |\n1 | ...ure , \"°C\") ; println ! (\"Status: student=\" , is_student , \", graduated=\" , has_graduated) } } } }\n  |                             ------------------   ^^^^^^^^^^   ^^^^^^^^^^^^^^   ^^^^^^^^^^^^^ argument never used\n  |                             |                    |            |\n  |                             |                    |            argument never used\n  |                             |                    argument never used\n  |                             multiple missing formatting specifiers\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpGEI5Yt/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let first_name = \"John\" . to_string () ; { let mut last_name = \"Doe\" . to_string () ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpGEI5Yt/main.rs:1:50\n  |\n1 | ... { { { let first_name = \"John\" . to_string () ; { let mut last_name = \"Doe\" . to_string () ; let mut full_name = format ! (\"{}{}\" , first_name , \" \") + last_name ; let mut score = 95i32 ; let mut percentage = 95.5f64 ; let mut temperature = - 10i32 ; let mut is_student = true ; let mut has_graduated = false ; let mut is_enrolled = ! has_graduated ; println ! (\"Student:\" , full_name) ; println ! (\"Score:\" , score , \"(\" , percentage , \"%)\") ; println ! (\"Temperature:\" , temperature , \"°C\") ; println ! (\"Status: student=\" , is_student , \", graduated=\" , has_graduated) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let first_name = \"John\" . to_string () ; { let mut last_name = \"Doe\" . to_string () ; let mut full_name = format ! (\"{}{}\" , first_name , \" \") + last_name ; let mut score = 95i32 ; let mut percentage = 95.5f64 ; let mut temperature = - 10i32 ; let mut is_student = true ; let mut has_graduated = false ; let mut is_enrolled = ! has_graduated ; println ! (\"Student:\" , full_name) ; println ! (\"Score:\" , score , \"(\" , percentage , \"%)\") ; println ! (\"Temperature:\" , temperature , \"°C\") ; println ! (\"Status: student=\" , is_student , \", graduated=\" , has_graduated) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let first_name = \"John\" . to_string () ; { let mut last_name = \"Doe\" . to_string () ; let mut full_name = format ! (\"{}{}\" , first_name , \" \") + last_name ; let mut score = 95i32 ; let mut percentage = 95.5f64 ; let mut temperature = - 10i32 ; let mut is_student = true ; let mut has_graduated = false ; let mut is_enrolled = ! has_graduated ; println ! (\"Student:\" , full_name) ; println ! (\"Score:\" , score , \"(\" , percentage , \"%)\") ; println ! (\"Temperature:\" , temperature , \"°C\") ; println ! (\"Status: student=\" , is_student , \", graduated=\" , has_graduated) } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpGEI5Yt/main.rs:1:199\n  |\n1 | ...name = format ! (\"{}{}\" , first_name , \" \") + last_name ; let mut score = 95i32 ; let mut percentage = 95.5f64 ; let mut temperature =...\n  |                                                  ^^^^^^^^^ expected `&str`, found `String`\n  |\nhelp: consider borrowing here\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let first_name = \"John\" . to_string () ; { let mut last_name = \"Doe\" . to_string () ; let mut full_name = format ! (\"{}{}\" , first_name , \" \") + &last_name ; let mut score = 95i32 ; let mut percentage = 95.5f64 ; let mut temperature = - 10i32 ; let mut is_student = true ; let mut has_graduated = false ; let mut is_enrolled = ! has_graduated ; println ! (\"Student:\" , full_name) ; println ! (\"Score:\" , score , \"(\" , percentage , \"%)\") ; println ! (\"Temperature:\" , temperature , \"°C\") ; println ! (\"Status: student=\" , is_student , \", graduated=\" , has_graduated) } } } }\n  |                                                                                                                                                                                                       +\n\nerror: aborting due to 5 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 3,
          "line_number": 119,
          "code": "// Status: ✅ WORKING\nfun main() {\n    // Store user information\n    let username = \"programmer2024\"\n    let mut login_count = 1\n    let mut is_premium = false\n\n    // Use variables in calculations\n    let welcome_bonus = 100\n    let total_points = welcome_bonus + (login_count * 10)\n\n    // Update information (use mut for mutable variables)\n    login_count = login_count + 1\n    is_premium = total_points > 150\n\n    println(\"Welcome back,\", username, \"!\")\n    println(\"Logins:\", login_count, \", Points:\", total_points)\n    println(\"Premium status:\", is_premium)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: multiple unused formatting arguments\n --> /tmp/.tmpgY3BKf/main.rs:1:358\n  |\n1 | ...um = total_points > 150i32 ; println ! (\"Welcome back,\" , username , \"!\") ; println ! (\"Logins:\" , login_count , \", Points:\" , total_p...\n  |                                            ---------------   ^^^^^^^^   ^^^ argument never used\n  |                                            |                 |\n  |                                            |                 argument never used\n  |                                            multiple missing formatting specifiers\n\nerror: multiple unused formatting arguments\n --> /tmp/.tmpgY3BKf/main.rs:1:399\n  |\n1 | ..., username , \"!\") ; println ! (\"Logins:\" , login_count , \", Points:\" , total_points) ; println ! (\"Premium status:\" , is_premium) } } } }\n  |                                   ---------   ^^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^^ argument never used\n  |                                   |           |             |\n  |                                   |           |             argument never used\n  |                                   |           argument never used\n  |                                   multiple missing formatting specifiers\n\nerror: argument never used\n --> /tmp/.tmpgY3BKf/main.rs:1:474\n  |\n1 | ... \", Points:\" , total_points) ; println ! (\"Premium status:\" , is_premium) } } } }\n  |                                              -----------------   ^^^^^^^^^^ argument never used\n  |                                              |\n  |                                              formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpgY3BKf/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let username = \"programmer2024\" . to_string () ; { let mut login_count = 1i32 ; let ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpgY3BKf/main.rs:1:50\n  |\n1 | ... { { { let username = \"programmer2024\" . to_string () ; { let mut login_count = 1i32 ; let mut is_premium = false ; let mut welcome_bonus = 100i32 ; let mut total_points = welcome_bonus + login_count * 10i32 ; login_count = login_count + 1i32 ; is_premium = total_points > 150i32 ; println ! (\"Welcome back,\" , username , \"!\") ; println ! (\"Logins:\" , login_count , \", Points:\" , total_points) ; println ! (\"Premium status:\" , is_premium) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let username = \"programmer2024\" . to_string () ; { let mut login_count = 1i32 ; let mut is_premium = false ; let mut welcome_bonus = 100i32 ; let mut total_points = welcome_bonus + login_count * 10i32 ; login_count = login_count + 1i32 ; is_premium = total_points > 150i32 ; println ! (\"Welcome back,\" , username , \"!\") ; println ! (\"Logins:\" , login_count , \", Points:\" , total_points) ; println ! (\"Premium status:\" , is_premium) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let username = \"programmer2024\" . to_string () ; { let mut login_count = 1i32 ; let mut is_premium = false ; let mut welcome_bonus = 100i32 ; let mut total_points = welcome_bonus + login_count * 10i32 ; login_count = login_count + 1i32 ; is_premium = total_points > 150i32 ; println ! (\"Welcome back,\" , username , \"!\") ; println ! (\"Logins:\" , login_count , \", Points:\" , total_points) ; println ! (\"Premium status:\" , is_premium) } } }\n  |\n\nwarning: value assigned to `is_premium` is never read\n --> /tmp/.tmpgY3BKf/main.rs:1:142\n  |\n1 | ...2024\" . to_string () ; { let mut login_count = 1i32 ; let mut is_premium = false ; let mut welcome_bonus = 100i32 ; let mut total_poin...\n  |                                                                  ^^^^^^^^^^\n  |\n  = help: maybe it is overwritten before being read?\n  = note: `#[warn(unused_assignments)]` on by default\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmpgY3BKf/main.rs:1:167\n  |\n1 | ...ogin_count = 1i32 ; let mut is_premium = false ; let mut welcome_bonus = 100i32 ; let mut total_points = welcome_bonus + login_count *...\n  |                                                         ----^^^^^^^^^^^^^\n  |                                                         |\n  |                                                         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmpgY3BKf/main.rs:1:200\n  |\n1 | ...emium = false ; let mut welcome_bonus = 100i32 ; let mut total_points = welcome_bonus + login_count * 10i32 ; login_count = login_coun...\n  |                                                         ----^^^^^^^^^^^^\n  |                                                         |\n  |                                                         help: remove this `mut`\n\nerror: aborting due to 3 previous errors; 5 warnings emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 4,
          "line_number": 149,
          "code": "// Status: ❌ BROKEN\nfun main() {\n    // Store multiple values\n    let favorite_languages = [\"Python\", \"Rust\", \"Ruchy\"]\n    let daily_temperatures = [22.5, 25.0, 23.8, 26.2]\n    let task_completed = [true, false, true, true]\n\n    // Access items by index (starting from 0)\n    println(\"First language:\", favorite_languages[0])\n    println(\"Today's temp:\", daily_temperatures[0], \"°C\")\n\n    // Get list length\n    println(\"I know\", favorite_languages.len(), \"languages\")\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: argument never used\n --> /tmp/.tmpnSv1P6/main.rs:1:287\n  |\n1 | ...e , true , true] ; println ! (\"First language:\" , favorite_languages [0i32 as usize]) ; println ! (\"Today's temp:\" , daily_temperature...\n  |                                  -----------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used\n  |                                  |\n  |                                  formatting specifier missing\n\nerror: multiple unused formatting arguments\n --> /tmp/.tmpnSv1P6/main.rs:1:354\n  |\n1 | ...32 as usize]) ; println ! (\"Today's temp:\" , daily_temperatures [0i32 as usize] , \"°C\") ; println ! (\"I know\" , favorite_languages . l...\n  |                               ---------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^ argument never used\n  |                               |                 |\n  |                               |                 argument never used\n  |                               multiple missing formatting specifiers\n\nerror: multiple unused formatting arguments\n --> /tmp/.tmpnSv1P6/main.rs:1:421\n  |\n1 | ...as usize] , \"°C\") ; println ! (\"I know\" , favorite_languages . len () , \"languages\") } } } }\n  |                                   --------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^ argument never used\n  |                                   |          |\n  |                                   |          argument never used\n  |                                   multiple missing formatting specifiers\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpnSv1P6/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let favorite_languages = vec ! [\"Python\" , \"Rust\" , \"Ruchy\"] ; { let mut daily_tempe...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpnSv1P6/main.rs:1:50\n  |\n1 | ... { { { let favorite_languages = vec ! [\"Python\" , \"Rust\" , \"Ruchy\"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! (\"First language:\" , favorite_languages [0i32 as usize]) ; println ! (\"Today's temp:\" , daily_temperatures [0i32 as usize] , \"°C\") ; println ! (\"I know\" , favorite_languages . len () , \"languages\") } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                               ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let favorite_languages = vec ! [\"Python\" , \"Rust\" , \"Ruchy\"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! (\"First language:\" , favorite_languages [0i32 as usize]) ; println ! (\"Today's temp:\" , daily_temperatures [0i32 as usize] , \"°C\") ; println ! (\"I know\" , favorite_languages . len () , \"languages\") } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let favorite_languages = vec ! [\"Python\" , \"Rust\" , \"Ruchy\"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! (\"First language:\" , favorite_languages [0i32 as usize]) ; println ! (\"Today's temp:\" , daily_temperatures [0i32 as usize] , \"°C\") ; println ! (\"I know\" , favorite_languages . len () , \"languages\") } } }\n  |\n\nwarning: unused variable: `task_completed`\n --> /tmp/.tmpnSv1P6/main.rs:1:202\n  |\n1 | ..., 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! (\"First language:\" , favorite_languages [0i32 as ...\n  |                         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_task_completed`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmpnSv1P6/main.rs:1:123\n  |\n1 | ...guages = vec ! [\"Python\" , \"Rust\" , \"Ruchy\"] ; { let mut daily_temperatures = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut ta...\n  |                                                         ----^^^^^^^^^^^^^^^^^^\n  |                                                         |\n  |                                                         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmpnSv1P6/main.rs:1:198\n  |\n1 | ... = vec ! [22.5f64 , 25f64 , 23.8f64 , 26.2f64] ; let mut task_completed = vec ! [true , false , true , true] ; println ! (\"First langu...\n  |                                                         ----^^^^^^^^^^^^^^\n  |                                                         |\n  |                                                         help: remove this `mut`\n\nerror: aborting due to 3 previous errors; 5 warnings emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 5,
          "line_number": 176,
          "code": "// Status: ❌ BROKEN\n// ❌ This won't work\nfun main() {\n    user_name = \"Alice\"  \n}\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `user_name` in this scope\n --> /tmp/.tmpER9MtQ/main.rs:1:52\n  |\n1 | use std :: collections :: HashMap ; fn main () { { user_name = \"Alice\" } }\n  |                                                    ^^^^^^^^^ not found in this scope\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpER9MtQ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { user_name = \"Alice\" } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpER9MtQ/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { user_name = \"Alice\" } }\n  |                                                  ^^                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { user_name = \"Alice\" } }\n1 + use std :: collections :: HashMap ; fn main () { user_name = \"Alice\" }\n  |\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 6,
          "line_number": 192,
          "code": "// Status: ❌ BROKEN\n// ❌ This might not work as expected\nfun main() {\n    let age = \"25\"  // String, not number\n    let next_year = age + 1  // Can't add number to string\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpsMtnJ5/main.rs:1:117\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let age = \"25\" . to_string () ; let mut next_year = age + 1i32 } } }\n  |                                                                                                                     ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpsMtnJ5/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let age = \"25\" . to_string () ; let mut next_year = age + 1i32 } } }\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpsMtnJ5/main.rs:1:50\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let age = \"25\" . to_string () ; let mut next_year = age + 1i32 } } }\n  |                                                  ^^                                                                  ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let age = \"25\" . to_string () ; let mut next_year = age + 1i32 } } }\n1 + use std :: collections :: HashMap ; fn main () { { let age = \"25\" . to_string () ; let mut next_year = age + 1i32 } }\n  |\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 7,
          "line_number": 210,
          "code": "// Status: ✅ WORKING\n// ❌ These are different variables\nfun main() {\n    let userName = \"Alice\"\n    let username = \"Bob\"\n    println(userName)  // Prints \"Alice\", not \"Bob\"\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 8,
          "line_number": 235,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let name = \"Alice\"\n    let age = 25\n    println(\"Hi\", name, \", age\", age)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: multiple unused formatting arguments\n --> /tmp/.tmpqsZLfz/main.rs:1:132\n  |\n1 | ...ng () ; { let mut age = 25i32 ; println ! (\"Hi\" , name , \", age\" , age) } } } }\n  |                                               ----   ^^^^   ^^^^^^^   ^^^ argument never used\n  |                                               |      |      |\n  |                                               |      |      argument never used\n  |                                               |      argument never used\n  |                                               multiple missing formatting specifiers\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpqsZLfz/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" . to_string () ; { let mut age = 25i32 ; println ! (\"Hi\" , name ,...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpqsZLfz/main.rs:1:50\n  |\n1 | ...n main () { { { let name = \"Alice\" . to_string () ; { let mut age = 25i32 ; println ! (\"Hi\" , name , \", age\" , age) } } } }\n  |                ^^                                                                                                         ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" . to_string () ; { let mut age = 25i32 ; println ! (\"Hi\" , name , \", age\" , age) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let name = \"Alice\" . to_string () ; { let mut age = 25i32 ; println ! (\"Hi\" , name , \", age\" , age) } } }\n  |\n\nwarning: variable does not need to be mutable\n --> /tmp/.tmpqsZLfz/main.rs:1:96\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" . to_string () ; { let mut age = 25i32 ; println ! (\"Hi\" , name ,...\n  |                                                                                                ----^^^\n  |                                                                                                |\n  |                                                                                                help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror: aborting due to 1 previous error; 3 warnings emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch02-00-variables-types.md",
          "example_number": 9,
          "line_number": 304,
          "code": "// Status: ✅ WORKING\nfun main() {\n    // Personal profile\n    let name = \"Alex\"\n    let age = 28\n    let city = \"San Francisco\"\n    let hobby = \"rock climbing\"\n    let goal = \"master Ruchy in 30 days\"\n\n    // Data calculator  \n    let num1 = 15\n    let num2 = 25\n    let sum = num1 + num2\n    let difference = num1 - num2\n    let average = (num1 + num2) / 2\n\n    // Text manipulation\n    let first_name = \"Alex\"\n    let last_name = \"Johnson\"\n    let username = first_name + \"_\" + last_name\n    let email = username + \"@example.com\"\n\n    // Boolean logic\n    let is_adult = age >= 18\n    let lives_in_tech_city = city == \"San Francisco\"\n    let ready_for_job = is_adult && lives_in_tech_city\n\n    println(\"Profile:\", name, age, city)\n    println(\"Math:\", sum, difference, average)\n    println(\"Contact:\", username, email)\n    println(\"Status:\", is_adult, lives_in_tech_city, ready_for_job)\n}",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: multiple unused formatting arguments\n --> /tmp/.tmpCCQqxy/main.rs:1:812\n  |\n1 | ..._adult && lives_in_tech_city ; println ! (\"Profile:\" , name , age , city) ; println ! (\"Math:\" , sum , difference , average) ; println...\n  |                                              ----------   ^^^^   ^^^   ^^^^ argument never used\n  |                                              |            |      |\n  |                                              |            |      argument never used\n  |                                              |            argument never used\n  |                                              multiple missing formatting specifiers\n\nerror: multiple unused formatting arguments\n --> /tmp/.tmpCCQqxy/main.rs:1:854\n  |\n1 | ...le:\" , name , age , city) ; println ! (\"Math:\" , sum , difference , average) ; println ! (\"Contact:\" , username , email) ; println ! (...\n  |                                           -------   ^^^   ^^^^^^^^^^   ^^^^^^^ argument never used\n  |                                           |         |     |\n  |                                           |         |     argument never used\n  |                                           |         argument never used\n  |                                           multiple missing formatting specifiers\n\nerror: multiple unused formatting arguments\n --> /tmp/.tmpCCQqxy/main.rs:1:908\n  |\n1 | ... sum , difference , average) ; println ! (\"Contact:\" , username , email) ; println ! (\"Status:\" , is_adult , lives_in_tech_city , read...\n  |                                              ----------   ^^^^^^^^   ^^^^^ argument never used\n  |                                              |            |\n  |                                              |            argument never used\n  |                                              multiple missing formatting specifiers\n\nerror: multiple unused formatting arguments\n --> /tmp/.tmpCCQqxy/main.rs:1:951\n  |\n1 | ...rname , email) ; println ! (\"Status:\" , is_adult , lives_in_tech_city , ready_for_job) } } } }\n  |                                ---------   ^^^^^^^^   ^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^ argument never used\n  |                                |           |          |\n  |                                |           |          argument never used\n  |                                |           argument never used\n  |                                multiple missing formatting specifiers\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpCCQqxy/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let name = \"Alex\" . to_string () ; { let mut age = 28i32 ; let mut city = \"San Franc...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpCCQqxy/main.rs:1:50\n  |\n1 | ... { { { let name = \"Alex\" . to_string () ; { let mut age = 28i32 ; let mut city = \"San Francisco\" . to_string () ; let mut hobby = \"rock climbing\" . to_string () ; let mut goal = \"master Ruchy in 30 days\" . to_string () ; let mut num1 = 15i32 ; let mut num2 = 25i32 ; let mut sum = num1 + num2 ; let mut difference = num1 - num2 ; let mut average = num1 + num2 / 2i32 ; let mut first_name = \"Alex\" . to_string () ; let mut last_name = \"Johnson\" . to_string () ; let mut username = format ! (\"{}{}\" , first_name , \"_\") + last_name ; let mut email = format ! (\"{}{}\" , username , \"@example.com\") ; let mut is_adult = age >= 18i32 ; let mut lives_in_tech_city = city == \"San Francisco\" ; let mut ready_for_job = is_adult && lives_in_tech_city ; println ! (\"Profile:\" , name , age , city) ; println ! (\"Math:\" , sum , difference , average) ; println ! (\"Contact:\" , username , email) ; println ! (\"Status:\" , is_adult , lives_in_tech_city , ready_for_job) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let name = \"Alex\" . to_string () ; { let mut age = 28i32 ; let mut city = \"San Francisco\" . to_string () ; let mut hobby = \"rock climbing\" . to_string () ; let mut goal = \"master Ruchy in 30 days\" . to_string () ; let mut num1 = 15i32 ; let mut num2 = 25i32 ; let mut sum = num1 + num2 ; let mut difference = num1 - num2 ; let mut average = num1 + num2 / 2i32 ; let mut first_name = \"Alex\" . to_string () ; let mut last_name = \"Johnson\" . to_string () ; let mut username = format ! (\"{}{}\" , first_name , \"_\") + last_name ; let mut email = format ! (\"{}{}\" , username , \"@example.com\") ; let mut is_adult = age >= 18i32 ; let mut lives_in_tech_city = city == \"San Francisco\" ; let mut ready_for_job = is_adult && lives_in_tech_city ; println ! (\"Profile:\" , name , age , city) ; println ! (\"Math:\" , sum , difference , average) ; println ! (\"Contact:\" , username , email) ; println ! (\"Status:\" , is_adult , lives_in_tech_city , ready_for_job) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let name = \"Alex\" . to_string () ; { let mut age = 28i32 ; let mut city = \"San Francisco\" . to_string () ; let mut hobby = \"rock climbing\" . to_string () ; let mut goal = \"master Ruchy in 30 days\" . to_string () ; let mut num1 = 15i32 ; let mut num2 = 25i32 ; let mut sum = num1 + num2 ; let mut difference = num1 - num2 ; let mut average = num1 + num2 / 2i32 ; let mut first_name = \"Alex\" . to_string () ; let mut last_name = \"Johnson\" . to_string () ; let mut username = format ! (\"{}{}\" , first_name , \"_\") + last_name ; let mut email = format ! (\"{}{}\" , username , \"@example.com\") ; let mut is_adult = age >= 18i32 ; let mut lives_in_tech_city = city == \"San Francisco\" ; let mut ready_for_job = is_adult && lives_in_tech_city ; println ! (\"Profile:\" , name , age , city) ; println ! (\"Math:\" , sum , difference , average) ; println ! (\"Contact:\" , username , email) ; println ! (\"Status:\" , is_adult , lives_in_tech_city , ready_for_job) } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpCCQqxy/main.rs:1:566\n  |\n1 | ...name = format ! (\"{}{}\" , first_name , \"_\") + last_name ; let mut email = format ! (\"{}{}\" , username , \"@example.com\") ; let mut is_a...\n  |                                                  ^^^^^^^^^ expected `&str`, found `String`\n  |\nhelp: consider borrowing here\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let name = \"Alex\" . to_string () ; { let mut age = 28i32 ; let mut city = \"San Francisco\" . to_string () ; let mut hobby = \"rock climbing\" . to_string () ; let mut goal = \"master Ruchy in 30 days\" . to_string () ; let mut num1 = 15i32 ; let mut num2 = 25i32 ; let mut sum = num1 + num2 ; let mut difference = num1 - num2 ; let mut average = num1 + num2 / 2i32 ; let mut first_name = \"Alex\" . to_string () ; let mut last_name = \"Johnson\" . to_string () ; let mut username = format ! (\"{}{}\" , first_name , \"_\") + &last_name ; let mut email = format ! (\"{}{}\" , username , \"@example.com\") ; let mut is_adult = age >= 18i32 ; let mut lives_in_tech_city = city == \"San Francisco\" ; let mut ready_for_job = is_adult && lives_in_tech_city ; println ! (\"Profile:\" , name , age , city) ; println ! (\"Math:\" , sum , difference , average) ; println ! (\"Contact:\" , username , email) ; println ! (\"Status:\" , is_adult , lives_in_tech_city , ready_for_job) } } } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      +\n\nerror: aborting due to 5 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch06-00-data-structures-tdd": {
      "chapter": "ch06-00-data-structures-tdd",
      "total_examples": 8,
      "working_examples": 3,
      "failing_examples": 5,
      "examples": [
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let greeting = \"Hello\";\n    let name = \"World\";\n    println(greeting);\n    println(name);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 2,
          "line_number": 54,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let first = \"Hello\";\n    let second = \"Beautiful\";\n    let third = \"World\";\n    println(first);\n    println(second);\n    println(third);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 3,
          "line_number": 79,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let number = 42;\n    let text = \"Answer\";\n    println(text);\n    println(number);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 4,
          "line_number": 119,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet message = \"Hello World\";\nlet name = \"Alice\";\nlet greeting = \"Welcome\";",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpzzNxnv/main.rs:1:198\n  |\n1 | ...ut greeting = \"Welcome\" . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpzzNxnv/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut message = \"Hello World\" . to_string () ; let mut name = \"Alice\" ....\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 5,
          "line_number": 130,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet text = \"Count\";\nlet number = 100;\nlet flag = true;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpdkSC3R/main.rs:1:151\n  |\n1 | ... number = 100i32 ; let mut flag = true } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpdkSC3R/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut text = \"Count\" . to_string () ; let mut number = 100i32 ; let mut...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 6,
          "line_number": 155,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet first_name = \"John\";\nlet last_name = \"Doe\";\nlet title = \"Mr.\";",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpxfDhHt/main.rs:1:190\n  |\n1 | ...; let mut title = \"Mr.\" . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpxfDhHt/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut first_name = \"John\" . to_string () ; let mut last_name = \"Doe\" . ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 7,
          "line_number": 166,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet label = \"Temperature\";\nlet value = 72;\nlet unit = \"Fahrenheit\";",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpT9vEJX/main.rs:1:179\n  |\n1 | ...mut unit = \"Fahrenheit\" . to_string () } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpT9vEJX/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut label = \"Temperature\" . to_string () ; let mut value = 72i32 ; le...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 8,
          "line_number": 177,
          "code": "// Status: ❌ BROKEN\n// Error: ✗ Compilation failed: Compilation failed:\nlet app_name = \"MyApp\";\nlet version = \"1.0\";\nlet debug = true;",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpZLpy1s/main.rs:1:171\n  |\n1 | ... . to_string () ; let mut debug = true } ; if let Some (s) = (& result as & dyn std :: any :: Any) . downcast_ref :: < String > () { p...\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpZLpy1s/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { let result = { let mut app_name = \"MyApp\" . to_string () ; let mut version = \"1.0\" . to_...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch03-00-functions": {
      "chapter": "ch03-00-functions",
      "total_examples": 12,
      "working_examples": 2,
      "failing_examples": 10,
      "examples": [
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 1,
          "line_number": 30,
          "code": "// Status: ❌ BROKEN\nfun main() {\n    // Organize calculations\n    let name = \"Alice\"  \n    let a = 15\n    let b = 27\n\n    // Reusable greeting logic\n    let greeting = \"Hello, \" + name + \"! Welcome to Ruchy!\"\n\n    // Reusable calculation logic  \n    let sum = a + b\n    let result_message = a + \" + \" + b + \" = \" + sum\n\n    println(greeting)\n    println(result_message)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpMuzgXI/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" . to_string () ; { let mut a = 15i32 ; let mut b = 27i32 ; let mu...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpMuzgXI/main.rs:1:50\n  |\n1 | ... { { { let name = \"Alice\" . to_string () ; { let mut a = 15i32 ; let mut b = 27i32 ; let mut greeting = format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hello, \" , name) , \"! Welcome to Ruchy!\") ; let mut sum = a + b ; let mut result_message = format ! (\"{}{}\" , format ! (\"{}{}\" , a , \" + \") + b , \" = \") + sum ; println ! (\"{:?}\" , greeting) ; println ! (\"{:?}\" , result_message) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                  ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let name = \"Alice\" . to_string () ; { let mut a = 15i32 ; let mut b = 27i32 ; let mut greeting = format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hello, \" , name) , \"! Welcome to Ruchy!\") ; let mut sum = a + b ; let mut result_message = format ! (\"{}{}\" , format ! (\"{}{}\" , a , \" + \") + b , \" = \") + sum ; println ! (\"{:?}\" , greeting) ; println ! (\"{:?}\" , result_message) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let name = \"Alice\" . to_string () ; { let mut a = 15i32 ; let mut b = 27i32 ; let mut greeting = format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hello, \" , name) , \"! Welcome to Ruchy!\") ; let mut sum = a + b ; let mut result_message = format ! (\"{}{}\" , format ! (\"{}{}\" , a , \" + \") + b , \" = \") + sum ; println ! (\"{:?}\" , greeting) ; println ! (\"{:?}\" , result_message) } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpMuzgXI/main.rs:1:332\n  |\n1 | ... format ! (\"{}{}\" , format ! (\"{}{}\" , a , \" + \") + b , \" = \") + sum ; println ! (\"{:?}\" , greeting) ; println ! (\"{:?}\" , result_mess...\n  |                                                        ^ expected `&str`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpMuzgXI/main.rs:1:345\n  |\n1 | ...{}\" , format ! (\"{}{}\" , a , \" + \") + b , \" = \") + sum ; println ! (\"{:?}\" , greeting) ; println ! (\"{:?}\" , result_message) } } } }\n  |                                                       ^^^ expected `&str`, found `i32`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 2,
          "line_number": 70,
          "code": "// Status: ❌ BROKEN\nfun main() {\n    // Store inputs\n    let input1 = 10\n    let input2 = 20\n\n    // Organize calculations  \n    let sum = input1 + input2\n    let product = input1 * input2\n    let average = sum / 2\n\n    // Organize output\n    let result = \"Sum: \" + sum + \", Product: \" + product + \", Average: \" + average\n    println(result)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp3niM8P/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp3niM8P/main.rs:1:50\n  |\n1 | ... { { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let mut product = input1 * input2 ; let mut average = sum / 2i32 ; let mut result = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Sum: \" , sum) , \", Product: \") + product , \", Average: \") + average ; println ! (\"{:?}\" , result) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let mut product = input1 * input2 ; let mut average = sum / 2i32 ; let mut result = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Sum: \" , sum) , \", Product: \") + product , \", Average: \") + average ; println ! (\"{:?}\" , result) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let input1 = 10i32 ; { let mut input2 = 20i32 ; let mut sum = input1 + input2 ; let mut product = input1 * input2 ; let mut average = sum / 2i32 ; let mut result = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Sum: \" , sum) , \", Product: \") + product , \", Average: \") + average ; println ! (\"{:?}\" , result) } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp3niM8P/main.rs:1:309\n  |\n1 | ...at ! (\"{}{}\" , \"Sum: \" , sum) , \", Product: \") + product , \", Average: \") + average ; println ! (\"{:?}\" , result) } } } }\n  |                                                     ^^^^^^^ expected `&str`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp3niM8P/main.rs:1:336\n  |\n1 | ...m) , \", Product: \") + product , \", Average: \") + average ; println ! (\"{:?}\" , result) } } } }\n  |                                                     ^^^^^^^ expected `&str`, found `i32`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 3,
          "line_number": 98,
          "code": "// Status: ❌ BROKEN\nfun main() {\n    // Template: greeting with name\n    let user_name = \"Alice\"\n    let greeting_template = \"Hello, \" + user_name + \"! Welcome!\"\n\n    // Template: calculation display\n    let num1 = 15\n    let num2 = 27  \n    let operation = \"addition\"\n    let calc_result = num1 + num2\n    let calc_display = operation + \": \" + num1 + \" + \" + num2 + \" = \" + calc_result\n    \n    println(greeting_template)\n    println(calc_display)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpyFQaRc/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let user_name = \"Alice\" . to_string () ; { let mut greeting_template = format ! (\"{}...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpyFQaRc/main.rs:1:50\n  |\n1 | ... { { { let user_name = \"Alice\" . to_string () ; { let mut greeting_template = format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hello, \" , user_name) , \"! Welcome!\") ; let mut num1 = 15i32 ; let mut num2 = 27i32 ; let mut operation = \"addition\" . to_string () ; let mut calc_result = num1 + num2 ; let mut calc_display = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , operation , \": \") + num1 , \" + \") + num2 , \" = \") + calc_result ; println ! (\"{:?}\" , greeting_template) ; println ! (\"{:?}\" , calc_display) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let user_name = \"Alice\" . to_string () ; { let mut greeting_template = format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hello, \" , user_name) , \"! Welcome!\") ; let mut num1 = 15i32 ; let mut num2 = 27i32 ; let mut operation = \"addition\" . to_string () ; let mut calc_result = num1 + num2 ; let mut calc_display = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , operation , \": \") + num1 , \" + \") + num2 , \" = \") + calc_result ; println ! (\"{:?}\" , greeting_template) ; println ! (\"{:?}\" , calc_display) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let user_name = \"Alice\" . to_string () ; { let mut greeting_template = format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hello, \" , user_name) , \"! Welcome!\") ; let mut num1 = 15i32 ; let mut num2 = 27i32 ; let mut operation = \"addition\" . to_string () ; let mut calc_result = num1 + num2 ; let mut calc_display = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , operation , \": \") + num1 , \" + \") + num2 , \" = \") + calc_result ; println ! (\"{:?}\" , greeting_template) ; println ! (\"{:?}\" , calc_display) } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpyFQaRc/main.rs:1:434\n  |\n1 | ... (\"{}{}\" , format ! (\"{}{}\" , operation , \": \") + num1 , \" + \") + num2 , \" = \") + calc_result ; println ! (\"{:?}\" , greeting_template)...\n  |                                                      ^^^^ expected `&str`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpyFQaRc/main.rs:1:450\n  |\n1 | ...t ! (\"{}{}\" , operation , \": \") + num1 , \" + \") + num2 , \" = \") + calc_result ; println ! (\"{:?}\" , greeting_template) ; println ! (\"{...\n  |                                                      ^^^^ expected `&str`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpyFQaRc/main.rs:1:466\n  |\n1 | ...tion , \": \") + num1 , \" + \") + num2 , \" = \") + calc_result ; println ! (\"{:?}\" , greeting_template) ; println ! (\"{:?}\" , calc_display...\n  |                                                   ^^^^^^^^^^^ expected `&str`, found `i32`\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 4,
          "line_number": 127,
          "code": "// Status: ❌ BROKEN\nfun main() {\n    // Input section\n    let temperature_f = 68\n    let user_location = \"San Francisco\"\n\n    // Processing section  \n    let temperature_c = (temperature_f - 32) * 5 / 9\n    let is_comfortable = temperature_c > 18 && temperature_c < 25\n\n    // Output section\n    let weather_report = \"Weather in \" + user_location + \": \" + temperature_f + \"°F (\" + temperature_c + \"°C)\"\n    let comfort_message = if is_comfortable { \"Perfect weather!\" } else { \"Dress accordingly\" }\n\n    println(weather_report)\n    println(comfort_message)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpRex0Fa/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = \"San Francisco\" . to_string ()...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpRex0Fa/main.rs:1:50\n  |\n1 | ... { { { let temperature_f = 68i32 ; { let mut user_location = \"San Francisco\" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Weather in \" , user_location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{:?}\" , weather_report) ; println ! (\"{:?}\" , comfort_message) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = \"San Francisco\" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Weather in \" , user_location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{:?}\" , weather_report) ; println ! (\"{:?}\" , comfort_message) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { let temperature_f = 68i32 ; { let mut user_location = \"San Francisco\" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Weather in \" , user_location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{:?}\" , weather_report) ; println ! (\"{:?}\" , comfort_message) } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpRex0Fa/main.rs:1:516\n  |\n1 | ... \"°C)\") ; let mut comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{:?}\" ...\n  |                                                            ^^                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = \"San Francisco\" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Weather in \" , user_location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{:?}\" , weather_report) ; println ! (\"{:?}\" , comfort_message) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = \"San Francisco\" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Weather in \" , user_location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfortable { \"Perfect weather!\" } else { { \"Dress accordingly\" } } ; println ! (\"{:?}\" , weather_report) ; println ! (\"{:?}\" , comfort_message) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpRex0Fa/main.rs:1:548\n  |\n1 | ... = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{:?}\" , weather_report) ; println ! (\"{...\n  |                                                           ^^                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = \"San Francisco\" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Weather in \" , user_location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { { \"Dress accordingly\" } } ; println ! (\"{:?}\" , weather_report) ; println ! (\"{:?}\" , comfort_message) } } } }\n1 + use std :: collections :: HashMap ; fn main () { { { let temperature_f = 68i32 ; { let mut user_location = \"San Francisco\" . to_string () ; let mut temperature_c = temperature_f - 32i32 * 5i32 / 9i32 ; let mut is_comfortable = temperature_c > 18i32 && temperature_c < 25i32 ; let mut weather_report = format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Weather in \" , user_location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfortable { { \"Perfect weather!\" } } else { \"Dress accordingly\" } ; println ! (\"{:?}\" , weather_report) ; println ! (\"{:?}\" , comfort_message) } } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpRex0Fa/main.rs:1:419\n  |\n1 | ...}\" , \"Weather in \" , user_location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfo...\n  |                                                  ^^^^^^^^^^^^^ expected `&str`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpRex0Fa/main.rs:1:445\n  |\n1 | ...location) , \": \") + temperature_f , \"°F (\") + temperature_c , \"°C)\") ; let mut comfort_message = if is_comfortable { { \"Perfect weathe...\n  |                                                  ^^^^^^^^^^^^^ expected `&str`, found `i32`\n\nerror: aborting due to 2 previous errors; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 5,
          "line_number": 158,
          "code": "// Status: ❌ BROKEN\n// Mathematical operations\nfun square(x) {\n    x * x\n}\n\nfun circle_area(radius) {\n    let pi = 3.14159\n    pi * square(radius)\n}\n\n// Text processing\nfun make_username(first_name, last_name) {\n    first_name + \"_\" + last_name\n}\n\nfun shout(message) {\n    message + \"!!!\"\n}\n\nfun main() {\n    // Use them together\n    let area = circle_area(5)\n    let username = make_username(\"Alice\", \"Johnson\") \n    let excited = shout(\"I love functions\")\n\n    println(\"Circle area:\", area)\n    println(\"Username:\", username)\n    println(excited)\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: argument never used\n --> /tmp/.tmpOKQXNC/main.rs:1:595\n  |\n1 | ...love functions\" . to_string ()) ; println ! (\"Circle area:\" , area) ; println ! (\"Username:\" , username) ; println ! (\"{:?}\" , excited...\n  |                                                 --------------   ^^^^ argument never used\n  |                                                 |\n  |                                                 formatting specifier missing\n\nerror: argument never used\n --> /tmp/.tmpOKQXNC/main.rs:1:628\n  |\n1 | ...rintln ! (\"Circle area:\" , area) ; println ! (\"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n  |                                                  -----------   ^^^^^^^^ argument never used\n  |                                                  |\n  |                                                  formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpOKQXNC/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpOKQXNC/main.rs:1:66\n  |\n1 | use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f...\n  |                                                                  ^^     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"Circle area:\" , area) ; println ! (\"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { x * x } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"Circle area:\" , area) ; println ! (\"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpOKQXNC/main.rs:1:117\n  |\n1 | ... } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , la...\n  |                                              ^^                                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"Circle area:\" , area) ; println ! (\"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { let pi = 3.14159f64 ; pi * square (radius) } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"Circle area:\" , area) ; println ! (\"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpOKQXNC/main.rs:1:233\n  |\n1 | ...t_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout (message : String) -> i32 { {...\n  |                                             ^^                                                ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"Circle area:\" , area) ; println ! (\"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { format ! (\"{}{}\" , first_name , \"_\") + last_name } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"Circle area:\" , area) ; println ! (\"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpOKQXNC/main.rs:1:325\n  |\n1 | ..._name } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32...\n  |                                                   ^^                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"Circle area:\" , area) ; println ! (\"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout (message : String) -> i32 { format ! (\"{}{}\" , message , \"!!!\") } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"Circle area:\" , area) ; println ! (\"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpOKQXNC/main.rs:1:380\n  |\n1 | ... { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"Circle area:\" , area) ; println ! (\"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                  ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"Circle area:\" , area) ; println ! (\"Username:\" , username) ; println ! (\"{:?}\" , excited) } } } }\n1 + use std :: collections :: HashMap ; fn square (x : i32) -> i32 { { x * x } } fn circle_area (radius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { let area = circle_area (5i32) ; { let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . to_string ()) ; println ! (\"Circle area:\" , area) ; println ! (\"Username:\" , username) ; println ! (\"{:?}\" , excited) } } }\n  |\n\nerror[E0277]: cannot multiply `f64` by `i32`\n --> /tmp/.tmpOKQXNC/main.rs:1:146\n  |\n1 | ...ius : i32) -> i32 { { { let pi = 3.14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 ...\n  |                                                     ^ no implementation for `f64 * i32`\n  |\n  = help: the trait `Mul<i32>` is not implemented for `f64`\n  = help: the following other types implement trait `Mul<Rhs>`:\n            `&f64` implements `Mul<f64>`\n            `&f64` implements `Mul`\n            `f64` implements `Mul<&f64>`\n            `f64` implements `Mul`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpOKQXNC/main.rs:1:274\n  |\n1 | ... i32 { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!...\n  |                                                    ^^^^^^^^^ expected `&str`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpOKQXNC/main.rs:1:235\n  |\n1 | ... , last_name : i32) -> i32 { { format ! (\"{}{}\" , first_name , \"_\") + last_name } } fn shout (message : String) -> i32 { { format ! (\"...\n  |                           ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`\n  |                           |\n  |                           expected `i32` because of return type\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpOKQXNC/main.rs:1:327\n  |\n1 | ...n shout (message : String) -> i32 { { format ! (\"{}{}\" , message , \"!!!\") } } fn main () { { { let area = circle_area (5i32) ; { let m...\n  |                                  ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`\n  |                                  |\n  |                                  expected `i32` because of return type\n  |\n  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmpOKQXNC/main.rs:1:437\n  |\n1 | ...let mut username = make_username (\"Alice\" . to_string () , \"Johnson\" . to_string ()) ; let mut excited = shout (\"I love functions\" . t...\n  |                       ^^^^^^^^^^^^^  ----------------------   ------------------------ expected `i32`, found `String`\n  |                                      |\n  |                                      expected `i32`, found `String`\n  |\nnote: function defined here\n --> /tmp/.tmpOKQXNC/main.rs:1:173\n  |\n1 | ....14159f64 ; pi * square (radius) } } } fn make_username (first_name : i32 , last_name : i32) -> i32 { { format ! (\"{}{}\" , first_name ...\n  |                                              ^^^^^^^^^^^^^  ----------------   ---------------\n\nerror: aborting due to 7 previous errors; 6 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 6,
          "line_number": 200,
          "code": "// Status: ❌ BROKEN\nfun is_even(number) {\n    number % 2 == 0\n}\n\nfun grade_letter(score) {\n    if score >= 90 {\n        \"A\"\n    } else if score >= 80 {\n        \"B\"\n    } else if score >= 70 {\n        \"C\"\n    } else if score >= 60 {\n        \"D\"\n    } else {\n        \"F\"\n    }\n}\n\nfun describe_number(n) {\n    let even_odd = if is_even(n) { \"even\" } else { \"odd\" }\n    let size = if n > 100 { \"large\" } else { \"small\" }\n    n + \" is a \" + size + \" \" + even_odd + \" number\"\n}\n\nfun main() {\n    // Test your functions\n    println(describe_number(42))   // \"42 is a small even number\"\n    println(describe_number(150))  // \"150 is a large even number\"\n    println(grade_letter(85))      // \"B\"\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp8RsetZ/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp8RsetZ/main.rs:1:72\n  |\n1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...\n  |                                                                        ^^                     ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { number % 2i32 == 0i32 } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp8RsetZ/main.rs:1:142\n  |\n1 | ... { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } ...\n  |       ^^                                                                                                                                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp8RsetZ/main.rs:1:164\n  |\n1 | ...n grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { \"A\" } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp8RsetZ/main.rs:1:201\n  |\n1 | ...2 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { \"B\" } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp8RsetZ/main.rs:1:238\n  |\n1 | ...lse { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } }...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { \"C\" } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp8RsetZ/main.rs:1:275\n  |\n1 | ...lse { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i3...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { \"D\" } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp8RsetZ/main.rs:1:292\n  |\n1 | ... 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_...\n  |                                                                   ^^   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { \"F\" } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp8RsetZ/main.rs:1:350\n  |\n1 | ... { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } ...\n  |       ^^                                                                                                                                                                                                                                                          ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp8RsetZ/main.rs:1:386\n  |\n1 | ...number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"la...\n  |                                                                  ^^      ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { \"even\" } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp8RsetZ/main.rs:1:406\n  |\n1 | ...i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"s...\n  |                                                                  ^^     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { \"odd\" } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp8RsetZ/main.rs:1:453\n  |\n1 | ...n\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" ...\n  |                                                                 ^^       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { \"large\" } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp8RsetZ/main.rs:1:474\n  |\n1 | ... } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , ...\n  |                                                                 ^^       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n1 + use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { \"small\" } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } } } } fn main () { { println ! (\"{:?}\" , describe_number (42i32)) ; println ! (\"{:?}\" , describe_number (150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp8RsetZ/main.rs:1:74\n  |\n1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...\n  |                                                                  ---     ^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `bool`\n  |                                                                  |\n  |                                                                  expected `i32` because of return type\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp8RsetZ/main.rs:1:156\n  |\n1 | ...er (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } }...\n  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                      |        |\n  |                                      |        expected `String`, found `i32`\n  |                                      expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp8RsetZ/main.rs:1:166\n  |\n1 | ...fn grade_letter (score : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i3...\n  |                                        ---                           ^^^ expected `i32`, found `&str`\n  |                                        |\n  |                                        expected `i32` because of return type\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp8RsetZ/main.rs:1:193\n  |\n1 | ...re >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } }...\n  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                      |        |\n  |                                      |        expected `String`, found `i32`\n  |                                      expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp8RsetZ/main.rs:1:203\n  |\n1 | ...ore : String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else ...\n  |                     --- expected `i32` because of return type                          ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp8RsetZ/main.rs:1:230\n  |\n1 | ...re >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn descri...\n  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                      |        |\n  |                                      |        expected `String`, found `i32`\n  |                                      expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp8RsetZ/main.rs:1:240\n  |\n1 | ...String) -> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if s...\n  |               --- expected `i32` because of return type                                                               ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp8RsetZ/main.rs:1:267\n  |\n1 | ...re >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } } } } } } } fn describe_number (n : i32) -> i32 { { { let ...\n  |                                      -----    ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                      |        |\n  |                                      |        expected `String`, found `i32`\n  |                                      expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp8RsetZ/main.rs:1:277\n  |\n1 | ...-> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } ...\n  |       --- expected `i32` because of return type                                                                                                    ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp8RsetZ/main.rs:1:294\n  |\n1 | ...-> i32 { { if score >= 90i32 { { \"A\" } } else { if score >= 80i32 { { \"B\" } } else { if score >= 70i32 { { \"C\" } } else { if score >= 60i32 { { \"D\" } } else { { \"F\" } ...\n  |       --- expected `i32` because of return type                                                                                                                     ^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp8RsetZ/main.rs:1:372\n  |\n1 | ...umber (n : i32) -> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"lar...\n  |                                                   ^^^^^^^^^^^ expected `bool`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp8RsetZ/main.rs:1:490\n  |\n1 | ...-> i32 { { { let even_odd = if is_even (n) { { \"even\" } } else { { \"odd\" } } ; { let mut size = if n > 100i32 { { \"large\" } } else { { \"small\" } } ; format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , n , \" is a \") + size , \" \") + even_odd , \" number\") } ...\n  |       --- expected `i32` because of return type                                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`\n  |\n  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp8RsetZ/main.rs:1:751\n  |\n1 | ...150i32)) ; println ! (\"{:?}\" , grade_letter (85i32)) } }\n  |                                   ------------  ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                   |             |\n  |                                   |             expected `String`, found `i32`\n  |                                   arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmp8RsetZ/main.rs:1:103\n  |\n1 | use std :: collections :: HashMap ; fn is_even (number : i32) -> i32 { { number % 2i32 == 0i32 } } fn grade_letter (score : String) -> i3...\n  |                                                                                                       ^^^^^^^^^^^^  --------------\n\nerror: aborting due to 13 previous errors; 13 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 7,
          "line_number": 243,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\nfun calculate_total(prices) {\n    let mut total = 0.0\n    let mut i = 0\n    while i < prices.len() {\n        total = total + prices[i]\n        i = i + 1\n    }\n    total\n}\n\nfun find_max(numbers) {\n    let mut max_val = numbers[0]\n    let mut i = 0\n    while i < numbers.len() {\n        if numbers[i] > max_val {\n            max_val = numbers[i]\n        }\n        i = i + 1\n    }\n    max_val\n}\n\nfun count_words(text) {\n    let words = text.split(\" \")\n    words.len()\n}\n\nfun main() {\n    // Real-world usage\n    let shopping_cart = [19.99, 5.50, 12.00, 8.75]\n    let test_scores = [85, 92, 78, 96, 88]\n    let essay = \"Functions make code reusable and testable\"\n\n    println(\"Total cost: $\", calculate_total(shopping_cart))\n    println(\"Highest score:\", find_max(test_scores))\n    println(\"Word count:\", count_words(essay))\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nerror: argument never used\n --> /tmp/.tmp4gp05s/main.rs:1:825\n  |\n1 | ...le\" . to_string () ; println ! (\"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"Highest score:\" , find_max (test_scor...\n  |                                    ---------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used\n  |                                    |\n  |                                    formatting specifier missing\n\nerror: argument never used\n --> /tmp/.tmp4gp05s/main.rs:1:890\n  |\n1 | ...total (shopping_cart)) ; println ! (\"Highest score:\" , find_max (test_scores)) ; println ! (\"Word count:\" , count_words (essay)) } } } }\n  |                                        ----------------   ^^^^^^^^^^^^^^^^^^^^^^ argument never used\n  |                                        |\n  |                                        formatting specifier missing\n\nerror: argument never used\n --> /tmp/.tmp4gp05s/main.rs:1:943\n  |\n1 | ..., find_max (test_scores)) ; println ! (\"Word count:\" , count_words (essay)) } } } }\n  |                                           -------------   ^^^^^^^^^^^^^^^^^^^ argument never used\n  |                                           |\n  |                                           formatting specifier missing\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp4gp05s/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < p...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4gp05s/main.rs:1:396\n  |\n1 | ... . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words...\n  |                                                      ^^                              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" . to_string () ; println ! (\"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"Highest score:\" , find_max (test_scores)) ; println ! (\"Word count:\" , count_words (essay)) } } } }\n1 + use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { max_val = numbers [i as usize] } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" . to_string () ; println ! (\"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"Highest score:\" , find_max (test_scores)) ; println ! (\"Word count:\" , count_words (essay)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4gp05s/main.rs:1:506\n  |\n1 | ...n count_words (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = ...\n  |                                           ^^                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" . to_string () ; println ! (\"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"Highest score:\" , find_max (test_scores)) ; println ! (\"Word count:\" , count_words (essay)) } } } }\n1 + use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { let words = text . split (\" \") ; words . len () } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" . to_string () ; println ! (\"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"Highest score:\" , find_max (test_scores)) ; println ! (\"Word count:\" , count_words (essay)) } } } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp4gp05s/main.rs:1:577\n  |\n1 | ... { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" . to_string () ; println ! (\"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"Highest score:\" , find_max (test_scores)) ; println ! (\"Word count:\" , count_words (essay)) } } } }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                                                                    ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" . to_string () ; println ! (\"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"Highest score:\" , find_max (test_scores)) ; println ! (\"Word count:\" , count_words (essay)) } } } }\n1 + use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" . to_string () ; println ! (\"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"Highest score:\" , find_max (test_scores)) ; println ! (\"Word count:\" , count_words (essay)) } } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp4gp05s/main.rs:1:137\n  |\n1 | ...t total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } f...\n  |                                              -   ^^^^^^^^^^^^^^^ expected `i32`, found `usize`\n  |                                              |\n  |                                              expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len ().try_into().unwrap() { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" . to_string () ; println ! (\"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"Highest score:\" , find_max (test_scores)) ; println ! (\"Word count:\" , count_words (essay)) } } } }\n  |                                                                                                                                                        ++++++++++++++++++++\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmp4gp05s/main.rs:1:181\n  |\n1 | ...rices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mu...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp4gp05s/main.rs:1:214\n  |\n1 | ...-> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } ...\n  |       --- expected `i32` because of return type                                                                                                ^^^^^ expected `i32`, found `f64`\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmp4gp05s/main.rs:1:293\n  |\n1 | ...ng) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] >...\n  |                                              ^^^^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp4gp05s/main.rs:1:339\n  |\n1 | ...0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize...\n  |                                              -   ^^^^^^^^^^^^^^^^ expected `i32`, found `usize`\n  |                                              |\n  |                                              expected because this is `i32`\n  |\nhelp: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\n  |\n1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < prices . len () { { total = total + prices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ; let mut i = 0i32 ; while i < numbers . len ().try_into().unwrap() { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5.5f64 , 12f64 , 8.75f64] ; { let mut test_scores = vec ! [85i32 , 92i32 , 78i32 , 96i32 , 88i32] ; let mut essay = \"Functions make code reusable and testable\" . to_string () ; println ! (\"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"Highest score:\" , find_max (test_scores)) ; println ! (\"Word count:\" , count_words (essay)) } } } }\n  |                                                                                                                                                                                                                                                                                                                                                                   ++++++++++++++++++++\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmp4gp05s/main.rs:1:372\n  |\n1 | ...while i < numbers . len () { { if numbers [i as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val }...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n --> /tmp/.tmp4gp05s/main.rs:1:417\n  |\n1 | ...as usize] > max_val { { max_val = numbers [i as usize] } } ; i = i + 1i32 } } ; max_val } } fn count_words (text : String) -> i32 { { ...\n  |                                               ^^^^^^^^^^ string indices are ranges of `usize`\n  |\n  = help: the trait `SliceIndex<str>` is not implemented for `usize`\n  = help: the following other types implement trait `SliceIndex<T>`:\n            `usize` implements `SliceIndex<ByteStr>`\n            `usize` implements `SliceIndex<[T]>`\n  = note: required for `String` to implement `Index<usize>`\n\nerror[E0599]: no method named `len` found for struct `std::str::Split` in the current scope\n    --> /tmp/.tmp4gp05s/main.rs:1:551\n     |\n1    | ... : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn main () { { { let shopping_cart = vec ! [19.99f64 , 5...\n     |                                                                     ^^^\n     |\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:3877:5\n     |\n3877 | /     fn le<I>(self, other: I) -> bool\n3878 | |     where\n3879 | |         I: IntoIterator,\n3880 | |         Self::Item: PartialOrd<I::Item>,\n3881 | |         Self: Sized,\n     | |____________________^\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp4gp05s/main.rs:1:842\n  |\n1 | ...() ; println ! (\"Total cost: $\" , calculate_total (shopping_cart)) ; println ! (\"Highest score:\" , find_max (test_scores)) ; println !...\n  |                                      ---------------  ^^^^^^^^^^^^^ expected `String`, found `Vec<f64>`\n  |                                      |\n  |                                      arguments to this function are incorrect\n  |\n  = note: expected struct `String`\n             found struct `Vec<f64>`\nnote: function defined here\n --> /tmp/.tmp4gp05s/main.rs:1:40\n  |\n1 | use std :: collections :: HashMap ; fn calculate_total (prices : String) -> i32 { { let mut total = 0f64 ; let mut i = 0i32 ; while i < p...\n  |                                        ^^^^^^^^^^^^^^^  ---------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp4gp05s/main.rs:1:900\n  |\n1 | ...art)) ; println ! (\"Highest score:\" , find_max (test_scores)) ; println ! (\"Word count:\" , count_words (essay)) } } } }\n  |                                          --------  ^^^^^^^^^^^ expected `String`, found `Vec<i32>`\n  |                                          |\n  |                                          arguments to this function are incorrect\n  |\n  = note: expected struct `String`\n             found struct `Vec<i32>`\nnote: function defined here\n --> /tmp/.tmp4gp05s/main.rs:1:227\n  |\n1 | ...rices [i as usize] ; i = i + 1i32 } } ; total } } fn find_max (numbers : String) -> i32 { { let mut max_val = numbers [0i32 as usize] ...\n  |                                                         ^^^^^^^^  ----------------\n\nerror: aborting due to 13 previous errors; 4 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: len()"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 8,
          "line_number": 294,
          "code": "// Status: ✅ WORKING\n// ❌ This returns nothing (unit type)\nfun bad_add(a, b) {\n    a + b;\n    // The semicolon makes this a statement, returns ()\n}\n\n// ✅ This returns the sum\nfun good_add(a, b) {\n    a + b  // No semicolon - this is an expression\n}\n\nfun main() {\n    println(good_add(2, 3))\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 9,
          "line_number": 319,
          "code": "// Status: ❌ BROKEN\nfun greet(name, age) {\n    \"Hi \" + name + \", you're \" + age + \" years old\"\n}\n\nfun main() {\n    // ❌ This won't work\n    let msg = greet(\"Alice\")  // Missing age parameter\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n --> /tmp/.tmpU9YHmN/main.rs:1:256\n  |\n1 | ...t msg = greet (\"Alice\" . to_string ()) } }\n  |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpU9YHmN/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpU9YHmN/main.rs:1:86\n  |\n1 | ...) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hi \" , name) , \", you're \") + age , \" years old\") } } fn main (...\n  |               ^^                                                                                                           ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hi \" , name) , \", you're \") + age , \" years old\") } } fn main () { { let msg = greet (\"Alice\" . to_string ()) } }\n1 + use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hi \" , name) , \", you're \") + age , \" years old\") } fn main () { { let msg = greet (\"Alice\" . to_string ()) } }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpU9YHmN/main.rs:1:176\n  |\n1 | ...ormat ! (\"{}{}\" , \"Hi \" , name) , \", you're \") + age , \" years old\") } } fn main () { { let msg = greet (\"Alice\" . to_string ()) } }\n  |                                                     ^^^ expected `&str`, found `String`\n  |\nhelp: consider borrowing here\n  |\n1 | use std :: collections :: HashMap ; fn greet (name : String , age : String) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hi \" , name) , \", you're \") + &age , \" years old\") } } fn main () { { let msg = greet (\"Alice\" . to_string ()) } }\n  |                                                                                                                                                                                +\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpU9YHmN/main.rs:1:88\n  |\n1 | ...ng) -> i32 { { format ! (\"{}{}\" , format ! (\"{}{}\" , format ! (\"{}{}\" , \"Hi \" , name) , \", you're \") + age , \" years old\") } } fn main...\n  |           ---     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `String`\n  |           |\n  |           expected `i32` because of return type\n  |\n  = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 10,
          "line_number": 340,
          "code": "// Status: ❌ BROKEN\n// ❌ Parameters are read-only\nfun bad_function(x) {\n    x = x + 1  \n    x\n}\n\n// ✅ Create new variables inside functions\nfun good_function(x) {\n    let result = x + 1\n    result\n}\n\nfun main() {\n    println(good_function(5))\n}\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "broken",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmpv7yv52/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { ...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpv7yv52/main.rs:1:134\n  |\n1 | ...i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { { println ! (\"{:?}\" , good_funct...\n  |                                                    ^^                                  ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { { println ! (\"{:?}\" , good_function (5i32)) } }\n1 + use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { let result = x + 1i32 ; result } } fn main () { { println ! (\"{:?}\" , good_function (5i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpv7yv52/main.rs:1:188\n  |\n1 | ...sult = x + 1i32 ; result } } } fn main () { { println ! (\"{:?}\" , good_function (5i32)) } }\n  |                                                ^^                                         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { { println ! (\"{:?}\" , good_function (5i32)) } }\n1 + use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { let result = x + 1i32 ; result } } } fn main () { println ! (\"{:?}\" , good_function (5i32)) }\n  |\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpv7yv52/main.rs:1:85\n  |\n1 | use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { ...\n  |                                                                                     ^^^^ expected `&str`, found `i32`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpv7yv52/main.rs:1:92\n  |\n1 | use std :: collections :: HashMap ; fn bad_function (x : String) -> i32 { { x = x + 1i32 ; x } } fn good_function (x : i32) -> i32 { { { ...\n  |                                                                     ---                    ^ expected `i32`, found `String`\n  |                                                                     |\n  |                                                                     expected `i32` because of return type\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 11,
          "line_number": 373,
          "code": "// Status: ✅ WORKING\nfun add(a, b) {\n    a + b\n}\n\nfun main() {\n    let result = add(10, 20)\n    println(result)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions.md",
          "example_number": 12,
          "line_number": 468,
          "code": "// Status: ⚠️ NOT IMPLEMENTED\n// Personal calculator\nfun celsius_to_fahrenheit(celsius) {\n    (celsius * 9 / 5) + 32\n}\n\nfun calculate_bmi(weight_kg, height_m) {\n    weight_kg / (height_m * height_m)\n}\n\nfun apply_discount(price, discount_percent) {\n    let discount = price * (discount_percent / 100)\n    price - discount\n}\n\n// Text tools\nfun word_count(text) {\n    let words = text.split(\" \")\n    words.len()\n}\n\nfun get_initials(full_name) {\n    let words = full_name.split(\" \")\n    let mut initials = \"\"\n    let mut i = 0\n    while i < words.len() {\n        let word = words[i]\n        initials = initials + word[0]\n        i = i + 1\n    }\n    initials\n}\n\n// Decision makers\nfun recommend_activity(energy_level, available_time) {\n    if energy_level > 7 && available_time > 60 {\n        \"Go for a run or hit the gym!\"\n    } else if energy_level > 5 && available_time > 30 {\n        \"Perfect time for a walk\"\n    } else {\n        \"Maybe just relax and read\"\n    }\n}\n\nfun main() {\n    // Test your functions!\n    println(celsius_to_fahrenheit(20))  // 68\n    println(calculate_bmi(70, 1.75))    // 22.86\n    println(get_initials(\"Alice Johnson\"))  // \"AJ\"\n    println(recommend_activity(8, 45))\n}\n\n\n\n\n\n// Error: ✗ Compilation failed: Compilation failed:",
          "passed": false,
          "status": "not_implemented",
          "error": "✗ Compilation failed: Compilation failed:\nwarning: unused import: `std :: collections :: HashMap`\n --> /tmp/.tmp7jhVoM/main.rs:1:5\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bm...\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7jhVoM/main.rs:1:87\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bm...\n  |                                                                                       ^^                             ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { celsius * 9i32 / 5i32 + 32i32 } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7jhVoM/main.rs:1:184\n  |\n1 | ..._bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_perce...\n  |                                                     ^^                               ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { weight_kg / height_m * height_m } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7jhVoM/main.rs:1:288\n  |\n1 | ...ount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : Strin...\n  |                                 ^^                                                                       ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { let discount = price * discount_percent / 100i32 ; price - discount } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7jhVoM/main.rs:1:405\n  |\n1 | ...fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) ...\n  |                                           ^^                                                   ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { let words = text . split (\" \") ; words . len () } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7jhVoM/main.rs:1:509\n  |\n1 | ... { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } ...\n  |       ^^                                                                                                                                                                                                                                                     ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7jhVoM/main.rs:1:638\n  |\n1 | ...ords . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } }...\n  |                    ^^                                                                                                 ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7jhVoM/main.rs:1:842\n  |\n1 | ... { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } ...\n  |       ^^                                                                                                                                                                                                                            ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7jhVoM/main.rs:1:895\n  |\n1 | ...f energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time...\n  |                                                      ^^                              ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { \"Go for a run or hit the gym!\" } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7jhVoM/main.rs:1:990\n  |\n1 | ... if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn ...\n  |                                                        ^^                         ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { \"Perfect time for a walk\" } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp7jhVoM/main.rs:1:1029\n  |\n1 | ...e > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_...\n  |                                                       ^^                           ^^\n  |\nhelp: remove these braces\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { \"Maybe just relax and read\" } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nerror[E0599]: no method named `len` found for struct `std::str::Split` in the current scope\n    --> /tmp/.tmp7jhVoM/main.rs:1:450\n     |\n1    | ... : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let wo...\n     |                                                                     ^^^\n     |\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:3877:5\n     |\n3877 | /     fn le<I>(self, other: I) -> bool\n3878 | |     where\n3879 | |         I: IntoIterator,\n3880 | |         Self::Item: PartialOrd<I::Item>,\n3881 | |         Self: Sized,\n     | |____________________^\n\nerror[E0599]: no method named `len` found for struct `std::str::Split` in the current scope\n    --> /tmp/.tmp7jhVoM/main.rs:1:629\n     |\n1    | ...tials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + ...\n     |                                                                     ^^^\n     |\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/noah/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:3877:5\n     |\n3877 | /     fn le<I>(self, other: I) -> bool\n3878 | |     where\n3879 | |         I: IntoIterator,\n3880 | |         Self::Item: PartialOrd<I::Item>,\n3881 | |         Self: Sized,\n     | |____________________^\n\nerror[E0608]: cannot index into a value of type `std::str::Split<'_, &str>`\n --> /tmp/.tmp7jhVoM/main.rs:1:659\n  |\n1 | ...t i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i3...\n  |                                                                 ^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7jhVoM/main.rs:1:744\n  |\n1 | ...-> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } ...\n  |       --- expected `i32` because of return type                                                                                                                                                                                                        ^^^^^^^^ expected `i32`, found `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7jhVoM/main.rs:1:862\n  |\n1 | ...e_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_l...\n  |                                   ------------   ^^^^- help: try using a conversion method: `.to_string()`\n  |                                   |              |\n  |                                   |              expected `String`, found `i32`\n  |                                   expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7jhVoM/main.rs:1:887\n  |\n1 | ...{ { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available...\n  |                                  --------------   ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                  |                |\n  |                                  |                expected `String`, found `i32`\n  |                                  expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7jhVoM/main.rs:1:897\n  |\n1 | ...ng) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 &...\n  |           --- expected `i32` because of return type                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7jhVoM/main.rs:1:957\n  |\n1 | ...or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just re...\n  |                                   ------------   ^^^^- help: try using a conversion method: `.to_string()`\n  |                                   |              |\n  |                                   |              expected `String`, found `i32`\n  |                                   expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7jhVoM/main.rs:1:982\n  |\n1 | ...e { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } ...\n  |                                  --------------   ^^^^^- help: try using a conversion method: `.to_string()`\n  |                                  |                |\n  |                                  |                expected `String`, found `i32`\n  |                                  expected because this is `String`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7jhVoM/main.rs:1:992\n  |\n1 | ...-> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } ...\n  |       --- expected `i32` because of return type                                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7jhVoM/main.rs:1:1031\n  |\n1 | ...-> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } ...\n  |       --- expected `i32` because of return type                                                                                                                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nerror[E0308]: mismatched types\n --> /tmp/.tmp7jhVoM/main.rs:1:1180\n  |\n1 | ...enheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string...\n  |                                          -------------          ^^^^^^^ expected `i32`, found `f64`\n  |                                          |\n  |                                          arguments to this function are incorrect\n  |\nnote: function defined here\n --> /tmp/.tmp7jhVoM/main.rs:1:126\n  |\n1 | ...2 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m...\n  |                                               ^^^^^^^^^^^^^                    --------------\nhelp: change the type of the numeric literal from `f64` to `i32`\n  |\n1 - use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n1 + use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1i32)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |\n\nerror[E0308]: arguments to this function are incorrect\n --> /tmp/.tmp7jhVoM/main.rs:1:1281\n  |\n1 | ..._string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32)) } }\n  |                                       ^^^^^^^^^^^^^^^^^^  ----   ----- expected `String`, found `i32`\n  |                                                           |\n  |                                                           expected `String`, found `i32`\n  |\nnote: function defined here\n --> /tmp/.tmp7jhVoM/main.rs:1:764\n  |\n1 | ...32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i3...\n  |                                     ^^^^^^^^^^^^^^^^^^  ---------------------   -----------------------\nhelp: try using a conversion method\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32.to_string() , 45i32)) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ++++++++++++\nhelp: try using a conversion method\n  |\n1 | use std :: collections :: HashMap ; fn celsius_to_fahrenheit (celsius : i32) -> i32 { { celsius * 9i32 / 5i32 + 32i32 } } fn calculate_bmi (weight_kg : i32 , height_m : i32) -> i32 { { weight_kg / height_m * height_m } } fn apply_discount (price : i32 , discount_percent : i32) -> i32 { { { let discount = price * discount_percent / 100i32 ; price - discount } } } fn word_count (text : String) -> i32 { { { let words = text . split (\" \") ; words . len () } } } fn get_initials (full_name : String) -> i32 { { { let words = full_name . split (\" \") ; { let mut initials = \"\" . to_string () ; let mut i = 0i32 ; while i < words . len () { { { let word = words [i as usize] ; { initials = initials + word [0i32 as usize] ; i = i + 1i32 } } } } ; initials } } } } fn recommend_activity (energy_level : String , available_time : String) -> i32 { { if energy_level > 7i32 && available_time > 60i32 { { \"Go for a run or hit the gym!\" } } else { if energy_level > 5i32 && available_time > 30i32 { { \"Perfect time for a walk\" } } else { { \"Maybe just relax and read\" } } } } } fn main () { { println ! (\"{:?}\" , celsius_to_fahrenheit (20i32)) ; println ! (\"{:?}\" , calculate_bmi (70i32 , 1.75f64)) ; println ! (\"{:?}\" , get_initials (\"Alice Johnson\" . to_string ())) ; println ! (\"{:?}\" , recommend_activity (8i32 , 45i32.to_string())) } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ++++++++++++\n\nerror: aborting due to 13 previous errors; 11 warnings emitted\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "METHOD_ERROR",
          "rootCause": "Missing method implementation: len()"
        }
      ]
    },
    "ch01-02-hello-world-tdd": {
      "chapter": "ch01-02-hello-world-tdd",
      "total_examples": 6,
      "working_examples": 6,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 2,
          "line_number": 55,
          "code": "// Status: ✅ WORKING\nfun main() {\n    println(\"Hello,\");\n    println(\"World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 3,
          "line_number": 75,
          "code": "// Status: ✅ WORKING\nfun main() {\n    let greeting = \"Hello, World!\";\n    println(greeting);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 4,
          "line_number": 124,
          "code": "// Status: ✅ WORKING\nprintln(\"Your message here\");",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 5,
          "line_number": 132,
          "code": "// Status: ✅ WORKING\nlet message = \"Your message\";\nprintln(message);",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 6,
          "line_number": 141,
          "code": "// Status: ✅ WORKING\nprintln(\"First line\");\nprintln(\"Second line\");",
          "passed": true,
          "status": "working"
        }
      ]
    }
  }
}