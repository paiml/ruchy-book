{
  "timestamp": "2025-09-28T14:12:29.551Z",
  "ruchy_version": "ruchy 3.52.0",
  "chapters_processed": 15,
  "examples_found": 111,
  "examples_working": 86,
  "examples_failing": 25,
  "success_rate": 77,
  "chapters": {
    "ch21-00-professional-tooling-tdd": {
      "chapter": "ch21-00-professional-tooling-tdd",
      "total_examples": 1,
      "working_examples": 1,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch21-00-professional-tooling-tdd.md",
          "example_number": 1,
          "line_number": 23,
          "code": "// test/tooling/simple_test.ruchy - âœ“ VERIFIED WORKING\nfun add(a: i32, b: i32) -> i32 {\n    a + b\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch16-00-testing-quality-assurance": {
      "chapter": "ch16-00-testing-quality-assurance",
      "total_examples": 8,
      "working_examples": 5,
      "failing_examples": 3,
      "examples": [
        {
          "file": "src/ch16-00-testing-quality-assurance.md",
          "example_number": 1,
          "line_number": 9,
          "code": "fun add_numbers(a: i32, b: i32) -> i32 {\n    a + b\n}\n\nfun main() {\n    // Basic functionality test\n    let result = add_numbers(5, 3);\n    assert_eq(result, 8, \"Addition should work correctly\");\n    \n    println(\"âœ… All tests passed!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch16-00-testing-quality-assurance.md",
          "example_number": 2,
          "line_number": 48,
          "code": "fun factorial(n: i32) -> i32 {\n    if n <= 1 {\n        1\n    } else {\n        n * factorial(n - 1)\n    }\n}\n\nfun test_factorial_base_cases() {\n    assert_eq(factorial(0), 1, \"0! should equal 1\");\n    assert_eq(factorial(1), 1, \"1! should equal 1\");\n    println(\"âœ… Base cases pass\");\n}\n\nfun test_factorial_recursive_cases() {\n    assert_eq(factorial(3), 6, \"3! should equal 6\");\n    assert_eq(factorial(4), 24, \"4! should equal 24\");\n    assert_eq(factorial(5), 120, \"5! should equal 120\");\n    println(\"âœ… Recursive cases pass\");\n}\n\nfun main() {\n    test_factorial_base_cases();\n    test_factorial_recursive_cases();\n    println(\"ðŸŽ‰ All factorial tests passed!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch16-00-testing-quality-assurance.md",
          "example_number": 3,
          "line_number": 78,
          "code": "fun safe_divide(a: i32, b: i32) -> i32 {\n    if b == 0 {\n        println(\"Error: Division by zero\");\n        return 0;\n    }\n    a / b\n}\n\nfun test_division_normal_cases() {\n    assert_eq(safe_divide(10, 2), 5, \"Normal division should work\");\n    assert_eq(safe_divide(15, 3), 5, \"Another normal case\");\n    println(\"âœ… Normal division tests pass\");\n}\n\nfun test_division_error_cases() {\n    // Test division by zero handling\n    let result = safe_divide(10, 0);\n    assert_eq(result, 0, \"Division by zero should return 0\");\n    println(\"âœ… Error handling tests pass\");\n}\n\nfun main() {\n    test_division_normal_cases();\n    test_division_error_cases();\n    println(\"ðŸŽ‰ All division tests passed!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch16-00-testing-quality-assurance.md",
          "example_number": 4,
          "line_number": 108,
          "code": "fun absolute_value(x: i32) -> i32 {\n    if x < 0 {\n        -x\n    } else {\n        x\n    }\n}\n\nfun test_absolute_value_properties() {\n    // Property: abs(x) >= 0 for all x\n    let test_values = [5, -3, 0, 100, -50];\n    let mut i = 0;\n    \n    while i < 5 {\n        let x = test_values[i];\n        let abs_x = absolute_value(x);\n        \n        // Property 1: Result is always non-negative\n        assert(abs_x >= 0, \"Absolute value must be non-negative\");\n        \n        // Property 2: abs(abs(x)) == abs(x) (idempotent)\n        assert_eq(absolute_value(abs_x), abs_x, \"Absolute value should be idempotent\");\n        \n        i = i + 1;\n    }\n    \n    println(\"âœ… Property tests pass\");\n}\n\nfun main() {\n    test_absolute_value_properties();\n    println(\"ðŸŽ‰ All property tests passed!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch16-00-testing-quality-assurance.md",
          "example_number": 5,
          "line_number": 230,
          "code": "// File: calculator_test.ruchy\nfun test_addition() {\n    assert_eq(add(2, 3), 5, \"Basic addition\");\n    assert_eq(add(-1, 1), 0, \"Adding negative numbers\");\n    assert_eq(add(0, 0), 0, \"Adding zeros\");\n    println(\"âœ… Addition tests pass\");\n}\n\nfun test_multiplication() {\n    assert_eq(multiply(3, 4), 12, \"Basic multiplication\");\n    assert_eq(multiply(-2, 3), -6, \"Negative multiplication\");\n    assert_eq(multiply(0, 100), 0, \"Multiply by zero\");\n    println(\"âœ… Multiplication tests pass\");\n}\n\nfun run_all_tests() {\n    test_addition();\n    test_multiplication();\n    println(\"ðŸŽ‰ Calculator test suite complete!\");\n}\n\nfun main() {\n    run_all_tests();\n}",
          "passed": false,
          "status": "broken",
          "error": "DEBUG: transpile_function called for function: test_addition\nDEBUG: transpile_function called for function: test_multiplication\nDEBUG: transpile_function called for function: run_all_tests\nDEBUG: transpile_function called for function: main\nâœ— Compilation failed: Compilation failed:\nerror[E0425]: cannot find function `add` in this scope\n --> /tmp/.tmpJDg1UB/main.rs:1:36\n  |\n1 | fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative ...\n  |                                    ^^^ not found in this scope\n  |\nhelp: use the `.` operator to call the method `Add::add` on `{integer}`\n  |\n1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"âœ… Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"âœ… Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"ðŸŽ‰ Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n1 + fn test_addition () { assert_eq ! (2.add(3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"âœ… Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"âœ… Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"ðŸŽ‰ Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n  |\n\nerror[E0425]: cannot find function `add` in this scope\n --> /tmp/.tmpJDg1UB/main.rs:1:94\n  |\n1 | fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative ...\n  |                                                                                              ^^^ not found in this scope\n  |\nhelp: use the `.` operator to call the method `Add::add` on `{integer}`\n  |\n1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"âœ… Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"âœ… Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"ðŸŽ‰ Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n1 + fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! ((- 1).add(1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"âœ… Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"âœ… Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"ðŸŽ‰ Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n  |\n\nerror[E0425]: cannot find function `add` in this scope\n --> /tmp/.tmpJDg1UB/main.rs:1:163\n  |\n1 | ...0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"âœ… Addition tests pass\") ; }...\n  |                                                         ^^^ not found in this scope\n  |\nhelp: use the `.` operator to call the method `Add::add` on `{integer}`\n  |\n1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"âœ… Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"âœ… Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"ðŸŽ‰ Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n1 + fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (0.add(0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"âœ… Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"âœ… Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"ðŸŽ‰ Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n  |\n\nerror[E0425]: cannot find function `multiply` in this scope\n --> /tmp/.tmpJDg1UB/main.rs:1:287\n  |\n1 | ...ass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `multiply` in this scope\n --> /tmp/.tmpJDg1UB/main.rs:1:357\n  |\n1 | ...12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multipl...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `multiply` in this scope\n --> /tmp/.tmpJDg1UB/main.rs:1:433\n  |\n1 | ..., \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"âœ… Multiplication t...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n\nError: Compilation failed:\nerror[E0425]: cannot find function `add` in this scope\n --> /tmp/.tmpJDg1UB/main.rs:1:36\n  |\n1 | fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative ...\n  |                                    ^^^ not found in this scope\n  |\nhelp: use the `.` operator to call the method `Add::add` on `{integer}`\n  |\n1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"âœ… Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"âœ… Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"ðŸŽ‰ Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n1 + fn test_addition () { assert_eq ! (2.add(3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"âœ… Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"âœ… Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"ðŸŽ‰ Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n  |\n\nerror[E0425]: cannot find function `add` in this scope\n --> /tmp/.tmpJDg1UB/main.rs:1:94\n  |\n1 | fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative ...\n  |                                                                                              ^^^ not found in this scope\n  |\nhelp: use the `.` operator to call the method `Add::add` on `{integer}`\n  |\n1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"âœ… Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"âœ… Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"ðŸŽ‰ Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n1 + fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! ((- 1).add(1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"âœ… Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"âœ… Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"ðŸŽ‰ Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n  |\n\nerror[E0425]: cannot find function `add` in this scope\n --> /tmp/.tmpJDg1UB/main.rs:1:163\n  |\n1 | ...0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"âœ… Addition tests pass\") ; }...\n  |                                                         ^^^ not found in this scope\n  |\nhelp: use the `.` operator to call the method `Add::add` on `{integer}`\n  |\n1 - fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (add (0 , 0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"âœ… Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"âœ… Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"ðŸŽ‰ Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n1 + fn test_addition () { assert_eq ! (add (2 , 3) , 5 , \"{}\" , \"Basic addition\") ; assert_eq ! (add (- 1 , 1) , 0 , \"{}\" , \"Adding negative numbers\") ; assert_eq ! (0.add(0) , 0 , \"{}\" , \"Adding zeros\") ; println ! (\"âœ… Addition tests pass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"âœ… Multiplication tests pass\") ; } fn run_all_tests () { test_addition () ; test_multiplication () ; println ! (\"ðŸŽ‰ Calculator test suite complete!\") ; } fn main () { run_all_tests () }\n  |\n\nerror[E0425]: cannot find function `multiply` in this scope\n --> /tmp/.tmpJDg1UB/main.rs:1:287\n  |\n1 | ...ass\") ; } fn test_multiplication () { assert_eq ! (multiply (3 , 4) , 12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `multiply` in this scope\n --> /tmp/.tmpJDg1UB/main.rs:1:357\n  |\n1 | ...12 , \"{}\" , \"Basic multiplication\") ; assert_eq ! (multiply (- 2 , 3) , - 6 , \"{}\" , \"Negative multiplication\") ; assert_eq ! (multipl...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `multiply` in this scope\n --> /tmp/.tmpJDg1UB/main.rs:1:433\n  |\n1 | ..., \"{}\" , \"Negative multiplication\") ; assert_eq ! (multiply (0 , 100) , 0 , \"{}\" , \"Multiply by zero\") ; println ! (\"âœ… Multiplication t...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality-assurance.md",
          "example_number": 6,
          "line_number": 258,
          "code": "fun fibonacci(n: i32) -> i32 {\n    if n <= 1 {\n        n\n    } else {\n        fibonacci(n - 1) + fibonacci(n - 2)\n    }\n}\n\nfun test_fibonacci_performance() {\n    // Test reasonable performance expectations\n    let start_time = get_time_ms(); // Placeholder - actual timing would need stdlib\n    let result = fibonacci(20);\n    let end_time = get_time_ms();\n    \n    assert_eq(result, 6765, \"Fibonacci(20) should equal 6765\");\n    \n    // Performance assertion (conceptual)\n    let duration = end_time - start_time;\n    assert(duration < 1000, \"Fibonacci(20) should complete within 1 second\");\n    \n    println(\"âœ… Performance test passes\");\n}\n\nfun main() {\n    test_fibonacci_performance();\n}",
          "passed": false,
          "status": "broken",
          "error": "DEBUG: transpile_function called for function: fibonacci\nDEBUG: transpile_function called for function: test_fibonacci_performance\nDEBUG: transpile_function called for function: main\nâœ— Compilation failed: Compilation failed:\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpYvBuqI/main.rs:1:201\n  |\n1 | ... = get_time_ms () ; { let result = fibonacci (20) ; ; let end_time = get_time_ms () ; ; assert_eq ! (result , 6765 , \"{}\" , \"Fibonacci...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpYvBuqI/main.rs:1:235\n  |\n1 | ... fibonacci (20) ; ; let end_time = get_time_ms () ; ; assert_eq ! (result , 6765 , \"{}\" , \"Fibonacci(20) should equal 6765\") ; let dur...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpYvBuqI/main.rs:1:349\n  |\n1 | ...ual 6765\") ; let duration = end_time - start_time ; ; assert ! (duration < 1000 , \"{}\" , \"Fibonacci(20) should complete within 1 secon...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `get_time_ms` in this scope\n --> /tmp/.tmpYvBuqI/main.rs:1:152\n  |\n1 | ...st_fibonacci_performance () { { let start_time = get_time_ms () ; { let result = fibonacci (20) ; ; let end_time = get_time_ms () ; ; ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `get_time_ms` in this scope\n --> /tmp/.tmpYvBuqI/main.rs:1:218\n  |\n1 | ...{ let result = fibonacci (20) ; ; let end_time = get_time_ms () ; ; assert_eq ! (result , 6765 , \"{}\" , \"Fibonacci(20) should equal 67...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\nError: Compilation failed:\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpYvBuqI/main.rs:1:201\n  |\n1 | ... = get_time_ms () ; { let result = fibonacci (20) ; ; let end_time = get_time_ms () ; ; assert_eq ! (result , 6765 , \"{}\" , \"Fibonacci...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpYvBuqI/main.rs:1:235\n  |\n1 | ... fibonacci (20) ; ; let end_time = get_time_ms () ; ; assert_eq ! (result , 6765 , \"{}\" , \"Fibonacci(20) should equal 6765\") ; let dur...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpYvBuqI/main.rs:1:349\n  |\n1 | ...ual 6765\") ; let duration = end_time - start_time ; ; assert ! (duration < 1000 , \"{}\" , \"Fibonacci(20) should complete within 1 secon...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `get_time_ms` in this scope\n --> /tmp/.tmpYvBuqI/main.rs:1:152\n  |\n1 | ...st_fibonacci_performance () { { let start_time = get_time_ms () ; { let result = fibonacci (20) ; ; let end_time = get_time_ms () ; ; ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `get_time_ms` in this scope\n --> /tmp/.tmpYvBuqI/main.rs:1:218\n  |\n1 | ...{ let result = fibonacci (20) ; ; let end_time = get_time_ms () ; ; assert_eq ! (result , 6765 , \"{}\" , \"Fibonacci(20) should equal 67...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality-assurance.md",
          "example_number": 7,
          "line_number": 352,
          "code": "// Clear, specific assertions\nassert_eq(actual, expected, \"Descriptive failure message\");\n\n// Boolean assertions with context\nassert(condition, \"Explain why this should be true\");\n\n// Multiple related assertions\nfun test_range_function() {\n    let result = create_range(1, 5);\n    assert_eq(len(result), 4, \"Range should have 4 elements\");\n    assert_eq(result[0], 1, \"First element should be 1\");  \n    assert_eq(result[3], 4, \"Last element should be 4\");\n}",
          "passed": false,
          "status": "broken",
          "error": "DEBUG: transpile_function called for function: test_range_function\nâœ— Compilation failed: Compilation failed:\nerror[E0425]: cannot find value `actual` in this scope\n --> /tmp/.tmpjBV1I1/main.rs:1:325\n  |\n1 | ...ement should be 4\") } } } fn main () { assert_eq ! (actual , expected , \"{}\" , \"Descriptive failure message\") ; assert ! (condition , ...\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `expected` in this scope\n --> /tmp/.tmpjBV1I1/main.rs:1:334\n  |\n1 | ...ld be 4\") } } } fn main () { assert_eq ! (actual , expected , \"{}\" , \"Descriptive failure message\") ; assert ! (condition , \"{}\" , \"Ex...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `condition` in this scope\n --> /tmp/.tmpjBV1I1/main.rs:1:395\n  |\n1 | ...\"{}\" , \"Descriptive failure message\") ; assert ! (condition , \"{}\" , \"Explain why this should be true\") ; }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `create_range` in this scope\n --> /tmp/.tmpjBV1I1/main.rs:1:44\n  |\n1 | fn test_range_function () { { let result = create_range (1 , 5) ; { assert_eq ! (len (result) , 4 , \"{}\" , \"Range should have 4 elements\"...\n  |                                            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n --> /tmp/.tmpjBV1I1/main.rs:1:82\n  |\n1 | fn test_range_function () { { let result = create_range (1 , 5) ; { assert_eq ! (len (result) , 4 , \"{}\" , \"Range should have 4 elements\"...\n  |                                                                                  ^^^ not found in this scope\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n\nError: Compilation failed:\nerror[E0425]: cannot find value `actual` in this scope\n --> /tmp/.tmpjBV1I1/main.rs:1:325\n  |\n1 | ...ement should be 4\") } } } fn main () { assert_eq ! (actual , expected , \"{}\" , \"Descriptive failure message\") ; assert ! (condition , ...\n  |                                                        ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `expected` in this scope\n --> /tmp/.tmpjBV1I1/main.rs:1:334\n  |\n1 | ...ld be 4\") } } } fn main () { assert_eq ! (actual , expected , \"{}\" , \"Descriptive failure message\") ; assert ! (condition , \"{}\" , \"Ex...\n  |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `condition` in this scope\n --> /tmp/.tmpjBV1I1/main.rs:1:395\n  |\n1 | ...\"{}\" , \"Descriptive failure message\") ; assert ! (condition , \"{}\" , \"Explain why this should be true\") ; }\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `create_range` in this scope\n --> /tmp/.tmpjBV1I1/main.rs:1:44\n  |\n1 | fn test_range_function () { { let result = create_range (1 , 5) ; { assert_eq ! (len (result) , 4 , \"{}\" , \"Range should have 4 elements\"...\n  |                                            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n --> /tmp/.tmpjBV1I1/main.rs:1:82\n  |\n1 | fn test_range_function () { { let result = create_range (1 , 5) ; { assert_eq ! (len (result) , 4 , \"{}\" , \"Range should have 4 elements\"...\n  |                                                                                  ^^^ not found in this scope\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch16-00-testing-quality-assurance.md",
          "example_number": 8,
          "line_number": 377,
          "code": "fun gcd(a: i32, b: i32) -> i32 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\n// Property: gcd(a, b) divides both a and b\nfun test_gcd_properties() {\n    let a = 48;\n    let b = 18;\n    let result = gcd(a, b);\n    \n    // Property verification\n    assert_eq(a % result, 0, \"GCD should divide first number\");\n    assert_eq(b % result, 0, \"GCD should divide second number\");\n    assert_eq(result, 6, \"GCD(48, 18) should equal 6\");\n    \n    println(\"âœ… GCD properties verified\");\n}\n\nfun main() {\n    test_gcd_properties();\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch15-00-binary-compilation-deployment": {
      "chapter": "ch15-00-binary-compilation-deployment",
      "total_examples": 4,
      "working_examples": 1,
      "failing_examples": 3,
      "examples": [
        {
          "file": "src/ch15-00-binary-compilation-deployment.md",
          "example_number": 1,
          "line_number": 9,
          "code": "fun main() {\n    println(\"Hello from compiled Ruchy!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch15-00-binary-compilation-deployment.md",
          "example_number": 2,
          "line_number": 44,
          "code": "fun main() {\n    let args = std::env::args();\n    \n    if args.len() < 2 {\n        println(\"Usage: calculator <expression>\");\n        return;\n    }\n    \n    let expr = args[1];\n    let result = evaluate_expression(expr);\n    println(\"Result: {}\", result);\n}\n\nfun evaluate_expression(expr: String) -> f64 {\n    // Simple calculator - supports +, -, *, /\n    if expr.contains('+') {\n        let parts = expr.split('+');\n        return parts[0].parse::<f64>() + parts[1].parse::<f64>();\n    } else if expr.contains('-') {\n        let parts = expr.split('-');\n        return parts[0].parse::<f64>() - parts[1].parse::<f64>();\n    } else if expr.contains('*') {\n        let parts = expr.split('*');\n        return parts[0].parse::<f64>() * parts[1].parse::<f64>();\n    } else if expr.contains('/') {\n        let parts = expr.split('/');\n        let divisor = parts[1].parse::<f64>();\n        if divisor != 0.0 {\n            return parts[0].parse::<f64>() / divisor;\n        }\n    }\n    \n    expr.parse::<f64>()\n}",
          "passed": false,
          "status": "broken",
          "error": "âœ— Compilation failed: Failed to parse Ruchy source\nError: Failed to parse Ruchy source\n\nCaused by:\n    Expected RightBrace, found If\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-binary-compilation-deployment.md",
          "example_number": 3,
          "line_number": 90,
          "code": "fun main() {\n    let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    \n    let sum = calculate_sum(&data);\n    let avg = calculate_average(&data);\n    let max = find_maximum(&data);\n    \n    println(\"Data Analysis Results:\");\n    println(\"Sum: {}\", sum);\n    println(\"Average: {:.2}\", avg);\n    println(\"Maximum: {}\", max);\n}\n\nfun calculate_sum(data: &Vec<i32>) -> i32 {\n    let mut total = 0;\n    let mut i = 0;\n    while i < data.len() {\n        total = total + data[i];\n        i = i + 1;\n    }\n    total\n}\n\nfun calculate_average(data: &Vec<i32>) -> f64 {\n    let sum = calculate_sum(data);\n    (sum as f64) / (data.len() as f64)\n}\n\nfun find_maximum(data: &Vec<i32>) -> i32 {\n    let mut max = data[0];\n    let mut i = 1;\n    while i < data.len() {\n        if data[i] > max {\n            max = data[i];\n        }\n        i = i + 1;\n    }\n    max\n}",
          "passed": false,
          "status": "broken",
          "error": "âœ— Compilation failed: Failed to parse Ruchy source\nError: Failed to parse Ruchy source\n\nCaused by:\n    Expected RightBrace, found Let\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch15-00-binary-compilation-deployment.md",
          "example_number": 4,
          "line_number": 142,
          "code": "fun main() {\n    println(\"Mathematical Functions Demo\");\n    \n    let n = 10;\n    println(\"Factorial of {}: {}\", n, factorial(n));\n    \n    let x = 25;\n    println(\"Square root of {}: {}\", x, integer_sqrt(x));\n    \n    let a = 48;\n    let b = 18;\n    println(\"GCD of {} and {}: {}\", a, b, gcd(a, b));\n}\n\nfun factorial(n: i32) -> i64 {\n    if n <= 1 {\n        1\n    } else {\n        (n as i64) * factorial(n - 1)\n    }\n}\n\nfun integer_sqrt(n: i32) -> i32 {\n    if n < 2 {\n        return n;\n    }\n    \n    let mut x = n / 2;\n    let mut prev = 0;\n    \n    while x != prev {\n        prev = x;\n        x = (x + n / x) / 2;\n    }\n    \n    x\n}\n\nfun gcd(mut a: i32, mut b: i32) -> i32 {\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a\n}",
          "passed": false,
          "status": "broken",
          "error": "DEBUG: transpile_function called for function: factorial\nDEBUG: transpile_function called for function: integer_sqrt\nDEBUG: transpile_function called for function: gcd\nDEBUG: transpile_function called for function: main\nâœ— Compilation failed: Compilation failed:\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpG2F56E/main.rs:1:170\n  |\n1 | ...> i32 { if n < 2 { return n } ; let mut x = n / 2 ; ; let mut prev = 0 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x ...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpG2F56E/main.rs:1:191\n  |\n1 | ...turn n } ; let mut x = n / 2 ; ; let mut prev = 0 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , b...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpG2F56E/main.rs:1:305\n  |\n1 | ...a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematic...\n  |                                               ^^                                           ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; ; let mut prev = 0 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n = 10 ; { println ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let x = 25 ; ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let a = 48 ; ; let b = 18 ; ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } ; }\n1 + fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; ; let mut prev = 0 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0 { { let temp = b ; { b = a % b ; a = temp } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n = 10 ; { println ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let x = 25 ; ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let a = 48 ; ; let b = 18 ; ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpG2F56E/main.rs:1:504\n  |\n1 | ...rial of {}: {}\" , n , factorial (n)) ; let x = 25 ; ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let a = 48 ; ; let ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpG2F56E/main.rs:1:580\n  |\n1 | ...t of {}: {}\" , x , integer_sqrt (x)) ; let a = 48 ; ; let b = 18 ; ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } ; }\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpG2F56E/main.rs:1:595\n  |\n1 | ...x , integer_sqrt (x)) ; let a = 48 ; ; let b = 18 ; ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } ; }\n  |                                                        ^ help: remove this semicolon\n\nerror[E0384]: cannot assign to immutable argument `b`\n --> /tmp/.tmpG2F56E/main.rs:1:326\n  |\n1 | ...> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ...\n  |                                                ^^^^^^^^^ cannot assign to immutable argument\n  |\nhelp: consider making this binding mutable\n  |\n1 | fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; ; let mut prev = 0 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , mut b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n = 10 ; { println ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let x = 25 ; ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let a = 48 ; ; let b = 18 ; ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } ; }\n  |                                                                                                                                                                                                                                                                                +++\n\nerror[E0384]: cannot assign to immutable argument `a`\n --> /tmp/.tmpG2F56E/main.rs:1:338\n  |\n1 | ...le b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n =...\n  |                                                 ^^^^^^^^ cannot assign to immutable argument\n  |\nhelp: consider making this binding mutable\n  |\n1 | fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; ; let mut prev = 0 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (mut a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n = 10 ; { println ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let x = 25 ; ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let a = 48 ; ; let b = 18 ; ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } ; }\n  |                                                                                                                                                                                                                                                                      +++\n\nerror: aborting due to 2 previous errors; 6 warnings emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n\nError: Compilation failed:\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpG2F56E/main.rs:1:170\n  |\n1 | ...> i32 { if n < 2 { return n } ; let mut x = n / 2 ; ; let mut prev = 0 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x ...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpG2F56E/main.rs:1:191\n  |\n1 | ...turn n } ; let mut x = n / 2 ; ; let mut prev = 0 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , b...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpG2F56E/main.rs:1:305\n  |\n1 | ...a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematic...\n  |                                               ^^                                           ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; ; let mut prev = 0 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n = 10 ; { println ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let x = 25 ; ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let a = 48 ; ; let b = 18 ; ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } ; }\n1 + fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; ; let mut prev = 0 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , b : i32) -> i32 { while b != 0 { { let temp = b ; { b = a % b ; a = temp } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n = 10 ; { println ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let x = 25 ; ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let a = 48 ; ; let b = 18 ; ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } ; }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpG2F56E/main.rs:1:504\n  |\n1 | ...rial of {}: {}\" , n , factorial (n)) ; let x = 25 ; ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let a = 48 ; ; let ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpG2F56E/main.rs:1:580\n  |\n1 | ...t of {}: {}\" , x , integer_sqrt (x)) ; let a = 48 ; ; let b = 18 ; ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } ; }\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpG2F56E/main.rs:1:595\n  |\n1 | ...x , integer_sqrt (x)) ; let a = 48 ; ; let b = 18 ; ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } ; }\n  |                                                        ^ help: remove this semicolon\n\nerror[E0384]: cannot assign to immutable argument `b`\n --> /tmp/.tmpG2F56E/main.rs:1:326\n  |\n1 | ...> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ...\n  |                                                ^^^^^^^^^ cannot assign to immutable argument\n  |\nhelp: consider making this binding mutable\n  |\n1 | fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; ; let mut prev = 0 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (a : i32 , mut b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n = 10 ; { println ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let x = 25 ; ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let a = 48 ; ; let b = 18 ; ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } ; }\n  |                                                                                                                                                                                                                                                                                +++\n\nerror[E0384]: cannot assign to immutable argument `a`\n --> /tmp/.tmpG2F56E/main.rs:1:338\n  |\n1 | ...le b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n =...\n  |                                                 ^^^^^^^^ cannot assign to immutable argument\n  |\nhelp: consider making this binding mutable\n  |\n1 | fn factorial (n : i32) -> i64 { if n <= 1 { 1 } else { (n as i64) * factorial (n - 1) } } fn integer_sqrt (n : i32) -> i32 { if n < 2 { return n } ; let mut x = n / 2 ; ; let mut prev = 0 ; ; while x != prev { { prev = x ; x = (x + n / x) / 2 } } ; x } fn gcd (mut a : i32 , b : i32) -> i32 { while b != 0 { { { let temp = b ; { b = a % b ; a = temp } } } } ; a } fn main () { println ! (\"Mathematical Functions Demo\") ; { let n = 10 ; { println ! (\"Factorial of {}: {}\" , n , factorial (n)) ; let x = 25 ; ; println ! (\"Square root of {}: {}\" , x , integer_sqrt (x)) ; let a = 48 ; ; let b = 18 ; ; println ! (\"GCD of {} and {}: {}\" , a , b , gcd (a , b)) } } ; }\n  |                                                                                                                                                                                                                                                                      +++\n\nerror: aborting due to 2 previous errors; 6 warnings emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch03-00-functions-tdd": {
      "chapter": "ch03-00-functions-tdd",
      "total_examples": 11,
      "working_examples": 9,
      "failing_examples": 2,
      "examples": [
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun greet() {\n    println(\"Hello from function!\");\n}\n\nfun main() {\n    greet();\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 2,
          "line_number": 54,
          "code": "fun add(a, b) {\n    a + b\n}\n\nfun main() {\n    let result = add(5, 3);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 3,
          "line_number": 77,
          "code": "fun multiply(x: i32, y: i32) -> i32 {\n    x * y\n}\n\nfun main() {\n    let product = multiply(6, 7);\n    println(product);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 4,
          "line_number": 100,
          "code": "fun square(n: i32) -> i32 {\n    n * n\n}\n\nfun sum_of_squares(a: i32, b: i32) -> i32 {\n    square(a) + square(b)\n}\n\nfun main() {\n    let result = sum_of_squares(3, 4);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 5,
          "line_number": 127,
          "code": "// Example function definition\nfun calculate_area(length: i32, width: i32) -> i32 {\n    length * width\n}\n\nfun main() {\n    let area = calculate_area(5, 3);\n    println(area);  // Output: 15\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 6,
          "line_number": 167,
          "code": "fun calculate(x: i32, y: i32) -> i32 {\n    x * 2 + y * 3\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 7,
          "line_number": 196,
          "code": "fun calculate(input: i32) -> i32 {\n    input * 2\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 8,
          "line_number": 206,
          "code": "fun combine(a: i32, b: i32, c: i32) -> i32 {\n    a + b + c\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 9,
          "line_number": 216,
          "code": "fun helper(x: i32) -> i32 {\n    x * x\n}\n\nfun main_calculation(n: i32) -> i32 {\n    helper(n) + helper(n + 1)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 10,
          "line_number": 230,
          "code": "fun analyze_sales(df: DataFrame) -> DataFrame {\n    // Function that processes a DataFrame\n    df.group_by(\"product\")\n      .agg(\"revenue\", \"sum\")\n      .sort_by(\"revenue_sum\", descending: true)\n}\n\nfun filter_high_value(df: DataFrame, threshold: f64) -> DataFrame {\n    // Function with DataFrame and parameter\n    df.filter(|row| row[\"value\"] > threshold)\n}\n\nfun main() {\n    let sales = DataFrame::from_csv(\"sales.csv\");\n    let analysis = analyze_sales(sales);\n    let top_items = filter_high_value(analysis, 10000.0);\n    println(\"Found {} high-value items\", top_items.rows());\n}",
          "passed": false,
          "status": "broken",
          "error": "âœ— Compilation failed: Failed to parse Ruchy source\nError: Failed to parse Ruchy source\n\nCaused by:\n    Expected RightBrace, found DataFrame\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch03-00-functions-tdd.md",
          "example_number": 11,
          "line_number": 252,
          "code": "fun add_profit_margin(df: DataFrame) -> DataFrame {\n    // Add calculated column to DataFrame\n    df.with_column(\"margin\", |row| {\n        (row[\"revenue\"] - row[\"cost\"]) / row[\"revenue\"] * 100.0\n    })\n}\n\nfun summarize_by_category(df: DataFrame) -> DataFrame {\n    // Aggregate DataFrame by category\n    df.group_by(\"category\")\n      .agg(\"quantity\", \"sum\")\n      .agg(\"revenue\", \"mean\")\n      .agg(\"margin\", \"mean\")\n}",
          "passed": false,
          "status": "broken",
          "error": "DEBUG: transpile_function called for function: add_profit_margin\nDEBUG: transpile_function called for function: summarize_by_category\nâœ— Compilation failed: Compilation failed:\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> /tmp/.tmpqdyyQj/main.rs:1:28\n  |\n1 | fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column (\"margin\" , | row | { (row . get (\"revenue\") . cloned () . unwrap_o...\n  |                            ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> /tmp/.tmpqdyyQj/main.rs:1:42\n  |\n1 | fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column (\"margin\" , | row | { (row . get (\"revenue\") . cloned () . unwrap_o...\n  |                                          ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> /tmp/.tmpqdyyQj/main.rs:1:387\n  |\n1 | ...d\")) * 100f64 }) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect (\"Failed to group DataFrame\")...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> /tmp/.tmpqdyyQj/main.rs:1:401\n  |\n1 | ...}) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect (\"Failed to group DataFrame\") . agg (\"quant...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0412`.\n\nError: Compilation failed:\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> /tmp/.tmpqdyyQj/main.rs:1:28\n  |\n1 | fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column (\"margin\" , | row | { (row . get (\"revenue\") . cloned () . unwrap_o...\n  |                            ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> /tmp/.tmpqdyyQj/main.rs:1:42\n  |\n1 | fn add_profit_margin (df : DataFrame) -> DataFrame { df . with_column (\"margin\" , | row | { (row . get (\"revenue\") . cloned () . unwrap_o...\n  |                                          ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> /tmp/.tmpqdyyQj/main.rs:1:387\n  |\n1 | ...d\")) * 100f64 }) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect (\"Failed to group DataFrame\")...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> /tmp/.tmpqdyyQj/main.rs:1:401\n  |\n1 | ...}) } fn summarize_by_category (df : DataFrame) -> DataFrame { df . groupby (& []) . expect (\"Failed to group DataFrame\") . agg (\"quant...\n  |                                                      ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch06-00-data-structures-tdd": {
      "chapter": "ch06-00-data-structures-tdd",
      "total_examples": 8,
      "working_examples": 8,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun main() {\n    let greeting = \"Hello\";\n    let name = \"World\";\n    println(greeting);\n    println(name);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 2,
          "line_number": 54,
          "code": "fun main() {\n    let first = \"Hello\";\n    let second = \"Beautiful\";\n    let third = \"World\";\n    println(first);\n    println(second);\n    println(third);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 3,
          "line_number": 79,
          "code": "fun main() {\n    let number = 42;\n    let text = \"Answer\";\n    println(text);\n    println(number);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 4,
          "line_number": 119,
          "code": "// Error: âœ— Compilation failed: Compilation failed:\nlet message = \"Hello World\";\nlet name = \"Alice\";\nlet greeting = \"Welcome\";",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 5,
          "line_number": 129,
          "code": "// Error: âœ— Compilation failed: Compilation failed:\nlet text = \"Count\";\nlet number = 100;\nlet flag = true;",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 6,
          "line_number": 153,
          "code": "// Error: âœ— Compilation failed: Compilation failed:\nlet first_name = \"John\";\nlet last_name = \"Doe\";\nlet title = \"Mr.\";",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 7,
          "line_number": 163,
          "code": "// Error: âœ— Compilation failed: Compilation failed:\nlet label = \"Temperature\";\nlet value = 72;\nlet unit = \"Fahrenheit\";",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch06-00-data-structures-tdd.md",
          "example_number": 8,
          "line_number": 173,
          "code": "// Error: âœ— Compilation failed: Compilation failed:\nlet app_name = \"MyApp\";\nlet version = \"1.0\";\nlet debug = true;",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch17-00-error-handling-robustness": {
      "chapter": "ch17-00-error-handling-robustness",
      "total_examples": 11,
      "working_examples": 6,
      "failing_examples": 5,
      "examples": [
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 1,
          "line_number": 9,
          "code": "fun safe_divide(a: i32, b: i32) -> i32 {\n    if b == 0 {\n        println(\"Error: Division by zero attempted\");\n        return 0; // Safe default\n    }\n    a / b\n}\n\nfun main() {\n    let result1 = safe_divide(10, 2);   // Normal case\n    let result2 = safe_divide(10, 0);   // Error case\n    \n    println(\"10 / 2 = {}\", result1);   // Output: 5\n    println(\"10 / 0 = {}\", result2);   // Output: 0 (safe)\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 2,
          "line_number": 51,
          "code": "fun validate_age(age: i32) -> i32 {\n    if age < 0 {\n        println(\"Error: Age cannot be negative. Using 0.\");\n        return 0;\n    }\n    \n    if age > 150 {\n        println(\"Error: Age seems unrealistic. Using 150.\");\n        return 150;\n    }\n    \n    age\n}\n\nfun calculate_retirement_year(current_age: i32) -> i32 {\n    let safe_age = validate_age(current_age);\n    let current_year = 2024; // Simplified\n    let retirement_age = 65;\n    \n    if safe_age >= retirement_age {\n        println(\"Already at retirement age\");\n        return current_year;\n    }\n    \n    current_year + (retirement_age - safe_age)\n}\n\nfun main() {\n    let year1 = calculate_retirement_year(30);\n    let year2 = calculate_retirement_year(-5);\n    let year3 = calculate_retirement_year(200);\n    \n    println(\"Retirement years: {}, {}, {}\", year1, year2, year3);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 3,
          "line_number": 89,
          "code": "fun safe_sqrt(x: f64) -> f64 {\n    if x < 0.0 {\n        println(\"Error: Cannot compute square root of negative number\");\n        return 0.0;\n    }\n    \n    // Simple approximation for square root\n    let mut guess = x / 2.0;\n    let mut i = 0;\n    \n    while i < 10 {\n        if guess * guess > x - 0.01 && guess * guess < x + 0.01 {\n            return guess;\n        }\n        guess = (guess + x / guess) / 2.0;\n        i = i + 1;\n    }\n    \n    guess\n}\n\nfun safe_factorial(n: i32) -> i64 {\n    if n < 0 {\n        println(\"Error: Factorial undefined for negative numbers\");\n        return 0;\n    }\n    \n    if n > 20 {\n        println(\"Error: Factorial too large, computing factorial(20)\");\n        return safe_factorial(20);\n    }\n    \n    if n <= 1 {\n        return 1;\n    }\n    \n    (n as i64) * safe_factorial(n - 1)\n}\n\nfun main() {\n    let sqrt1 = safe_sqrt(16.0);\n    let sqrt2 = safe_sqrt(-4.0);\n    \n    let fact1 = safe_factorial(5);\n    let fact2 = safe_factorial(-3);\n    let fact3 = safe_factorial(25);\n    \n    println(\"Square roots: {:.2}, {:.2}\", sqrt1, sqrt2);\n    println(\"Factorials: {}, {}, {}\", fact1, fact2, fact3);\n}",
          "passed": false,
          "status": "broken",
          "error": "DEBUG: transpile_function called for function: safe_sqrt\nDEBUG: transpile_function called for function: safe_factorial\nDEBUG: transpile_function called for function: main\nâœ— Compilation failed: Compilation failed:\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp500jJk/main.rs:1:159\n  |\n1 | ...mber\") ; return 0f64 } ; let mut guess = x / 2f64 ; ; let mut i = 0 ; ; while i < 10 { { if guess * guess > x - 0.01f64 && guess * gue...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp500jJk/main.rs:1:177\n  |\n1 | ...64 } ; let mut guess = x / 2f64 ; ; let mut i = 0 ; ; while i < 10 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 {...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp500jJk/main.rs:1:586\n  |\n1 | ...factorial(20)\") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let...\n  |                                                                 ^^        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { println ! (\"Error: Cannot compute square root of negative number\") ; return 0f64 } ; let mut guess = x / 2f64 ; ; let mut i = 0 ; ; while i < 10 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { return guess } ; guess = (guess + x / guess) / 2f64 ; i = i + 1 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0 { println ! (\"Error: Factorial undefined for negative numbers\") ; return 0 } ; if n > 20 { println ! (\"Error: Factorial too large, computing factorial(20)\") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { let sqrt2 = safe_sqrt (- 4f64) ; ; let fact1 = safe_factorial (5) ; ; let fact2 = safe_factorial (- 3) ; ; let fact3 = safe_factorial (25) ; ; println ! (\"{} {:?} {:?}\" , \"Square roots: {:.2}, {:.2}\" , sqrt1 , sqrt2) ; println ! (\"Factorials: {}, {}, {}\" , fact1 , fact2 , fact3) } } }\n1 + fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { println ! (\"Error: Cannot compute square root of negative number\") ; return 0f64 } ; let mut guess = x / 2f64 ; ; let mut i = 0 ; ; while i < 10 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { return guess } ; guess = (guess + x / guess) / 2f64 ; i = i + 1 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0 { println ! (\"Error: Factorial undefined for negative numbers\") ; return 0 } ; if n > 20 { println ! (\"Error: Factorial too large, computing factorial(20)\") ; return safe_factorial (20) } ; if n <= 1 { return 1 ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { let sqrt2 = safe_sqrt (- 4f64) ; ; let fact1 = safe_factorial (5) ; ; let fact2 = safe_factorial (- 3) ; ; let fact3 = safe_factorial (25) ; ; println ! (\"{} {:?} {:?}\" , \"Square roots: {:.2}, {:.2}\" , sqrt1 , sqrt2) ; println ! (\"Factorials: {}, {}, {}\" , fact1 , fact2 , fact3) } } }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp500jJk/main.rs:1:723\n  |\n1 | ...e_sqrt (16f64) ; { let sqrt2 = safe_sqrt (- 4f64) ; ; let fact1 = safe_factorial (5) ; ; let fact2 = safe_factorial (- 3) ; ; let fact...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp500jJk/main.rs:1:758\n  |\n1 | ..._sqrt (- 4f64) ; ; let fact1 = safe_factorial (5) ; ; let fact2 = safe_factorial (- 3) ; ; let fact3 = safe_factorial (25) ; ; println...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp500jJk/main.rs:1:795\n  |\n1 | ...actorial (5) ; ; let fact2 = safe_factorial (- 3) ; ; let fact3 = safe_factorial (25) ; ; println ! (\"{} {:?} {:?}\" , \"Square roots: {...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp500jJk/main.rs:1:831\n  |\n1 | ...ctorial (- 3) ; ; let fact3 = safe_factorial (25) ; ; println ! (\"{} {:?} {:?}\" , \"Square roots: {:.2}, {:.2}\" , sqrt1 , sqrt2) ; prin...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unreachable expression\n --> /tmp/.tmp500jJk/main.rs:1:599\n  |\n1 | ...ctorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { l...\n  |                                   --------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression\n  |                                   |\n  |                                   any code following this expression is unreachable\n  |\n  = note: `#[warn(unreachable_code)]` on by default\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmp500jJk/main.rs:1:574\n  |\n1 | ...-> i64 { if n < 0 { println ! (\"Error: Factorial undefined for negative numbers\") ; return 0 } ; if n > 20 { println ! (\"Error: Factorial too large, computing factorial(20)\") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } ...\n  |       --- expected `i64` because of this return type                                                                                                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n\nerror: aborting due to 1 previous error; 8 warnings emitted\n\nFor more information about this error, try `rustc --explain E0317`.\n\nError: Compilation failed:\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp500jJk/main.rs:1:159\n  |\n1 | ...mber\") ; return 0f64 } ; let mut guess = x / 2f64 ; ; let mut i = 0 ; ; while i < 10 { { if guess * guess > x - 0.01f64 && guess * gue...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp500jJk/main.rs:1:177\n  |\n1 | ...64 } ; let mut guess = x / 2f64 ; ; let mut i = 0 ; ; while i < 10 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 {...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp500jJk/main.rs:1:586\n  |\n1 | ...factorial(20)\") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let...\n  |                                                                 ^^        ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { println ! (\"Error: Cannot compute square root of negative number\") ; return 0f64 } ; let mut guess = x / 2f64 ; ; let mut i = 0 ; ; while i < 10 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { return guess } ; guess = (guess + x / guess) / 2f64 ; i = i + 1 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0 { println ! (\"Error: Factorial undefined for negative numbers\") ; return 0 } ; if n > 20 { println ! (\"Error: Factorial too large, computing factorial(20)\") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { let sqrt2 = safe_sqrt (- 4f64) ; ; let fact1 = safe_factorial (5) ; ; let fact2 = safe_factorial (- 3) ; ; let fact3 = safe_factorial (25) ; ; println ! (\"{} {:?} {:?}\" , \"Square roots: {:.2}, {:.2}\" , sqrt1 , sqrt2) ; println ! (\"Factorials: {}, {}, {}\" , fact1 , fact2 , fact3) } } }\n1 + fn safe_sqrt (x : f64) -> f64 { if x < 0f64 { println ! (\"Error: Cannot compute square root of negative number\") ; return 0f64 } ; let mut guess = x / 2f64 ; ; let mut i = 0 ; ; while i < 10 { { if guess * guess > x - 0.01f64 && guess * guess < x + 0.01f64 { return guess } ; guess = (guess + x / guess) / 2f64 ; i = i + 1 } } ; guess } fn safe_factorial (n : i32) -> i64 { if n < 0 { println ! (\"Error: Factorial undefined for negative numbers\") ; return 0 } ; if n > 20 { println ! (\"Error: Factorial too large, computing factorial(20)\") ; return safe_factorial (20) } ; if n <= 1 { return 1 ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { let sqrt2 = safe_sqrt (- 4f64) ; ; let fact1 = safe_factorial (5) ; ; let fact2 = safe_factorial (- 3) ; ; let fact3 = safe_factorial (25) ; ; println ! (\"{} {:?} {:?}\" , \"Square roots: {:.2}, {:.2}\" , sqrt1 , sqrt2) ; println ! (\"Factorials: {}, {}, {}\" , fact1 , fact2 , fact3) } } }\n  |\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp500jJk/main.rs:1:723\n  |\n1 | ...e_sqrt (16f64) ; { let sqrt2 = safe_sqrt (- 4f64) ; ; let fact1 = safe_factorial (5) ; ; let fact2 = safe_factorial (- 3) ; ; let fact...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp500jJk/main.rs:1:758\n  |\n1 | ..._sqrt (- 4f64) ; ; let fact1 = safe_factorial (5) ; ; let fact2 = safe_factorial (- 3) ; ; let fact3 = safe_factorial (25) ; ; println...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp500jJk/main.rs:1:795\n  |\n1 | ...actorial (5) ; ; let fact2 = safe_factorial (- 3) ; ; let fact3 = safe_factorial (25) ; ; println ! (\"{} {:?} {:?}\" , \"Square roots: {...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp500jJk/main.rs:1:831\n  |\n1 | ...ctorial (- 3) ; ; let fact3 = safe_factorial (25) ; ; println ! (\"{} {:?} {:?}\" , \"Square roots: {:.2}, {:.2}\" , sqrt1 , sqrt2) ; prin...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unreachable expression\n --> /tmp/.tmp500jJk/main.rs:1:599\n  |\n1 | ...ctorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } fn main () { { let sqrt1 = safe_sqrt (16f64) ; { l...\n  |                                   --------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression\n  |                                   |\n  |                                   any code following this expression is unreachable\n  |\n  = note: `#[warn(unreachable_code)]` on by default\n\nerror[E0317]: `if` may be missing an `else` clause\n --> /tmp/.tmp500jJk/main.rs:1:574\n  |\n1 | ...-> i64 { if n < 0 { println ! (\"Error: Factorial undefined for negative numbers\") ; return 0 } ; if n > 20 { println ! (\"Error: Factorial too large, computing factorial(20)\") ; return safe_factorial (20) } ; if n <= 1 { { return 1 } ((n as i64)) * safe_factorial (n - 1) } } ...\n  |       --- expected `i64` because of this return type                                                                                                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `()`\n  |\n  = note: `if` expressions without `else` evaluate to `()`\n  = help: consider adding an `else` block that evaluates to the expected type\n\nerror: aborting due to 1 previous error; 8 warnings emitted\n\nFor more information about this error, try `rustc --explain E0317`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 4,
          "line_number": 143,
          "code": "fun safe_array_access(arr: [i32; 5], index: i32) -> i32 {\n    if index < 0 {\n        println(\"Error: Array index cannot be negative\");\n        return arr[0]; // Return first element as default\n    }\n    \n    if index >= 5 {\n        println(\"Error: Array index {} out of bounds\", index);\n        return arr[4]; // Return last element as default\n    }\n    \n    arr[index]\n}\n\nfun find_maximum_safe(numbers: [i32; 5]) -> i32 {\n    let mut max = numbers[0];\n    let mut i = 1;\n    \n    while i < 5 {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n        i = i + 1;\n    }\n    \n    max\n}\n\nfun main() {\n    let data = [10, 25, 5, 30, 15];\n    \n    let val1 = safe_array_access(data, 2);\n    let val2 = safe_array_access(data, -1);\n    let val3 = safe_array_access(data, 10);\n    \n    let maximum = find_maximum_safe(data);\n    \n    println(\"Values: {}, {}, {}\", val1, val2, val3);\n    println(\"Maximum: {}\", maximum);\n}",
          "passed": false,
          "status": "broken",
          "error": "DEBUG: transpile_function called for function: safe_array_access\nDEBUG: transpile_function called for function: find_maximum_safe\nDEBUG: transpile_function called for function: main\nâœ— Compilation failed: Compilation failed:\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpkyXvPF/main.rs:1:376\n  |\n1 | ...; 5]) -> i32 { let mut max = numbers [0 as usize] ; ; let mut i = 1 ; ; while i < 5 { { if numbers [i as usize] > max { max = numbers ...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpkyXvPF/main.rs:1:394\n  |\n1 | ... mut max = numbers [0 as usize] ; ; let mut i = 1 ; ; while i < 5 { { if numbers [i as usize] > max { max = numbers [i as usize] } ; i...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpkyXvPF/main.rs:1:599\n  |\n1 | ..., 15] ; { let val1 = safe_array_access (data , 2) ; ; let val2 = safe_array_access (data , - 1) ; ; let val3 = safe_array_access (data...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpkyXvPF/main.rs:1:645\n  |\n1 | ... 2) ; ; let val2 = safe_array_access (data , - 1) ; ; let val3 = safe_array_access (data , 10) ; ; let maximum = find_maximum_safe (da...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpkyXvPF/main.rs:1:690\n  |\n1 | ...- 1) ; ; let val3 = safe_array_access (data , 10) ; ; let maximum = find_maximum_safe (data) ; ; println ! (\"Values: {}, {}, {}\" , val...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpkyXvPF/main.rs:1:733\n  |\n1 | ... , 10) ; ; let maximum = find_maximum_safe (data) ; ; println ! (\"Values: {}, {}, {}\" , val1 , val2 , val3) ; println ! (\"Maximum: {}\"...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpkyXvPF/main.rs:1:587\n  |\n1 | ...25 , 5 , 30 , 15] ; { let val1 = safe_array_access (data , 2) ; ; let val2 = safe_array_access (data , - 1) ; ; let val3 = safe_array_...\n  |                                     -----------------  ^^^^ expected `[i32; 5]`, found `Vec<{integer}>`\n  |                                     |\n  |                                     arguments to this function are incorrect\n  |\n  = note: expected array `[i32; 5]`\n            found struct `Vec<{integer}>`\nnote: function defined here\n --> /tmp/.tmpkyXvPF/main.rs:1:4\n  |\n1 | fn safe_array_access (arr : [i32 ; 5] , index : i32) -> i32 { if index < 0 { println ! (\"Error: Array index cannot be negative\") ; return...\n  |    ^^^^^^^^^^^^^^^^^  ---------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpkyXvPF/main.rs:1:631\n  |\n1 | ...access (data , 2) ; ; let val2 = safe_array_access (data , - 1) ; ; let val3 = safe_array_access (data , 10) ; ; let maximum = find_ma...\n  |                                     -----------------  ^^^^ expected `[i32; 5]`, found `Vec<{integer}>`\n  |                                     |\n  |                                     arguments to this function are incorrect\n  |\n  = note: expected array `[i32; 5]`\n            found struct `Vec<{integer}>`\nnote: function defined here\n --> /tmp/.tmpkyXvPF/main.rs:1:4\n  |\n1 | fn safe_array_access (arr : [i32 ; 5] , index : i32) -> i32 { if index < 0 { println ! (\"Error: Array index cannot be negative\") ; return...\n  |    ^^^^^^^^^^^^^^^^^  ---------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpkyXvPF/main.rs:1:677\n  |\n1 | ...cess (data , - 1) ; ; let val3 = safe_array_access (data , 10) ; ; let maximum = find_maximum_safe (data) ; ; println ! (\"Values: {}, ...\n  |                                     -----------------  ^^^^ expected `[i32; 5]`, found `Vec<{integer}>`\n  |                                     |\n  |                                     arguments to this function are incorrect\n  |\n  = note: expected array `[i32; 5]`\n            found struct `Vec<{integer}>`\nnote: function defined here\n --> /tmp/.tmpkyXvPF/main.rs:1:4\n  |\n1 | fn safe_array_access (arr : [i32 ; 5] , index : i32) -> i32 { if index < 0 { println ! (\"Error: Array index cannot be negative\") ; return...\n  |    ^^^^^^^^^^^^^^^^^  ---------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpkyXvPF/main.rs:1:725\n  |\n1 | ...ss (data , 10) ; ; let maximum = find_maximum_safe (data) ; ; println ! (\"Values: {}, {}, {}\" , val1 , val2 , val3) ; println ! (\"Maxi...\n  |                                     -----------------  ^^^^ expected `[i32; 5]`, found `Vec<{integer}>`\n  |                                     |\n  |                                     arguments to this function are incorrect\n  |\n  = note: expected array `[i32; 5]`\n            found struct `Vec<{integer}>`\nnote: function defined here\n --> /tmp/.tmpkyXvPF/main.rs:1:290\n  |\n1 | ...arr [4 as usize] } ; arr [index as usize] } fn find_maximum_safe (numbers : [i32 ; 5]) -> i32 { let mut max = numbers [0 as usize] ; ;...\n  |                                                   ^^^^^^^^^^^^^^^^^  -------------------\n\nerror: aborting due to 4 previous errors; 6 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\nError: Compilation failed:\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpkyXvPF/main.rs:1:376\n  |\n1 | ...; 5]) -> i32 { let mut max = numbers [0 as usize] ; ; let mut i = 1 ; ; while i < 5 { { if numbers [i as usize] > max { max = numbers ...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpkyXvPF/main.rs:1:394\n  |\n1 | ... mut max = numbers [0 as usize] ; ; let mut i = 1 ; ; while i < 5 { { if numbers [i as usize] > max { max = numbers [i as usize] } ; i...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpkyXvPF/main.rs:1:599\n  |\n1 | ..., 15] ; { let val1 = safe_array_access (data , 2) ; ; let val2 = safe_array_access (data , - 1) ; ; let val3 = safe_array_access (data...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpkyXvPF/main.rs:1:645\n  |\n1 | ... 2) ; ; let val2 = safe_array_access (data , - 1) ; ; let val3 = safe_array_access (data , 10) ; ; let maximum = find_maximum_safe (da...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpkyXvPF/main.rs:1:690\n  |\n1 | ...- 1) ; ; let val3 = safe_array_access (data , 10) ; ; let maximum = find_maximum_safe (data) ; ; println ! (\"Values: {}, {}, {}\" , val...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpkyXvPF/main.rs:1:733\n  |\n1 | ... , 10) ; ; let maximum = find_maximum_safe (data) ; ; println ! (\"Values: {}, {}, {}\" , val1 , val2 , val3) ; println ! (\"Maximum: {}\"...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpkyXvPF/main.rs:1:587\n  |\n1 | ...25 , 5 , 30 , 15] ; { let val1 = safe_array_access (data , 2) ; ; let val2 = safe_array_access (data , - 1) ; ; let val3 = safe_array_...\n  |                                     -----------------  ^^^^ expected `[i32; 5]`, found `Vec<{integer}>`\n  |                                     |\n  |                                     arguments to this function are incorrect\n  |\n  = note: expected array `[i32; 5]`\n            found struct `Vec<{integer}>`\nnote: function defined here\n --> /tmp/.tmpkyXvPF/main.rs:1:4\n  |\n1 | fn safe_array_access (arr : [i32 ; 5] , index : i32) -> i32 { if index < 0 { println ! (\"Error: Array index cannot be negative\") ; return...\n  |    ^^^^^^^^^^^^^^^^^  ---------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpkyXvPF/main.rs:1:631\n  |\n1 | ...access (data , 2) ; ; let val2 = safe_array_access (data , - 1) ; ; let val3 = safe_array_access (data , 10) ; ; let maximum = find_ma...\n  |                                     -----------------  ^^^^ expected `[i32; 5]`, found `Vec<{integer}>`\n  |                                     |\n  |                                     arguments to this function are incorrect\n  |\n  = note: expected array `[i32; 5]`\n            found struct `Vec<{integer}>`\nnote: function defined here\n --> /tmp/.tmpkyXvPF/main.rs:1:4\n  |\n1 | fn safe_array_access (arr : [i32 ; 5] , index : i32) -> i32 { if index < 0 { println ! (\"Error: Array index cannot be negative\") ; return...\n  |    ^^^^^^^^^^^^^^^^^  ---------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpkyXvPF/main.rs:1:677\n  |\n1 | ...cess (data , - 1) ; ; let val3 = safe_array_access (data , 10) ; ; let maximum = find_maximum_safe (data) ; ; println ! (\"Values: {}, ...\n  |                                     -----------------  ^^^^ expected `[i32; 5]`, found `Vec<{integer}>`\n  |                                     |\n  |                                     arguments to this function are incorrect\n  |\n  = note: expected array `[i32; 5]`\n            found struct `Vec<{integer}>`\nnote: function defined here\n --> /tmp/.tmpkyXvPF/main.rs:1:4\n  |\n1 | fn safe_array_access (arr : [i32 ; 5] , index : i32) -> i32 { if index < 0 { println ! (\"Error: Array index cannot be negative\") ; return...\n  |    ^^^^^^^^^^^^^^^^^  ---------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpkyXvPF/main.rs:1:725\n  |\n1 | ...ss (data , 10) ; ; let maximum = find_maximum_safe (data) ; ; println ! (\"Values: {}, {}, {}\" , val1 , val2 , val3) ; println ! (\"Maxi...\n  |                                     -----------------  ^^^^ expected `[i32; 5]`, found `Vec<{integer}>`\n  |                                     |\n  |                                     arguments to this function are incorrect\n  |\n  = note: expected array `[i32; 5]`\n            found struct `Vec<{integer}>`\nnote: function defined here\n --> /tmp/.tmpkyXvPF/main.rs:1:290\n  |\n1 | ...arr [4 as usize] } ; arr [index as usize] } fn find_maximum_safe (numbers : [i32 ; 5]) -> i32 { let mut max = numbers [0 as usize] ; ;...\n  |                                                   ^^^^^^^^^^^^^^^^^  -------------------\n\nerror: aborting due to 4 previous errors; 6 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 5,
          "line_number": 189,
          "code": "fun unreliable_operation(attempt: i32) -> bool {\n    // Simulate an operation that fails sometimes\n    if attempt < 3 {\n        println(\"Operation failed on attempt {}\", attempt);\n        return false;\n    }\n    println(\"Operation succeeded on attempt {}\", attempt);\n    return true;\n}\n\nfun retry_with_limit(max_attempts: i32) -> bool {\n    let mut attempt = 1;\n    \n    while attempt <= max_attempts {\n        println(\"Attempting operation (try {})\", attempt);\n        \n        if unreliable_operation(attempt) {\n            return true;\n        }\n        \n        attempt = attempt + 1;\n    }\n    \n    println(\"Error: Operation failed after {} attempts\", max_attempts);\n    return false;\n}\n\nfun main() {\n    let success = retry_with_limit(5);\n    \n    if success {\n        println(\"âœ… Operation completed successfully\");\n    } else {\n        println(\"âŒ Operation failed after all retries\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 6,
          "line_number": 229,
          "code": "fun get_config_value(config_name: &str) -> i32 {\n    // Simulate configuration lookup\n    if config_name == \"timeout\" {\n        return 30;\n    } else if config_name == \"retries\" {\n        return 3;\n    } else {\n        println(\"Warning: Unknown config '{}', using default\", config_name);\n        return 0; // Safe default\n    }\n}\n\nfun initialize_system() -> bool {\n    let timeout = get_config_value(\"timeout\");\n    let retries = get_config_value(\"retries\");\n    let unknown = get_config_value(\"unknown_setting\");\n    \n    println(\"System configuration:\");\n    println(\"  Timeout: {} seconds\", timeout);\n    println(\"  Retries: {} attempts\", retries);\n    println(\"  Unknown: {} (default)\", unknown);\n    \n    // Validate configuration\n    if timeout <= 0 {\n        println(\"Error: Invalid timeout configuration\");\n        return false;\n    }\n    \n    if retries < 0 {\n        println(\"Error: Invalid retry configuration\");\n        return false;\n    }\n    \n    println(\"âœ… System initialized successfully\");\n    return true;\n}\n\nfun main() {\n    let initialized = initialize_system();\n    \n    if initialized {\n        println(\"System ready for operation\");\n    } else {\n        println(\"System initialization failed\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 7,
          "line_number": 281,
          "code": "fun sanitize_username(username: &str) -> String {\n    // Check for null or empty\n    if username.len() == 0 {\n        println(\"Error: Username cannot be empty\");\n        return String::from(\"anonymous\");\n    }\n    \n    // Check length limits\n    if username.len() < 3 {\n        println(\"Error: Username too short, minimum 3 characters\");\n        return String::from(\"user123\");\n    }\n    \n    if username.len() > 20 {\n        println(\"Warning: Username truncated to 20 characters\");\n        return username.chars().take(20).collect();\n    }\n    \n    // Return sanitized username\n    username.to_string()\n}\n\nfun validate_email(email: &str) -> bool {\n    // Basic email validation\n    if email.len() == 0 {\n        println(\"Error: Email cannot be empty\");\n        return false;\n    }\n    \n    if !email.contains('@') {\n        println(\"Error: Invalid email format - missing @\");\n        return false;\n    }\n    \n    if !email.contains('.') {\n        println(\"Error: Invalid email format - missing domain\");\n        return false;\n    }\n    \n    return true;\n}\n\nfun create_user_account(username: &str, email: &str) -> bool {\n    println(\"Creating user account...\");\n    \n    let safe_username = sanitize_username(username);\n    let valid_email = validate_email(email);\n    \n    if !valid_email {\n        println(\"âŒ Account creation failed: Invalid email\");\n        return false;\n    }\n    \n    println(\"âœ… Account created for user: {}\", safe_username);\n    return true;\n}\n\nfun main() {\n    let success1 = create_user_account(\"john_doe\", \"john@example.com\");\n    let success2 = create_user_account(\"\", \"invalid-email\");\n    let success3 = create_user_account(\"ab\", \"test@domain.co.uk\");\n    \n    println(\"Account creation results: {}, {}, {}\", success1, success2, success3);\n}",
          "passed": false,
          "status": "broken",
          "error": "âœ— Compilation failed: Failed to parse Ruchy source\nError: Failed to parse Ruchy source\n\nCaused by:\n    Expected RightBrace, found If\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 8,
          "line_number": 349,
          "code": "fun parse_positive_integer(input: &str) -> i32 {\n    // Simulate string to integer conversion\n    let mut result = 0;\n    let mut i = 0;\n    let chars = input.as_bytes();\n    \n    if input.len() == 0 {\n        println(\"Error: Empty input, using 0\");\n        return 0;\n    }\n    \n    // Check for negative sign\n    if chars[0] == b'-' {\n        println(\"Error: Negative numbers not allowed, using 0\");\n        return 0;\n    }\n    \n    // Simple digit parsing (simplified for example)\n    while i < input.len() {\n        let ch = chars[i];\n        if ch >= b'0' && ch <= b'9' {\n            let digit = (ch - b'0') as i32;\n            result = result * 10 + digit;\n        } else {\n            println(\"Error: Invalid character in number, stopping at {}\", result);\n            break;\n        }\n        i = i + 1;\n    }\n    \n    // Validate range\n    if result > 1000 {\n        println(\"Warning: Value {} too large, capping at 1000\", result);\n        return 1000;\n    }\n    \n    result\n}\n\nfun calculate_score(correct: &str, total: &str) -> f64 {\n    let correct_num = parse_positive_integer(correct);\n    let total_num = parse_positive_integer(total);\n    \n    if total_num == 0 {\n        println(\"Error: Cannot calculate score with zero total\");\n        return 0.0;\n    }\n    \n    if correct_num > total_num {\n        println(\"Error: Correct answers cannot exceed total\");\n        return 0.0;\n    }\n    \n    (correct_num as f64) / (total_num as f64) * 100.0\n}\n\nfun main() {\n    let score1 = calculate_score(\"8\", \"10\");\n    let score2 = calculate_score(\"abc\", \"10\");\n    let score3 = calculate_score(\"15\", \"10\");\n    let score4 = calculate_score(\"5\", \"0\");\n    \n    println(\"Scores: {:.1}%, {:.1}%, {:.1}%, {:.1}%\", score1, score2, score3, score4);\n}",
          "passed": false,
          "status": "broken",
          "error": "âœ— Compilation failed: Failed to parse Ruchy source\nError: Failed to parse Ruchy source\n\nCaused by:\n    Expected RightBrace, found Let\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 9,
          "line_number": 419,
          "code": "fun test_division_error_handling() {\n    println(\"Testing division error handling...\");\n    \n    // Test normal case\n    let result1 = safe_divide(10, 2);\n    if result1 == 5 {\n        println(\"âœ… Normal division test passed\");\n    } else {\n        println(\"âŒ Normal division test failed\");\n    }\n    \n    // Test division by zero\n    let result2 = safe_divide(10, 0);\n    if result2 == 0 {\n        println(\"âœ… Division by zero handling passed\");\n    } else {\n        println(\"âŒ Division by zero handling failed\");\n    }\n    \n    // Test negative numbers\n    let result3 = safe_divide(-10, 2);\n    if result3 == -5 {\n        println(\"âœ… Negative number handling passed\");\n    } else {\n        println(\"âŒ Negative number handling failed\");\n    }\n}\n\nfun test_input_validation() {\n    println(\"Testing input validation...\");\n    \n    // Test valid age\n    let age1 = validate_age(25);\n    if age1 == 25 {\n        println(\"âœ… Valid age test passed\");\n    } else {\n        println(\"âŒ Valid age test failed\");\n    }\n    \n    // Test negative age\n    let age2 = validate_age(-5);\n    if age2 == 0 {\n        println(\"âœ… Negative age handling passed\");\n    } else {\n        println(\"âŒ Negative age handling failed\");\n    }\n    \n    // Test extreme age\n    let age3 = validate_age(200);\n    if age3 == 150 {\n        println(\"âœ… Extreme age handling passed\");\n    } else {\n        println(\"âŒ Extreme age handling failed\");\n    }\n}\n\nfun main() {\n    test_division_error_handling();\n    println(\"\");\n    test_input_validation();\n    println(\"\");\n    println(\"ðŸŽ‰ Error handling tests complete!\");\n}",
          "passed": false,
          "status": "broken",
          "error": "DEBUG: transpile_function called for function: test_division_error_handling\nDEBUG: transpile_function called for function: test_input_validation\nDEBUG: transpile_function called for function: main\nâœ— Compilation failed: Compilation failed:\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpvwwGsO/main.rs:1:286\n  |\n1 | ...t failed\") } ; let result2 = safe_divide (10 , 0) ; ; if result2 == 0 { println ! (\"âœ… Division by zero handling passed\") } else { print...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpvwwGsO/main.rs:1:456\n  |\n1 | ...failed\") } ; let result3 = safe_divide (- 10 , 2) ; ; if result3 == - 5 { println ! (\"âœ… Negative number handling passed\") } else { prin...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpvwwGsO/main.rs:1:839\n  |\n1 | ...e test failed\") } ; let age2 = validate_age (- 5) ; ; if age2 == 0 { println ! (\"âœ… Negative age handling passed\") } else { println ! (\"âŒ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpvwwGsO/main.rs:1:991\n  |\n1 | ...ndling failed\") } ; let age3 = validate_age (200) ; ; if age3 == 150 { println ! (\"âœ… Extreme age handling passed\") } else { println ! (\"...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `safe_divide` in this scope\n --> /tmp/.tmpvwwGsO/main.rs:1:105\n  |\n1 | ...g division error handling...\") ; { let result1 = safe_divide (10 , 2) ; { if result1 == 5 { println ! (\"âœ… Normal division test passed\")...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `safe_divide` in this scope\n --> /tmp/.tmpvwwGsO/main.rs:1:263\n  |\n1 | ... Normal division test failed\") } ; let result2 = safe_divide (10 , 0) ; ; if result2 == 0 { println ! (\"âœ… Division by zero handling pass...\n  |                                                      ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `safe_divide` in this scope\n --> /tmp/.tmpvwwGsO/main.rs:1:431\n  |\n1 | ...sion by zero handling failed\") } ; let result3 = safe_divide (- 10 , 2) ; ; if result3 == - 5 { println ! (\"âœ… Negative number handling ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `validate_age` in this scope\n --> /tmp/.tmpvwwGsO/main.rs:1:680\n  |\n1 | ...! (\"Testing input validation...\") ; { let age1 = validate_age (25) ; { if age1 == 25 { println ! (\"âœ… Valid age test passed\") } else { p...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `validate_age` in this scope\n --> /tmp/.tmpvwwGsO/main.rs:1:818\n  |\n1 | ...tln ! (\"âŒ Valid age test failed\") } ; let age2 = validate_age (- 5) ; ; if age2 == 0 { println ! (\"âœ… Negative age handling passed\") } el...\n  |                                                      ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `validate_age` in this scope\n --> /tmp/.tmpvwwGsO/main.rs:1:970\n  |\n1 | ...\"âŒ Negative age handling failed\") } ; let age3 = validate_age (200) ; ; if age3 == 150 { println ! (\"âœ… Extreme age handling passed\") } e...\n  |                                                      ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\nError: Compilation failed:\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpvwwGsO/main.rs:1:286\n  |\n1 | ...t failed\") } ; let result2 = safe_divide (10 , 0) ; ; if result2 == 0 { println ! (\"âœ… Division by zero handling passed\") } else { print...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpvwwGsO/main.rs:1:456\n  |\n1 | ...failed\") } ; let result3 = safe_divide (- 10 , 2) ; ; if result3 == - 5 { println ! (\"âœ… Negative number handling passed\") } else { prin...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpvwwGsO/main.rs:1:839\n  |\n1 | ...e test failed\") } ; let age2 = validate_age (- 5) ; ; if age2 == 0 { println ! (\"âœ… Negative age handling passed\") } else { println ! (\"âŒ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpvwwGsO/main.rs:1:991\n  |\n1 | ...ndling failed\") } ; let age3 = validate_age (200) ; ; if age3 == 150 { println ! (\"âœ… Extreme age handling passed\") } else { println ! (\"...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0425]: cannot find function `safe_divide` in this scope\n --> /tmp/.tmpvwwGsO/main.rs:1:105\n  |\n1 | ...g division error handling...\") ; { let result1 = safe_divide (10 , 2) ; { if result1 == 5 { println ! (\"âœ… Normal division test passed\")...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `safe_divide` in this scope\n --> /tmp/.tmpvwwGsO/main.rs:1:263\n  |\n1 | ... Normal division test failed\") } ; let result2 = safe_divide (10 , 0) ; ; if result2 == 0 { println ! (\"âœ… Division by zero handling pass...\n  |                                                      ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `safe_divide` in this scope\n --> /tmp/.tmpvwwGsO/main.rs:1:431\n  |\n1 | ...sion by zero handling failed\") } ; let result3 = safe_divide (- 10 , 2) ; ; if result3 == - 5 { println ! (\"âœ… Negative number handling ...\n  |                                                     ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `validate_age` in this scope\n --> /tmp/.tmpvwwGsO/main.rs:1:680\n  |\n1 | ...! (\"Testing input validation...\") ; { let age1 = validate_age (25) ; { if age1 == 25 { println ! (\"âœ… Valid age test passed\") } else { p...\n  |                                                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `validate_age` in this scope\n --> /tmp/.tmpvwwGsO/main.rs:1:818\n  |\n1 | ...tln ! (\"âŒ Valid age test failed\") } ; let age2 = validate_age (- 5) ; ; if age2 == 0 { println ! (\"âœ… Negative age handling passed\") } el...\n  |                                                      ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `validate_age` in this scope\n --> /tmp/.tmpvwwGsO/main.rs:1:970\n  |\n1 | ...\"âŒ Negative age handling failed\") } ; let age3 = validate_age (200) ; ; if age3 == 150 { println ! (\"âœ… Extreme age handling passed\") } e...\n  |                                                      ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 10,
          "line_number": 488,
          "code": "fun log_error(component: &str, message: &str) {\n    println(\"[ERROR] {}: {}\", component, message);\n}\n\nfun log_warning(component: &str, message: &str) {\n    println(\"[WARN] {}: {}\", component, message);\n}\n\nfun log_info(component: &str, message: &str) {\n    println(\"[INFO] {}: {}\", component, message);\n}\n\nfun process_user_data(user_id: i32, data: &str) -> bool {\n    log_info(\"DataProcessor\", \"Starting user data processing\");\n    \n    // Validate user ID\n    if user_id <= 0 {\n        log_error(\"DataProcessor\", \"Invalid user ID provided\");\n        return false;\n    }\n    \n    // Validate data\n    if data.len() == 0 {\n        log_error(\"DataProcessor\", \"Empty data received\");\n        return false;\n    }\n    \n    if data.len() > 1000 {\n        log_warning(\"DataProcessor\", \"Data size exceeds recommended limit\");\n    }\n    \n    // Simulate processing\n    log_info(\"DataProcessor\", \"Processing data for user\");\n    \n    // Simulate potential failure\n    if user_id == 999 {\n        log_error(\"DataProcessor\", \"Processing failed for user 999\");\n        return false;\n    }\n    \n    log_info(\"DataProcessor\", \"Data processing completed successfully\");\n    return true;\n}\n\nfun main() {\n    let results = [\n        process_user_data(123, \"valid_data\"),\n        process_user_data(0, \"invalid_user\"),\n        process_user_data(456, \"\"),\n        process_user_data(999, \"test_data\")\n    ];\n    \n    let mut successful = 0;\n    let mut i = 0;\n    \n    while i < 4 {\n        if results[i] {\n            successful = successful + 1;\n        }\n        i = i + 1;\n    }\n    \n    println(\"\");\n    println(\"Summary: {}/4 operations successful\", successful);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch17-00-error-handling-robustness.md",
          "example_number": 11,
          "line_number": 559,
          "code": "fun calculate_monthly_payment(principal: f64, rate: f64, months: i32) -> f64 {\n    // Preconditions - validate inputs\n    if principal <= 0.0 {\n        println(\"Error: Principal must be positive\");\n        return 0.0;\n    }\n    \n    if rate < 0.0 {\n        println(\"Error: Interest rate cannot be negative\");\n        return 0.0;\n    }\n    \n    if months <= 0 {\n        println(\"Error: Loan term must be positive\");\n        return 0.0;\n    }\n    \n    // Handle edge case of zero interest\n    if rate == 0.0 {\n        return principal / (months as f64);\n    }\n    \n    // Calculate monthly payment\n    let monthly_rate = rate / 12.0;\n    let payment = principal * monthly_rate * \n        ((1.0 + monthly_rate).powf(months as f64)) /\n        (((1.0 + monthly_rate).powf(months as f64)) - 1.0);\n    \n    // Postcondition - validate result\n    if payment <= 0.0 {\n        println(\"Error: Calculated payment is invalid\");\n        return 0.0;\n    }\n    \n    payment\n}\n\nfun main() {\n    let payment1 = calculate_monthly_payment(100000.0, 0.05, 360);\n    let payment2 = calculate_monthly_payment(-1000.0, 0.05, 360);\n    let payment3 = calculate_monthly_payment(50000.0, 0.0, 60);\n    \n    println(\"Monthly payments: {:.2}, {:.2}, {:.2}\", payment1, payment2, payment3);\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch05-00-control-flow-tdd": {
      "chapter": "ch05-00-control-flow-tdd",
      "total_examples": 17,
      "working_examples": 14,
      "failing_examples": 3,
      "examples": [
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun main() {\n    let x = 10;\n    if x > 5 {\n        println(\"x is greater than 5\");\n    } else {\n        println(\"x is not greater than 5\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 2,
          "line_number": 55,
          "code": "fun main() {\n    let score = 85;\n    if score >= 80 {\n        println(\"Great job!\");\n    }\n    println(\"Score processed\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 3,
          "line_number": 78,
          "code": "fun main() {\n    let grade = 75;\n    if grade >= 90 {\n        println(\"A grade\");\n    } else if grade >= 80 {\n        println(\"B grade\");\n    } else if grade >= 70 {\n        println(\"C grade\");\n    } else {\n        println(\"Below C\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 4,
          "line_number": 105,
          "code": "fun main() {\n    let mut i = 0;\n    while i < 3 {\n        println(i);\n        i = i + 1;\n    }\n    println(\"Done\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 5,
          "line_number": 131,
          "code": "fun main() {\n    for i in 0..3 {\n        println(i);\n    }\n    println(\"For loop done\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 6,
          "line_number": 155,
          "code": "fun main() {\n    let number = 2;\n    match number {\n        1 => println(\"One\"),\n        2 => println(\"Two\"),\n        3 => println(\"Three\"),\n        _ => println(\"Other\")\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 7,
          "line_number": 179,
          "code": "fun main() {\n    let mut i = 0;\n    while i < 10 {\n        i = i + 1;\n        if i == 3 {\n            continue;\n        }\n        if i == 6 {\n            break;\n        }\n        println(i);\n    }\n    println(\"Loop ended\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 8,
          "line_number": 236,
          "code": "fun main() {\n    let x = 10;\n    let y = 5;\n\n    if x > y {\n        println(\"x is greater\");\n    } else if x < y {\n        println(\"y is greater\");\n    } else {\n        println(\"they are equal\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 9,
          "line_number": 252,
          "code": "fun main() {\n    // While loop\n    let mut count = 0;\n    while count < 3 {\n        println(\"Count: \" + count);\n        count = count + 1;\n    }\n\n    // For loop with range\n    for i in 1..4 {\n        println(\"Iteration: \" + i);\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 10,
          "line_number": 269,
          "code": "fun main() {\n    let number = 2;\n    match number {\n        1 => println(\"One\"),\n        2 => println(\"Two\"),\n        3 => println(\"Three\"),\n        _ => println(\"Other\")\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 11,
          "line_number": 296,
          "code": "fun main() {\n    let user_input = 75;\n    let threshold = 50;\n\n    if user_input > threshold {\n        println(\"High value: \" + user_input);\n    } else {\n        println(\"Normal value: \" + user_input);\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 12,
          "line_number": 310,
          "code": "fun main() {\n    let mut count = 0;\n    while count < 10 {\n        println(\"Count is: \" + count);\n        count = count + 1;\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 13,
          "line_number": 321,
          "code": "fun main() {\n    for i in 1..5 {\n        println(\"Processing item \" + i);\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 14,
          "line_number": 330,
          "code": "fun main() {\n    let status_code = 200;\n    match status_code {\n        200 => println(\"Success\"),\n        404 => println(\"Not Found\"),\n        500 => println(\"Server Error\"),\n        _ => println(\"Unknown Status\")\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 15,
          "line_number": 343,
          "code": "fun main() {\n    let df = DataFrame::from_csv(\"sales.csv\");\n    \n    // Filter based on conditions\n    if df.rows() > 0 {\n        let high_value = df.filter(|row| {\n            if row[\"amount\"] > 1000 {\n                row[\"status\"] == \"active\"\n            } else {\n                false\n            }\n        });\n        \n        println(\"Found {} high-value active sales\", high_value.rows());\n    } else {\n        println(\"No data to process\");\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "DEBUG: transpile_function called for function: main\nâœ— Compilation failed: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmpezbBih/main.rs:1:23\n  |\n1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"sales.csv\") . expect (\"Failed to open CSV file\") . finish () . expect...\n  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpezbBih/main.rs:1:169\n  |\n1 | ... . finish () . expect (\"Failed to read CSV file\") ; ; if df . height () > 0 { { let high_value = df . lazy () . filter (| row | { if r...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\nError: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmpezbBih/main.rs:1:23\n  |\n1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"sales.csv\") . expect (\"Failed to open CSV file\") . finish () . expect...\n  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpezbBih/main.rs:1:169\n  |\n1 | ... . finish () . expect (\"Failed to read CSV file\") ; ; if df . height () > 0 { { let high_value = df . lazy () . filter (| row | { if r...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 16,
          "line_number": 365,
          "code": "fun main() {\n    let df = DataFrame::from_csv(\"inventory.csv\");\n    \n    // Process each row with for loop\n    for row in df.iter_rows() {\n        if row[\"quantity\"] < 10 {\n            println(\"Low stock alert: {} ({})\", row[\"product\"], row[\"quantity\"]);\n        }\n    }\n    \n    // Conditional aggregation\n    let mut total = 0.0;\n    for value in df[\"price\"].iter() {\n        if value > 0.0 {\n            total = total + value;\n        }\n    }\n    println(\"Total positive prices: {}\", total);\n}",
          "passed": false,
          "status": "broken",
          "error": "DEBUG: transpile_function called for function: main\nâœ— Compilation failed: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmp37FahC/main.rs:1:23\n  |\n1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . ex...\n  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp37FahC/main.rs:1:173\n  |\n1 | ... . finish () . expect (\"Failed to read CSV file\") ; ; for row in df . iter_rows () { { if row . get (\"quantity\") . cloned () . unwrap_...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp37FahC/main.rs:1:540\n  |\n1 | ... (\"Key not found\"))) } } } ; let mut total = 0f64 ; ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key n...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp37FahC/main.rs:1:206\n  |\n1 | ... { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; ; for row in df . iter_rows () { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } } ; let mut total = 0f64 ; ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! (\"Total positive prices: {}\" , total) ; }\n1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; ; for row in df . iter_rows () { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } ; let mut total = 0f64 ; ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! (\"Total positive prices: {}\" , total) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp37FahC/main.rs:1:646\n  |\n1 | ... (|| panic ! (\"Key not found\")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! (\"Total positive prices: {}\" ,...\n  |                                                ^^                                         ^^\n  |\nhelp: remove these braces\n  |\n1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; ; for row in df . iter_rows () { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } } ; let mut total = 0f64 ; ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! (\"Total positive prices: {}\" , total) ; }\n1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; ; for row in df . iter_rows () { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } } ; let mut total = 0f64 ; ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) . iter () { if value > 0f64 { total = total + value } } ; println ! (\"Total positive prices: {}\" , total) ; }\n  |\n\nerror: aborting due to 1 previous error; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\nError: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmp37FahC/main.rs:1:23\n  |\n1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . ex...\n  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp37FahC/main.rs:1:173\n  |\n1 | ... . finish () . expect (\"Failed to read CSV file\") ; ; for row in df . iter_rows () { { if row . get (\"quantity\") . cloned () . unwrap_...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp37FahC/main.rs:1:540\n  |\n1 | ... (\"Key not found\"))) } } } ; let mut total = 0f64 ; ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key n...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp37FahC/main.rs:1:206\n  |\n1 | ... { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } } ...\n  |       ^^                                                                                                                                                                                                                                                                                                              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; ; for row in df . iter_rows () { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } } ; let mut total = 0f64 ; ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! (\"Total positive prices: {}\" , total) ; }\n1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; ; for row in df . iter_rows () { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } ; let mut total = 0f64 ; ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! (\"Total positive prices: {}\" , total) ; }\n  |\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmp37FahC/main.rs:1:646\n  |\n1 | ... (|| panic ! (\"Key not found\")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! (\"Total positive prices: {}\" ,...\n  |                                                ^^                                         ^^\n  |\nhelp: remove these braces\n  |\n1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; ; for row in df . iter_rows () { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } } ; let mut total = 0f64 ; ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) . iter () { { if value > 0f64 { total = total + value } } } ; println ! (\"Total positive prices: {}\" , total) ; }\n1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"inventory.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; ; for row in df . iter_rows () { { if row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) < 10 { println ! (\"Low stock alert: {} ({})\" , row . get (\"product\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , row . get (\"quantity\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\"))) } } } ; let mut total = 0f64 ; ; for value in df . get (\"price\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) . iter () { if value > 0f64 { total = total + value } } ; println ! (\"Total positive prices: {}\" , total) ; }\n  |\n\nerror: aborting due to 1 previous error; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch05-00-control-flow-tdd.md",
          "example_number": 17,
          "line_number": 388,
          "code": "fun main() {\n    let df = DataFrame::from_csv(\"customers.csv\");\n    \n    for row in df.iter_rows() {\n        let category = match row[\"total_purchases\"] {\n            v if v > 10000 => \"Platinum\",\n            v if v > 5000 => \"Gold\",\n            v if v > 1000 => \"Silver\",\n            _ => \"Bronze\"\n        };\n        \n        println(\"Customer {} is {} tier\", row[\"name\"], category);\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "DEBUG: transpile_function called for function: main\nâœ— Compilation failed: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmpwwbXZz/main.rs:1:23\n  |\n1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"customers.csv\") . expect (\"Failed to open CSV file\") . finish () . ex...\n  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpwwbXZz/main.rs:1:173\n  |\n1 | ... . finish () . expect (\"Failed to read CSV file\") ; ; for row in df . iter_rows () { { { let category = match row . get (\"total_purcha...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpwwbXZz/main.rs:1:206\n  |\n1 | ... { { { let category = match row . get (\"total_purchases\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) { v if v > 10000 => \"Platinum\" , v if v > 5000 => \"Gold\" , v if v > 1000 => \"Silver\" , _ => \"Bronze\" , } ; println ! (\"Customer {} is {} tier\" , row . get (\"name\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , category) } } } ; }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"customers.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; ; for row in df . iter_rows () { { { let category = match row . get (\"total_purchases\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) { v if v > 10000 => \"Platinum\" , v if v > 5000 => \"Gold\" , v if v > 1000 => \"Silver\" , _ => \"Bronze\" , } ; println ! (\"Customer {} is {} tier\" , row . get (\"name\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , category) } } } ; }\n1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"customers.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; ; for row in df . iter_rows () { { let category = match row . get (\"total_purchases\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) { v if v > 10000 => \"Platinum\" , v if v > 5000 => \"Gold\" , v if v > 1000 => \"Silver\" , _ => \"Bronze\" , } ; println ! (\"Customer {} is {} tier\" , row . get (\"name\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , category) } } ; }\n  |\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\nError: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmpwwbXZz/main.rs:1:23\n  |\n1 | fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"customers.csv\") . expect (\"Failed to open CSV file\") . finish () . ex...\n  |                       ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpwwbXZz/main.rs:1:173\n  |\n1 | ... . finish () . expect (\"Failed to read CSV file\") ; ; for row in df . iter_rows () { { { let category = match row . get (\"total_purcha...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpwwbXZz/main.rs:1:206\n  |\n1 | ... { { { let category = match row . get (\"total_purchases\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) { v if v > 10000 => \"Platinum\" , v if v > 5000 => \"Gold\" , v if v > 1000 => \"Silver\" , _ => \"Bronze\" , } ; println ! (\"Customer {} is {} tier\" , row . get (\"name\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , category) } } } ; }\n  |       ^^                                                                                                                                                                                                                                                                                                                                                              ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"customers.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; ; for row in df . iter_rows () { { { let category = match row . get (\"total_purchases\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) { v if v > 10000 => \"Platinum\" , v if v > 5000 => \"Gold\" , v if v > 1000 => \"Silver\" , _ => \"Bronze\" , } ; println ! (\"Customer {} is {} tier\" , row . get (\"name\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , category) } } } ; }\n1 + fn main () { let df = polars :: prelude :: CsvReader :: from_path (\"customers.csv\") . expect (\"Failed to open CSV file\") . finish () . expect (\"Failed to read CSV file\") ; ; for row in df . iter_rows () { { let category = match row . get (\"total_purchases\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) { v if v > 10000 => \"Platinum\" , v if v > 5000 => \"Gold\" , v if v > 1000 => \"Silver\" , _ => \"Bronze\" , } ; println ! (\"Customer {} is {} tier\" , row . get (\"name\") . cloned () . unwrap_or_else (|| panic ! (\"Key not found\")) , category) } } ; }\n  |\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch02-00-variables-types-tdd": {
      "chapter": "ch02-00-variables-types-tdd",
      "total_examples": 8,
      "working_examples": 8,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun main() {\n    let x = 42;\n    println(x);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 2,
          "line_number": 51,
          "code": "fun main() {\n    let name = \"Ruchy\";\n    println(name);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 3,
          "line_number": 70,
          "code": "fun main() {\n    let x = 10;\n    let y = 20;\n    let sum = x + y;\n    println(sum);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 4,
          "line_number": 91,
          "code": "fun main() {\n    let pi = 3.14159;\n    let radius = 5.0;\n    let area = pi * radius * radius;\n    println(area);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 5,
          "line_number": 136,
          "code": "fun main() {\n    let outer = 100;\n    // outer is accessible here\n    println(outer);\n}\n// outer is NOT accessible here",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 6,
          "line_number": 163,
          "code": "fun main() {\n    let value1 = 10;\n    let value2 = 20;\n    let result = value1 + value2;\n    println(result);  // Output: 30\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 7,
          "line_number": 173,
          "code": "fun main() {\n    let initial_value = 100;\n    let factor = 2;\n    let adjustment = 50;\n    let divisor = 3;\n    \n    let step1 = initial_value * factor;\n    let step2 = step1 + adjustment;\n    let final_result = step2 / divisor;\n    \n    println(final_result);  // Output: 83\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch02-00-variables-types-tdd.md",
          "example_number": 8,
          "line_number": 189,
          "code": "// Error: âœ— Compilation failed: Compilation failed:\nlet PI = 3.14159;\nlet GRAVITY = 9.81;",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch04-00-practical-patterns-tdd": {
      "chapter": "ch04-00-practical-patterns-tdd",
      "total_examples": 10,
      "working_examples": 5,
      "failing_examples": 5,
      "examples": [
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 1,
          "line_number": 9,
          "code": "// Calculator with validation and error handling\nfun safe_calculate(operation: &str, a: i32, b: i32) -> i32 {\n    if operation == \"add\" {\n        a + b\n    } else if operation == \"subtract\" {\n        a - b\n    } else if operation == \"multiply\" {\n        a * b\n    } else if operation == \"divide\" {\n        if b == 0 {\n            println(\"Error: Division by zero\");\n            0  // Safe default\n        } else {\n            a / b\n        }\n    } else {\n        println(\"Error: Unknown operation '{}'\", operation);\n        0  // Safe default\n    }\n}\n\nfun main() {\n    let result1 = safe_calculate(\"add\", 10, 5);\n    let result2 = safe_calculate(\"divide\", 12, 3);\n    let result3 = safe_calculate(\"divide\", 10, 0);\n    \n    println(\"10 + 5 = {}\", result1);\n    println(\"12 / 3 = {}\", result2);\n    println(\"10 / 0 = {}\", result3);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 2,
          "line_number": 69,
          "code": "fun validate_user_input(name: &str, age: i32, email: &str) -> bool {\n    // Guard clause: check for empty name\n    if name.len() == 0 {\n        println(\"Error: Name cannot be empty\");\n        return false;\n    }\n    \n    // Guard clause: check age range\n    if age < 0 || age > 150 {\n        println(\"Error: Age must be between 0 and 150\");\n        return false;\n    }\n    \n    // Guard clause: basic email validation\n    if !email.contains('@') {\n        println(\"Error: Invalid email format\");\n        return false;\n    }\n    \n    // All validations passed\n    println(\"User input is valid\");\n    return true;\n}\n\nfun create_user_profile(name: &str, age: i32, email: &str) -> &str {\n    if validate_user_input(name, age, email) {\n        println(\"Creating profile for: {}\", name);\n        return \"Profile created successfully\";\n    } else {\n        return \"Profile creation failed\";\n    }\n}\n\nfun main() {\n    let result1 = create_user_profile(\"Alice\", 25, \"alice@example.com\");\n    let result2 = create_user_profile(\"\", 30, \"bob@example.com\");\n    let result3 = create_user_profile(\"Charlie\", -5, \"charlie@example.com\");\n    \n    println(\"Result 1: {}\", result1);\n    println(\"Result 2: {}\", result2); \n    println(\"Result 3: {}\", result3);\n}",
          "passed": false,
          "status": "broken",
          "error": "DEBUG: transpile_function called for function: validate_user_input\nDEBUG: transpile_function called for function: create_user_profile\nDEBUG: transpile_function called for function: main\nâœ— Compilation failed: Compilation failed:\nerror[E0106]: missing lifetime specifier\n --> /tmp/.tmp6gBRKq/main.rs:1:468\n  |\n1 | ...n create_user_profile (name : & str , age : i32 , email : & str) -> & str { if validate_user_input (name , age , email) { println ! (\"...\n  |                                  -----                       -----     ^ expected named lifetime parameter\n  |\n  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `name` or `email`\nhelp: consider introducing a named lifetime parameter\n  |\n1 | fn validate_user_input (name : & str , age : i32 , email : & str) -> bool { if name . len () == 0 { println ! (\"Error: Name cannot be empty\") ; return false } ; if age < 0 || age > 150 { println ! (\"Error: Age must be between 0 and 150\") ; return false } ; if ! email . contains ('@') { println ! (\"Error: Invalid email format\") ; return false } ; println ! (\"User input is valid\") ; return true } fn create_user_profile<'a> (name : &'a  str , age : i32 , email : &'a  str) -> &'a  str { if validate_user_input (name , age , email) { println ! (\"Creating profile for: {}\" , name) ; return \"Profile created successfully\" } else { return \"Profile creation failed\" } } fn main () { { let result1 = create_user_profile (\"Alice\" , 25 , \"alice@example.com\") ; { let result2 = create_user_profile (\"\" , 30 , \"bob@example.com\") ; ; let result3 = create_user_profile (\"Charlie\" , - 5 , \"charlie@example.com\") ; ; println ! (\"Result 1: {}\" , result1) ; println ! (\"Result 2: {}\" , result2) ; println ! (\"Result 3: {}\" , result3) } } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                     ++++          ++                             ++           ++\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp6gBRKq/main.rs:1:810\n  |\n1 | ...create_user_profile (\"\" , 30 , \"bob@example.com\") ; ; let result3 = create_user_profile (\"Charlie\" , - 5 , \"charlie@example.com\") ; ; ...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp6gBRKq/main.rs:1:890\n  |\n1 | ...profile (\"Charlie\" , - 5 , \"charlie@example.com\") ; ; println ! (\"Result 1: {}\" , result1) ; println ! (\"Result 2: {}\" , result2) ; pr...\n  |                                                        ^ help: remove this semicolon\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0106`.\n\nError: Compilation failed:\nerror[E0106]: missing lifetime specifier\n --> /tmp/.tmp6gBRKq/main.rs:1:468\n  |\n1 | ...n create_user_profile (name : & str , age : i32 , email : & str) -> & str { if validate_user_input (name , age , email) { println ! (\"...\n  |                                  -----                       -----     ^ expected named lifetime parameter\n  |\n  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `name` or `email`\nhelp: consider introducing a named lifetime parameter\n  |\n1 | fn validate_user_input (name : & str , age : i32 , email : & str) -> bool { if name . len () == 0 { println ! (\"Error: Name cannot be empty\") ; return false } ; if age < 0 || age > 150 { println ! (\"Error: Age must be between 0 and 150\") ; return false } ; if ! email . contains ('@') { println ! (\"Error: Invalid email format\") ; return false } ; println ! (\"User input is valid\") ; return true } fn create_user_profile<'a> (name : &'a  str , age : i32 , email : &'a  str) -> &'a  str { if validate_user_input (name , age , email) { println ! (\"Creating profile for: {}\" , name) ; return \"Profile created successfully\" } else { return \"Profile creation failed\" } } fn main () { { let result1 = create_user_profile (\"Alice\" , 25 , \"alice@example.com\") ; { let result2 = create_user_profile (\"\" , 30 , \"bob@example.com\") ; ; let result3 = create_user_profile (\"Charlie\" , - 5 , \"charlie@example.com\") ; ; println ! (\"Result 1: {}\" , result1) ; println ! (\"Result 2: {}\" , result2) ; println ! (\"Result 3: {}\" , result3) } } }\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                     ++++          ++                             ++           ++\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp6gBRKq/main.rs:1:810\n  |\n1 | ...create_user_profile (\"\" , 30 , \"bob@example.com\") ; ; let result3 = create_user_profile (\"Charlie\" , - 5 , \"charlie@example.com\") ; ; ...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmp6gBRKq/main.rs:1:890\n  |\n1 | ...profile (\"Charlie\" , - 5 , \"charlie@example.com\") ; ; println ! (\"Result 1: {}\" , result1) ; println ! (\"Result 2: {}\" , result2) ; pr...\n  |                                                        ^ help: remove this semicolon\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0106`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 3,
          "line_number": 116,
          "code": "fun process_score(raw_score: i32, max_score: i32) -> f64 {\n    // Step 1: Validate inputs\n    if max_score <= 0 {\n        println(\"Error: Max score must be positive\");\n        return 0.0;\n    }\n    \n    if raw_score < 0 {\n        println(\"Warning: Negative score adjusted to 0\");\n        return 0.0;\n    }\n    \n    if raw_score > max_score {\n        println(\"Warning: Score exceeds maximum, capping at {}\", max_score);\n        return 100.0;\n    }\n    \n    // Step 2: Calculate percentage\n    let percentage = (raw_score as f64) / (max_score as f64) * 100.0;\n    \n    // Step 3: Round to reasonable precision\n    let rounded = (percentage * 10.0).round() / 10.0;\n    \n    // Step 4: Return result\n    rounded\n}\n\nfun grade_assignment(student: &str, raw_score: i32, max_score: i32) -> &str {\n    let percentage = process_score(raw_score, max_score);\n    \n    println(\"Student: {}\", student);\n    println(\"Score: {}/{} ({:.1}%)\", raw_score, max_score, percentage);\n    \n    // Letter grade assignment\n    if percentage >= 90.0 {\n        return \"A\";\n    } else if percentage >= 80.0 {\n        return \"B\";\n    } else if percentage >= 70.0 {\n        return \"C\";\n    } else if percentage >= 60.0 {\n        return \"D\";\n    } else {\n        return \"F\";\n    }\n}\n\nfun main() {\n    let grade1 = grade_assignment(\"Alice\", 95, 100);\n    let grade2 = grade_assignment(\"Bob\", 42, 50);\n    let grade3 = grade_assignment(\"Charlie\", 150, 100);\n    \n    println(\"Grades: {}, {}, {}\", grade1, grade2, grade3);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 4,
          "line_number": 175,
          "code": "fun get_setting(setting_name: &str, default_value: i32) -> i32 {\n    // Simulate configuration lookup\n    if setting_name == \"timeout\" {\n        return 30;\n    } else if setting_name == \"max_retries\" {\n        return 3;\n    } else if setting_name == \"buffer_size\" {\n        return 1024;\n    } else {\n        println(\"Warning: Unknown setting '{}', using default {}\", setting_name, default_value);\n        return default_value;\n    }\n}\n\nfun initialize_system() -> bool {\n    println(\"Initializing system...\");\n    \n    // Get settings with defaults\n    let timeout = get_setting(\"timeout\", 15);\n    let retries = get_setting(\"max_retries\", 1);\n    let buffer = get_setting(\"buffer_size\", 512);\n    let unknown = get_setting(\"cache_size\", 256);\n    \n    // Display configuration\n    println(\"Configuration:\");\n    println(\"  Timeout: {} seconds\", timeout);\n    println(\"  Max retries: {}\", retries);\n    println(\"  Buffer size: {} bytes\", buffer);\n    println(\"  Cache size: {} MB\", unknown);\n    \n    // Validate critical settings\n    if timeout <= 0 {\n        println(\"Error: Timeout must be positive\");\n        return false;\n    }\n    \n    if retries < 0 {\n        println(\"Error: Retries cannot be negative\");\n        return false;\n    }\n    \n    println(\"âœ… System initialized successfully\");\n    return true;\n}\n\nfun main() {\n    let success = initialize_system();\n    \n    if success {\n        println(\"System is ready for operation\");\n    } else {\n        println(\"System initialization failed\");\n    }\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 5,
          "line_number": 236,
          "code": "fun calculate_total(prices: [i32; 5]) -> i32 {\n    let mut total = 0;  // Accumulator starts at zero\n    let mut i = 0;\n    \n    while i < 5 {\n        total = total + prices[i];  // Accumulate each value\n        i = i + 1;\n    }\n    \n    total  // Return accumulated result\n}\n\nfun find_maximum(numbers: [i32; 5]) -> i32 {\n    let mut max_value = numbers[0];  // Accumulator starts with first value\n    let mut i = 1;\n    \n    while i < 5 {\n        if numbers[i] > max_value {\n            max_value = numbers[i];  // Update accumulator if better value found\n        }\n        i = i + 1;\n    }\n    \n    max_value  // Return best value found\n}\n\nfun count_positives(numbers: [i32; 5]) -> i32 {\n    let mut count = 0;  // Counter accumulator\n    let mut i = 0;\n    \n    while i < 5 {\n        if numbers[i] > 0 {\n            count = count + 1;  // Increment counter for matches\n        }\n        i = i + 1;\n    }\n    \n    count  // Return count\n}\n\nfun main() {\n    let prices = [10, 25, 5, 15, 8];\n    let numbers = [-3, 7, -1, 12, 0];\n    \n    let total = calculate_total(prices);\n    let maximum = find_maximum(prices);\n    let positive_count = count_positives(numbers);\n    \n    println(\"Total: {}\", total);\n    println(\"Maximum: {}\", maximum);\n    println(\"Positive numbers: {}\", positive_count);\n}",
          "passed": false,
          "status": "broken",
          "error": "DEBUG: transpile_function called for function: calculate_total\nDEBUG: transpile_function called for function: find_maximum\nDEBUG: transpile_function called for function: count_positives\nDEBUG: transpile_function called for function: main\nâœ— Compilation failed: Compilation failed:\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:70\n  |\n1 | fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0 ; ; let mut i = 0 ; ; while i < 5 { { total = total + prices [i as usi...\n  |                                                                      ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:88\n  |\n1 | fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0 ; ; let mut i = 0 ; ; while i < 5 { { total = total + prices [i as usi...\n  |                                                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:258\n  |\n1 | ...-> i32 { let mut max_value = numbers [0 as usize] ; ; let mut i = 1 ; ; while i < 5 { { if numbers [i as usize] > max_value { max_valu...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:276\n  |\n1 | ...ax_value = numbers [0 as usize] ; ; let mut i = 1 ; ; while i < 5 { { if numbers [i as usize] > max_value { max_value = numbers [i as ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:467\n  |\n1 | ... (numbers : [i32 ; 5]) -> i32 { let mut count = 0 ; ; let mut i = 0 ; ; while i < 5 { { if numbers [i as usize] > 0 { count = count + ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:485\n  |\n1 | ... 5]) -> i32 { let mut count = 0 ; ; let mut i = 0 ; ; while i < 5 { { if numbers [i as usize] > 0 { count = count + 1 } ; i = i + 1 } ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:687\n  |\n1 | ... ; { let numbers = vec ! [- 3 , 7 , - 1 , 12 , 0] ; ; let total = calculate_total (prices) ; ; let maximum = find_maximum (prices) ; ;...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:728\n  |\n1 | ... 12 , 0] ; ; let total = calculate_total (prices) ; ; let maximum = find_maximum (prices) ; ; let positive_count = count_positives (nu...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:768\n  |\n1 | ... (prices) ; ; let maximum = find_maximum (prices) ; ; let positive_count = count_positives (numbers) ; ; println ! (\"Total: {}\" , tota...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:819\n  |\n1 | ... ; let positive_count = count_positives (numbers) ; ; println ! (\"Total: {}\" , total) ; println ! (\"Maximum: {}\" , maximum) ; println ...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpx6t8ir/main.rs:1:718\n  |\n1 | ... , - 1 , 12 , 0] ; ; let total = calculate_total (prices) ; ; let maximum = find_maximum (prices) ; ; let positive_count = count_posit...\n  |                                     ---------------  ^^^^^^ expected `[i32; 5]`, found `Vec<{integer}>`\n  |                                     |\n  |                                     arguments to this function are incorrect\n  |\n  = note: expected array `[i32; 5]`\n            found struct `Vec<{integer}>`\nnote: function defined here\n --> /tmp/.tmpx6t8ir/main.rs:1:4\n  |\n1 | fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0 ; ; let mut i = 0 ; ; while i < 5 { { total = total + prices [i as usi...\n  |    ^^^^^^^^^^^^^^^  ------------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpx6t8ir/main.rs:1:758\n  |\n1 | ...e_total (prices) ; ; let maximum = find_maximum (prices) ; ; let positive_count = count_positives (numbers) ; ; println ! (\"Total: {}\"...\n  |                                       ------------  ^^^^^^ expected `[i32; 5]`, found `Vec<{integer}>`\n  |                                       |\n  |                                       arguments to this function are incorrect\n  |\n  = note: expected array `[i32; 5]`\n            found struct `Vec<{integer}>`\nnote: function defined here\n --> /tmp/.tmpx6t8ir/main.rs:1:171\n  |\n1 | ... prices [i as usize] ; i = i + 1 } } ; total } fn find_maximum (numbers : [i32 ; 5]) -> i32 { let mut max_value = numbers [0 as usize]...\n  |                                                      ^^^^^^^^^^^^  -------------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpx6t8ir/main.rs:1:808\n  |\n1 | ...prices) ; ; let positive_count = count_positives (numbers) ; ; println ! (\"Total: {}\" , total) ; println ! (\"Maximum: {}\" , maximum) ;...\n  |                                     ---------------  ^^^^^^^ expected `[i32; 5]`, found `Vec<{integer}>`\n  |                                     |\n  |                                     arguments to this function are incorrect\n  |\n  = note: expected array `[i32; 5]`\n            found struct `Vec<{integer}>`\nnote: function defined here\n --> /tmp/.tmpx6t8ir/main.rs:1:400\n  |\n1 | ...[i as usize] } ; i = i + 1 } } ; max_value } fn count_positives (numbers : [i32 ; 5]) -> i32 { let mut count = 0 ; ; let mut i = 0 ; ;...\n  |                                                    ^^^^^^^^^^^^^^^  -------------------\n\nerror: aborting due to 3 previous errors; 10 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\nError: Compilation failed:\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:70\n  |\n1 | fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0 ; ; let mut i = 0 ; ; while i < 5 { { total = total + prices [i as usi...\n  |                                                                      ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:88\n  |\n1 | fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0 ; ; let mut i = 0 ; ; while i < 5 { { total = total + prices [i as usi...\n  |                                                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:258\n  |\n1 | ...-> i32 { let mut max_value = numbers [0 as usize] ; ; let mut i = 1 ; ; while i < 5 { { if numbers [i as usize] > max_value { max_valu...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:276\n  |\n1 | ...ax_value = numbers [0 as usize] ; ; let mut i = 1 ; ; while i < 5 { { if numbers [i as usize] > max_value { max_value = numbers [i as ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:467\n  |\n1 | ... (numbers : [i32 ; 5]) -> i32 { let mut count = 0 ; ; let mut i = 0 ; ; while i < 5 { { if numbers [i as usize] > 0 { count = count + ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:485\n  |\n1 | ... 5]) -> i32 { let mut count = 0 ; ; let mut i = 0 ; ; while i < 5 { { if numbers [i as usize] > 0 { count = count + 1 } ; i = i + 1 } ...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:687\n  |\n1 | ... ; { let numbers = vec ! [- 3 , 7 , - 1 , 12 , 0] ; ; let total = calculate_total (prices) ; ; let maximum = find_maximum (prices) ; ;...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:728\n  |\n1 | ... 12 , 0] ; ; let total = calculate_total (prices) ; ; let maximum = find_maximum (prices) ; ; let positive_count = count_positives (nu...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:768\n  |\n1 | ... (prices) ; ; let maximum = find_maximum (prices) ; ; let positive_count = count_positives (numbers) ; ; println ! (\"Total: {}\" , tota...\n  |                                                        ^ help: remove this semicolon\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpx6t8ir/main.rs:1:819\n  |\n1 | ... ; let positive_count = count_positives (numbers) ; ; println ! (\"Total: {}\" , total) ; println ! (\"Maximum: {}\" , maximum) ; println ...\n  |                                                        ^ help: remove this semicolon\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpx6t8ir/main.rs:1:718\n  |\n1 | ... , - 1 , 12 , 0] ; ; let total = calculate_total (prices) ; ; let maximum = find_maximum (prices) ; ; let positive_count = count_posit...\n  |                                     ---------------  ^^^^^^ expected `[i32; 5]`, found `Vec<{integer}>`\n  |                                     |\n  |                                     arguments to this function are incorrect\n  |\n  = note: expected array `[i32; 5]`\n            found struct `Vec<{integer}>`\nnote: function defined here\n --> /tmp/.tmpx6t8ir/main.rs:1:4\n  |\n1 | fn calculate_total (prices : [i32 ; 5]) -> i32 { let mut total = 0 ; ; let mut i = 0 ; ; while i < 5 { { total = total + prices [i as usi...\n  |    ^^^^^^^^^^^^^^^  ------------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpx6t8ir/main.rs:1:758\n  |\n1 | ...e_total (prices) ; ; let maximum = find_maximum (prices) ; ; let positive_count = count_positives (numbers) ; ; println ! (\"Total: {}\"...\n  |                                       ------------  ^^^^^^ expected `[i32; 5]`, found `Vec<{integer}>`\n  |                                       |\n  |                                       arguments to this function are incorrect\n  |\n  = note: expected array `[i32; 5]`\n            found struct `Vec<{integer}>`\nnote: function defined here\n --> /tmp/.tmpx6t8ir/main.rs:1:171\n  |\n1 | ... prices [i as usize] ; i = i + 1 } } ; total } fn find_maximum (numbers : [i32 ; 5]) -> i32 { let mut max_value = numbers [0 as usize]...\n  |                                                      ^^^^^^^^^^^^  -------------------\n\nerror[E0308]: mismatched types\n --> /tmp/.tmpx6t8ir/main.rs:1:808\n  |\n1 | ...prices) ; ; let positive_count = count_positives (numbers) ; ; println ! (\"Total: {}\" , total) ; println ! (\"Maximum: {}\" , maximum) ;...\n  |                                     ---------------  ^^^^^^^ expected `[i32; 5]`, found `Vec<{integer}>`\n  |                                     |\n  |                                     arguments to this function are incorrect\n  |\n  = note: expected array `[i32; 5]`\n            found struct `Vec<{integer}>`\nnote: function defined here\n --> /tmp/.tmpx6t8ir/main.rs:1:400\n  |\n1 | ...[i as usize] } ; i = i + 1 } } ; max_value } fn count_positives (numbers : [i32 ; 5]) -> i32 { let mut count = 0 ; ; let mut i = 0 ; ;...\n  |                                                    ^^^^^^^^^^^^^^^  -------------------\n\nerror: aborting due to 3 previous errors; 10 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 6,
          "line_number": 293,
          "code": "fun process_order_state(current_state: &str, action: &str) -> &str {\n    if current_state == \"pending\" {\n        if action == \"pay\" {\n            println(\"Payment received, order confirmed\");\n            return \"confirmed\";\n        } else if action == \"cancel\" {\n            println(\"Order cancelled\");\n            return \"cancelled\";\n        } else {\n            println(\"Invalid action '{}' for pending order\", action);\n            return current_state;\n        }\n    } else if current_state == \"confirmed\" {\n        if action == \"ship\" {\n            println(\"Order shipped\");\n            return \"shipped\";\n        } else if action == \"cancel\" {\n            println(\"Confirmed order cancelled, refund processed\");\n            return \"cancelled\";\n        } else {\n            println(\"Invalid action '{}' for confirmed order\", action);\n            return current_state;\n        }\n    } else if current_state == \"shipped\" {\n        if action == \"deliver\" {\n            println(\"Order delivered\");\n            return \"delivered\";\n        } else {\n            println(\"Cannot modify shipped order\");\n            return current_state;\n        }\n    } else if current_state == \"delivered\" {\n        println(\"Order already completed\");\n        return current_state;\n    } else if current_state == \"cancelled\" {\n        println(\"Order was cancelled\");\n        return current_state;\n    } else {\n        println(\"Unknown order state: {}\", current_state);\n        return \"error\";\n    }\n}\n\nfun track_order() -> &str {\n    let mut state = \"pending\";\n    \n    println(\"Order tracking simulation:\");\n    println(\"Initial state: {}\", state);\n    \n    // Process sequence of actions\n    state = process_order_state(state, \"pay\");\n    println(\"Current state: {}\", state);\n    \n    state = process_order_state(state, \"ship\");\n    println(\"Current state: {}\", state);\n    \n    state = process_order_state(state, \"deliver\");\n    println(\"Current state: {}\", state);\n    \n    state\n}\n\nfun main() {\n    let final_state = track_order();\n    println(\"Final order state: {}\", final_state);\n}",
          "passed": false,
          "status": "broken",
          "error": "âœ— Compilation failed: Failed to parse Ruchy source\nError: Failed to parse Ruchy source\n\nCaused by:\n    Expected RightBrace, found Let\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 7,
          "line_number": 364,
          "code": "fun build_greeting(name: &str, formal: bool, include_time: bool) -> String {\n    let mut greeting = String::new();\n    \n    // Start with appropriate formality\n    if formal {\n        greeting = greeting + \"Good day, \";\n    } else {\n        greeting = greeting + \"Hello, \";\n    }\n    \n    // Add the name\n    greeting = greeting + name;\n    \n    // Add time information if requested\n    if include_time {\n        greeting = greeting + \"! Hope you're having a great day\";\n    } else {\n        greeting = greeting + \"!\";\n    }\n    \n    greeting\n}\n\nfun build_email_subject(priority: &str, department: &str, topic: &str) -> String {\n    let mut subject = String::new();\n    \n    // Add priority prefix\n    if priority == \"urgent\" {\n        subject = subject + \"[URGENT] \";\n    } else if priority == \"high\" {\n        subject = subject + \"[HIGH] \";\n    }\n    \n    // Add department prefix\n    subject = subject + \"[\" + department + \"] \";\n    \n    // Add main topic\n    subject = subject + topic;\n    \n    subject\n}\n\nfun main() {\n    let greeting1 = build_greeting(\"Alice\", true, true);\n    let greeting2 = build_greeting(\"Bob\", false, false);\n    \n    let subject1 = build_email_subject(\"urgent\", \"IT\", \"Server maintenance required\");\n    let subject2 = build_email_subject(\"normal\", \"HR\", \"Team meeting scheduled\");\n    \n    println(\"Greetings:\");\n    println(\"  {}\", greeting1);\n    println(\"  {}\", greeting2);\n    \n    println(\"Email subjects:\");\n    println(\"  {}\", subject1);\n    println(\"  {}\", subject2);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 8,
          "line_number": 428,
          "code": "fun process_student_data(name: &str, scores: [i32; 3]) -> String {\n    // Pattern 1: Input validation\n    if name.len() == 0 {\n        return String::from(\"Error: Student name required\");\n    }\n    \n    // Pattern 2: Accumulator for total\n    let mut total = 0;\n    let mut i = 0;\n    while i < 3 {\n        if scores[i] < 0 || scores[i] > 100 {\n            return String::from(\"Error: Scores must be between 0 and 100\");\n        }\n        total = total + scores[i];\n        i = i + 1;\n    }\n    \n    // Pattern 3: Calculation with validation\n    let average = total / 3;\n    \n    // Pattern 4: State-based classification\n    let grade = if average >= 90 {\n        \"A\"\n    } else if average >= 80 {\n        \"B\"\n    } else if average >= 70 {\n        \"C\"\n    } else if average >= 60 {\n        \"D\"\n    } else {\n        \"F\"\n    };\n    \n    // Pattern 5: Builder pattern for result\n    let mut result = String::from(\"Student Report\\n\");\n    result = result + \"Name: \" + name + \"\\n\";\n    result = result + \"Scores: \";\n    \n    // Add individual scores\n    let mut i = 0;\n    while i < 3 {\n        if i > 0 {\n            result = result + \", \";\n        }\n        result = result + &scores[i].to_string();\n        i = i + 1;\n    }\n    \n    result = result + \"\\n\";\n    result = result + \"Average: \" + &average.to_string() + \"\\n\";\n    result = result + \"Grade: \" + grade;\n    \n    result\n}\n\nfun main() {\n    let report1 = process_student_data(\"Alice Johnson\", [95, 87, 92]);\n    let report2 = process_student_data(\"Bob Smith\", [78, 82, 75]);\n    let report3 = process_student_data(\"\", [85, 90, 88]);\n    \n    println(\"{}\\n\", report1);\n    println(\"{}\\n\", report2);  \n    println(\"{}\\n\", report3);\n}",
          "passed": false,
          "status": "broken",
          "error": "âœ— Compilation failed: Failed to parse Ruchy source\nError: Failed to parse Ruchy source\n\nCaused by:\n    Expected RightBrace, found If\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 9,
          "line_number": 499,
          "code": "// Test helper function\nfun assert_equal(actual: i32, expected: i32, test_name: &str) {\n    if actual == expected {\n        println(\"âœ… {}: {} == {}\", test_name, actual, expected);\n    } else {\n        println(\"âŒ {}: {} != {} (expected)\", test_name, actual, expected);\n    }\n}\n\nfun assert_string_equal(actual: &str, expected: &str, test_name: &str) {\n    if actual == expected {\n        println(\"âœ… {}: strings match\", test_name);\n    } else {\n        println(\"âŒ {}: '{}' != '{}' (expected)\", test_name, actual, expected);\n    }\n}\n\n// Function to test\nfun calculate_discount(price: i32, discount_percent: i32) -> i32 {\n    if discount_percent < 0 || discount_percent > 100 {\n        return price;  // No discount for invalid percentage\n    }\n    \n    let discount_amount = (price * discount_percent) / 100;\n    price - discount_amount\n}\n\n// Test suite\nfun test_discount_calculation() {\n    println(\"Testing discount calculation...\");\n    \n    // Normal cases\n    assert_equal(calculate_discount(100, 10), 90, \"10% discount on $100\");\n    assert_equal(calculate_discount(50, 20), 40, \"20% discount on $50\");\n    assert_equal(calculate_discount(200, 0), 200, \"0% discount on $200\");\n    \n    // Edge cases\n    assert_equal(calculate_discount(100, -5), 100, \"Negative discount\");\n    assert_equal(calculate_discount(100, 150), 100, \"Over 100% discount\");\n    assert_equal(calculate_discount(0, 50), 0, \"50% discount on $0\");\n    \n    println(\"Discount tests completed.\\n\");\n}\n\nfun main() {\n    test_discount_calculation();\n    \n    // Demo the actual function\n    println(\"Discount examples:\");\n    println(\"$100 with 15% discount: ${}\", calculate_discount(100, 15));\n    println(\"$250 with 25% discount: ${}\", calculate_discount(250, 25));\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch04-00-practical-patterns-tdd.md",
          "example_number": 10,
          "line_number": 558,
          "code": "fun count_word_frequencies(text: &str) -> i32 {\n    // Simple word counting simulation\n    // In real implementation, this would be more sophisticated\n    let mut word_count = 0;\n    let mut in_word = false;\n    let chars = text.as_bytes();\n    let mut i = 0;\n    \n    while i < text.len() {\n        let ch = chars[i];\n        \n        // Simple word boundary detection\n        if ch == b' ' || ch == b'\\n' || ch == b'\\t' {\n            if in_word {\n                word_count = word_count + 1;\n                in_word = false;\n            }\n        } else {\n            if !in_word {\n                in_word = true;\n            }\n        }\n        \n        i = i + 1;\n    }\n    \n    // Count the last word if text doesn't end with whitespace\n    if in_word {\n        word_count = word_count + 1;\n    }\n    \n    word_count\n}\n\nfun process_text_efficiently(text: &str) -> String {\n    let word_count = count_word_frequencies(text);\n    let char_count = text.len();\n    \n    // Build result efficiently\n    let mut result = String::from(\"Text Analysis:\\n\");\n    result = result + \"Characters: \" + &char_count.to_string() + \"\\n\";\n    result = result + \"Words: \" + &word_count.to_string() + \"\\n\";\n    \n    // Calculate average word length\n    let avg_word_length = if word_count > 0 {\n        char_count / (word_count as usize)\n    } else {\n        0\n    };\n    \n    result = result + \"Average word length: \" + &avg_word_length.to_string();\n    \n    result\n}\n\nfun main() {\n    let sample_text = \"Hello world this is a simple text processing example\";\n    let analysis = process_text_efficiently(sample_text);\n    \n    println(\"Sample text: \\\"{}\\\"\", sample_text);\n    println(\"{}\", analysis);\n}",
          "passed": false,
          "status": "broken",
          "error": "âœ— Compilation failed: Failed to parse Ruchy source\nError: Failed to parse Ruchy source\n\nCaused by:\n    Expected RightBrace, found Let\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "conclusion": {
      "chapter": "conclusion",
      "total_examples": 1,
      "working_examples": 1,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/conclusion.md",
          "example_number": 1,
          "line_number": 205,
          "code": "fun calculate(x: i32, y: i32) -> i32 {\n    return x + y;\n}\n\nfun main() {\n    let result = calculate(10, 20);\n    println(result);  // Output: 30\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch01-02-hello-world-tdd": {
      "chapter": "ch01-02-hello-world-tdd",
      "total_examples": 6,
      "working_examples": 6,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun main() {\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 2,
          "line_number": 55,
          "code": "fun main() {\n    println(\"Hello,\");\n    println(\"World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 3,
          "line_number": 75,
          "code": "fun main() {\n    let greeting = \"Hello, World!\";\n    println(greeting);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 4,
          "line_number": 124,
          "code": "println(\"Your message here\");",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 5,
          "line_number": 132,
          "code": "let message = \"Your message\";\nprintln(message);",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world-tdd.md",
          "example_number": 6,
          "line_number": 141,
          "code": "println(\"First line\");\nprintln(\"Second line\");",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch18-00-dataframes-data-processing": {
      "chapter": "ch18-00-dataframes-data-processing",
      "total_examples": 4,
      "working_examples": 0,
      "failing_examples": 4,
      "examples": [
        {
          "file": "src/ch18-00-dataframes-data-processing.md",
          "example_number": 1,
          "line_number": 13,
          "code": "fun create_dataframe() {\n    let df = DataFrame::new()\n        .column(\"employee_id\", [101, 102, 103, 104])\n        .column(\"name\", [\"Alice\", \"Bob\", \"Charlie\", \"Diana\"])\n        .column(\"department\", [\"Engineering\", \"Sales\", \"Engineering\", \"HR\"])\n        .column(\"salary\", [95000, 75000, 105000, 65000])\n        .build();\n    \n    println(\"Created DataFrame with {} employees\", df.rows());\n    println(df);  // Display the DataFrame\n}",
          "passed": false,
          "status": "broken",
          "error": "DEBUG: transpile_function called for function: create_dataframe\nâœ— Compilation failed: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmpKyleL8/main.rs:1:35\n  |\n1 | fn create_dataframe () { let df = polars :: prelude :: DataFrame :: empty () . column (\"employee_id\" , vec ! [101 , 102 , 103 , 104]) . c...\n  |                                   ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpKyleL8/main.rs:1:345\n  |\n1 | ...salary\" , vec ! [95000 , 75000 , 105000 , 65000]) ; ; println ! (\"Created DataFrame with {} employees\" , df . height ()) ; println ! (...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\nError: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmpKyleL8/main.rs:1:35\n  |\n1 | fn create_dataframe () { let df = polars :: prelude :: DataFrame :: empty () . column (\"employee_id\" , vec ! [101 , 102 , 103 , 104]) . c...\n  |                                   ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpKyleL8/main.rs:1:345\n  |\n1 | ...salary\" , vec ! [95000 , 75000 , 105000 , 65000]) ; ; println ! (\"Created DataFrame with {} employees\" , df . height ()) ; println ! (...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-dataframes-data-processing.md",
          "example_number": 2,
          "line_number": 29,
          "code": "fun analyze_sales(df: DataFrame) {\n    println(\"Analyzing {} sales records\", df.rows());\n    println(\"Data has {} columns\", df.columns());\n}\n\nfun main() {\n    let sales = DataFrame::new()\n        .column(\"product\", [\"Widget\", \"Gadget\", \"Gizmo\"])\n        .column(\"quantity\", [100, 150, 200])\n        .column(\"revenue\", [999.00, 1499.00, 1999.00])\n        .build();\n    \n    analyze_sales(sales);\n}",
          "passed": false,
          "status": "broken",
          "error": "DEBUG: transpile_function called for function: analyze_sales\nDEBUG: transpile_function called for function: main\nâœ— Compilation failed: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmplYHTDx/main.rs:1:189\n  |\n1 | ...es ()) ; } fn main () { { let sales = polars :: prelude :: DataFrame :: empty () . column (\"product\" , vec ! [\"Widget\" , \"Gadget\" , \"G...\n  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> /tmp/.tmplYHTDx/main.rs:1:24\n  |\n1 | fn analyze_sales (df : DataFrame) { println ! (\"Analyzing {} sales records\" , df . height ()) ; println ! (\"Data has {} columns\" , df . g...\n  |                        ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n\nError: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmplYHTDx/main.rs:1:189\n  |\n1 | ...es ()) ; } fn main () { { let sales = polars :: prelude :: DataFrame :: empty () . column (\"product\" , vec ! [\"Widget\" , \"Gadget\" , \"G...\n  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nerror[E0412]: cannot find type `DataFrame` in this scope\n --> /tmp/.tmplYHTDx/main.rs:1:24\n  |\n1 | fn analyze_sales (df : DataFrame) { println ! (\"Analyzing {} sales records\" , df . height ()) ; println ! (\"Data has {} columns\" , df . g...\n  |                        ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-dataframes-data-processing.md",
          "example_number": 3,
          "line_number": 48,
          "code": "fun work_with_multiple_dataframes() {\n    let customers = DataFrame::new()\n        .column(\"customer_id\", [1, 2, 3])\n        .column(\"name\", [\"Alice\", \"Bob\", \"Charlie\"])\n        .column(\"city\", [\"New York\", \"Los Angeles\", \"Chicago\"])\n        .build();\n    \n    let orders = DataFrame::new()\n        .column(\"order_id\", [101, 102, 103])\n        .column(\"customer_id\", [1, 2, 1])\n        .column(\"amount\", [99.99, 149.99, 79.99])\n        .build();\n    \n    println(\"Customers: {} rows\", customers.rows());\n    println(\"Orders: {} rows\", orders.rows());\n}",
          "passed": false,
          "status": "broken",
          "error": "DEBUG: transpile_function called for function: work_with_multiple_dataframes\nâœ— Compilation failed: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmpMEcRsI/main.rs:1:57\n  |\n1 | fn work_with_multiple_dataframes () { { let customers = polars :: prelude :: DataFrame :: empty () . column (\"customer_id\" , vec ! [1 , 2...\n  |                                                         ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmpMEcRsI/main.rs:1:285\n  |\n1 | ...geles\" , \"Chicago\"]) ; { let orders = polars :: prelude :: DataFrame :: empty () . column (\"order_id\" , vec ! [101 , 102 , 103]) . col...\n  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpMEcRsI/main.rs:1:485\n  |\n1 | ...mount\" , vec ! [99.99f64 , 149.99f64 , 79.99f64]) ; ; println ! (\"Customers: {} rows\" , customers . rows ()) ; println ! (\"Orders: {} ...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\nError: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmpMEcRsI/main.rs:1:57\n  |\n1 | fn work_with_multiple_dataframes () { { let customers = polars :: prelude :: DataFrame :: empty () . column (\"customer_id\" , vec ! [1 , 2...\n  |                                                         ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmpMEcRsI/main.rs:1:285\n  |\n1 | ...geles\" , \"Chicago\"]) ; { let orders = polars :: prelude :: DataFrame :: empty () . column (\"order_id\" , vec ! [101 , 102 , 103]) . col...\n  |                                          ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpMEcRsI/main.rs:1:485\n  |\n1 | ...mount\" , vec ! [99.99f64 , 149.99f64 , 79.99f64]) ; ; println ! (\"Customers: {} rows\" , customers . rows ()) ; println ! (\"Orders: {} ...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        },
        {
          "file": "src/ch18-00-dataframes-data-processing.md",
          "example_number": 4,
          "line_number": 69,
          "code": "fun conditional_processing() {\n    let df = DataFrame::new()\n        .column(\"status\", [\"active\", \"pending\", \"closed\"])\n        .column(\"value\", [1000, 500, 1500])\n        .build();\n    \n    if df.rows() > 0 {\n        println(\"DataFrame contains data\");\n    }\n    \n    if df.columns() == 2 {\n        println(\"DataFrame has exactly 2 columns\");\n    }\n    \n    for i in 0..df.rows() {\n        println(\"Processing row {}\", i);\n    }\n}",
          "passed": false,
          "status": "broken",
          "error": "DEBUG: transpile_function called for function: conditional_processing\nâœ— Compilation failed: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmpGgoJNQ/main.rs:1:41\n  |\n1 | fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column (\"status\" , vec ! [\"active\" , \"pending\" , \"cl...\n  |                                         ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpGgoJNQ/main.rs:1:195\n  |\n1 | ...]) . column (\"value\" , vec ! [1000 , 500 , 1500]) ; ; if df . height () > 0 { println ! (\"DataFrame contains data\") } ; if df . get_co...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpGgoJNQ/main.rs:1:379\n  |\n1 | ...2 columns\") } ; for i in 0 .. df . height () { { println ! (\"Processing row {}\" , i) } } ; } fn main () { }\n  |                                                   ^^                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column (\"status\" , vec ! [\"active\" , \"pending\" , \"closed\"]) . column (\"value\" , vec ! [1000 , 500 , 1500]) ; ; if df . height () > 0 { println ! (\"DataFrame contains data\") } ; if df . get_column_names () == 2 { println ! (\"DataFrame has exactly 2 columns\") } ; for i in 0 .. df . height () { { println ! (\"Processing row {}\" , i) } } ; } fn main () { }\n1 + fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column (\"status\" , vec ! [\"active\" , \"pending\" , \"closed\"]) . column (\"value\" , vec ! [1000 , 500 , 1500]) ; ; if df . height () > 0 { println ! (\"DataFrame contains data\") } ; if df . get_column_names () == 2 { println ! (\"DataFrame has exactly 2 columns\") } ; for i in 0 .. df . height () { println ! (\"Processing row {}\" , i) } ; } fn main () { }\n  |\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\nError: Compilation failed:\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `polars`\n --> /tmp/.tmpGgoJNQ/main.rs:1:41\n  |\n1 | fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column (\"status\" , vec ! [\"active\" , \"pending\" , \"cl...\n  |                                         ^^^^^^ use of unresolved module or unlinked crate `polars`\n  |\n  = help: you might be missing a crate named `polars`\n\nwarning: unnecessary trailing semicolon\n --> /tmp/.tmpGgoJNQ/main.rs:1:195\n  |\n1 | ...]) . column (\"value\" , vec ! [1000 , 500 , 1500]) ; ; if df . height () > 0 { println ! (\"DataFrame contains data\") } ; if df . get_co...\n  |                                                        ^ help: remove this semicolon\n  |\n  = note: `#[warn(redundant_semicolons)]` on by default\n\nwarning: unnecessary braces around block return value\n --> /tmp/.tmpGgoJNQ/main.rs:1:379\n  |\n1 | ...2 columns\") } ; for i in 0 .. df . height () { { println ! (\"Processing row {}\" , i) } } ; } fn main () { }\n  |                                                   ^^                                   ^^\n  |\n  = note: `#[warn(unused_braces)]` on by default\nhelp: remove these braces\n  |\n1 - fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column (\"status\" , vec ! [\"active\" , \"pending\" , \"closed\"]) . column (\"value\" , vec ! [1000 , 500 , 1500]) ; ; if df . height () > 0 { println ! (\"DataFrame contains data\") } ; if df . get_column_names () == 2 { println ! (\"DataFrame has exactly 2 columns\") } ; for i in 0 .. df . height () { { println ! (\"Processing row {}\" , i) } } ; } fn main () { }\n1 + fn conditional_processing () { let df = polars :: prelude :: DataFrame :: empty () . column (\"status\" , vec ! [\"active\" , \"pending\" , \"closed\"]) . column (\"value\" , vec ! [1000 , 500 , 1500]) ; ; if df . height () > 0 { println ! (\"DataFrame contains data\") } ; if df . get_column_names () == 2 { println ! (\"DataFrame has exactly 2 columns\") } ; for i in 0 .. df . height () { println ! (\"Processing row {}\" , i) } ; } fn main () { }\n  |\n\nerror: aborting due to 1 previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0433`.\n\n",
          "errorCategory": "UNKNOWN",
          "rootCause": "Unknown error - needs manual investigation"
        }
      ]
    },
    "ch10-00-input-output-tdd": {
      "chapter": "ch10-00-input-output-tdd",
      "total_examples": 10,
      "working_examples": 10,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 1,
          "line_number": 32,
          "code": "fun main() {\n    println(\"=== Output Demo ===\");\n    println(\"Number: \");\n    println(42);\n    println(\"Boolean: \");\n    println(true);\n    println(\"=== End Demo ===\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 2,
          "line_number": 60,
          "code": "fun main() {\n    let name = \"Alice\";\n    let age = 30;\n    let height = 5.6;\n    \n    println(\"=== User Profile ===\");\n    println(\"Name:\");\n    println(name);\n    println(\"Age:\");\n    println(age);\n    println(\"Height:\");\n    println(height);\n    println(\"================\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 3,
          "line_number": 96,
          "code": "fun display_menu() {\n    println(\"=== Main Menu ===\");\n    println(\"1. View Profile\");\n    println(\"2. Settings\");\n    println(\"3. Exit\");\n    println(\"=================\");\n}\n\nfun main() {\n    display_menu();\n    println(\"Menu displayed successfully\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 4,
          "line_number": 147,
          "code": "fun main() {\n    let variable = \"Hello World\";\n    println(\"text message\");\n    println(variable);\n    println(42);\n    println(true);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 5,
          "line_number": 158,
          "code": "fun main() {\n    let value = \"Important Data\";\n    let data = value;\n    println(\"Label:\");\n    println(data);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 6,
          "line_number": 168,
          "code": "fun display_options() {\n    println(\"=== Menu ===\");\n    println(\"1. Option One\");\n    println(\"2. Option Two\");\n    println(\"============\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 7,
          "line_number": 195,
          "code": "let value = 100;\nprintln(\"Result:\");\nprintln(value);",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 8,
          "line_number": 205,
          "code": "// Error: âœ— Compilation failed: Failed to parse Ruchy source\nfun display_report(title: &str, data: i32) {\n    println(\"=== Report ===\");\n    println(title);\n    println(data);\n    println(\"==============\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 9,
          "line_number": 218,
          "code": "println(\"Processing...\");\n// ... do work ...\nprintln(\"Complete!\");",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch10-00-input-output-tdd.md",
          "example_number": 10,
          "line_number": 228,
          "code": "fun show_options() {\n    println(\"Choose an option:\");\n    println(\"1. Start\");\n    println(\"2. Stop\");\n    println(\"3. Help\");\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch01-02-hello-world": {
      "chapter": "ch01-02-hello-world",
      "total_examples": 8,
      "working_examples": 8,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 1,
          "line_number": 30,
          "code": "fun main() {\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 2,
          "line_number": 86,
          "code": "fun main() {\n    println(\"Hello\", \"World\", \"from\", \"Ruchy\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 3,
          "line_number": 106,
          "code": "fun main() {\n    let name = \"Alice\";\n    println(\"Hello,\", name);\n    \n    // String concatenation (interpolation coming in future versions)\n    println(\"Hello, \" + name + \"!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 4,
          "line_number": 131,
          "code": "fun main() {\n    println(\"The answer is\", 42);\n    println(\"Pi is approximately\", 3.14159);\n    println(\"Is Ruchy awesome?\", true);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 5,
          "line_number": 156,
          "code": "// âŒ This won't work - intentional error example\n// println(Hello, World!);\n//\n\n// Always use quotes for literal text.\n\nfun main() {\n    // âœ… Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 6,
          "line_number": 176,
          "code": "// âŒ Quotes don't match - intentional error example\n// println(\"Hello, World!');\n//\n\n// Use either \"...\" or '...' but be consistent.\n\nfun main() {\n    // âœ… Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 7,
          "line_number": 196,
          "code": "// âŒ Wrong capitalization - intentional error example\n// PrintLn(\"Hello, World!\");\n//\n\n\nfun main() {\n    // âœ… Correct way:\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch01-02-hello-world.md",
          "example_number": 8,
          "line_number": 222,
          "code": "fun main() {\n    println(\"Hello, World!\");\n}",
          "passed": true,
          "status": "working"
        }
      ]
    },
    "ch14-00-toolchain-mastery-tdd": {
      "chapter": "ch14-00-toolchain-mastery-tdd",
      "total_examples": 4,
      "working_examples": 4,
      "failing_examples": 0,
      "examples": [
        {
          "file": "src/ch14-00-toolchain-mastery-tdd.md",
          "example_number": 1,
          "line_number": 20,
          "code": "fun greet(name: String) -> String {\n    \"Hello, \" + name + \"!\"\n}\n\nfun main() {\n    let message = greet(\"Ruchy Developer\");\n    println(message);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch14-00-toolchain-mastery-tdd.md",
          "example_number": 2,
          "line_number": 56,
          "code": "// calculator_test.ruchy\nfun add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\nfun test_addition() {\n    let result = add(2, 3);\n    assert_eq(result, 5);\n    println(\"Addition test passed\");\n}\n\nfun main() {\n    test_addition();\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch14-00-toolchain-mastery-tdd.md",
          "example_number": 3,
          "line_number": 121,
          "code": "fun calculate_factorial(n: i32) -> i32 {\n    if n <= 1 {\n        1\n    } else {\n        n * calculate_factorial(n - 1)\n    }\n}\n\nfun main() {\n    let result = calculate_factorial(10);\n    println(result);\n}",
          "passed": true,
          "status": "working"
        },
        {
          "file": "src/ch14-00-toolchain-mastery-tdd.md",
          "example_number": 4,
          "line_number": 258,
          "code": "fun fibonacci_recursive(n: i32) -> i32 {\n    if n <= 1 {\n        n\n    } else {\n        fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)\n    }\n}\n\nfun fibonacci_iterative(n: i32) -> i32 {\n    let mut a = 0;\n    let mut b = 1;\n    let mut i = 0;\n    \n    while i < n {\n        let temp = a + b;\n        a = b;\n        b = temp;\n        i = i + 1;\n    }\n    \n    a\n}\n\nfun main() {\n    let result1 = fibonacci_recursive(10);\n    let result2 = fibonacci_iterative(10);\n    println(result1);\n    println(result2);\n}",
          "passed": true,
          "status": "working"
        }
      ]
    }
  }
}