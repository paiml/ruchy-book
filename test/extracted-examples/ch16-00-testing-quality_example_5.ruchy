use proptest::prelude::*

// Generate arbitrary test data
#[derive(Arbitrary)]
struct TestUser {
    #[proptest(regex = "[a-z]{3,10}")]
    name: String
    
    #[proptest(range = 0..150)]
    age: u8
    
    #[proptest(strategy = "email_strategy()")]
    email: String
}

// Property test
#[proptest]
fn test_user_serialization(user: TestUser) {
    // Property: serialization round-trip preserves data
    let json = to_json(user)
    let restored: TestUser = from_json(json)
    prop_assert_eq!(user, restored)
}

// Custom strategies
fn email_strategy() -> impl Strategy<Value = String> {
    "[a-z]{3,10}@[a-z]{3,10}\\.(com|org|net)"
        .prop_map(|s| s.to_string())
}

// Shrinking for minimal failing case
#[proptest]
fn test_no_panic(input: Vec<u8>) {
    // Proptest will find minimal input that causes panic
    process_bytes(input)  // Should never panic
}

// Stateful property testing
#[proptest]
fn test_database_consistency(operations: Vec<DbOperation>) {
    let db = Database::new()
    
    for op in operations {
        op.apply(&db)
    }
    
    // Properties that should always hold
    prop_assert!(db.is_consistent())
    prop_assert_eq!(db.total_balance(), INITIAL_BALANCE)
}