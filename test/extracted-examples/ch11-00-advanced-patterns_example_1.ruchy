// File: event_system.ruchy
// Event-driven architecture with multiple patterns

use std::patterns;

// Observer pattern for events
class EventBus {
    let subscribers = {}
    
    fn on(event, handler) {
        if !subscribers.has_key(event) {
            subscribers[event] = []
        }
        subscribers[event].push(handler)
        
        // Return unsubscribe function (closure pattern)
        return || {
            subscribers[event] = subscribers[event].filter(|h| h != handler)
        }
    }
    
    fn emit(event, data) {
        if subscribers.has_key(event) {
            for handler in subscribers[event] {
                spawn { handler(data) }  // Async pattern
            }
        }
    }
}

// Singleton pattern for global event bus
let events = EventBus::singleton()

// Decorator pattern for logging
fn with_logging(handler) {
    return |data| {
        println(f"[{current_datetime()}] Event triggered: {data}")
        let result = handler(data)
        println(f"[{current_datetime()}] Event completed")
        return result
    }
}

// Usage combining patterns
let unsubscribe = events.on("user.login", with_logging(|user| {
    println(f"User {user.name} logged in")
    update_last_login(user)
}))

events.emit("user.login", {name: "Alice", id: 123})