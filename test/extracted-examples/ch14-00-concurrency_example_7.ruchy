fn producer_consumer_pipeline<T>() {
    let (tx, rx) = channel()
    
    // Multiple producers
    for i in range(4) {
        let tx = tx.clone()
        spawn move {
            loop {
                let work = generate_work(i)
                if tx.send(work).is_err() {
                    break  // Channel closed
                }
            }
        }
    }
    
    // Multiple consumers  
    for i in range(2) {
        let rx = rx.clone()
        spawn move {
            while let Ok(work) = rx.recv() {
                process_work(work)
            }
        }
    }
}

// With bounded queue for backpressure
fn bounded_pipeline() {
    let (tx, rx) = sync_channel(100)  // Max 100 items
    
    spawn move {
        for item in generate_items() {
            tx.send(item)  // Blocks if queue full
        }
    }
    
    spawn move {
        while let Ok(item) = rx.recv() {
            slow_process(item)
        }
    }
}