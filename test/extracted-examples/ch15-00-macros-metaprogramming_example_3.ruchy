// Derive macro for automatic implementation
#[proc_macro_derive(Builder)]
fn derive_builder(input: TokenStream) -> TokenStream {
    let ast = parse(input)
    let name = ast.name
    let builder_name = f"{name}Builder"
    
    let fields = ast.fields.map(|f| {
        let name = f.name
        let ty = f.ty
        quote! {
            fn $name(mut self, value: $ty) -> Self {
                self.$name = Some(value)
                self
            }
        }
    })
    
    quote! {
        struct $builder_name {
            $($fields.name: Option<$fields.ty>),*
        }
        
        impl $builder_name {
            fn new() -> Self {
                Self {
                    $($fields.name: None),*
                }
            }
            
            $fields
            
            fn build(self) -> Result<$name, String> {
                Ok($name {
                    $($fields.name: self.$fields.name
                        .ok_or(f"Missing field: {stringify!($fields.name)}")?,)*
                })
            }
        }
        
        impl $name {
            fn builder() -> $builder_name {
                $builder_name::new()
            }
        }
    }
}

// Use the derive macro
#[derive(Builder)]
struct Config {
    host: String
    port: u16
    workers: usize
}

// Generated builder pattern!
let config = Config::builder()
    .host("localhost")
    .port(8080)
    .workers(4)
    .build()?