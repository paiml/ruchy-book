// Ruchy 2.0: Functional Programming Patterns
// Combining closures, higher-order functions, and chaining

// Pipeline of transformations
let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// Filter even numbers
let evens = numbers.filter(|n| n % 2 == 0)
println(f"Even count: {evens.len()}")

// Double each number
let doubled = numbers.map(|n| n * 2)
println(f"First doubled: {doubled[0]}")
println(f"Last doubled: {doubled[9]}")

// Chain operations: filter then map
let result = [1, 2, 3, 4, 5, 6]
    .filter(|n| n > 2)      // [3, 4, 5, 6]
    .map(|n| n * n)         // [9, 16, 25, 36]

println(f"Chained result: {result[0]}, {result[1]}, {result[2]}")

// Custom reduce function
fun reduce(arr, initial, f) {
    let mut acc = initial
    for item in arr {
        acc = f(acc, item)
    }
    acc
}

let sum = reduce([1, 2, 3, 4, 5], 0, |acc, n| acc + n)
println(f"Sum: {sum}")

let product = reduce([1, 2, 3, 4, 5], 1, |acc, n| acc * n)
println(f"Product: {product}")

// Find max using reduce
let max = reduce([3, 1, 4, 1, 5, 9, 2, 6], 0, |acc, n| {
    if n > acc { n } else { acc }
})
println(f"Max: {max}")

// Apply function multiple times
fun apply_n_times(f, x, n) {
    let mut result = x
    let mut i = 0
    while i < n {
        result = f(result)
        i = i + 1
    }
    result
}

let doubled_3_times = apply_n_times(|x| x * 2, 1, 3)
println(f"1 doubled 3 times: {doubled_3_times}")  // 1 * 2 * 2 * 2 = 8

let incremented_5_times = apply_n_times(|x| x + 1, 0, 5)
println(f"0 incremented 5 times: {incremented_5_times}")  // 5

// Building pipelines with named functions
fun add_one(x) { x + 1 }
fun double(x) { x * 2 }
fun square(x) { x * x }

let value = 3
let step1 = add_one(value)    // 4
let step2 = double(step1)      // 8
let step3 = square(step2)      // 64
println(f"Pipeline: 3 -> +1 -> *2 -> ^2 = {step3}")
